Webruntime.moduleRegistry.define('c/lwcrelatedclientobjectives', ['lwc', 'lightning/configProvider', 'force/lds', 'aura', 'aura-instrumentation', 'wire-service', 'lightning/navigation'], function (lwc, configProvider, lds, aura, auraInstrumentation, wireService, navigation) { 'use strict';

    function stylesheet(hostSelector, shadowSelector, nativeShadow) {
      return "_:-ms-lang(x)" + shadowSelector + ", svg" + shadowSelector + " {pointer-events: none;}\n";
    }
    var _implicitStylesheets = [stylesheet];

    function tmpl($api, $cmp, $slotset, $ctx) {
      const {
        fid: api_scoped_frag_id,
        h: api_element
      } = $api;
      return [api_element("svg", {
        className: $cmp.computedClass,
        attrs: {
          "focusable": "false",
          "data-key": $cmp.name,
          "aria-hidden": "true"
        },
        key: 2
      }, [api_element("use", {
        attrs: {
          "xlink:href": lwc.sanitizeAttribute("use", "http://www.w3.org/2000/svg", "xlink:href", api_scoped_frag_id($cmp.href))
        },
        key: 3
      }, [])])];
    }

    var _tmpl = lwc.registerTemplate(tmpl);
    tmpl.stylesheets = [];

    if (_implicitStylesheets) {
      tmpl.stylesheets.push.apply(tmpl.stylesheets, _implicitStylesheets);
    }
    tmpl.stylesheetTokens = {
      hostAttribute: "lightning-primitiveIcon_primitiveIcon-host",
      shadowAttribute: "lightning-primitiveIcon_primitiveIcon"
    };

    const proto = {
      add(className) {
        if (typeof className === 'string') {
          this[className] = true;
        } else {
          Object.assign(this, className);
        }

        return this;
      },

      invert() {
        Object.keys(this).forEach(key => {
          this[key] = !this[key];
        });
        return this;
      },

      toString() {
        return Object.keys(this).filter(key => this[key]).join(' ');
      }

    };
    function classSet(config) {
      if (typeof config === 'string') {
        const key = config;
        config = {};
        config[key] = true;
      }

      return Object.assign(Object.create(proto), config);
    }

    const inputableNode = /input|select|textarea|button|object/;

    function visible(element) {
      const {
        width,
        height
      } = element.getBoundingClientRect();
      const noZeroSize = width > 0 || height > 0;
      return noZeroSize && window.getComputedStyle(lwc.unwrap(element)).visibility !== 'hidden';
    }

    function focusable(element) {
      const nodeName = element.tagName.toLowerCase();
      const res = inputableNode.test(nodeName) && !element.disabled || nodeName === 'a' && element.href;
      return res && visible(element);
    }

    function tabbable(element) {
      const isDataActionable = element.getAttribute('data-navigation') === 'enable';
      const tabIndex = element.tabIndex;
      return tabIndex >= 0 && focusable(element) || isDataActionable;
    }

    function queryFocusable(element) {
      return [].slice.call(element.querySelectorAll('*'), 0).filter(tabbable);
    }

    // NOTE: lightning-utils is a public library. adding new utils here means we

    function assert(condition, message) {
      {
        if (!condition) {
          throw new Error(message);
        }
      }
    }

    /**
    An emitter implementation based on the Node.js EventEmitter API:
    https://nodejs.org/dist/latest-v6.x/docs/api/events.html#events_class_eventemitter
    **/
    class EventEmitter {
      constructor() {
        this.registry = {};
      }
      /**
      Registers a listener on the emitter
      @method EventEmitter#on
      @param {String} name - The name of the event
      @param {Function} listener - The callback function
      @return {EventEmitter} - Returns a reference to the `EventEmitter` so that calls can be chained
      **/


      on(name, listener) {
        this.registry[name] = this.registry[name] || [];
        this.registry[name].push(listener);
        return this;
      }
      /**
      Registers a listener on the emitter that only executes once
      @method EventEmitter#once
      @param {String} name - The name of the event
      @param {Function} listener - The callback function
      @return {EventEmitter} - Returns a reference to the `EventEmitter` so that calls can be chained
      **/


      once(name, listener) {
        const doOnce = function () {
          listener.apply(null, arguments);
          this.removeListener(name, doOnce);
        }.bind(this);

        this.on(name, doOnce);
        return this;
      }
      /**
      Synchronously calls each listener registered with the specified event
      @method EventEmitter#emit
      @param {String} name - The name of the event
      @return {Boolean} - Returns `true` if the event had listeners, `false` otherwise
      **/


      emit(name, ...args) {
        const listeners = this.registry[name];
        let count = 0;

        if (listeners) {
          listeners.forEach(listener => {
            count += 1;
            listener.apply(null, args);
          });
        }

        return count > 0;
      }
      /**
      Removes the specified `listener` from the listener array for the event named `name`
      @method EventEmitter#removeListener
      @param {String} name - The name of the event
      @param {Function} listener - The callback function
      @return {EventEmitter} - Returns a reference to the `EventEmitter` so that calls can be chained
      **/


      removeListener(name, listener) {
        const listeners = this.registry[name];

        if (listeners) {
          for (let i = 0, len = listeners.length; i < len; i += 1) {
            if (listeners[i] === listener) {
              listeners.splice(i, 1);
              return this;
            }
          }
        }

        return this;
      }

    }

    const NA_PHONE_NUMBER = '($1) $2-$3';
    const IS_TEN_DIGITS = /^\d{10}$/;
    const TEN_TO_NA = /(\d{3})(\d{3})(\d{4})/;
    const IS_ELEVEN_DIGITS = /^1\d{10}/;
    const ELEVEN_TO_NA = /1(\d{3})(\d{3})(\d{4})$/;
    function toNorthAmericanPhoneNumber(value) {
      if (IS_TEN_DIGITS.test(value)) {
        return value.replace(TEN_TO_NA, NA_PHONE_NUMBER);
      } else if (IS_ELEVEN_DIGITS.test(value)) {
        return value.replace(ELEVEN_TO_NA, NA_PHONE_NUMBER);
      }

      return value || '';
    }

    const urlRegexString = "((?:(?:https?|ftp):\\/\\/(?:[\\w\\-\\|=%~#\\/+*@\\.,;:\\?!']|&){0,2047}(?:[\\(\\)\\.\\w=\\/+#-]*)[^\\s()\\.<>,;\\[\\]`'\"])|(?:\\b(?:[a-z0-9](?:[-a-z0-9]{0,62}[a-z0-9])?\\.)+(?:AC|AD|AE|AERO|AF|AG|AI|AL|AM|AN|AO|AQ|AR|ARPA|AS|ASIA|AT|AU|AW|AX|AZ|BA|BB|BD|BE|BF|BG|BH|BI|BIZ|BJ|BM|BN|BO|BR|BS|BT|BV|BW|BY|BZ|CA|CAT|CC|CD|CF|CG|CH|CI|CK|CL|CM|CN|CO|COM|COOP|CR|CU|CV|CX|CY|CZ|DE|DJ|DK|DM|DO|DZ|EC|EDU|EE|EG|ER|ES|ET|EU|FI|FJ|FK|FM|FO|FR|GA|GB|GD|GE|GF|GG|GH|GI|GL|GM|GN|GOV|GP|GQ|GR|GS|GT|GU|GW|GY|HK|HM|HN|HR|HT|HU|ID|IE|IL|IM|IN|INFO|INT|IO|IQ|IR|IS|IT|JE|JM|JO|JOBS|JP|KE|KG|KH|KI|KM|KN|KP|KR|KW|KY|KZ|LA|LB|LC|LI|LK|LR|LS|LT|LU|LV|LY|MA|MC|MD|ME|MG|MH|MIL|MK|ML|MM|MN|MO|MOBI|MP|MQ|MR|MS|MT|MU|MUSEUM|MV|MW|MX|MY|MZ|NA|NAME|NC|NE|NET|NF|NG|NI|NL|NO|NP|NR|NU|NZ|OM|ORG|PA|PE|PF|PG|PH|PK|PL|PM|PN|PR|PRO|PS|PT|PW|PY|QA|RE|RO|RS|RU|RW|SA|SB|SC|SD|SE|SG|SH|SI|SJ|SK|SL|SM|SN|SO|SR|ST|SU|SV|SY|SZ|TC|TD|TEL|TF|TG|TH|TJ|TK|TL|TM|TN|TO|TP|TR|TRAVEL|TT|TV|TW|TZ|UA|UG|UK|US|UY|UZ|VA|VC|VE|VG|VI|VN|VU|WF|WS|XN--0ZWM56D|XN--11B5BS3A9AJ6G|XN--80AKHBYKNJ4F|XN--9T4B11YI5A|XN--DEBA0AD|XN--FIQS8S|XN--FIQZ9S|XN--G6W251D|XN--HGBK6AJ7F53BBA|XN--HLCJ6AYA9ESC7A|XN--J6W193G|XN--JXALPDLP|XN--KGBECHTV|XN--KPRW13D|XN--KPRY57D|XN--MGBAAM7A8H|XN--MGBERP4A5D4AR|XN--P1AI|XN--WGBH1C|XN--ZCKZAH|YE|YT|ZA|ZM|ZW)(?!@(?:[a-z0-9](?:[-a-z0-9]{0,62}[a-z0-9])?\\.)+(?:AC|AD|AE|AERO|AF|AG|AI|AL|AM|AN|AO|AQ|AR|ARPA|AS|ASIA|AT|AU|AW|AX|AZ|BA|BB|BD|BE|BF|BG|BH|BI|BIZ|BJ|BM|BN|BO|BR|BS|BT|BV|BW|BY|BZ|CA|CAT|CC|CD|CF|CG|CH|CI|CK|CL|CM|CN|CO|COM|COOP|CR|CU|CV|CX|CY|CZ|DE|DJ|DK|DM|DO|DZ|EC|EDU|EE|EG|ER|ES|ET|EU|FI|FJ|FK|FM|FO|FR|GA|GB|GD|GE|GF|GG|GH|GI|GL|GM|GN|GOV|GP|GQ|GR|GS|GT|GU|GW|GY|HK|HM|HN|HR|HT|HU|ID|IE|IL|IM|IN|INFO|INT|IO|IQ|IR|IS|IT|JE|JM|JO|JOBS|JP|KE|KG|KH|KI|KM|KN|KP|KR|KW|KY|KZ|LA|LB|LC|LI|LK|LR|LS|LT|LU|LV|LY|MA|MC|MD|ME|MG|MH|MIL|MK|ML|MM|MN|MO|MOBI|MP|MQ|MR|MS|MT|MU|MUSEUM|MV|MW|MX|MY|MZ|NA|NAME|NC|NE|NET|NF|NG|NI|NL|NO|NP|NR|NU|NZ|OM|ORG|PA|PE|PF|PG|PH|PK|PL|PM|PN|PR|PRO|PS|PT|PW|PY|QA|RE|RO|RS|RU|RW|SA|SB|SC|SD|SE|SG|SH|SI|SJ|SK|SL|SM|SN|SO|SR|ST|SU|SV|SY|SZ|TC|TD|TEL|TF|TG|TH|TJ|TK|TL|TM|TN|TO|TP|TR|TRAVEL|TT|TV|TW|TZ|UA|UG|UK|US|UY|UZ|VA|VC|VE|VG|VI|VN|VU|WF|WS|XN--0ZWM56D|XN--11B5BS3A9AJ6G|XN--80AKHBYKNJ4F|XN--9T4B11YI5A|XN--DEBA0AD|XN--FIQS8S|XN--FIQZ9S|XN--G6W251D|XN--HGBK6AJ7F53BBA|XN--HLCJ6AYA9ESC7A|XN--J6W193G|XN--JXALPDLP|XN--KGBECHTV|XN--KPRW13D|XN--KPRY57D|XN--MGBAAM7A8H|XN--MGBERP4A5D4AR|XN--P1AI|XN--WGBH1C|XN--ZCKZAH|YE|YT|ZA|ZM|ZW))(?:/[\\w\\-=?/.&;:%~,+@#*]{0,2048}(?:[\\w=/+#-]|\\([^\\s()]*\\)))?(?:$|(?=\\.$)|(?=\\.\\s)|(?=[^\\w\\.]))))";
    const emailRegexString = '([\\w-\\.\\+_]{1,64}@(?:[\\w-]){1,255}(?:\\.[\\w-]{1,255}){1,10})';
    const newLineRegexString = '(\r\n|\r|\n)';
    const tagRegexString = '(<a[\\s]+[^>]+[^/]>[\\s\\S]*?</a>|<a[\\s]+[^>]+/>|' + '<i?frame[\\s]+[^>]+[^/]>[\\s\\S]*?</i?frame>|<i?frame[\\s]+[^>]+/>|' + '<area[\\s]+[^>]+[^/]>[\\s\\S]*?</area>|<area[\\s]+[^>]+/>|' + '<link[\\s]+[^>]+[^/]>[\\s\\S]*?</link>|<link[\\s]+[^>]+/>|' + '<img[\\s]+[^>]+[^/]>[\\s\\S]*?</img>|<img[\\s]+[^>]+>|' + '<form[\\s]+[^>]+[^/]>[\\s\\S]*?</form>|<form[\\s]+[^>]+/>|' + '<body[\\s]+[^>]+[^/]>[\\s\\S]*?</body>|<body[\\s]+[^>]+/>|' + '<head[\\s]+[^>]+[^/]>[\\s\\S]*?</head>|<head[\\s]+[^>]+/>|' + '<input[\\s]+[^>]+[^/]>[\\s\\S]*?</input>|<input[\\s]+[^>]+/>|' + '<button[\\s]+[^>]+[^/]>[\\s\\S]*?</button>|<button[\\s]+[^>]+/>|' + '<blockquote[\\s]+[^>]+[^/]>[\\s\\S]*?</blockquote>|<blockquote[\\s]+[^>]+/>|' + '<q[\\s]+[^>]+[^/]>[\\s\\S]*?</q>|<q[\\s]+[^>]+/>|' + '<del[\\s]+[^>]+[^/]>[\\s\\S]*?</del>|<del[\\s]+[^>]+/>|' + '<ins[\\s]+[^>]+[^/]>[\\s\\S]*?</ins>|<ins[\\s]+[^>]+/>)';
    const createHttpHref = function (url) {
      let href = url;

      if (url.toLowerCase().lastIndexOf('http', 0) !== 0 && url.toLowerCase().lastIndexOf('ftp', 0) !== 0) {
        href = `http://${href}`;
      }

      return href;
    };
    const createEmailHref = function (email) {
      return `mailto:${email}`;
    };

    /**
     * Create a deep copy of an object or array
     * @param {object|array} o - item to be copied
     * @returns {object|array} copy of the item
     */

    /**
     * Utility function to generate an unique guid.
     * used on state objects to provide a performance aid when iterating
     * through the items and marking them for render
     * @returns {String} an unique string ID
     */
    function guid() {
      function s4() {
        return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
      }

      return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    }

    function classListMutation(classList, config) {
      Object.keys(config).forEach(key => {
        if (typeof key === 'string' && key.length) {
          if (config[key]) {
            classList.add(key);
          } else {
            classList.remove(key);
          }
        }
      });
    }

    /**
    A string normalization utility for attributes.
    @param {String} value - The value to normalize.
    @param {Object} config - The optional configuration object.
    @param {String} [config.fallbackValue] - The optional fallback value to use if the given value is not provided or invalid. Defaults to an empty string.
    @param {Array} [config.validValues] - An optional array of valid values. Assumes all input is valid if not provided.
    @return {String} - The normalized value.
    **/
    function normalizeString(value, config = {}) {
      const {
        fallbackValue = '',
        validValues,
        toLowerCase = true
      } = config;
      let normalized = typeof value === 'string' && value.trim() || '';
      normalized = toLowerCase ? normalized.toLowerCase() : normalized;

      if (validValues && validValues.indexOf(normalized) === -1) {
        normalized = fallbackValue;
      }

      return normalized;
    }
    /**
    A boolean normalization utility for attributes.
    @param {Any} value - The value to normalize.
    @return {Boolean} - The normalized value.
    **/

    function normalizeBoolean(value) {
      return typeof value === 'string' || !!value;
    }
    function normalizeArray(value) {
      if (Array.isArray(value)) {
        return value;
      }

      return [];
    }
    /**
    A aria attribute normalization utility.
    @param {Any} value - A single aria value or an array of aria values
    @return {String} - A space separated list of aria values
    **/

    function normalizeAriaAttribute(value) {
      let arias = Array.isArray(value) ? value : [value];
      arias = arias.map(ariaValue => {
        if (typeof ariaValue === 'string') {
          return ariaValue.replace(/\s+/g, ' ').trim();
        }

        return '';
      }).filter(ariaValue => !!ariaValue);
      return arias.length > 0 ? arias.join(' ') : null;
    }

    const keyCodes = {
      tab: 9,
      backspace: 8,
      enter: 13,
      escape: 27,
      space: 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      left: 37,
      up: 38,
      right: 39,
      down: 40,
      delete: 46,
      shift: 16
    };
    const buffer = {};
    /**
     * Runs an action and passes the string of buffered keys typed within a short time period.
     * Use for type-ahead like functionality in menus, lists, comboboxes, and similar components.
     *
     * @param {CustomEvent} event A keyboard event
     * @param {Function} action function to run, it's passed the buffered text
     */

    function runActionOnBufferedTypedCharacters(event, action) {
      const letter = event.key;

      if (letter.length > 1) {
        // Not an individual character/letter, but rather a special code (like Shift, Backspace, etc.)
        return;
      } // If we were going to clear what keys were typed, don't yet.


      if (buffer._clearBufferId) {
        clearTimeout(buffer._clearBufferId);
      }

      buffer._keyBuffer = buffer._keyBuffer || [];

      buffer._keyBuffer.push(letter);

      const matchText = buffer._keyBuffer.join('').toLowerCase();

      action(matchText); // eslint-disable-next-line lwc/no-set-timeout

      buffer._clearBufferId = setTimeout(() => {
        buffer._keyBuffer = [];
      }, 700);
    }

    function raf(fn) {
      let ticking = false;
      return function (event) {
        if (!ticking) {
          requestAnimationFrame(() => {
            fn.call(this, event);
            ticking = false;
          });
        }

        ticking = true;
      };
    }

    const isIE11 = isIE11Test(navigator);
    const isChrome = isChromeTest(navigator); // The following functions are for tests only

    function isIE11Test(navigator) {
      // https://stackoverflow.com/questions/17447373/how-can-i-target-only-internet-explorer-11-with-javascript
      return /Trident.*rv[ :]*11\./.test(navigator.userAgent);
    }
    function isChromeTest(navigator) {
      // https://stackoverflow.com/questions/4565112/javascript-how-to-find-out-if-the-user-browser-is-chrome
      return /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
    }

    /**
     * Set an attribute on an element, if it's a normal element
     * it will use setAttribute, if it's an LWC component
     * it will use the public property
     *
     * @param {HTMLElement} element The element to act on
     * @param {String} attribute the attribute to set
     * @param {Any} value the value to set
     */
    function smartSetAttribute(element, attribute, value) {
      if (element.tagName.match(/^LIGHTNING/i)) {
        attribute = attribute.replace(/-\w/g, m => m[1].toUpperCase());
        element[attribute] = value ? value : null;
      } else if (value) {
        element.setAttribute(attribute, value);
      } else {
        element.removeAttribute(attribute);
      }
    }

    const CONTENT_SEPARATOR = '\n';
    /**
    <template>
        <span lwc:dom="manual" class="visually-hidden"></span>
        <input>
    </template>

    class Foo extends LightningElement {
        constructor() {
            super();
            this.ariaObserver = new ContentMutation(this);
        }

        @track ariaLabeledbyValue = '';

        @api
        get ariaLabeledby() {
            return this.ariaLabeledbyValue; // whatever they set, is what they get back.
        }
        set ariaLabeledby(refs) {
            this.ariaLabeledbyValue = refs;
            this.ariaObserver.link('input', 'aria-labeledby', refs, 'span.visually-hidden');
        }

        renderedCallback() {
            this.ariaObserver.sync();
        }
    }
    **/

    function getAttr(elm, attr) {
      if (elm.tagName.match(/lightning/i)) {
        return elm[attr];
      }

      return elm.getAttribute(attr);
    }

    function extractElements(root, selector) {
      if (typeof selector !== 'string' || selector === '') {
        return [];
      }

      return [].slice.call(root.querySelectorAll(selector));
    }

    function extractContent(elements) {
      return elements.map(element => element.textContent).filter(text => text.length).join(CONTENT_SEPARATOR);
    }

    function splitIds(ids) {
      return (ids + '').trim().split(/\s+/);
    }

    function hashIds(ids) {
      return (ids + '').trim().split(/\s+/).reduce((r, v) => {
        r[v] = 1;
        return r;
      }, {});
    } // this method should check each individual id from computedIds
    // against the existing value of the attrName on elm, and dupe
    // them, and add the new ones.


    function addAriaRefWhenNeeded(elm, attrName, computedIds) {
      const newIds = splitIds(computedIds);
      const oldIds = getAttr(elm, attrName) || '';
      const oldIdsHash = hashIds(oldIds);
      const suffix = [];

      for (let i = 0; i < newIds.length; i += 1) {
        if (!oldIdsHash[newIds[i]]) {
          suffix.push(newIds[i]);
        }
      }

      if (suffix.length !== 0) {
        smartSetAttribute(elm, attrName, oldIds + (oldIds.length === 0 ? '' : ' ') + suffix.join(' '));
      }
    } // this method should check each individual id from computedIds
    // against the existing value of the attrName on elm, and remove
    // them when possible in preparation for some new values.


    function removeAriaRefWhenPossible(elm, attrName, computedIds) {
      const newIds = splitIds(computedIds);
      const oldIds = getAttr(elm, attrName) || '';
      const oldIdsHash = hashIds(oldIds);
      const newValues = [];

      for (let i = 0; i < newIds.length; i += 1) {
        if (!oldIdsHash[newIds[i]]) {
          newValues.push(newIds[i]);
        }
      }

      smartSetAttribute(elm, attrName, newValues.join(' '));
    }

    class ContentMutation {
      constructor(component) {
        this.template = component.template;
        this.isNative = this.template.constructor.toString().match(/\[native code\]/);
        this.state = {};
        this.liveIds = {};
        this.guid = guid();
      }

      connectLiveIdRef(refs, callback) {
        const selector = (refs + '').trim().split(/\s+/).map(ref => `[id*="${ref}"]`).join(',');
        const liveId = {
          selector,
          callback
        };
        this.liveIds[refs] = liveId;
      }

      link(innerSelector, attrName, ids, placeholderContainerSelector) {
        let attrState = this.state[attrName];

        if (attrState) {
          // note: we don't support linking to a different innerSelector,
          // attrName, or placeholderContainerSelector
          if (!this.isNative) {
            const elm = this.template.querySelector(innerSelector);

            if (elm) {
              // removing the old ids if possible before setting the new ones
              removeAriaRefWhenPossible(elm, attrName, attrState.ids);
            }

            attrState.ids = ids;
          }
        } else {
          attrState = this.state[attrName] = {
            ids,
            innerSelector,
            placeholderContainerSelector
          };
        }

        if (this.isNative) {
          attrState.outerSelector = (ids + '').trim().split(/\s+/).map(ref => `#${ref}`).join(',');
          attrState.placeholder = document.createElement('span');
          attrState.placeholder.id = `auto-link-${attrName}-${this.guid}`;
        }

        if (this.template.host.parentNode) {
          this.privateUpdate(attrName);
        }
      }

      sync() {
        if (!this.template.host.parentNode) {
          throw new Error(`Invalid sync invocation. It can only be invoked during renderedCallback().`);
        }

        if (this.isNative && !this.mo) {
          this.privateConnect();
        }

        for (const attrName in this.state) {
          if (this.state.hasOwnProperty(attrName)) {
            this.privateUpdate(attrName);
          }
        } // live idRef feature is a no-op in native


        if (!this.isNative) {
          this.privateUpdateLiveIds();
        }
      }

      privateExtractIds(elements) {
        return elements.map(el => {
          return el.getAttribute('id');
        }).join(' ');
      }

      privateUpdateLiveIds() {
        const root = this.template.host.getRootNode(); // if not connected do nothing

        if (!root) {
          return;
        }

        for (const liveId in this.liveIds) {
          if (this.liveIds.hasOwnProperty(liveId)) {
            const thisId = this.liveIds[liveId];

            if (!thisId.elements) {
              // element refs are cached
              thisId.elements = Array.prototype.slice.call(root.querySelectorAll(thisId.selector));
            }

            const newIds = this.privateExtractIds(thisId.elements); // only fire calback if the value changed

            if (newIds !== thisId.ids) {
              thisId.callback(newIds);
              thisId.ids = newIds;
            }
          }
        }
      }

      privateUpdate(attrName) {
        const {
          innerSelector
        } = this.state[attrName];
        const elm = this.template.querySelector(innerSelector);

        if (!elm) {
          return; // nothing to update
        }

        let computedIds;

        if (this.isNative) {
          const {
            outerSelector,
            content,
            placeholder,
            placeholderContainerSelector
          } = this.state[attrName];
          const newContent = extractContent(extractElements(this.root, outerSelector));

          if (content !== newContent) {
            this.state[attrName].content = placeholder.textContent = newContent;
          }

          if (!placeholder.parentNode) {
            // inserting the placeholder once
            const container = this.template.querySelector(placeholderContainerSelector);

            if (container) {
              container.appendChild(placeholder);
            }
          }

          computedIds = placeholder.id;
        } else {
          computedIds = this.state[attrName].ids;
        }

        addAriaRefWhenNeeded(elm, attrName, computedIds);
      }

      privateConnect() {
        // caching root ref
        this.root = this.template.host.getRootNode(); // creating the observer once

        const mo = new MutationObserver(() => {
          if (!this.template.host.parentNode) {
            return; // do nothing when the template is not connected
          }

          this.sync();
        });
        mo.observe(this.root, {
          characterData: true,
          childList: true,
          subtree: true
        });
      }

    }

    // hide panel on scroll
    const POSITION_CHANGE_THRESHOLD = 5;
    function observePosition(target, threshold = POSITION_CHANGE_THRESHOLD, originalRect, callback) {
      // retrieve current bounding client rect of target element
      const newBoundingRect = target.getBoundingClientRect();
      const newLeft = newBoundingRect.left;
      const newTop = newBoundingRect.top; // old bounding rect values

      const oldLeft = originalRect.left;
      const oldTop = originalRect.top; // if we have a position change (horizontal or vertical) equal or greater to the threshold then execute the callback

      const horizontalShiftDelta = Math.abs(newLeft - oldLeft);
      const verticalShiftDelta = Math.abs(newTop - oldTop);

      if (horizontalShiftDelta >= threshold || verticalShiftDelta >= threshold) {
        callback();
      }
    }

    const ALLOWED_DOMAINS = new Set(['www.youtube.com', 'player.vimeo.com', 'play.vidyard.com']);
    function hasOnlyAllowedVideoIframes(htmlString) {
      if (htmlString && htmlString.indexOf('<iframe') > -1) {
        const parsedHtml = new DOMParser().parseFromString(htmlString, 'text/html');
        const iframesList = Array.prototype.slice.call(parsedHtml.querySelectorAll('iframe'));
        return iframesList.length > 0 && !iframesList.some(iframe => !isUrlAllowed(iframe.src));
      }

      return false;
    }

    function isUrlAllowed(url) {
      const anchor = document.createElement('a');
      anchor.href = url;
      return anchor.protocol === 'https:' && ALLOWED_DOMAINS.has(anchor.hostname);
    }

    /**
     * @param {HTMLElement} element Element to act on
     * @param {Object} values values and attributes to set, if the value is
     *                        falsy it the attribute will be removed
     */

    function synchronizeAttrs(element, values) {
      if (!element) {
        return;
      }

      const attributes = Object.keys(values);
      attributes.forEach(attribute => {
        smartSetAttribute(element, attribute, values[attribute]);
      });
    }
    /**
     * Get the actual DOM id for an element
     * @param {HTMLElement|String} el The element to get the id for (string will just be returned)
     *
     * @returns {String} The DOM id or null
     */

    function getRealDOMId(el) {
      if (el && typeof el === 'string') {
        return el;
      } else if (el) {
        return el.getAttribute('id');
      }

      return null;
    }
    const URL_CHECK_REGEX = /^(\/+|\.+|ftp|http(s?):\/\/)/i;
    function isAbsoluteUrl(url) {
      return URL_CHECK_REGEX.test(url);
    }
    /**
     * Returns the active element traversing shadow roots
     * @returns {Element} Active Element inside shadow
     */

    function getShadowActiveElement() {
      let activeElement = document.activeElement;

      while (activeElement.shadowRoot && activeElement.shadowRoot.activeElement) {
        activeElement = activeElement.shadowRoot.activeElement;
      }

      return activeElement;
    }
    const DEFAULT_ZINDEX_BASELINE = 9000;
    /**
     * Returns the zIndex baseline from slds zIndex variable --lwc-zIndexModal.
     * @returns {Number} zIndex baseline
     */

    function getZIndexBaseline() {
      const value = (window.getComputedStyle(document.documentElement) || document.documentElement.style).getPropertyValue('--lwc-zIndexModal');
      const base = parseInt(value, 10);
      return isNaN(base) ? DEFAULT_ZINDEX_BASELINE : base;
    }

    var _tmpl$1 = void 0;

    // Taken from https://github.com/jonathantneal/svg4everybody/pull/139
    // Remove this iframe-in-edge check once the following is resolved https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8323875/
    const isEdgeUA = /\bEdge\/.(\d+)\b/.test(navigator.userAgent);
    const inIframe = window.top !== window.self;
    const isIframeInEdge = isEdgeUA && inIframe;
    var isIframeInEdge$1 = lwc.registerComponent(isIframeInEdge, {
      tmpl: _tmpl$1
    });

    // Taken from https://git.soma.salesforce.com/aura/lightning-global/blob/999dc35f948246181510df6e56f45ad4955032c2/src/main/components/lightning/SVGLibrary/stamper.js#L38-L60
    function fetchSvg(url) {
      return new Promise((resolve, reject) => {
        const xhr = new XMLHttpRequest();
        xhr.open('GET', url);
        xhr.send();

        xhr.onreadystatechange = () => {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              resolve(xhr.responseText);
            } else {
              reject(xhr);
            }
          }
        };
      });
    }

    // Which looks like it was inspired by https://github.com/jonathantneal/svg4everybody/blob/377d27208fcad3671ed466e9511556cb9c8b5bd8/lib/svg4everybody.js#L92-L107
    // Modify at your own risk!

    const newerIEUA = /\bTrident\/[567]\b|\bMSIE (?:9|10)\.0\b/;
    const webkitUA = /\bAppleWebKit\/(\d+)\b/;
    const olderEdgeUA = /\bEdge\/12\.(\d+)\b/;
    const isIE = newerIEUA.test(navigator.userAgent) || (navigator.userAgent.match(olderEdgeUA) || [])[1] < 10547 || (navigator.userAgent.match(webkitUA) || [])[1] < 537;
    const supportsSvg = !isIE && !isIframeInEdge$1;
    var supportsSvg$1 = lwc.registerComponent(supportsSvg, {
      tmpl: _tmpl$1
    });

    /**
    This polyfill injects SVG sprites into the document for clients that don't
    fully support SVG. We do this globally at the document level for performance
    reasons. This causes us to lose namespacing of IDs across sprites. For example,
    if both #image from utility sprite and #image from doctype sprite need to be
    rendered on the page, both end up as #image from the doctype sprite (last one
    wins). SLDS cannot change their image IDs due to backwards-compatibility
    reasons so we take care of this issue at runtime by adding namespacing as we
    polyfill SVG elements.

    For example, given "/assets/icons/action-sprite/svg/symbols.svg#approval", we
    replace the "#approval" id with "#${namespace}-approval" and a similar
    operation is done on the corresponding symbol element.
    **/
    const svgTagName = /svg/i;

    const isSvgElement = el => el && svgTagName.test(el.nodeName);

    const requestCache = {};
    const symbolEls = {};
    const svgFragments = {};
    const spritesContainerId = 'slds-svg-sprites';
    let spritesEl;
    function polyfill(el) {
      if (!supportsSvg$1 && isSvgElement(el)) {
        if (!spritesEl) {
          spritesEl = document.createElement('svg');
          spritesEl.xmlns = 'http://www.w3.org/2000/svg';
          spritesEl['xmlns:xlink'] = 'http://www.w3.org/1999/xlink';
          spritesEl.style.display = 'none';
          spritesEl.id = spritesContainerId;
          document.body.insertBefore(spritesEl, document.body.childNodes[0]);
        }

        Array.from(el.getElementsByTagName('use')).forEach(use => {
          // We access the href differently in raptor and in aura, probably
          // due to difference in the way the svg is constructed.
          const src = use.getAttribute('xlink:href') || use.getAttribute('href');

          if (src) {
            // "/assets/icons/action-sprite/svg/symbols.svg#approval" =>
            // ["/assets/icons/action-sprite/svg/symbols.svg", "approval"]
            const parts = src.split('#');
            const url = parts[0];
            const id = parts[1];
            const namespace = url.replace(/[^\w]/g, '-');
            const href = `#${namespace}-${id}`;

            if (url.length) {
              // set the HREF value to no longer be an external reference
              if (use.getAttribute('xlink:href')) {
                use.setAttribute('xlink:href', href);
              } else {
                use.setAttribute('href', href);
              } // only insert SVG content if it hasn't already been retrieved


              if (!requestCache[url]) {
                requestCache[url] = fetchSvg(url);
              }

              requestCache[url].then(svgContent => {
                // create a document fragment from the svgContent returned (is parsed by HTML parser)
                if (!svgFragments[url]) {
                  const svgFragment = document.createRange().createContextualFragment(svgContent);
                  svgFragments[url] = svgFragment;
                }

                if (!symbolEls[href]) {
                  const svgFragment = svgFragments[url];
                  const symbolEl = svgFragment.querySelector(`#${id}`);
                  symbolEls[href] = true;
                  symbolEl.id = `${namespace}-${id}`;
                  spritesEl.appendChild(symbolEl);
                }
              });
            }
          }
        });
      }
    }

    const validNameRe = /^([a-zA-Z]+):([a-zA-Z]\w*)$/;
    const underscoreRe = /_/g;
    let pathPrefix;
    const tokenNameMap = Object.assign(Object.create(null), {
      action: 'lightning.actionSprite',
      custom: 'lightning.customSprite',
      doctype: 'lightning.doctypeSprite',
      standard: 'lightning.standardSprite',
      utility: 'lightning.utilitySprite'
    });
    const tokenNameMapRtl = Object.assign(Object.create(null), {
      action: 'lightning.actionSpriteRtl',
      custom: 'lightning.customSpriteRtl',
      doctype: 'lightning.doctypeSpriteRtl',
      standard: 'lightning.standardSpriteRtl',
      utility: 'lightning.utilitySpriteRtl'
    });
    const defaultTokenValueMap = Object.assign(Object.create(null), {
      'lightning.actionSprite': '/assets/icons/action-sprite/svg/symbols.svg',
      'lightning.actionSpriteRtl': '/assets/icons/action-sprite/svg/symbols.svg',
      'lightning.customSprite': '/assets/icons/custom-sprite/svg/symbols.svg',
      'lightning.customSpriteRtl': '/assets/icons/custom-sprite/svg/symbols.svg',
      'lightning.doctypeSprite': '/assets/icons/doctype-sprite/svg/symbols.svg',
      'lightning.doctypeSpriteRtl': '/assets/icons/doctype-sprite/svg/symbols.svg',
      'lightning.standardSprite': '/assets/icons/standard-sprite/svg/symbols.svg',
      'lightning.standardSpriteRtl': '/assets/icons/standard-sprite/svg/symbols.svg',
      'lightning.utilitySprite': '/assets/icons/utility-sprite/svg/symbols.svg',
      'lightning.utilitySpriteRtl': '/assets/icons/utility-sprite/svg/symbols.svg'
    });

    const getDefaultBaseIconPath = (category, nameMap) => defaultTokenValueMap[nameMap[category]];

    const getBaseIconPath = (category, direction) => {
      const nameMap = direction === 'rtl' ? tokenNameMapRtl : tokenNameMap;
      return configProvider.getToken(nameMap[category]) || getDefaultBaseIconPath(category, nameMap);
    };

    const getMatchAtIndex = index => iconName => {
      const result = validNameRe.exec(iconName);
      return result ? result[index] : '';
    };

    const getCategory = getMatchAtIndex(1);
    const getName = getMatchAtIndex(2);
    const isValidName = iconName => validNameRe.test(iconName);
    const getIconPath = (iconName, direction = 'ltr') => {
      pathPrefix = pathPrefix !== undefined ? pathPrefix : configProvider.getPathPrefix();

      if (isValidName(iconName)) {
        const baseIconPath = getBaseIconPath(getCategory(iconName), direction);

        if (baseIconPath) {
          // This check was introduced the following MS-Edge issue:
          // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/9655192/
          // If and when this get fixed, we can safely remove this block of code.
          if (isIframeInEdge$1) {
            // protocol => 'https:' or 'http:'
            // host => hostname + port
            const origin = `${window.location.protocol}//${window.location.host}`;
            return `${origin}${pathPrefix}${baseIconPath}#${getName(iconName)}`;
          }

          return `${pathPrefix}${baseIconPath}#${getName(iconName)}`;
        }
      }

      return '';
    };
    const computeSldsClass = iconName => {
      if (isValidName(iconName)) {
        const category = getCategory(iconName);
        const name = getName(iconName).replace(underscoreRe, '-');
        return `slds-icon-${category}-${name}`;
      }

      return '';
    };

    const isSafari = window.safari && window.safari.pushNotification && window.safari.pushNotification.toString() === '[object SafariRemoteNotification]'; // [W-3421985] https://bugs.webkit.org/show_bug.cgi?id=162866
    // https://git.soma.salesforce.com/aura/lightning-global/blob/82e8bfd02846fa7e6b3e7549a64be95b619c4b1f/src/main/components/lightning/primitiveIcon/primitiveIconHelper.js#L53-L56

    function safariA11yPatch(svgElement) {
      if (!svgElement || !isSafari) {
        return;
      } // In case we're dealing with a proxied element.


      svgElement = lwc.unwrap(svgElement);
      const use = svgElement.querySelector('use');

      if (!use) {
        return;
      }

      svgElement.insertBefore(document.createTextNode('\n'), use); // If use.nextSibling is null, the text node is added to the end of
      // the list of children of the SVG element.
      // https://developer.mozilla.org/en-US/docs/Web/API/Node/insertBefore

      svgElement.insertBefore(document.createTextNode('\n'), use.nextSibling);
    }

    class LightningPrimitiveIcon extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.iconName = void 0;
        this.src = void 0;
        this.svgClass = void 0;
        this.size = 'medium';
        this.variant = void 0;
        this.privateIconSvgTemplates = configProvider.getIconSvgTemplates();
      }

      get inlineSvgProvided() {
        return !!this.privateIconSvgTemplates;
      }

      renderedCallback() {
        if (this.iconName !== this.prevIconName && !this.inlineSvgProvided) {
          this.prevIconName = this.iconName;
          const svgElement = this.template.querySelector('svg');
          polyfill(svgElement);
          safariA11yPatch(svgElement);
        }
      }

      get href() {
        return this.src || getIconPath(this.iconName, configProvider.getLocale && configProvider.getLocale().dir);
      }

      get name() {
        return getName(this.iconName);
      }

      get normalizedSize() {
        return normalizeString(this.size, {
          fallbackValue: 'medium',
          validValues: ['xx-small', 'x-small', 'small', 'medium', 'large']
        });
      }

      get normalizedVariant() {
        // NOTE: Leaving a note here because I just wasted a bunch of time
        // investigating why both 'bare' and 'inverse' are supported in
        // lightning-primitive-icon. lightning-icon also has a deprecated
        // 'bare', but that one is synonymous to 'inverse'. This 'bare' means
        // that no classes should be applied. So this component needs to
        // support both 'bare' and 'inverse' while lightning-icon only needs to
        // support 'inverse'.
        return normalizeString(this.variant, {
          fallbackValue: '',
          validValues: ['bare', 'error', 'inverse', 'warning', 'success']
        });
      }

      get computedClass() {
        const {
          normalizedSize,
          normalizedVariant
        } = this;
        const classes = classSet(this.svgClass);

        if (normalizedVariant !== 'bare') {
          classes.add('slds-icon');
        }

        switch (normalizedVariant) {
          case 'error':
            classes.add('slds-icon-text-error');
            break;

          case 'warning':
            classes.add('slds-icon-text-warning');
            break;

          case 'success':
            classes.add('slds-icon-text-success');
            break;

          case 'inverse':
          case 'bare':
            break;

          default:
            // if custom icon is set, we don't want to set
            // the text-default class
            if (!this.src) {
              classes.add('slds-icon-text-default');
            }

        }

        if (normalizedSize !== 'medium') {
          classes.add(`slds-icon_${normalizedSize}`);
        }

        return classes.toString();
      }

      resolveTemplate() {
        const name = this.iconName;

        if (isValidName(name)) {
          const [spriteName, iconName] = name.split(':');
          const template = this.privateIconSvgTemplates[`${spriteName}_${iconName}`];

          if (template) {
            return template;
          }
        }

        return _tmpl;
      }

      render() {
        if (this.inlineSvgProvided) {
          return this.resolveTemplate();
        }

        return _tmpl;
      }

    }

    lwc.registerDecorators(LightningPrimitiveIcon, {
      publicProps: {
        iconName: {
          config: 0
        },
        src: {
          config: 0
        },
        svgClass: {
          config: 0
        },
        size: {
          config: 0
        },
        variant: {
          config: 0
        }
      }
    });

    var _lightningPrimitiveIcon = lwc.registerComponent(LightningPrimitiveIcon, {
      tmpl: _tmpl
    });

    function tmpl$1($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element
      } = $api;
      return [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.state.iconName,
          "size": $cmp.size,
          "variant": $cmp.variant,
          "src": $cmp.state.src
        },
        key: 2
      }, []), $cmp.alternativeText ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 3
      }, [api_dynamic($cmp.alternativeText)]) : null];
    }

    var _tmpl$2 = lwc.registerTemplate(tmpl$1);
    tmpl$1.stylesheets = [];
    tmpl$1.stylesheetTokens = {
      hostAttribute: "lightning-icon_icon-host",
      shadowAttribute: "lightning-icon_icon"
    };

    /**
     * Represents a visual element that provides context and enhances usability.
     */

    class LightningIcon extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.state = {};
        this.alternativeText = void 0;
      }

      /**
       * A uri path to a custom svg sprite, including the name of the resouce,
       * for example: /assets/icons/standard-sprite/svg/test.svg#icon-heart
       * @type {string}
       */
      get src() {
        return this.privateSrc;
      }

      set src(value) {
        this.privateSrc = value; // if value is not present, then we set the state back
        // to the original iconName that was passed
        // this might happen if the user sets a custom icon, then
        // decides to revert back to SLDS by removing the src attribute

        if (!value) {
          this.state.iconName = this.iconName;
          this.classList.remove('slds-icon-standard-default');
        } // if isIE11 and the src is set
        // we'd like to show the 'standard:default' icon instead
        // for performance reasons.


        if (value && isIE11) {
          this.setDefault();
          return;
        }

        this.state.src = value;
      }
      /**
       * The Lightning Design System name of the icon.
       * Names are written in the format 'utility:down' where 'utility' is the category,
       * and 'down' is the specific icon to be displayed.
       * @type {string}
       * @required
       */


      get iconName() {
        return this.privateIconName;
      }

      set iconName(value) {
        this.privateIconName = value; // if src is set, we don't need to validate
        // iconName

        if (this.src) {
          return;
        }

        if (isValidName(value)) {
          const isAction = getCategory(value) === 'action'; // update classlist only if new iconName is different than state.iconName
          // otherwise classListMutation receives class:true and class: false and removes slds class

          if (value !== this.state.iconName) {
            classListMutation(this.classList, {
              'slds-icon_container_circle': isAction,
              [computeSldsClass(value)]: true,
              [computeSldsClass(this.state.iconName)]: false
            });
          }

          this.state.iconName = value;
        } else {
          console.warn(`<lightning-icon> Invalid icon name ${value}`); // eslint-disable-line no-console
          // Invalid icon names should render a blank icon. Remove any
          // classes that might have been previously added.

          classListMutation(this.classList, {
            'slds-icon_container_circle': false,
            [computeSldsClass(this.state.iconName)]: false
          });
          this.state.iconName = undefined;
        }
      }
      /**
       * The size of the icon. Options include xx-small, x-small, small, medium, or large.
       * The default is medium.
       * @type {string}
       * @default medium
       */


      get size() {
        return normalizeString(this.state.size, {
          fallbackValue: 'medium',
          validValues: ['xx-small', 'x-small', 'small', 'medium', 'large']
        });
      }

      set size(value) {
        this.state.size = value;
      }
      /**
       * The variant changes the appearance of a utility icon.
       * Accepted variants include inverse, success, warning, and error.
       * Use the inverse variant to implement a white fill in utility icons on dark backgrounds.
       * @type {string}
       */


      get variant() {
        return normalizeVariant(this.state.variant, this.state.iconName);
      }

      set variant(value) {
        this.state.variant = value;
      }

      connectedCallback() {
        this.classList.add('slds-icon_container');
      }

      setDefault() {
        this.state.src = undefined;
        this.state.iconName = 'standard:default';
        this.classList.add('slds-icon-standard-default');
      }

    }

    lwc.registerDecorators(LightningIcon, {
      publicProps: {
        alternativeText: {
          config: 0
        },
        src: {
          config: 3
        },
        iconName: {
          config: 3
        },
        size: {
          config: 3
        },
        variant: {
          config: 3
        }
      },
      track: {
        state: 1
      }
    });

    var _lightningIcon = lwc.registerComponent(LightningIcon, {
      tmpl: _tmpl$2
    });

    function normalizeVariant(variant, iconName) {
      // Unfortunately, the `bare` variant was implemented to do what the
      // `inverse` variant should have done. Keep this logic for as long as
      // we support the `bare` variant.
      if (variant === 'bare') {
        // TODO: Deprecation warning using strippable assertion
        variant = 'inverse';
      }

      if (getCategory(iconName) === 'utility') {
        return normalizeString(variant, {
          fallbackValue: '',
          validValues: ['error', 'inverse', 'warning', 'success']
        });
      }

      return 'inverse';
    }

    function tmpl$2($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        h: api_element,
        d: api_dynamic,
        s: api_slot
      } = $api;
      return [api_element("article", {
        className: $cmp.computedWrapperClassNames,
        key: 2
      }, [api_element("header", {
        classMap: {
          "slds-card__header": true,
          "slds-grid": true
        },
        key: 3
      }, [api_element("div", {
        classMap: {
          "slds-media": true,
          "slds-media_center": true,
          "slds-has-flexi-truncate": true
        },
        key: 4
      }, [$cmp.hasIcon ? api_element("div", {
        classMap: {
          "slds-media__figure": true
        },
        key: 6
      }, [api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "iconName": $cmp.iconName,
          "size": "small"
        },
        key: 7
      }, [])]) : null, api_element("div", {
        classMap: {
          "slds-media__body": true,
          "slds-truncate": true
        },
        key: 8
      }, [api_element("h2", {
        key: 9
      }, [api_element("span", {
        classMap: {
          "slds-text-heading_small": true
        },
        key: 10
      }, [$cmp.hasStringTitle ? api_dynamic($cmp.title) : null, !$cmp.hasStringTitle ? api_slot("title", {
        attrs: {
          "name": "title"
        },
        key: 13
      }, [], $slotset) : null])])])]), api_element("div", {
        classMap: {
          "slds-no-flex": true
        },
        key: 14
      }, [api_slot("actions", {
        attrs: {
          "name": "actions"
        },
        key: 15
      }, [], $slotset)])]), api_element("div", {
        classMap: {
          "slds-card__body": true
        },
        key: 16
      }, [api_slot("", {
        key: 17
      }, [], $slotset)]), api_element("div", {
        classMap: {
          "slds-card__footer": true
        },
        key: 18
      }, [api_slot("footer", {
        attrs: {
          "name": "footer"
        },
        key: 19
      }, [api_element("span", {
        attrs: {
          "data-id": "default-content"
        },
        key: 20
      }, [])], $slotset)])])];
    }

    var _tmpl$3 = lwc.registerTemplate(tmpl$2);
    tmpl$2.slots = ["title", "actions", "", "footer"];
    tmpl$2.stylesheets = [];
    tmpl$2.stylesheetTokens = {
      hostAttribute: "lightning-card_card-host",
      shadowAttribute: "lightning-card_card"
    };

    function isNarrow(variant) {
      return typeof variant === 'string' && variant.toLowerCase() === 'narrow';
    }
    function isBase(variant) {
      return typeof variant === 'string' && variant.toLowerCase() === 'base';
    }

    /**
     * Cards apply a container around a related grouping of information.
     * @slot title Placeholder for the card title, which can be represented by a header or h1 element.
     * The title is displayed at the top of the card, to the right of the icon.
     * Alternatively, use the title attribute if you don't need to pass in extra markup in your title.
     * @slot actions Placeholder for actionable components, such as lightning-button or lightning-button-menu.
     * Actions are displayed on the top right corner of the card next to the title.
     * @slot footer Placeholder for the card footer, which is displayed at the bottom of the card and is usually optional.
     * For example, the footer can display a "View All" link to navigate to a list view.
     * @slot default Placeholder for your content in the card body.
     */

    class LightningCard extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.title = void 0;
        this.iconName = void 0;
        this.privateVariant = 'base';
      }

      set variant(value) {
        if (isNarrow(value) || isBase(value)) {
          this.privateVariant = value;
        } else {
          this.privateVariant = 'base';
        }
      }
      /**
       * The variant changes the appearance of the card.
       * Accepted variants include base or narrow.
       * This value defaults to base.
       *
       * @type {string}
       * @default base
       */


      get variant() {
        return this.privateVariant;
      }

      renderedCallback() {
        const footerWrapper = this.template.querySelector('.slds-card__footer');
        const noFooterContent = this.template.querySelector('slot[name="footer"] [data-id="default-content"]');

        if (noFooterContent) {
          if (footerWrapper.remove) {
            footerWrapper.remove();
          } else if (footerWrapper.parentNode) {
            // IE11 doesn't support remove. https://caniuse.com/#feat=childnode-remove
            // TODO: remove when lwc can polyfill node.remove.
            footerWrapper.parentNode.removeChild(footerWrapper);
          }
        }
      }

      get computedWrapperClassNames() {
        return classSet('slds-card').add({
          'slds-card_narrow': isNarrow(this.privateVariant)
        });
      }

      get hasIcon() {
        return !!this.iconName;
      }

      get hasStringTitle() {
        return !!this.title;
      }

    }

    lwc.registerDecorators(LightningCard, {
      publicProps: {
        title: {
          config: 0
        },
        iconName: {
          config: 0
        },
        variant: {
          config: 3
        }
      },
      track: {
        privateVariant: 1
      }
    });

    var _lightningCard = lwc.registerComponent(LightningCard, {
      tmpl: _tmpl$3
    });

    function stylesheet$1(hostSelector, shadowSelector, nativeShadow) {
      return ".record-form-spanner" + shadowSelector + " {min-height: 50px;}\n";
    }
    var _implicitStylesheets$1 = [stylesheet$1];

    function tmpl$3($api, $cmp, $slotset, $ctx) {
      const {
        s: api_slot,
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_element("form", {
        className: $cmp.formClass,
        props: {
          "noValidate": true
        },
        key: 2,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleSubmit)),
          "registeroutputfield": _m1 || ($ctx._m1 = api_bind($cmp.handleRegister)),
          "registerinputfield": _m2 || ($ctx._m2 = api_bind($cmp.handleRegister)),
          "registerfielddependency": _m3 || ($ctx._m3 = api_bind($cmp.registerDependentField)),
          "updatedependentfields": _m4 || ($ctx._m4 = api_bind($cmp.updateDependentFields)),
          "error": _m5 || ($ctx._m5 = api_bind($cmp.handleError))
        }
      }, [api_slot("", {
        key: 3
      }, [], $slotset)])];
    }

    var _tmpl$4 = lwc.registerTemplate(tmpl$3);
    tmpl$3.slots = [""];
    tmpl$3.stylesheets = [];
    tmpl$3.stylesheetTokens = {
      hostAttribute: "lightning-recordEditForm_recordEditForm-host",
      shadowAttribute: "lightning-recordEditForm_recordEditForm"
    };

    var labelApiNameMismatch = 'API Name {0} is invalid, did you mean "{1}?"';

    var labelInvalidId = 'Error in fetching record: invalid record id.';

    /*
     * Constants to use UI API.
     *
     * The values must match those used in UI API responses.
     */
    const DensityValues = {
      COMFY: 'comfy',
      COMPACT: 'compact',
      AUTO: 'auto'
    };
    const LabelAlignValues = {
      STACKED: 'stacked',
      HORIZONTAL: 'horizontal'
    };
    /**
     * Field types.
     * source: TODO - add ui sdk java class
     */

    const FieldTypes = {
      ADDRESS: 'Address',
      BASE64: 'Base64',
      BOOLEAN: 'Boolean',
      COMPLEX_VALUE: 'ComplexValue',
      CURRENCY: 'Currency',
      DATE: 'Date',
      DATETIME: 'DateTime',
      DOUBLE: 'Double',
      RICH_TEXTAREA: 'RichTextArea',
      DECIMAL: 'Decimal',
      EMAIL: 'Email',
      ENCRYPTED_STRING: 'EncryptedString',
      INT: 'Int',
      LOCATION: 'Location',
      MULTI_PICKLIST: 'MultiPicklist',
      PLAIN_TEXTAREA: 'PlainTextArea',
      PERCENT: 'Percent',
      PHONE: 'Phone',
      PICKLIST: 'Picklist',
      REFERENCE: 'Reference',
      STRING: 'String',
      TEXT: 'Text',
      TEXTAREA: 'TextArea',
      TIME: 'Time',
      URL: 'Url',
      PERSON_NAME: 'PersonName',
      SWITCHABLE_PERSON_NAME: 'SwitchablePersonName'
    };
    /**
     * Localized field types.
     * source: com.force.util.soql.functions.SoqlFunctions.fieldSupportsToLabel(String, String)
     */

    const LocalizedFieldTypes = [FieldTypes.MULTI_PICKLIST, FieldTypes.PICKLIST, FieldTypes.CURRENCY, FieldTypes.DATE, FieldTypes.DATETIME];

    const Fields = FieldTypes;
    const UNSUPPORTED_REFERENCE_FIELDS = ['OwnerId', 'CreatedById', 'LastModifiedById'];
    const labelAlignValues = LabelAlignValues;
    const densityValues = DensityValues;

    const getCompoundValue = (field, record, fieldInfo, objectInfo) => {
      if (FieldTypes.LOCATION === fieldInfo.dataType) {
        const prefix = field.slice(0, field.indexOf('__c'));
        const longitude = record.fields[prefix + '__Longitude__s'].value;
        const latitude = record.fields[prefix + '__Latitude__s'].value;
        return {
          longitude,
          latitude
        };
      } // fields with no value, it must be derived from the constituant fields


      const compoundFields = getCompoundFields(field, record, objectInfo);
      const ret = {};
      compoundFields.forEach(childField => {
        if (record.fields[childField]) {
          ret[childField] = record.fields[childField].value;
        }
      });
      return ret;
    };
    /**
     * Given a record will determine if it is a PersonAccount or not
     * @param {Object} record the record to check
     *
     * @returns {boolean} true if the record is a personAccount
     */


    function isPersonAccount(record) {
      if (record.apiName !== 'Account' && record.apiName !== 'PersonAccount') {
        return false;
      }

      return record.fields.IsPersonAccount ? record.fields.IsPersonAccount.value : false;
    }
    /**
    /**
     *
     * @param {string} field the field identifier (SOQL syntax)
     * @param {object} record the record
     * @param {object} objectInfo a single object info defining the field
     * @return {array} a list of constituent fields
     */

    function getCompoundFields(field, record, objectInfo) {
      return Object.keys(objectInfo.fields).filter(key => {
        return key !== field && record.fields[key] && objectInfo.fields[key].compoundFieldName === field;
      });
    }

    const getReferenceInfo = (record, fieldInfo) => {
      const relationshipName = fieldInfo.relationshipName; // TODO: handle multiple referenceToInfos

      const relationshipNameFields = fieldInfo.referenceToInfos[0].nameFields;
      const relationship = record.fields[relationshipName];

      if (!relationship || !relationship.value) {
        return {
          referenceId: null,
          displayValue: null
        };
      } // TODO: Should references support localized fields and thus return a value to complement their displayValue?


      const referenceField = relationship.value.fields;
      const displayValue = relationship.displayValue || relationshipNameFields.reduce((acc, nameField) => {
        const thisField = referenceField[nameField];

        if (thisField) {
          return acc + ' ' + thisField.value;
        }

        return acc;
      }, '').trim();
      return {
        referenceId: referenceField.Id.value,
        displayValue
      };
    };
    /**
     * Get a UiField from a field on a record.
     * objectInfo and objectInfos are optional but at least one must be present
     * @param {string} field the field identifier (SOQL syntax)
     * @param {object} record the record
     * @param {object} objectInfo a single object info defining the field
     * @return {array} a UiField representing the field.
     */


    const getUiField = (field, record, objectInfo) => {
      const fieldInfo = objectInfo.fields[field];

      if (!fieldInfo) {
        throw new Error(`Field [${field}] was not found`);
      }

      const personAccount = isPersonAccount(record);
      const value = isCompoundField(field, objectInfo, personAccount) ? getCompoundValue(field, record, fieldInfo, objectInfo) : record.fields[field] && record.fields[field].value; // TODO - handle formatting
      // ui sdk formats these field types: currency, date, datetime, time (/ui-services-api/java/src/ui/services/api/soql/FormatFunctionHelper.java
      // ui sdk localizes based on com.force.util.soql.functions.SoqlFunctions.fieldSupportsToLabel(String, String)
      // thomas will expose this in objectInfo but until then i can pivot on that logic
      // - if [currency date datetime time] use value
      // - else if diplayValue is present use it
      // - else use value

      let result = {
        type: fieldInfo.dataType,
        extraTypeInfo: fieldInfo.extraTypeInfo,
        label: fieldInfo.label,
        inlineHelpText: fieldInfo.inlineHelpText,
        value
      };
      result = Object.assign(result, fieldInfo);

      if (fieldInfo.reference) {
        const referenceInfo = getReferenceInfo(record, fieldInfo);
        result.value = referenceInfo.referenceId;
        result.displayValue = referenceInfo.displayValue;
      } else {
        // provide the display value for localizable field types
        const includeDisplayValue = LocalizedFieldTypes.includes(fieldInfo.dataType);

        if (includeDisplayValue) {
          result.displayValue = record.fields[field].displayValue;
        }
      }

      return result;
    };
    /**
     * Determine if any field in a list of fields
     * is updateable
     * @param {array} fields list of constituent fields
     * @param {object} record the record
     * @param {object} objectInfo object info
     *
     * @returns {Boolean} true if any of the fields are updateable, otherwise false
     */

    function compoundFieldIsUpdateable(fields, record, objectInfo) {
      // if any constituent field is updateable, the field is
      for (let i = 0; i < fields.length; i++) {
        if (objectInfo.fields[fields[i]].updateable) {
          return true;
        }
      }

      return false;
    }
    /**
     *
     * Determines if a field actually has contituent fields,
     * because some fields might identify themselves as compound
     * but without constituent fields we can't treat them as compound
     *
     * @param {string} field the field identifier (SOQL syntax)
     * @param {object} objectInfo a single object info defining the field
     * @param {boolean} personAccount if this object is a PersonAccount (Name is compound)
     *                                  https://help.salesforce.com/articleView?id=account_person.htm&type=5
     * @returns {boolean} true if the field is a compound field, false if it is not
     */

    function isCompoundField(field, objectInfo, personAccount = false) {
      const fieldInfo = objectInfo.fields[field];

      if (!fieldInfo) {
        // a field that does not exist is not compound
        // this is safety to prevent gacks and probably should not generally happen
        return false;
      }

      if (fieldInfo.compound === false) {
        return false;
      }

      const keys = Object.keys(objectInfo.fields);

      for (let i = 0; i < keys.length; i++) {
        if (keys[i] !== field && objectInfo.fields[keys[i]].compoundFieldName === field) {
          // special case for when person accounts are enabled, but this is not a personAccount. In this case
          // the Name field of an account looks like a compound field but is not.
          if (objectInfo.apiName === 'Account' && objectInfo.fields[keys[i]].compoundFieldName === 'Name' && !personAccount) {
            return false;
          }

          return true;
        }
      }

      return false;
    }
    /**
     * Normalize the given error object.
     * @param  {Error | Object} err This could be a javascript Error or an error emitted from LDS (ErrorResponse).
     * @return {Object} An object with a string message and a string detail
     */

    function parseError(err) {
      let message = '',
          output = {},
          detail = '';

      if (err) {
        if (err.body && err.body.output) {
          // ErrorResponse with Record Output Error
          // https://developer.salesforce.com/docs/atlas.en-us.uiapi.meta/uiapi/ui_api_responses_error_with_output.htm
          message = err.body.message;

          if (err.body.output.errors.length > 0) {
            detail = err.body.output.errors[0].message;
          } // output is part of the recordUi error response,
          // so we will include it.


          output = JSON.parse(JSON.stringify(err.body.output));
        } else if (Array.isArray(err.body) && err.body.length > 0) {
          // ErrorResponse with normal UIAPI error.
          message = err.body[0].message;
          detail = err.body[0].errorCode;
        } else if (err.body && err.body.message) {
          // ErrorResponse with body that has a message.
          message = err.body.message;
        } else if (err.body) {
          // ErrorResponse with unknown body.
          message = err.body;
        } else if (err.statusText) {
          // ErrorResponse with no body.
          message.err = err.statusText;
        } else if (err.message) {
          // Vanilla js error.
          message = err.message;
        } else {
          // Unknown error.
          message = err;
        }
      }

      return {
        message,
        detail,
        output
      };
    }
    function createErrorEvent(err) {
      const {
        message,
        detail
      } = parseError(err);
      const error = new Error(message);
      return new ErrorEvent('error', {
        error,
        message,
        detail
      });
    }
    /**
     *
     * Converts a Salesforce layout  response into a list of fields.
     *
     * Rolls compound field constituents up to parent
     * https://developer.salesforce.com/docs/atlas.en-us.uiapi.meta/uiapi/ui_api_responses_record_layout.htm#ui_api_responses_record_layout
     * @param {Object} layout the layout response
     * @param {Object} objectInfo the objectInfo for the object
     * @returns {Array} the list of fields.
     */

    function getFieldsForLayout(layout, objectInfo) {
      const processedFieldNames = {};

      const fieldsAccumulator = (listToReduce, fieldsGetterFn) => {
        return listToReduce.reduce((fields, item) => {
          return fields.concat(fieldsGetterFn(item));
        }, []);
      };

      const getFieldsFromLayoutComponent = layoutComponent => {
        // normalize compound fields, de-dupe (dupes are just caused by compound fields)
        // this assumes that layoutItems only ever have more than one component if they are
        // a compound field
        let fieldName = layoutComponent.apiName;
        const fieldInfo = objectInfo.fields[layoutComponent.apiName]; // checking for fieldInfo filters out layout items that aren't fields

        if (fieldInfo && fieldInfo.compoundFieldName) {
          fieldName = fieldInfo.compoundFieldName;
        }

        if (fieldInfo && !processedFieldNames[fieldName]) {
          processedFieldNames[fieldName] = true;
          return fieldName;
        }

        return []; // empty array so concat adds nothing
      };

      const getFieldsFromItem = item => fieldsAccumulator(item.layoutComponents, getFieldsFromLayoutComponent);

      const getFieldsFromRow = row => fieldsAccumulator(row.layoutItems, getFieldsFromItem);

      const getFieldsFromSection = section => fieldsAccumulator(section.layoutRows, getFieldsFromRow);

      const getFieldsFromSections = sections => fieldsAccumulator(sections, getFieldsFromSection);

      return getFieldsFromSections(layout.sections);
    }

    function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

    function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    function filterByPicklistsInForm(objectInfo, picklistValues, fields) {
      const picklistsInForm = getPicklistFields(objectInfo, fields);
      return filterPicklistValues(picklistValues, picklistsInForm);
    }
    function formHasPicklists(objectInfo, fields) {
      return getPicklistFields(objectInfo, fields).size > 0;
    }

    function getPicklistFields(objectInfo, fields) {
      const picklistFields = new Set();

      for (const fieldName in objectInfo.fields) {
        if (objectInfo.fields.hasOwnProperty(fieldName)) {
          const field = objectInfo.fields[fieldName];

          if (field.dataType === Fields.PICKLIST || field.dataType === Fields.MULTI_PICKLIST) {
            // need to check the parent for compound fields
            const fieldNameToCheck = field.compoundFieldName || fieldName;

            if (fields.includes(`${objectInfo.apiName}.${fieldNameToCheck}`)) {
              picklistFields.add(field.apiName);
            }
          }
        }
      }

      return picklistFields;
    }

    function filterPicklistValues(picklistsByRecordType, picklistsInForm) {
      return Object.keys(picklistsByRecordType).filter(key => picklistsInForm.has(key)).reduce((obj, key) => {
        return _objectSpread({}, obj, {
          [key]: picklistsByRecordType[key]
        });
      }, {});
    }

    /**
     * This file exists just to reduce code duplication
     * between the aura and raptor implementations
     * of record-edit-form
     */
    const OUTPUT_FIELD_TAGNAME = 'LIGHTNING-OUTPUT-FIELD';

    function normalizeRecord(newRecord) {
      const normalizedRecord = Object.assign({}, newRecord);
      normalizedRecord.fields = {};
      Object.keys(newRecord.fields).forEach(field => {
        if (newRecord.fields[field] && typeof newRecord.fields[field] === 'object') {
          normalizedRecord.fields[field] = newRecord.fields[field];
        } else {
          normalizedRecord.fields[field] = {
            value: newRecord.fields[field]
          };
        }
      });
      return normalizedRecord;
    }

    async function ldsUpdateRecord(newRecord, originalRecord, objectInfo) {
      newRecord.id = originalRecord.id;
      newRecord.apiName = null;
      const newRecordEdit = lds.generateRecordInputForUpdate(normalizeRecord(newRecord), objectInfo);
      const recordToSave = lds.createRecordInputFilteredByEditedFields(newRecordEdit, originalRecord);
      return lds.updateRecord(recordToSave);
    }
    async function ldsCreateRecord(newRecord, objectInfo) {
      const normalizedRecord = normalizeRecord(newRecord);
      const recordToSave = lds.generateRecordInputForCreate(normalizedRecord, objectInfo);
      return lds.createRecord(recordToSave);
    }
    /**
     *
     * Create or edit a record. If no original record is
     * specified create the record, otherwise update it
     * @param {recordInput} newRecord the dirty fields to change
     * @param {recordInput} originalRecord the original record
     * @param {objectInfo} objectInfo info about the object
     * @returns {Promise} Resovled when record is created or saved
     */

    async function createOrSaveRecord(newRecord, originalRecord, objectInfo) {
      if (originalRecord) {
        return ldsUpdateRecord(newRecord, originalRecord, objectInfo);
      }

      return ldsCreateRecord(newRecord, objectInfo);
    }
    /**
     * Returns a map of fieldNames : values
     * for an *array* of inputField components
     *
     * @param {lightningInputField[]} inputFields components
     * @returns {Object} map of fieldNames: values
     */

    function getFormValues(inputFields) {
      const values = {};
      inputFields.forEach(field => {
        if (field.readonly) {
          return;
        } // compound fields need to be flattened


        if (field.value && typeof field.value === 'object') {
          // geoloc compounds have weird field names
          if (field.value.longitude) {
            const prefix = field.fieldName.slice(0, field.fieldName.indexOf('__c'));
            values[prefix + '__Longitude__s'] = field.value.longitude;
            values[prefix + '__Latitude__s'] = field.value.latitude;
          } else {
            Object.assign(values, field.value);
          }
        } else {
          values[field.fieldName] = field.value;
        }
      });
      return values;
    }
    /**
     * Normalize the given error object.
     * @param  {Error | Object} err This could be a javascript Error or an error emitted from LDS (ErrorResponse).
     * @return {Object} An object with a string message and a string detail
     */

    function parseError$1(err) {
      let message = '',
          output = {},
          detail = '';

      if (err) {
        if (err.body && err.body.output) {
          // ErrorResponse with Record Output Error
          // https://developer.salesforce.com/docs/atlas.en-us.uiapi.meta/uiapi/ui_api_responses_error_with_output.htm
          message = err.body.message;

          if (err.body.output.errors.length > 0) {
            detail = err.body.output.errors[0].message;
          } else if (err.body.detail) {
            detail = err.body.detail;
          } // output is part of the recordUi error response,
          // so we will include it.


          output = JSON.parse(JSON.stringify(err.body.output));
        } else if (Array.isArray(err.body) && err.body.length > 0) {
          // ErrorResponse with normal UIAPI error.
          message = err.body[0].message;
          detail = err.body[0].errorCode;
        } else if (err.body && err.body.message) {
          // ErrorResponse with body that has a message.
          message = err.body.message;
          detail = err.body.detail ? err.body.detail : '';
        } else if (err.body) {
          // ErrorResponse with unknown body.
          message = err.body;
        } else if (err.statusText) {
          // ErrorResponse with no body.
          message.err = err.statusText;
        } else if (err.message) {
          // Vanilla js error.
          message = err.message;
        } else {
          // Unknown error.
          message = err;
        }
      }

      return {
        message,
        detail,
        output
      };
    }
    function createErrorEvent$1(err) {
      const parsed = parseError$1(err);
      return new CustomEvent('error', {
        detail: parsed
      });
    }
    /**
     * Creates a list of fully qualified
     * fieldnames with no duplicates
     */

    class FieldSet$1 {
      /**
       *
       * @param {String} objectApiName The object name
       */
      constructor(objectApiName) {
        this._set = new Set();
        this._apiName = objectApiName;
      }

      set objectApiName(objectApiName) {
        this._apiName = objectApiName;
      }
      /**
       * Add a single field
       * @param {String} val unqualified field name
       */


      add(val) {
        this._set.add(val);
      }
      /**
       * Add a list of fieldnames
       * @param {Array} arr Array of unqualified field names
       */


      concat(arr) {
        arr.forEach(item => {
          this.add(item);
        });
      } // using a method here rather than a getter
      // because this seemed clearer

      /**
       * @returns {Array} a list of fully qualified field names
       */


      getList() {
        const apiName = this._apiName;
        return [...this._set].map(field => {
          return `${apiName}.${field}`;
        });
      }
      /**
       * @returns {Array} a list of unqualified field names
       */


      getUnqualifiedList() {
        return [...this._set];
      }

    }
    /**
     *
     * Calls `reportValidity` on every input field, returns true
     * if all fields are valid, false if any are not
     *
     * @param {Array} inputFields list of input fields to validate
     * @returns {Boolean} true if all fields are false, true otherwise
     */


    function validateForm(inputFields) {
      let isValid = true;
      inputFields.forEach(cmp => {
        // output fields are always valid, the second clause is defensive in case
        // somebody passes the wrong type of component in this array
        if (cmp.tagName === OUTPUT_FIELD_TAGNAME || !cmp.reportValidity) {
          return;
        }

        if (!cmp.reportValidity()) {
          isValid = false;
        }
      });
      return isValid;
    }
    /**
     * Convenience function because you can't use
     * Set() in aura directly, also this
     * puts the "qualification" of fields in one place
     *
     * @param {String} objectApiName An object api name (entity name) to qualify fields
     * @returns {FieldSet} Field set has one method: add() to add a fieldname and one attribute list,
     *                     which you can use to get the qualified list of api names (an array)
     */

    function getFieldSet$1(objectApiName) {
      return new FieldSet$1(objectApiName);
    }

    class LightningResizeObserver {
      constructor(resizeCallback) {
        this._resizeObserverAvailable = typeof ResizeObserver === 'function';

        const delayedCallback = callback => {
          if (this._running) {
            return;
          }

          this._running = true; // eslint-disable-next-line lwc/no-set-timeout

          setTimeout(() => {
            callback();
            this._running = false;
          }, 60);
        };

        this._delayedResizeCallback = delayedCallback.bind(this, resizeCallback);

        if (this._resizeObserverAvailable) {
          this._resizeObserver = new ResizeObserver(this._delayedResizeCallback);
        }
      }

      observe(lightningElement) {
        // Using requestAnimationFrame as the element may not be physically in the DOM yet.
        this._requestAnimationId = requestAnimationFrame(() => {
          const domElement = lwc.unwrap(lightningElement);

          if (this._resizeObserverAvailable) {
            this._resizeObserver.observe(domElement);
          } else if (!this._hasWindowResizeHandler) {
            window.addEventListener('resize', this._delayedResizeCallback);
            this._hasWindowResizeHandler = true;
          }
        });
      }

      disconnect() {
        if (this._resizeObserver) {
          this._resizeObserver.disconnect();
        }

        if (this._requestAnimationId) {
          cancelAnimationFrame(this._requestAnimationId);
        }

        window.removeEventListener('resize', this._delayedResizeCallback);
        this._hasWindowResizeHandler = false;
      }

    }

    /**
     * Width breakpoint for changing desnification setting
     */
    const APP_DENSIFICATION_BREAKPOINT = 650;
    const appDensityValues = {
      COMFY: 'VIEW_ONE',
      COMPACT_AUTO: 'VIEW_TWO'
    };

    function doNormalization(val, cmpInterface) {
      const normalized = normalizeString(val, {
        fallbackValue: densityValues.AUTO,
        validValues: [densityValues.AUTO, densityValues.COMPACT, densityValues.COMFY]
      });
      cmpInterface.setDensityPrivate(normalized);
      setLabelAlignment(cmpInterface);
    }
    function setLabelAlignment(cmpInterface) {
      const fieldLabelAlignment = cmpInterface.getLabelAlignmentPrivate();

      if (isDensityComfy(cmpInterface)) {
        if (fieldLabelAlignment !== labelAlignValues.STACKED) {
          cmpInterface.setLabelAlignmentPrivate(labelAlignValues.STACKED);
          wireLabelAlignment(cmpInterface);
        }
      } else if (isDensityCompact(cmpInterface)) {
        if (fieldLabelAlignment !== labelAlignValues.HORIZONTAL) {
          cmpInterface.setLabelAlignmentPrivate(labelAlignValues.HORIZONTAL);
          wireLabelAlignment(cmpInterface);
        }
      }
    } // Only density auto with wired density compact needs resize observer
    // If density is auto with wired comfy we can disconnect the observer or not connect it

    function resetResizeObserver(cmp, cmpInterface) {
      if (cmp._resizeObserver && !isWiredDensityAuto(cmpInterface)) {
        // If we have a resize observer and the density is not auto it means it was changed
        // to not auto, we should disconnect the resize observer.
        cmp._resizeObserver.disconnect();

        cmp._resizeObserver = undefined;
      } else if (isWiredDensityAuto(cmpInterface)) {
        // No resize observer and density is auto, we should setup the resize observer
        cmp._resizeObserver = setupResizeObserver(cmpInterface);
      }
    }

    function isWiredDensityAuto(cmpInterface) {
      const density = cmpInterface.getDensityPrivate();
      const wiredDensity = configProvider.getOneConfig().densitySetting;
      return density === densityValues.AUTO && wiredDensity !== appDensityValues.COMFY;
    }

    function isDensityComfy(cmpInterface) {
      const density = cmpInterface.getDensityPrivate();
      return density === densityValues.AUTO && configProvider.getOneConfig().densitySetting === appDensityValues.COMFY || density === densityValues.COMFY;
    }

    function isDensityCompact(cmpInterface) {
      const density = cmpInterface.getDensityPrivate();
      return isWiredDensityAuto(cmpInterface) || density === densityValues.COMPACT;
    }

    function setupResizeObserver(cmpInterface) {
      const containerEle = cmpInterface.getContainerElement();
      const resizeObserver = new LightningResizeObserver(cmpInterface.getResizeObserverCallback(resizeObserverCallback));
      resizeObserver.observe(containerEle);
      return resizeObserver;
    }

    function resizeObserverCallback(cmpInterface) {
      const containerEle = cmpInterface.getContainerElement();

      if (containerEle) {
        const containerWidth = containerEle.getBoundingClientRect().width;
        const fieldLabelAlignment = cmpInterface.getLabelAlignmentPrivate();
        let alignmentChanged = false;

        if (containerWidth < APP_DENSIFICATION_BREAKPOINT && fieldLabelAlignment !== labelAlignValues.STACKED) {
          cmpInterface.setLabelAlignmentPrivate(labelAlignValues.STACKED);
          alignmentChanged = true;
        }

        if (containerWidth >= APP_DENSIFICATION_BREAKPOINT && fieldLabelAlignment !== labelAlignValues.HORIZONTAL) {
          cmpInterface.setLabelAlignmentPrivate(labelAlignValues.HORIZONTAL);
          alignmentChanged = true;
        }

        if (alignmentChanged) {
          wireLabelAlignment(cmpInterface);
        }
      }
    }

    function wireLabelAlignment(cmpInterface) {
      const recordUi = cmpInterface.getRecordUi();

      if (recordUi) {
        const fields = cmpInterface.getInputOutputFields();
        recordUi.labelAlignment = cmpInterface.getLabelAlignmentPrivate();

        for (let i = 0; i < fields.length; i += 1) {
          fields[i].wireRecordUi(recordUi);
        }
      }
    }

    // NOTE: lightning-record-utils is a public library. adding new utils here means we
    // will have to support it until the end of time. Consider adding the util to
    // lightning-utils-private instead if it's something we can live with as
    // internal-only.

    /**
     * This is a prettified copy-paste of the force:records#to18 method.
     * Converts to 18-char record ids. Details at http://sfdc.co/bnBMvm.
     *
     * @param {String} recordId - a 15- or 18-char record id.
     * @return {String|null} - an 18-char record id, null if an invalid record id was provided.
     */
    function normalizeRecordId(recordId) {
      if (!recordId) {
        return null;
      }

      if (recordId.length === 15) {
        let suffix = '';
        const CASE_DECODE_STRING = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456'; // Build the 3 character suffix

        for (let set = 0; set < 3; ++set) {
          let decodeValue = 0;

          for (let bit = 0; bit < 5; bit++) {
            const c = recordId.charAt(set * 5 + bit);

            if (c >= 'A' && c <= 'Z') {
              decodeValue += 1 << bit;
            }
          }

          suffix += CASE_DECODE_STRING.charAt(decodeValue);
        }

        return recordId + suffix;
      } else if (recordId.length === 18) {
        return recordId;
      }

      return null;
    }

    class DependencyManager {
      // map of fieldName -> {fieldElement, controllerName}
      // map of controllerFieldName -> [dependentFieldNames]
      // map of picklist fieldName -> picklistValues
      // cache of picklist options, fieldName-controllerValue -> picklistOptions
      constructor(dependencyInfo) {
        this._fieldValues = {};
        this._dependencyMap = {};
        this._picklistMap = {};
        this._optionsCache = {};

        if (dependencyInfo) {
          registerDependencyInfo.call(this, dependencyInfo);
        }
      }

      registerDependencyInfo(dependencyInfo) {
        registerDependencyInfo.call(this, dependencyInfo);
      }

      registerField(fieldInfo) {
        registerField.call(this, fieldInfo);
      }

      handleFieldValueChange(fieldName, fieldValue) {
        handleFieldValueChange.call(this, fieldName, fieldValue);
      }

    }

    function registerDependencyInfo({
      dependentFields,
      picklistValues
    }) {
      // mainly needed for tests to clear the existing maps before each test
      clearMaps.call(this);

      if (dependentFields) {
        buildDependencyMap.call(this, dependentFields);
      }

      if (picklistValues) {
        Object.assign(this._picklistMap, picklistValues);
      }
    }

    function buildDependencyMap(config) {
      for (const prop in config) {
        if (config.hasOwnProperty(prop)) {
          const result = Object.keys(config[prop]).reduce((prev, key) => {
            prev.push(key);
            return prev;
          }, []);

          if (result.length > 0) {
            this._dependencyMap[prop] = result;
          }

          buildDependencyMap.call(this, config[prop]);
        }
      }
    }

    function registerField({
      fieldName,
      fieldElement
    }) {
      // add field to fieldValues map
      if (!(fieldName in this._fieldValues)) {
        this._fieldValues[fieldName] = {
          controllerName: getControllerName.call(this, fieldName),
          fieldElement
        };
      }

      initializeField.call(this, fieldName);
    }

    function initializeField(fieldName) {
      const field = this._fieldValues[fieldName];
      const hasController = field.controllerName !== undefined; // controller could be registered after the dependent field. Avoid initializing the dependent before the controller is registered.

      const controllerNotRegistered = hasController && this._fieldValues[field.controllerName] === undefined;

      if (controllerNotRegistered) {
        return;
      } // checkbox fields don't have options, only need to update its dependents


      if (this._picklistMap[fieldName] !== undefined) {
        const controllerValue = getControllerValue.call(this, fieldName);
        const picklistOptions = getPicklistOptions.call(this, fieldName, controllerValue);
        updateFieldOptions(fieldName, field.fieldElement, picklistOptions);
      } // If controller field is registered after the dependent field, we have to update the dependents with the correct controller value


      const fieldValue = getFieldValue(fieldName, field.fieldElement);
      updateDependentFields.call(this, fieldName, fieldValue);
    }

    function handleFieldValueChange(fieldName, fieldValue) {
      updateDependentFields.call(this, fieldName, fieldValue);
    }

    function updateDependentFields(fieldName, fieldValue) {
      const dependentFieldNames = this._dependencyMap[fieldName] || [];

      if (!dependentFieldNames.length) {
        return;
      } // update the options on all of the fields that depend on the field


      for (let i = 0, len = dependentFieldNames.length; i < len; i++) {
        const dependentFieldName = dependentFieldNames[i];
        const field = this._fieldValues[dependentFieldName];

        if (field) {
          const newOptions = getPicklistOptions.call(this, dependentFieldName, fieldValue);
          updateFieldOptions(dependentFieldName, field.fieldElement, newOptions);
        }
      }
    }

    function getControllerName(fieldName) {
      return Object.keys(this._dependencyMap).find(key => this._dependencyMap[key].includes(fieldName));
    }

    function getControllerValue(fieldName) {
      const field = this._fieldValues[fieldName];
      const controllerField = this._fieldValues[field.controllerName]; // Value on the controller field could have been set to the picklist default value.
      // However, initially we may not have access to the controller field depending on the order that the fields are registered.

      let controllerValue;

      if (controllerField) {
        controllerValue = getFieldValue(field.controllerName, controllerField.fieldElement);
      }

      return controllerValue;
    }

    function getFieldValue(fieldName, fieldElement) {
      const fieldValue = fieldElement.getFieldValue(); // for compound fields like address, the value is an object

      if (typeof fieldValue === 'object' && fieldValue !== null) {
        return fieldValue[fieldName];
      }

      return fieldValue;
    }

    function getPicklistOptions(fieldName, controllerValue) {
      const cacheKey = getOptionsUniqueKey({
        fieldName,
        controllerValue
      });

      if (cacheKey in this._optionsCache) {
        return this._optionsCache[cacheKey];
      }

      const field = this._fieldValues[fieldName];
      const picklistInfo = this._picklistMap[fieldName];
      let picklistValues = picklistInfo && picklistInfo.values;
      const hasController = field.controllerName !== undefined;

      if (hasController) {
        if (controllerValue !== undefined && controllerValue !== null) {
          picklistValues = getDependentPicklistOptions(picklistInfo, controllerValue);
        } else {
          picklistValues = [];
        }
      }

      this._optionsCache[cacheKey] = picklistValues;
      return picklistValues;
    }

    function getDependentPicklistOptions(picklistOptions, controllerValue) {
      const controllerIndex = picklistOptions.controllerValues[controllerValue];
      const allPicklistOptions = picklistOptions.values;
      const options = [];

      for (let i = 0, len = allPicklistOptions.length; i < len; i++) {
        const option = allPicklistOptions[i];

        if (option.validFor.includes(controllerIndex)) {
          options.push(option);
        }
      }

      return options;
    }

    function updateFieldOptions(fieldName, fieldElement, options) {
      fieldElement.updateFieldOptions(fieldName, options);
    }

    function getOptionsUniqueKey(options) {
      return Object.keys(options).reduce((prev, optionName) => {
        const option = options[optionName];
        return option !== undefined && option !== '' ? prev + (prev !== '' ? '-' : '') + option + '' : prev + '';
      }, '');
    }

    function clearMaps() {
      this._fieldValues = {};
      this._dependencyMap = {};
      this._picklistMap = {};
      this._optionsCache = {};
    }

    function _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$1(target, key, source[key]); }); } return target; }

    function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    const MASTER_RECORD_TYPE_ID$1 = '012000000000000AAA';
    /**
     * Represents a record edit layout that displays one or more fields, provided by lightning-input-field.
     * @slot default Placeholder for form components like lightning-messages, lightning-button, lightning-input-field and lightning-output-field.
     * Use lightning-input-field to display an editable field.
     */

    class LightningRecordEditForm extends lwc.LightningElement {
      /**
       * Reserved for internal use. Names of the fields to include in the form.
       * @type {string[]}
       */

      /**
       * The ID of the record type, which is required if you created
       * multiple record types but don't have a default.
       * @type {string}
       */

      /**
       * A CSS class for the form element.
       * @type {string}
       */
      // no optional fields!
      // used to trigger picklist values wire

      /**
       * switch between edit and create mode,
       * triggering correct wires
       */
      checkMode() {
        if (this._recordId) {
          this._createMode = false; // trigger record ui wire

          this._wiredRecordId = [this._recordId];
          this._wiredApiName = null;
        } else if (!this._recordIdError && this.objectApiName) {
          this._createMode = true; // trigger record create defaults wire

          this._wiredApiName = this.objectApiName;
          this._wiredRecordId = null;
        }

        if (this._layout) {
          this._wiredLayoutTypes = [this._layout];
          this._layoutMode = true;
        } else {
          this._layoutMode = false;
          this._wiredLayoutTypes = ['Full']; // default to full layout
        }
      }

      constructor() {
        super();
        this.fieldNames = void 0;
        this.recordTypeId = void 0;
        this.formClass = void 0;
        this.optionalFields = [];
        this.fieldSet = void 0;
        this._recordId = void 0;
        this._layout = void 0;
        this._pendingAction = false;
        this._wiredApiName = null;
        this._wiredRecordId = null;
        this._wiredLayoutTypes = null;
        this._createMode = false;
        this._layoutMode = false;
        this._objectApiName = null;
        this._connected = false;
        this._recordIdError = false;
        this._rendered = false;
        this._pendingError = void 0;
        this._density = densityValues.AUTO;
        this._fieldLabelAlignment = labelAlignValues.HORIZONTAL;
        this._initialRender = true;
        this._wiredPicklistApiName = null;
        this._wiredRecordTypeId = null;
        this.recordUi = void 0;
        this.errors = void 0;
        this._fields = void 0;
        this._inputComponents = void 0;
        this._formLayoutInterface = this.formLayoutInterface();
      }

      connectedCallback() {
        this.fieldSet = getFieldSet$1(this.objectApiName); // special case for person accounts

        if (this.objectApiName === 'Account' || this.objectApiName === 'PersonAccount') {
          this.fieldSet.add('IsPersonAccount');
        }

        this.checkMode(); // make sure mode check happens only when needed
        // not all the time

        this._connected = true;
      }

      renderedCallback() {
        // populate the initial set of optionalfields
        this._rendered = true;

        if (this._pendingError) {
          this.handleErrors(this._pendingError);
        }

        if (this._initialRender) {
          setLabelAlignment(this._formLayoutInterface);
          resetResizeObserver(this, this._formLayoutInterface);
        }

        this._initialRender = false;
        this.handleRegister();
      }

      set layoutType(val) {
        this._layout = val;
        this.checkMode();
      }
      /**
       * The type of layout to use to display the form fields. Possible values: Compact, Full.
       * @type {string}
       */


      get layoutType() {
        return this._layout;
      }
      /**
       * Sets the arrangement style of fields and labels in the form.
       * Accepted values are compact, comfy, and auto (default).
       * Use compact to display fields and their labels on the same line.
       * Use comfy to display fields below their labels.
       * Use auto to let the component dynamically set
       * the density according to the user's Display Density setting
       * and the width of the form.
       * @type {string}
       */


      get density() {
        return this._density;
      }

      set density(val) {
        doNormalization(val, this._formLayoutInterface);

        if (!this._initialRender) {
          resetResizeObserver(this, this._formLayoutInterface);
        }
      }

      set recordId(id) {
        if (!id) {
          this._createMode = true;
          this._recordId = null; // normalize falsy to null
        }

        this._recordId = normalizeRecordId(id);

        if (!this._recordId && !this._createMode) {
          const error = {
            message: labelInvalidId
          };
          this.handleErrors(error);
          this._recordIdError = true;
          return;
        }

        this._recordIdError = false; // switch to edit mode

        this._wiredApiName = null;
        this._createMode = false;
        this._wiredRecordId = [this._recordId];

        if (this._connected) {
          this.checkMode();
        }
      }
      /**
       * The ID of the record to be displayed.
       * @type {string}
       */


      get recordId() {
        return this._recordId;
      }

      set objectApiName(val) {
        let apiName; // duck typing for string vs object

        if (val.objectApiName) {
          apiName = val.objectApiName;
        } else {
          apiName = val;
        }

        this._objectApiName = apiName;

        if (this.fieldSet) {
          this.fieldSet.objectApiName = apiName;
        }

        if (this._connected) {
          this.checkMode();
        }
      }
      /**
       * The API name of the object.
       * @type {string}
       * @required
       */


      get objectApiName() {
        return this._objectApiName;
      }

      wiredRecordUi(value) {
        this.handleData(value);
      }

      wiredRecordCreateDefaults(value) {
        this.handleData(value);
      }

      wiredPicklistValuesByRecordType(value) {
        this.handlePicklistValues(value);
      }

      handleData({
        error,
        data
      }) {
        if (error) {
          this.handleErrors(error);
          return;
        } else if (!data) {
          return;
        }

        this.wiredRecord = data;
        const record = data.records ? data.records[this._recordId] : data.record;

        if (record.apiName !== this.objectApiName) {
          const message = labelApiNameMismatch.replace('{0}', this.objectApiName).replace('{1}', record.apiName);
          this.handleErrors({
            message
          });
          return;
        }

        const viewData = {
          record,
          objectInfo: data.objectInfos[this.objectApiName],
          objectInfos: data.objectInfos,
          createMode: !this._recordId,
          labelAlignment: this._fieldLabelAlignment
        };
        this.recordUi = viewData;
        this.getInputAndOutputComponents().forEach(field => {
          field.wireRecordUi(viewData);
        });

        if (formHasPicklists(viewData.objectInfo, this.optionalFields)) {
          // trigger picklist values wire and then fire load event
          this.triggerPicklistWire();
        } else {
          // no picklists, fire load event
          this.dispatchLoadEvent();
        }
      }

      triggerPicklistWire() {
        const oldRecordTypeId = this._wiredRecordTypeId;
        const oldObjectApiName = this._wiredPicklistApiName;
        this._wiredPicklistApiName = this.objectApiName;
        this._wiredRecordTypeId = this.recordTypeId || MASTER_RECORD_TYPE_ID$1; // if apiName and recordTypeId haven't changed, use the same picklist values. Wire service will not fetch the values again.

        if (oldObjectApiName === this._wiredPicklistApiName && oldRecordTypeId === this._wiredRecordTypeId) {
          this.handlePicklistValues(this._picklistValues);
        }
      }

      handlePicklistValues(value) {
        this._picklistValues = value;
        const {
          error,
          data
        } = value;

        if (error) {
          this.handleErrors(error);
        }

        if (!data) {
          return;
        }

        const filteredPicklistValues = filterByPicklistsInForm(this.recordUi.objectInfo, data.picklistFieldValues || data, this.optionalFields);
        this._picklistValuesInForm = filteredPicklistValues;
        this.initDependencyManager({
          dependentFields: this.recordUi.objectInfo.dependentFields,
          picklistValues: filteredPicklistValues
        });
        this.getInputFieldComponents().forEach(field => {
          field.wirePicklistValues(filteredPicklistValues);
        }); // picklist values are loaded at the end, after record data are wired

        this.dispatchLoadEvent();
      }

      validateForm() {
        const cmps = this.getInputFieldComponents();
        return validateForm(cmps);
      }
      /**
       * Submits the form using an array of record fields or field IDs.
       * The field ID is provisioned from @salesforce/schema/.
       * Invoke this method only after the load event.
       * @param {string[]|FieldId[]} fields - Array of record field names or field IDs.
       */


      submit(fields) {
        this.doSubmit(fields).catch(err => {
          this.handleErrors(err);
        });
      }

      doSubmit(fields) {
        return new Promise((resolve, reject) => {
          this._pendingAction = true;
          const originalRecord = this._createMode ? null : this.recordUi.record;
          const newRecord = {
            fields: fields ? fields : this.getFormValues(),
            // api gets mad if you have an api name for edit, don't have one for create
            apiName: this._createMode ? this._objectApiName : null
          }; // add recordTypeId if it is provided

          if (this.recordTypeId) {
            newRecord.fields.RecordTypeId = this.recordTypeId;
          }

          createOrSaveRecord(newRecord, originalRecord, this.recordUi.objectInfo).then(savedRecord => {
            this._pendingAction = false;
            const lightningMessages = this.querySelector('lightning-messages');

            if (lightningMessages) {
              lightningMessages.setError(null);
            }

            this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
            new CustomEvent('success', {
              composed: true,
              bubbles: true,
              detail: savedRecord
            }));
            resolve();
          }, err => {
            this._pendingAction = false;
            reject(err);
          });
        });
      }

      getFormValues() {
        return getFormValues(this.getInputFieldComponents());
      }

      handleError(err) {
        err.stopPropagation();
        this.handleErrors(err.detail.error);
      }

      handleErrors(error) {
        const messages = this.querySelector('lightning-messages');
        const err = lwc.unwrap(error); // error arrived before render so we'll have to handle it later

        if (!this._rendered) {
          this._pendingError = err;
          return;
        }

        this._pendingError = null;
        const inputComponents = this.getInputFieldComponents();

        if (err.body && err.body.output && err.body.output.fieldErrors) {
          const fieldNames = inputComponents.map(field => {
            return field.fieldName;
          });
          Object.keys(err.body.output.fieldErrors).forEach(field => {
            if (fieldNames.indexOf(field) === -1) {
              // field error on missing field!
              err.body.detail = err.body.output.fieldErrors[field][0].message;
            }
          });
        }

        if (messages) {
          messages.setError(err);
        }

        inputComponents.forEach(field => {
          field.setErrors(err);
        });
        this.dispatchEvent(createErrorEvent$1(err));
      }

      dispatchLoadEvent() {
        this.dispatchEvent(new CustomEvent('load', {
          detail: _objectSpread$1({}, this.wiredRecord, {
            picklistValues: this._picklistValuesInForm
          })
        }));
      }

      handleRegister() {
        this.fieldSet.concat(this.getFields());
        this.optionalFields = this.fieldSet.getList();
      }

      registerDependentField(e) {
        e.stopPropagation();
        const {
          fieldName,
          fieldElement
        } = e.detail;

        this._depManager.registerField({
          fieldName,
          fieldElement
        });
      }

      updateDependentFields(e) {
        e.stopPropagation();

        if (this._depManager) {
          this._depManager.handleFieldValueChange(e.detail.fieldName, e.detail.value);
        }
      }

      handleSubmit(e) {
        // submit buttons can't work in slots,
        // so we listen for clicks on submit buttons
        // TODO discuss with A11Y team
        if (e.target.type !== 'submit') {
          return;
        }

        e.preventDefault();
        e.stopPropagation();

        if (!this.validateForm()) {
          // trigger native validation popups
          this.template.querySelector('form').reportValidity();
          return;
        } // cleanly clone and unwrap fields


        const fields = JSON.parse(JSON.stringify(this.getFormValues())); // eslint-disable-next-line lightning-global/no-custom-event-bubbling

        const evt = new CustomEvent('submit', {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            fields
          }
        });
        this.dispatchEvent(evt); // I think this should work, because events always
        // execute in the same stack, so tailing this
        // handler with setTimeout will cause it to wait until
        // the event has propogated to check for prevent default
        // there are some hacks with stopImmediatePropogation,
        // but they rely on re-firing the event, which won't work in
        // this situation
        // eslint-disable-next-line lwc/no-set-timeout

        setTimeout(() => {
          if (this._pendingAction) {
            return;
          }

          if (evt.defaultPrevented) {
            return;
          }

          this._pendingAction = true;
          this.doSubmit().catch(err => {
            this.handleErrors(err);
          });
        }, 0);
      }

      getInputFieldComponents() {
        return [...this.querySelectorAll('lightning-input-field')];
      }

      getInputAndOutputComponents() {
        return [...this.querySelectorAll('lightning-input-field,lightning-output-field')];
      }

      getFields() {
        return this.getInputAndOutputComponents().map(field => {
          return field.fieldName;
        });
      }

      initDependencyManager(dependencyInfo) {
        if (!this._depManager) {
          this._depManager = new DependencyManager(dependencyInfo);
        } else {
          this._depManager.registerDependencyInfo(dependencyInfo);
        }
      }

      formLayoutInterface() {
        const that = this;
        return {
          getDensityPrivate() {
            return that._density;
          },

          setDensityPrivate(value) {
            that._density = value;
          },

          getDensity() {
            return that.density;
          },

          getLabelAlignmentPrivate() {
            return that._fieldLabelAlignment;
          },

          getContainerElement() {
            return that.template.querySelector('form');
          },

          getInputOutputFields() {
            return that.getInputAndOutputComponents();
          },

          setLabelAlignmentPrivate(value) {
            that._fieldLabelAlignment = value;
          },

          getRecordUi() {
            return that.recordUi;
          },

          getResizeObserverCallback(callback) {
            return () => {
              callback(that._formLayoutInterface);
            };
          }

        };
      }

    }

    lwc.registerDecorators(LightningRecordEditForm, {
      publicProps: {
        fieldNames: {
          config: 0
        },
        recordTypeId: {
          config: 0
        },
        formClass: {
          config: 0
        },
        layoutType: {
          config: 3
        },
        density: {
          config: 3
        },
        recordId: {
          config: 3
        },
        objectApiName: {
          config: 3
        }
      },
      publicMethods: ["submit"],
      wire: {
        wiredRecordUi: {
          adapter: lds.getRecordUi,
          params: {
            recordIds: "_wiredRecordId",
            layoutTypes: "_wiredLayoutTypes",
            optionalFields: "optionalFields"
          },
          static: {
            modes: ['View']
          },
          method: 1
        },
        wiredRecordCreateDefaults: {
          adapter: lds.getRecordCreateDefaults,
          params: {
            objectApiName: "_wiredApiName",
            recordTypeId: "recordTypeId",
            optionalFields: "optionalFields"
          },
          static: {},
          method: 1
        },
        wiredPicklistValuesByRecordType: {
          adapter: lds.getPicklistValuesByRecordType,
          params: {
            objectApiName: "_wiredPicklistApiName",
            recordTypeId: "_wiredRecordTypeId"
          },
          static: {},
          method: 1
        }
      },
      track: {
        recordUi: 1,
        errors: 1
      }
    });

    var _lightningRecordEditForm = lwc.registerComponent(LightningRecordEditForm, {
      tmpl: _tmpl$4
    });

    function tmpl$4($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element
      } = $api;
      return [$cmp.hasError ? api_element("div", {
        classMap: {
          "slds-notify_container": true,
          "slds-is-relative": true
        },
        key: 2
      }, [api_element("div", {
        classMap: {
          "slds-notify": true,
          "slds-notify_toast": true,
          "slds-theme_error": true
        },
        attrs: {
          "role": "alert"
        },
        key: 3
      }, [api_element("div", {
        classMap: {
          "slds-notify__content": true
        },
        key: 4
      }, [api_element("h2", {
        classMap: {
          "slds-text-heading_small": true
        },
        key: 5
      }, [api_dynamic($cmp.err.message)]), $cmp.err.detail ? api_element("p", {
        key: 6
      }, [api_dynamic($cmp.err.detail)]) : null])])]) : null];
    }

    var _tmpl$5 = lwc.registerTemplate(tmpl$4);
    tmpl$4.stylesheets = [];
    tmpl$4.stylesheetTokens = {
      hostAttribute: "lightning-messages_messages-host",
      shadowAttribute: "lightning-messages_messages"
    };

    class LightningMessages extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.err = {};
        this.hasError = false;
      }

      // err is one of several error formats
      // returned by ui api, parseError normalizes them
      setError(err) {
        const parsedError = parseError$1(err);
        this.hasError = !!err;
        this.err = parsedError;
      }

      get error() {
        return this.err;
      } // alias to setError method, the
      // other method kept for backward compat


      set error(val) {
        this.setError(val);
      }

    }

    lwc.registerDecorators(LightningMessages, {
      publicProps: {
        error: {
          config: 3
        }
      },
      publicMethods: ["setError"],
      track: {
        err: 1,
        hasError: 1
      }
    });

    var _lightningMessages = lwc.registerComponent(LightningMessages, {
      tmpl: _tmpl$5
    });

    function tmpl$5($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element
      } = $api;
      return [api_element("div", {
        className: $cmp.computedClass,
        attrs: {
          "role": "status"
        },
        key: 2
      }, [$cmp.validAlternativeText ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 3
      }, [api_dynamic($cmp.alternativeText)]) : null, api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 4
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 5
      }, [])])];
    }

    var _tmpl$6 = lwc.registerTemplate(tmpl$5);
    tmpl$5.stylesheets = [];
    tmpl$5.stylesheetTokens = {
      hostAttribute: "lightning-spinner_spinner-host",
      shadowAttribute: "lightning-spinner_spinner"
    };

    /**
     * Displays an animated spinner.
     */

    class LightningSpinner extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.alternativeText = void 0;
        this.size = 'medium';
        this.variant = void 0;
      }

      connectedCallback() {
        this.classList.add('slds-spinner_container');
        this.template.addEventListener('mousewheel', this.stopScrolling);
        this.template.addEventListener('touchmove', this.stopScrolling);
      }

      get normalizedVariant() {
        return normalizeString(this.variant, {
          fallbackValue: 'base',
          validValues: ['base', 'brand', 'inverse']
        });
      }

      get normalizedSize() {
        return normalizeString(this.size, {
          fallbackValue: 'medium',
          validValues: ['small', 'medium', 'large']
        });
      }

      get computedClass() {
        const {
          normalizedVariant,
          normalizedSize
        } = this;
        const classes = classSet('slds-spinner'); // add variant-specific class

        if (normalizedVariant !== 'base') {
          classes.add(`slds-spinner_${normalizedVariant}`);
        } // add size-specific class


        classes.add(`slds-spinner_${normalizedSize}`);
        return classes.toString();
      } // alternativeText validation


      get validAlternativeText() {
        const hasAlternativeText = !!this.alternativeText; // if we have an empty value output a console warning

        if (!hasAlternativeText) {
          // eslint-disable-next-line no-console
          console.warn(`<lightning-spinner> The alternativeText attribute should not be empty. Please add a description of what is causing the wait.`);
        }

        return hasAlternativeText;
      } // prevent scrolling


      stopScrolling(event) {
        event.preventDefault();
      }

    }

    lwc.registerDecorators(LightningSpinner, {
      publicProps: {
        alternativeText: {
          config: 0
        },
        size: {
          config: 0
        },
        variant: {
          config: 0
        }
      }
    });

    var _lightningSpinner = lwc.registerComponent(LightningSpinner, {
      tmpl: _tmpl$6
    });

    function stylesheet$2(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$2 = [stylesheet$2];

    function tmpl$6($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element
      } = $api;
      return [api_element("div", {
        classMap: {
          "slds-form-element__icon": true
        },
        key: 2
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_icon": true
        },
        attrs: {
          "type": "button"
        },
        key: 3
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "svgClass": $cmp.computedSvgClass,
          "iconName": $cmp.iconName,
          "variant": "bare"
        },
        key: 4
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 5
      }, [api_dynamic($cmp.i18n.buttonAlternativeText)])])])];
    }

    var _tmpl$7 = lwc.registerTemplate(tmpl$6);
    tmpl$6.stylesheets = [];
    tmpl$6.stylesheetTokens = {
      hostAttribute: "lightning-helptext_helptext-host",
      shadowAttribute: "lightning-helptext_helptext"
    };

    var labelButtonAlternativeText = 'Help';

    const POSITION_ATTR_NAME = 'data-position-id';

    class BrowserWindow {
      get window() {
        if (!this._window) {
          this._window = window; // JTEST/Ingtegration: getComputedStyle may be null

          if (!this.window.getComputedStyle) {
            this.window.getComputedStyle = node => {
              return node.style;
            };
          }
        }

        return this._window;
      }

      mockWindow(value) {
        // For test, allow mock window.
        this._window = value;
      }

      get documentElement() {
        assert(this.window.document, 'Missing window.document');
        return this.window.document.documentElement;
      }

      get MutationObserver() {
        return this.window.MutationObserver;
      }

      isWindow(element) {
        return element && element.toString() === '[object Window]';
      }

    }

    const WindowManager = new BrowserWindow(); // A global

    let passiveEventsSupported;

    function supportsPassiveEvents() {
      if (typeof passiveEventsSupported !== 'boolean') {
        passiveEventsSupported = false;

        try {
          const opts = Object.defineProperty({}, 'passive', {
            get: () => {
              passiveEventsSupported = true;
            }
          });
          window.addEventListener('testPassive', null, opts);
          window.removeEventListener('testPassive', null, opts); // eslint-disable-next-line no-empty
        } catch (e) {}
      }

      return passiveEventsSupported;
    }

    function attachPassiveEvent(element, eventName, callback) {
      const options = supportsPassiveEvents() ? {
        passive: true
      } : false;
      element.addEventListener(eventName, callback, options);
      return () => {
        element.removeEventListener(eventName, callback, options);
      };
    }

    function isShadowRoot(node) {
      return node && node.nodeType === 11;
    }

    function enumerateParent(elem, stopEl, checker) {
      // document.body is not necessarily a body tag, because of the (very rare)
      // case of a frameset.
      if (!elem || elem === stopEl || elem === document.body) {
        return null;
      } // if overflow is auto and overflow-y is also auto,
      // however in firefox the opposite is not true


      try {
        // getComputedStyle throws an exception
        // if elem is not an element
        // (can happen during unrender)
        const computedStyle = WindowManager.window.getComputedStyle(elem);

        if (!computedStyle) {
          return null;
        }

        if (checker(computedStyle)) {
          return elem;
        }

        return enumerateParent(isShadowRoot(elem.parentNode) ? elem.parentNode.host : elem.parentNode, stopEl, checker);
      } catch (e) {
        return null;
      }
    }

    function getScrollableParent(elem, stopEl) {
      return enumerateParent(elem, stopEl, computedStyle => {
        const overflow = computedStyle['overflow-y'];
        return overflow === 'auto' || overflow === 'scroll';
      });
    }

    function queryOverflowHiddenParent(elem, stopEl) {
      return enumerateParent(elem, stopEl, computedStyle => {
        return computedStyle['overflow-x'] === 'hidden' || computedStyle['overflow-y'] === 'hidden';
      });
    }

    function isInDom(el) {
      if (el === WindowManager.window) {
        return true;
      }

      if (!isShadowRoot(el.parentNode) && el.parentNode && el.parentNode.tagName && el.parentNode.tagName.toUpperCase() === 'BODY') {
        return true;
      }

      if (isShadowRoot(el.parentNode) && el.parentNode.host) {
        return isInDom(el.parentNode.host);
      }

      if (el.parentNode) {
        return isInDom(el.parentNode);
      }

      return false;
    }
    function isScrolling(elem) {
      return elem.scrollHeight > elem.clientHeight;
    }
    function isDomNode(obj) {
      return obj.nodeType && (obj.nodeType === 1 || obj.nodeType === 11);
    }
    function timeout(time) {
      return new Promise(resolve => {
        // eslint-disable-next-line lwc/no-set-timeout
        setTimeout(() => {
          resolve();
        }, time);
      });
    }
    function containsScrollingElement(list) {
      const len = list.length;

      if (!len) {
        return false;
      }

      for (let i = 0; i < len; i++) {
        if (isScrolling(list[i])) {
          return true;
        }
      }

      return false;
    }
    function queryScrollableChildren(element) {
      return element.querySelectorAll('[data-scoped-scroll="true"]');
    }
    function getPositionTarget(element) {
      return element.tagName === 'TEXTAREA' ? isShadowRoot(element.parentNode) ? element.parentNode.host : element.parentNode : element;
    }
    let lastId = 1000000;
    function generateUniqueSelector() {
      return `lgcp-${lastId++}`;
    }
    function normalizeElement(element) {
      const selector = generateUniqueSelector();
      element.setAttribute(POSITION_ATTR_NAME, selector);
      element = document.querySelector(`[${POSITION_ATTR_NAME}="${selector}"]`) || element;
      return element;
    }

    function isInsideOverlay(element, modalOnly) {
      if (!element) {
        return false;
      }

      if (element.classList && (element.classList.contains('uiModal') || !modalOnly && element.classList.contains('uiPanel'))) {
        return true;
      }

      if (!element.parentNode) {
        return false;
      }

      return isInsideOverlay(isShadowRoot(element.parentNode) ? element.parentNode.host : element.parentNode, modalOnly);
    }

    function isInsideModal(element) {
      return isInsideOverlay(element, true);
    }
    function normalizePosition(element, nextIndex, target, alignWidth) {
      // Set element position to fixed
      // 1. element is inside overlay
      // or 2. When element isn't align with target's width, and target's parent has overflow-x:hidden setting.
      const isFixed = isInsideOverlay(element) || !alignWidth && queryOverflowHiddenParent(target, WindowManager.window, true);
      element.style.position = isFixed ? 'fixed' : 'absolute';
      element.style.zIndex = nextIndex || 0;
      element.style.left = '-9999px'; // Avoid flicker

      element.style.top = '0px'; // Avoid flicker

      return element;
    }
    function requestAnimationFrameAsPromise() {
      return new Promise(resolve => {
        requestAnimationFrame(() => resolve());
      });
    }

    const Direction = {
      Center: 'center',
      Middle: 'middle',
      Right: 'right',
      Left: 'left',
      Bottom: 'bottom',
      Top: 'top',
      Default: 'default'
    };
    const VerticalMap = {
      top: Direction.Top,
      bottom: Direction.Bottom,
      center: Direction.Middle
    };
    const HorizontalMap = {
      left: Direction.Left,
      right: Direction.Right,
      center: Direction.Center
    };
    const FlipMap = {
      left: Direction.Right,
      right: Direction.Left,
      top: Direction.Bottom,
      bottom: Direction.Top,
      center: Direction.Center,
      default: Direction.Right
    };

    function getWindowSize() {
      return {
        width: WindowManager.window.innerWidth || document.body.clientWidth || 0,
        height: WindowManager.window.innerHeight || document.body.clientHeight || 0
      };
    }

    function normalizeDirection(direction, defaultValue) {
      return normalizeString(direction, {
        fallbackValue: defaultValue || Direction.Default,
        validValues: [Direction.Center, Direction.Right, Direction.Left, Direction.Bottom, Direction.Top, Direction.Middle, Direction.Default]
      });
    }
    function mapToHorizontal(value) {
      value = normalizeDirection(value, Direction.Left);
      return HorizontalMap[value];
    }
    function mapToVertical(value) {
      value = normalizeDirection(value, Direction.Left);
      return VerticalMap[value];
    }
    function flipDirection(value) {
      value = normalizeDirection(value, Direction.Left);
      return FlipMap[value];
    } // TODO: Remove, not currently in use.
    function checkFlipPossibility(element, target, leftAsBoundary) {
      const viewPort = getWindowSize();
      const elemRect = element.getBoundingClientRect();
      const referenceElemRect = target.getBoundingClientRect();
      const height = typeof elemRect.height !== 'undefined' ? elemRect.height : elemRect.bottom - elemRect.top;
      const width = typeof elemRect.width !== 'undefined' ? elemRect.width : elemRect.right - elemRect.left; // TODO: We'll need to revisit the leftAsBoundary config property. Either we'll need a better
      // name to cover the RTL language cases and maybe open up the possibility of bounding the
      // element to the target in both the horizontal and vertical directions.
      // The boundary shrinks the available area to the edge of the target rather than the viewport.

      let rightAsBoundary = false;

      if (document.dir === 'rtl') {
        rightAsBoundary = leftAsBoundary;
        leftAsBoundary = false;
      }

      const hasSpaceAbove = referenceElemRect.top >= height;
      const hasSpaceBelow = viewPort.height - referenceElemRect.bottom >= height; // Assuming left alignment is specified this tests if:
      // - there's room to accommodate the element with right alignment
      // - there's not enough room to accommodate the element with left alignment

      const shouldAlignToRight = referenceElemRect.right >= width && referenceElemRect.left + width > (rightAsBoundary ? referenceElemRect.right : viewPort.width); // Assuming right alignment is specified this tests if:
      // - there's room to accommodate the element with left alignment
      // - there's not enough room to accommodate the element with right alignment

      const shouldAlignToLeft = referenceElemRect.left + width <= viewPort.width && referenceElemRect.right - width < (leftAsBoundary ? referenceElemRect.left : 0); // Assuming center alignment, does the viewport have space to fit half of the element around
      // the target?

      const centerOverflow = {
        left: referenceElemRect.left - width * 0.5 < 0,
        right: referenceElemRect.right + width * 0.5 > viewPort.width,
        top: referenceElemRect.top - height * 0.5 < 0,
        bottom: referenceElemRect.bottom + height * 0.5 > viewPort.height
      };
      return {
        shouldAlignToLeft,
        shouldAlignToRight,
        hasSpaceAbove,
        hasSpaceBelow,
        centerOverflow
      };
    }

    class Transformer {
      constructor(pad, boxDirections, transformX, transformY) {
        this.pad = pad || 0;
        this.boxDirections = boxDirections || {
          left: true,
          right: true
        };

        this.transformX = transformX || function () {};

        this.transformY = transformY || function () {};
      }

      transform() {// no-op
      }

    }

    class TopTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          top: this.transformY(targetBox.top, targetBox, elementBox) + this.pad
        };
      }

    }

    class BottomTransFormer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          top: this.transformY(targetBox.top, targetBox, elementBox) - elementBox.height - this.pad
        };
      }

    }

    class CenterTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          left: Math.floor(this.transformX(targetBox.left, targetBox, elementBox) - 0.5 * elementBox.width)
        };
      }

    }

    class MiddleTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          top: Math.floor(0.5 * (2 * targetBox.top + targetBox.height - elementBox.height))
        };
      }

    }

    class LeftTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          left: this.transformX(targetBox.left, targetBox, elementBox) + this.pad
        };
      }

    }

    class RightTransformer extends Transformer {
      transform(targetBox, elementBox) {
        return {
          left: this.transformX(targetBox.left, targetBox, elementBox) - elementBox.width - this.pad
        };
      }

    }

    class BelowTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const top = targetBox.top + targetBox.height + this.pad;
        return elementBox.top < top ? {
          top
        } : {};
      }

    }

    const MIN_HEIGHT = 36; // Minimum Line Height

    const MIN_WIDTH = 36;

    class ShrinkingBoxTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const retBox = {};

        if (this.boxDirections.top && elementBox.top < targetBox.top + this.pad) {
          retBox.top = targetBox.top + this.pad;
          retBox.height = Math.max(elementBox.height - (retBox.top - elementBox.top), MIN_HEIGHT);
        }

        if (this.boxDirections.left && elementBox.left < targetBox.left + this.pad) {
          retBox.left = targetBox.left + this.pad;
          retBox.width = Math.max(elementBox.width - (retBox.left - elementBox.left), MIN_WIDTH);
        }

        if (this.boxDirections.right && elementBox.left + elementBox.width > targetBox.left + targetBox.width - this.pad) {
          retBox.right = targetBox.left + targetBox.width - this.pad;
          retBox.width = Math.max(retBox.right - (retBox.left || elementBox.left), MIN_WIDTH);
        }

        if (this.boxDirections.bottom && elementBox.top + elementBox.height > targetBox.top + targetBox.height - this.pad) {
          retBox.bottom = targetBox.top + targetBox.height - this.pad;
          retBox.height = Math.max(retBox.bottom - (retBox.top || elementBox.top), MIN_HEIGHT);
        }

        return retBox;
      }

    }

    class BoundingBoxTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const retBox = {};

        if (this.boxDirections.top && elementBox.top < targetBox.top + this.pad) {
          retBox.top = targetBox.top + this.pad;
        }

        if (this.boxDirections.left && elementBox.left < targetBox.left + this.pad) {
          retBox.left = targetBox.left + this.pad;
        }

        if (this.boxDirections.right && elementBox.left + elementBox.width > targetBox.left + targetBox.width - this.pad) {
          retBox.left = targetBox.left + targetBox.width - elementBox.width - this.pad;
        }

        if (this.boxDirections.bottom && elementBox.top + elementBox.height > targetBox.top + targetBox.height - this.pad) {
          retBox.top = targetBox.top + targetBox.height - elementBox.height - this.pad;
        }

        return retBox;
      }

    }

    class InverseBoundingBoxTransformer extends Transformer {
      transform(targetBox, elementBox) {
        const retBox = {};

        if (this.boxDirections.left && targetBox.left - this.pad < elementBox.left) {
          retBox.left = targetBox.left - this.pad;
        }

        if (this.boxDirections.right && elementBox.left + elementBox.width < targetBox.left + targetBox.width + this.pad) {
          retBox.left = targetBox.width + this.pad - elementBox.width + targetBox.left;
        }

        if (this.boxDirections.top && targetBox.top < elementBox.top + this.pad) {
          retBox.top = targetBox.top - this.pad;
        }

        if (this.boxDirections.bottom && elementBox.top + elementBox.height < targetBox.top + targetBox.height + this.pad) {
          retBox.top = targetBox.height + this.pad - elementBox.height + targetBox.top;
        }

        return retBox;
      }

    }

    const TransformFunctions = {
      center(input, targetBox) {
        return Math.floor(input + 0.5 * targetBox.width);
      },

      right(input, targetBox) {
        return input + targetBox.width;
      },

      left(input) {
        return input;
      },

      bottom(input, targetBox) {
        return input + targetBox.height;
      }

    };
    const Transformers = {
      top: TopTransformer,
      bottom: BottomTransFormer,
      center: CenterTransformer,
      middle: MiddleTransformer,
      left: LeftTransformer,
      right: RightTransformer,
      below: BelowTransformer,
      'bounding box': BoundingBoxTransformer,
      'shrinking box': ShrinkingBoxTransformer,
      'inverse bounding box': InverseBoundingBoxTransformer,
      default: Transformer
    };
    function toTransformFunctions(value) {
      return TransformFunctions[value] || TransformFunctions.left;
    }

    class TransformBuilder {
      type(value) {
        this._type = value;
        return this;
      }

      align(horizontal, vertical) {
        this._transformX = toTransformFunctions(horizontal);
        this._transformY = toTransformFunctions(vertical);
        return this;
      }

      pad(value) {
        this._pad = parseInt(value, 10);
        return this;
      }

      boxDirections(value) {
        this._boxDirections = value;
        return this;
      }

      build() {
        const AConstructor = Transformers[this._type] ? Transformers[this._type] : Transformers[Direction.Default];
        return new AConstructor(this._pad || 0, this._boxDirections || {}, this._transformX || toTransformFunctions(Direction.left), this._transformY || toTransformFunctions(Direction.left));
      }

    }

    class Constraint {
      constructor(type, config) {
        const {
          target,
          element,
          pad,
          boxDirections
        } = config;
        const {
          horizontal,
          vertical
        } = config.targetAlign;
        this._element = element;
        this._targetElement = target;
        this.destroyed = false;
        this._transformer = new TransformBuilder().type(type).align(horizontal, vertical).pad(pad).boxDirections(boxDirections).build();
      }

      detach() {
        this._disabled = true;
      }

      attach() {
        this._disabled = false;
      }

      computeDisplacement() {
        if (!this._disabled) {
          this._targetElement.refresh();

          this._element.refresh();

          this._pendingBox = this._transformer.transform(this._targetElement, this._element);
        }

        return this;
      }

      computePosition() {
        const el = this._element;

        if (!this._disabled) {
          Object.keys(this._pendingBox).forEach(key => {
            el.setDirection(key, this._pendingBox[key]);
          });
        }

        return this;
      }

      destroy() {
        this._element.release();

        this._targetElement.release();

        this._disabled = true;
        this.destroyed = true;
      }

    }

    class ElementProxy {
      constructor(el, id) {
        this.id = id;
        this.width = 0;
        this.height = 0;
        this.left = 0;
        this.top = 0;
        this.right = 0;
        this.bottom = 0;
        this._dirty = false;
        this._node = null;
        this._releaseCb = null;

        if (!el) {
          throw new Error('Element missing');
        } // W-3262919
        // for some reason I cannot figure out sometimes the
        // window, which clearly a window object, is not the window object
        // this will correct that. It might be related to locker


        if (WindowManager.isWindow(el)) {
          el = WindowManager.window;
        }

        this._node = el;
        this.setupObserver();
        this.refresh();
      }

      setupObserver() {
        // this check is because phantomjs does not support
        // mutation observers. The consqeuence here
        // is that any browser without mutation observers will
        // fail to update dimensions if they changwe after the proxy
        // is created and the proxy is not not refreshed
        if (WindowManager.MutationObserver && !this._node.isObserved) {
          // Use mutation observers to invalidate cache. It's magic!
          this._observer = new WindowManager.MutationObserver(this.refresh.bind(this)); // do not observe the window

          if (!WindowManager.isWindow(this._node)) {
            this._observer.observe(this._node, {
              attributes: true,
              childList: true,
              characterData: true,
              subtree: true
            });

            this._node.isObserved = true;
          }
        }
      }

      setReleaseCallback(cb, scope) {
        const scopeObj = scope || this;
        this._releaseCb = cb.bind(scopeObj);
      }

      checkNodeIsInDom() {
        // if underlying DOM node is gone,
        // this proxy should be released
        if (!isInDom(this._node)) {
          return false;
        }

        return true;
      }

      refresh() {
        const w = WindowManager.window;

        if (!this.isDirty()) {
          if (!this.checkNodeIsInDom()) {
            return this.release();
          }

          let box, x, scrollTop, scrollLeft;

          if (typeof w.pageYOffset !== 'undefined') {
            scrollTop = w.pageYOffset;
            scrollLeft = w.pageXOffset;
          } else {
            scrollTop = w.scrollY;
            scrollLeft = w.scrollX;
          }

          if (!WindowManager.isWindow(this._node)) {
            // force paint
            // eslint-disable-next-line no-unused-vars
            const offsetHeight = this._node.offsetHeight;
            box = this._node.getBoundingClientRect(); // not using integers causes weird rounding errors
            // eslint-disable-next-line guard-for-in

            for (x in box) {
              this[x] = Math.floor(box[x]);
            }

            this.top = Math.floor(this.top + scrollTop);
            this.bottom = Math.floor(this.top + box.height);
            this.left = Math.floor(this.left + scrollLeft);
            this.right = Math.floor(this.left + box.width);
          } else {
            box = {};
            this.width = WindowManager.documentElement.clientWidth;
            this.height = WindowManager.documentElement.clientHeight;
            this.left = scrollLeft;
            this.top = scrollTop;
            this.right = WindowManager.documentElement.clientWidth + scrollLeft;
            this.bottom = WindowManager.documentElement.clientHeight;
          }

          this._dirty = false;
        }

        return this._dirty;
      }

      getNode() {
        return this._node;
      }

      isDirty() {
        return this._dirty;
      }

      bake() {
        const w = WindowManager.window;

        const absPos = this._node.getBoundingClientRect();

        const style = w.getComputedStyle(this._node) || this._node.style;

        const hasPageOffset = typeof w.pageYOffset !== 'undefined';
        const scrollTop = hasPageOffset ? w.pageYOffset : w.scrollY;
        const scrollLeft = hasPageOffset ? w.pageXOffset : w.scrollX;
        const originalLeft = style.left.match(/auto|fixed/) ? '0' : parseInt(style.left.replace('px', ''), 10);
        const originalTop = style.top.match(/auto|fixed/) ? '0' : parseInt(style.top.replace('px', ''), 10);
        const leftDif = Math.round(this.left - (absPos.left + scrollLeft));
        const topDif = this.top - (absPos.top + scrollTop);
        this._node.style.left = `${originalLeft + leftDif}px`;
        this._node.style.top = `${originalTop + topDif}px`;

        if (this._restoreSize) {
          // Only store the first height/width which is the original height/width.
          this.originalHeight = this.originalHeight || this._node.style.height;
          this.originalWidth = this.originalWidth || this._node.style.width;
          this._node.style.width = `${this.width}px`;
          this._node.style.height = `${this.height}px`;
        }

        this._dirty = false;
      }

      setDirection(direction, val) {
        this[direction] = val;
        this._dirty = true; // if size is changed, should restore the original size.

        if (direction === 'height' || direction === 'width') {
          this._restoreSize = true;
        }
      }

      release() {
        if (this._restoreSize) {
          this._node.style.width = this.originalWidth;
          this._node.style.height = this.originalHeight;

          if (this._removeMinHeight) {
            this._node.style.minHeight = '';
          }
        }

        if (this._releaseCb) {
          this._releaseCb(this);
        }
      }

      querySelectorAll(selector) {
        return this._node.querySelectorAll(selector);
      }

    }

    class ProxyCache {
      constructor() {
        this.proxyCache = {};
      }

      get count() {
        return Object.keys(this.proxyCache).length;
      }

      releaseOrphanProxies() {
        for (const proxy in this.proxyCache) {
          if (!this.proxyCache[proxy].el.checkNodeIsInDom()) {
            this.proxyCache[proxy].el.release();
          }
        }
      }

      bakeOff() {
        for (const proxy in this.proxyCache) {
          if (this.proxyCache[proxy].el.isDirty()) {
            this.proxyCache[proxy].el.bake();
          }
        }
      }

      getReferenceCount(proxy) {
        const id = proxy.id;

        if (!id || !this.proxyCache[id]) {
          return 0;
        }

        return this.proxyCache[id].refCount;
      }

      release(proxy) {
        const proxyInstance = this.proxyCache[proxy.id];

        if (proxyInstance) {
          --proxyInstance.refCount;
        }

        if (proxyInstance && proxyInstance.refCount <= 0) {
          delete this.proxyCache[proxy.id];
        }
      }

      reset() {
        this.proxyCache = {};
      }

      create(element) {
        let key = 'window';

        if (!WindowManager.isWindow(element)) {
          key = element ? element.getAttribute(POSITION_ATTR_NAME) : null; // 1 - Node.ELEMENT_NODE, 11 - Node.DOCUMENT_FRAGMENT_NODE

          assert(key && element.nodeType && (element.nodeType !== 1 || element.nodeType !== 11), `Element Proxy requires an element and has property ${POSITION_ATTR_NAME}`);
        }

        if (this.proxyCache[key]) {
          this.proxyCache[key].refCount++;
          return this.proxyCache[key].el;
        }

        const newProxy = new ElementProxy(element, key);
        newProxy.setReleaseCallback(release, newProxy);
        this.proxyCache[key] = {
          el: newProxy,
          refCount: 1
        }; // run GC

        timeout(0).then(() => {
          this.releaseOrphanProxies();
        });
        return this.proxyCache[key].el;
      }

    }

    const elementProxyCache = new ProxyCache();
    function bakeOff() {
      elementProxyCache.bakeOff();
    }
    function release(proxy) {
      return elementProxyCache.release(proxy);
    }
    function createProxy(element) {
      return elementProxyCache.create(element);
    }

    class RepositionQueue {
      constructor() {
        this.callbacks = [];
        this.repositionScheduled = false;
        this._constraints = [];
        this.timeoutId = 0;
        this.lastIndex = getZIndexBaseline();
        this.eventsBound = false;
      }

      get nextIndex() {
        return this.lastIndex++;
      }

      get constraints() {
        return this._constraints;
      }

      set constraints(value) {
        this._constraints = this._constraints.concat(value);
      }

      dispatchRepositionCallbacks() {
        while (this.callbacks.length > 0) {
          this.callbacks.shift()();
        }
      }

      add(callback) {
        if (typeof callback === 'function') {
          this.callbacks.push(callback);
          return true;
        }

        return false;
      }

      scheduleReposition(callback) {
        if (this.timeoutId === 0) {
          // eslint-disable-next-line lwc/no-set-timeout
          this.timeoutId = setTimeout(() => {
            this.reposition(callback);
          }, 10);
        }
      }

      reposition(callback) {
        // all the callbacks will be called
        if (typeof callback === 'function') {
          this.callbacks.push(callback);
        } // this is for throttling


        clearTimeout(this.timeoutId);
        this.timeoutId = 0; // this semaphore is to make sure
        // if reposition is called twice within one frame
        // we only run this once

        if (!this.repositionScheduled) {
          requestAnimationFrame(() => {
            this.repositionScheduled = false; // this must be executed in order or constraints
            // will behave oddly

            this._constraints = this._constraints.filter(constraint => {
              if (!constraint.destroyed) {
                constraint.computeDisplacement().computePosition();
                return true;
              }

              return false;
            });
            bakeOff();
            this.dispatchRepositionCallbacks();
          });
          this.repositionScheduled = true;
        }
      }

      get repositioning() {
        if (!this._reposition) {
          this._reposition = this.scheduleReposition.bind(this);
        }

        return this._reposition;
      }

      bindEvents() {
        if (!this.eventsBound) {
          window.addEventListener('resize', this.repositioning);
          window.addEventListener('scroll', this.repositioning);
          this.eventsBound = true;
        }
      }

      detachEvents() {
        window.removeEventListener('resize', this.repositioning);
        window.removeEventListener('scroll', this.repositioning);
        this.eventsBound = false;
      }

    }

    const positionQueue = new RepositionQueue();
    function scheduleReposition(callback) {
      positionQueue.scheduleReposition(callback);
    }
    function bindEvents() {
      positionQueue.bindEvents();
    }
    function addConstraints(list) {
      positionQueue.constraints = list;
    }
    function reposition(callback) {
      positionQueue.reposition(callback);
    }
    function nextIndex() {
      return positionQueue.nextIndex;
    }

    class Relationship {
      constructor(config, constraintList, scrollableParent) {
        this.config = config;
        this.constraintList = constraintList;
        this.scrollableParent = scrollableParent;
      }

      disable() {
        this.constraintList.forEach(constraintToDisable => {
          constraintToDisable.detach();
        });
      }

      enable() {
        this.constraintList.forEach(constraintToEnable => {
          constraintToEnable.attach();
        });
      }

      destroy() {
        if (this.config.removeListeners) {
          this.config.removeListeners();
          this.config.removeListeners = undefined;
        }

        while (this.constraintList.length > 0) {
          this.constraintList.pop().destroy();
        } // Clean up node appended to body of dom


        if (this.config.appendToBody && this.config.element) {
          const nodeToRemove = document.querySelector(`[${POSITION_ATTR_NAME}="${this.config.element.getAttribute(POSITION_ATTR_NAME)}"]`);

          if (nodeToRemove) {
            nodeToRemove.parentNode.removeChild(nodeToRemove);
          }
        }
      }

      reposition() {
        return new Promise(resolve => {
          reposition(() => {
            resolve();
          });
        });
      }

    }

    const DEFAULT_MIN_HEIGHT = '1.875rem';

    function setupObserver(config, scrollableParent) {
      let proxyWheelEvents = true;

      if (WindowManager.MutationObserver && !config.element.isObserved) {
        // phantomjs :(
        let scrollableChildren = queryScrollableChildren(config.element);
        const observer = new WindowManager.MutationObserver(() => {
          scrollableChildren = queryScrollableChildren(config.element);
          proxyWheelEvents = !containsScrollingElement(scrollableChildren);
        });

        if (containsScrollingElement(scrollableChildren)) {
          proxyWheelEvents = false;
        }

        observer.observe(config.element, {
          attributes: true,
          subtree: true,
          childList: true
        });
        config.element.isObserved = true;
      }

      if (scrollableParent) {
        const scrollRemovalFunction = attachPassiveEvent(scrollableParent, 'scroll', scheduleReposition); // if the target element is inside a
        // scrollable element, we need to make sure
        // scroll events move that element,
        // not the parent, also we need to reposition on scroll

        const wheelRemovalFunction = attachPassiveEvent(config.element, 'wheel', e => {
          if (proxyWheelEvents && scrollableParent && typeof scrollableParent.scrollTop !== 'undefined') {
            scrollableParent.scrollTop += e.deltaY;
          }
        });

        config.removeListeners = () => {
          scrollRemovalFunction();
          wheelRemovalFunction();
        };
      }
    }

    function validateConfig(config) {
      assert(config.element && isDomNode(config.element), 'Element is undefined or missing, or not a Dom Node');
      assert(config.target && (WindowManager.isWindow(config.target) || isDomNode(config.target)), 'Target is undefined or missing');
    }

    function createRelationship(config) {
      bindEvents();
      config.element = normalizePosition(config.element, nextIndex(), config.target, config.alignWidth);

      if (config.alignWidth && config.element.style.position === 'fixed') {
        config.element.style.width = config.target.getBoundingClientRect().width + 'px';
      }

      const constraintList = [];
      const scrollableParent = getScrollableParent(getPositionTarget(config.target), WindowManager.window); // This observer and the test for scrolling children
      // is so that if a panel contains a scroll we do not
      // proxy the events to the "parent"  (actually the target's parent)

      setupObserver(config, scrollableParent);

      if (config.appendToBody) {
        document.body.appendChild(config.element);
      }

      config.element = createProxy(config.element);
      config.target = createProxy(config.target); // Add horizontal constraint.

      const horizontalConfig = Object.assign({}, config);

      if (horizontalConfig.padLeft !== undefined) {
        horizontalConfig.pad = horizontalConfig.padLeft;
      } // Add vertical constraint.


      const verticalConfig = Object.assign({}, config);

      if (verticalConfig.padTop !== undefined) {
        verticalConfig.pad = verticalConfig.padTop;
      }

      constraintList.push(new Constraint(mapToHorizontal(config.align.horizontal), horizontalConfig));
      constraintList.push(new Constraint(mapToVertical(config.align.vertical), verticalConfig));
      const autoShrink = config.autoShrink.height || config.autoShrink.width;

      if (config.scrollableParentBound && scrollableParent) {
        const parent = normalizeElement(scrollableParent);
        const boxConfig = {
          element: config.element,
          enabled: config.enabled,
          target: createProxy(parent),
          align: {},
          targetAlign: {},
          pad: 3,
          boxDirections: {
            top: true,
            bottom: true,
            left: true,
            right: true
          }
        };

        if (autoShrink) {
          const style = boxConfig.element.getNode().style;

          if (!style.minHeight) {
            style.minHeight = config.minHeight;
            boxConfig.element._removeMinHeight = true;
          }

          boxConfig.boxDirections = {
            top: !!config.autoShrink.height,
            bottom: !!config.autoShrink.height,
            left: !!config.autoShrink.width,
            right: !!config.autoShrink.width
          };
          constraintList.push(new Constraint('shrinking box', boxConfig));
        } else {
          constraintList.push(new Constraint('bounding box', boxConfig));
        }
      }

      addConstraints(constraintList);
      reposition();
      return new Relationship(config, constraintList, scrollableParent);
    }

    function isAutoFlipHorizontal(config) {
      return config.autoFlip || config.autoFlipHorizontal;
    }

    function isAutoFlipVertical(config) {
      return config.autoFlip || config.autoFlipVertical;
    }

    function normalizeAlignments(config, flipConfig) {
      const align = {
        horizontal: config.align.horizontal,
        vertical: config.align.vertical
      };
      const targetAlign = {
        horizontal: config.targetAlign.horizontal,
        vertical: config.targetAlign.vertical
      }; // Horizontal alignments flip for RTL languages.

      if (document.dir === 'rtl') {
        align.horizontal = flipDirection(align.horizontal);
        targetAlign.horizontal = flipDirection(targetAlign.horizontal);
      } // When using the autoFlip flags with center alignment, we change the element alignment to fit
      // within the viewport when it's detected that it overflows the edge of the viewport.


      let vFlip = false;

      if (isAutoFlipVertical(config)) {
        if (align.vertical === Direction.Bottom) {
          vFlip = !flipConfig.hasSpaceAbove && flipConfig.hasSpaceBelow;
        } else if (align.vertical === Direction.Top) {
          vFlip = flipConfig.hasSpaceAbove && !flipConfig.hasSpaceBelow;
        } else if (align.vertical === Direction.Center) {
          if (flipConfig.centerOverflow.top && !flipConfig.centerOverflow.bottom) {
            align.vertical = targetAlign.vertical = Direction.Top;
          } else if (flipConfig.centerOverflow.bottom && !flipConfig.centerOverflow.top) {
            align.vertical = targetAlign.vertical = Direction.Bottom;
          }
        }
      }

      let hFlip = false;

      if (isAutoFlipHorizontal(config)) {
        if (align.horizontal === Direction.Left) {
          hFlip = flipConfig.shouldAlignToRight;
        } else if (align.horizontal === Direction.Right) {
          hFlip = flipConfig.shouldAlignToLeft;
        } else if (align.horizontal === Direction.Center) {
          if (flipConfig.centerOverflow.left && !flipConfig.centerOverflow.right) {
            align.horizontal = targetAlign.horizontal = Direction.Left;
          } else if (flipConfig.centerOverflow.right && !flipConfig.centerOverflow.left) {
            align.horizontal = targetAlign.horizontal = Direction.Right;
          }
        }
      }

      return {
        align: {
          horizontal: hFlip ? flipDirection(align.horizontal) : normalizeDirection(align.horizontal, Direction.Left),
          vertical: vFlip ? flipDirection(align.vertical) : normalizeDirection(align.vertical, Direction.Top)
        },
        targetAlign: {
          horizontal: hFlip ? flipDirection(targetAlign.horizontal) : normalizeDirection(targetAlign.horizontal, Direction.Left),
          vertical: vFlip ? flipDirection(targetAlign.vertical) : normalizeDirection(targetAlign.vertical, Direction.Bottom)
        }
      };
    }

    function normalizeConfig(config) {
      config.align = config.align || {};
      config.targetAlign = config.targetAlign || {};
      const flipConfig = checkFlipPossibility(config.element, config.target, config.leftAsBoundary);
      const {
        align,
        targetAlign
      } = normalizeAlignments(config, flipConfig);
      config.isInsideModal = isInsideModal(config.element); // When inside modal, element may expand out of the viewport and be cut off.
      // So if inside modal, and don't have enough space above or below, will add bounding box rule.

      if (config.isInsideModal && !flipConfig.hasSpaceAbove && !flipConfig.hasSpaceBelow) {
        config.scrollableParentBound = true;
      }

      return {
        target: config.target,
        element: config.element,
        align,
        targetAlign,
        alignWidth: config.alignWidth,
        scrollableParentBound: config.scrollableParentBound,
        pad: config.pad,
        padTop: config.padTop,
        padLeft: config.padLeft,
        autoShrink: {
          height: config.autoShrink || config.autoShrinkHeight,
          width: config.autoShrink || config.autoShrinkWidth
        },
        minHeight: config.minHeight || DEFAULT_MIN_HEIGHT
      };
    }

    function toElement(root, target) {
      if (target && typeof target === 'string') {
        return root.querySelector(target);
      } else if (target && typeof target === 'function') {
        return lwc.unwrap(target());
      }

      return target;
    }

    function startPositioning(root, config) {
      assert(root, 'Root is undefined or missing');
      assert(config, 'Config is undefined or missing');
      const node = normalizeElement(root);
      const target = toElement(node, config.target);
      const element = toElement(node, config.element); // when target/element is selector, there is chance, dom isn't present anymore.

      if (!target || !element) {
        return null;
      }

      config.target = normalizeElement(target);
      config.element = normalizeElement(element);
      validateConfig(config);
      return createRelationship(normalizeConfig(config));
    }
    function stopPositioning(relationship) {
      if (relationship) {
        relationship.destroy();
      }
    }
    class AutoPosition {
      constructor(root) {
        this._autoPositionUpdater = null;
        this._root = root;
      }

      start(config) {
        return requestAnimationFrameAsPromise().then(() => {
          let promise = Promise.resolve();

          if (!this._autoPositionUpdater) {
            this._autoPositionUpdater = startPositioning(this._root, config);
          } else {
            promise = promise.then(() => {
              return this._autoPositionUpdater.reposition();
            });
          }

          return promise.then(() => {
            return this._autoPositionUpdater;
          });
        });
      }

      stop() {
        if (this._autoPositionUpdater) {
          stopPositioning(this._autoPositionUpdater);
          this._autoPositionUpdater = null;
        }

        return Promise.resolve();
      }

    }

    function tmpl$7($api, $cmp, $slotset, $ctx) {
      const {
        h: api_element
      } = $api;
      return [api_element("div", {
        classMap: {
          "slds-popover__body": true
        },
        context: {
          lwc: {
            dom: "manual"
          }
        },
        key: 2
      }, [])];
    }

    var _tmpl$8 = lwc.registerTemplate(tmpl$7);
    tmpl$7.stylesheets = [];
    tmpl$7.stylesheetTokens = {
      hostAttribute: "lightning-primitiveBubble_primitiveBubble-host",
      shadowAttribute: "lightning-primitiveBubble_primitiveBubble"
    };

    const DEFAULT_ALIGN = {
      horizontal: 'left',
      vertical: 'bottom'
    };

    class LightningPrimitiveBubble extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.state = {
          visible: false,
          contentId: ''
        };
        this.divElement = void 0;
      }

      get contentId() {
        return this.state.contentId;
      }

      set contentId(value) {
        this.state.contentId = value;

        if (this.state.inDOM) {
          this.divEl.setAttribute('id', this.state.contentId);
        }
      }

      connectedCallback() {
        this.updateClassList();
        this.state.inDOM = true;
      }

      disconnectedCallback() {
        this.state.inDOM = false;
      }

      renderedCallback() {
        // set content manually once rendered
        // - this is required to avoid the content update being in the wrong 'tick'
        this.setContentManually();
        this.setIdManually();
      }

      set content(value) {
        this.state.content = value;

        if (this.state.inDOM) {
          this.setContentManually();
        }
      }

      get content() {
        return this.state.content || '';
      }

      get align() {
        return this.state.align || DEFAULT_ALIGN;
      }

      set align(value) {
        this.state.align = value;
        this.updateClassList();
      }

      get visible() {
        return this.state.visible;
      }

      set visible(value) {
        this.state.visible = value;
        this.updateClassList();
      }

      setIdManually() {
        this.divElement = this.divElement ? this.divElement : this.template.querySelector('div');
        this.divElement.setAttribute('id', this.state.contentId);
      } // manually set the content value


      setContentManually() {
        /* manipulate DOM directly */
        this.template.querySelector('.slds-popover__body').textContent = this.state.content;
      } // compute class value for this bubble


      updateClassList() {
        const classes = classSet('slds-popover').add('slds-popover_tooltip'); // show or hide bubble

        classes.add({
          'slds-rise-from-ground': this.visible,
          'slds-fall-into-ground': !this.visible
        }); // apply the proper nubbin CSS class

        const {
          horizontal,
          vertical
        } = this.align;
        classes.add({
          'slds-nubbin_top-left': horizontal === 'left' && vertical === 'top',
          'slds-nubbin_top-right': horizontal === 'right' && vertical === 'top',
          'slds-nubbin_bottom-left': horizontal === 'left' && vertical === 'bottom',
          'slds-nubbin_bottom-right': horizontal === 'right' && vertical === 'bottom',
          'slds-nubbin_bottom': horizontal === 'center' && vertical === 'bottom',
          'slds-nubbin_top': horizontal === 'center' && vertical === 'top',
          'slds-nubbin_left': horizontal === 'left' && vertical === 'center',
          'slds-nubbin_right': horizontal === 'right' && vertical === 'center'
        });
        classListMutation(this.classList, classes);
      }

    }

    lwc.registerDecorators(LightningPrimitiveBubble, {
      publicProps: {
        contentId: {
          config: 3
        },
        content: {
          config: 3
        },
        align: {
          config: 3
        },
        visible: {
          config: 3
        }
      },
      track: {
        state: 1
      }
    });

    var LightningPrimitiveBubble$1 = lwc.registerComponent(LightningPrimitiveBubble, {
      tmpl: _tmpl$8
    });

    const BUBBLE_ID = `salesforce-lightning-tooltip-bubble_${guid()}`;
    /**
     * Shared instance of a primitive bubble used as a tooltip by most components. This was originally
     * defined in the helptext component which is where the minWidth style came from.
     * TODO: We may want to revisit the minWidth style with the PO and/or UX.
     */

    let CACHED_BUBBLE_ELEMENT;

    function getCachedBubbleElement() {
      if (!CACHED_BUBBLE_ELEMENT) {
        CACHED_BUBBLE_ELEMENT = lwc.createElement('lightning-primitive-bubble', {
          is: LightningPrimitiveBubble$1
        });
        CACHED_BUBBLE_ELEMENT.contentId = BUBBLE_ID;
        CACHED_BUBBLE_ELEMENT.style.position = 'absolute';
        CACHED_BUBBLE_ELEMENT.style.minWidth = '75px';
      }

      return CACHED_BUBBLE_ELEMENT;
    }

    const ARIA_DESCRIBEDBY = 'aria-describedby';
    /**
     * Used as a position offset to compensate for the nubbin. The dimensions of the nubbin are not
     * included in the position library bounding box calculations. This is the size in pixels of the
     * nubbin.
     * TODO: We may want to measure this instead in cases it changes.
     */

    const NUBBIN_SIZE = 16;
    /**
     * Used in the calculation that moves the tooltip to a location that places the nubbin at the
     * center of the target element. This is the nubbin offset from the edge of the bubble in pixels
     * when using slds-nubbin_bottom-left or slds-nubbin_bottom-right.
     * TODO: We may want to measure this instead in case it changes.
     */

    const NUBBIN_OFFSET = 24;
    /**
     * Known tooltip types:
     * - info: used in cases where target already has click handlers such as button-icon
     * - toggle: used in cases where target only shows a tooltip such as helptext
     */

    const TooltipType = {
      Info: 'info',
      Toggle: 'toggle'
    };
    /**
     * Allows us to attach a tooltip to components. Typical usage is as follows:
     * - Create an instance of Tooltip
     * - Call Tooltip.initialize() to add the appropriate listeners to the element that needs a tooltip
     * See buttonIcon and buttonMenu for example usage.
     */

    class Tooltip {
      /**
       * A shared instance of primitiveBubble is used when an element is not specified in the config
       * object.
       * @param {string} value the content of the tooltip
       * @param {object} config specifies the root component, target element of the tooltip
       */
      constructor(value, config) {
        this._autoPosition = null;
        this._disabled = true;
        this._initialized = false;
        this._visible = false;
        assert(config.target, 'target for tooltip is undefined or missing');
        this.value = value;
        this._root = config.root;
        this._target = config.target;
        this._type = normalizeString(config.type, {
          fallbackValue: TooltipType.Info,
          validValues: Object.values(TooltipType)
        }); // If a tooltip element is not given, fall back on the globally shared instance.

        this._element = config.element;

        if (!this._element) {
          this._element = getCachedBubbleElement;
          const bubbleElement = getCachedBubbleElement();

          if (bubbleElement.parentNode === null) {
            document.body.appendChild(bubbleElement);
          }
        }

        this.handleDocumentTouch = this.handleDocumentTouch.bind(this);
      }
      /**
       * Disables the tooltip.
       */


      detach() {
        this._disabled = true;
      }
      /**
       * Enables the tooltip.
       */


      attach() {
        this._disabled = false;
      }
      /**
       * Adds the appropriate event listeners to the target element to make the tooltip appear. Also
       * links the tooltip and target element via the aria-describedby attribute for screen readers.
       */


      initialize() {
        const target = this._target();

        if (!this._initialized && target) {
          switch (this._type) {
            case TooltipType.Toggle:
              this.addToggleListeners();
              break;

            case TooltipType.Info:
            default:
              this.addInfoListeners();
              break;
          }

          const ariaDescribedBy = normalizeAriaAttribute([target.getAttribute(ARIA_DESCRIBEDBY), this._element().contentId]);
          target.setAttribute(ARIA_DESCRIBEDBY, ariaDescribedBy);
          this._initialized = true;
        }
      }

      addInfoListeners() {
        const target = this._target();

        if (!this._initialized && target) {
          ['mouseenter', 'focus'].forEach(event => target.addEventListener(event, () => this.show())); // Unlike the tooltip in Aura, we want clicks and keys to dismiss the tooltip.

          ['mouseleave', 'blur', 'click', 'keydown'].forEach(event => target.addEventListener(event, () => this.hide()));
        }
      }

      handleDocumentTouch() {
        if (this._visible) {
          this.hide();
        }
      }

      addToggleListeners() {
        const target = this._target();

        if (!this._initialized && target) {
          if (Tooltip.isMobile()) {
            target.addEventListener('touchstart', e => {
              e.stopPropagation();
              this.toggle();
            });
          } else {
            ['mouseenter', 'focus'].forEach(event => target.addEventListener(event, () => this.show()));
            ['mouseleave', 'blur'].forEach(event => target.addEventListener(event, () => this.hide()));
          }
        }
      }

      show() {
        if (this._disabled) {
          return;
        }

        this._visible = true;

        const tooltip = this._element();

        tooltip.content = this._value;
        this.startPositioning();

        if (Tooltip.isMobile()) {
          document.addEventListener('touchstart', this.handleDocumentTouch);
        }
      }

      hide() {
        this._visible = false;

        const tooltip = this._element();

        tooltip.visible = this._visible;
        this.stopPositioning();

        if (Tooltip.isMobile()) {
          document.removeEventListener('touchstart', this.handleDocumentTouch);
        }
      }

      toggle() {
        if (this._visible) {
          this.hide();
        } else {
          this.show();
        }
      }

      get value() {
        return this._value;
      }

      set value(value) {
        this._value = value;
        this._disabled = !value;
      }

      get initialized() {
        return this._initialized;
      }

      get visible() {
        return this._visible;
      }

      startPositioning() {
        if (!this._autoPosition) {
          this._autoPosition = new AutoPosition(this._root);
        } // The lightning-helptext component was originally left aligned.


        const align = {
          horizontal: Direction.Left,
          vertical: Direction.Bottom
        };
        const targetAlign = {
          horizontal: Direction.Left,
          vertical: Direction.Top
        }; // Pads the tooltip so its nubbin is at the center of the target element.

        const targetBox = this._target().getBoundingClientRect();

        const padLeft = targetBox.width * 0.5 - NUBBIN_OFFSET;

        this._autoPosition.start({
          target: this._target,
          element: this._element,
          align,
          targetAlign,
          autoFlip: true,
          padTop: NUBBIN_SIZE,
          padLeft
        }).then(autoPositionUpdater => {
          // The calculation above may have flipped the alignment of the tooltip. When the
          // tooltip changes alignment we need to update the nubbin class to have it draw in
          // the appropriate place.
          const tooltip = this._element();

          tooltip.align = autoPositionUpdater.config.align;
          tooltip.visible = this._visible;
        });
      }

      stopPositioning() {
        if (this._autoPosition) {
          this._autoPosition.stop();
        }
      }

      static isMobile() {
        return configProvider.getFormFactor() === 'PHONE';
      }

    }

    const i18n = {
      buttonAlternativeText: labelButtonAlternativeText
    };
    const DEFAULT_ICON_NAME = 'utility:info';
    const DEFAULT_ICON_VARIANT = 'bare';
    /**
     * An icon with a text popover used for tooltips.
     */

    class LightningHelptext extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.state = {
          iconName: DEFAULT_ICON_NAME,
          iconVariant: DEFAULT_ICON_VARIANT
        };
        this._tooltip = null;
      }

      /**
       * Text to be shown in the popover.
       * @type {string}
       * @param {string} value - The plain text string for the tooltip
       */
      set content(value) {
        if (this._tooltip) {
          this._tooltip.value = value;
        } else if (value) {
          // Note that because the tooltip target is a child element it may not be present in the
          // dom during initial rendering.
          this._tooltip = new Tooltip(value, {
            root: this,
            target: () => this.template.querySelector('button'),
            type: TooltipType.Toggle
          });

          this._tooltip.initialize();
        }
      }

      get content() {
        return this._tooltip ? this._tooltip.value : undefined;
      }
      /**
       * The Lightning Design System name of the icon used as the visible element.
       * Names are written in the format 'utility:info' where 'utility' is the category,
       * and 'info' is the specific icon to be displayed.
       * The default is 'utility:info'.
       * @type {string}
       * @param {string} value the icon name to use
       * @default utility:info
       */


      set iconName(value) {
        this.state.iconName = value;
      }

      get iconName() {
        if (isValidName(this.state.iconName)) {
          return this.state.iconName;
        }

        return DEFAULT_ICON_NAME;
      }
      /**
       * Changes the appearance of the icon.
       * Accepted variants include inverse, warning, error.
       * @type {string}
       * @param {string} value the icon variant to use
       * @default bare
       */


      set iconVariant(value) {
        this.state.iconVariant = value;
      }

      get iconVariant() {
        // NOTE: Leaving a note here because I just wasted a bunch of time
        // investigating why both 'bare' and 'inverse' are supported in
        // lightning-primitive-icon. lightning-icon also has a deprecated
        // 'bare', but that one is synonymous to 'inverse'. This 'bare' means
        // that no classes should be applied. So this component needs to
        // support both 'bare' and 'inverse' while lightning-icon only needs to
        // support 'inverse'.
        return normalizeString(this.state.iconVariant, {
          fallbackValue: DEFAULT_ICON_VARIANT,
          validValues: ['bare', 'error', 'inverse', 'warning']
        });
      }

      renderedCallback() {
        if (this._tooltip && !this._tooltip.initialized) {
          this._tooltip.initialize();
        }
      }

      get i18n() {
        return i18n;
      } // compute SVG CSS classes to apply to the icon


      get computedSvgClass() {
        const classes = classSet('slds-button__icon');

        switch (this.iconVariant) {
          case 'error':
            classes.add('slds-icon-text-error');
            break;

          case 'warning':
            classes.add('slds-icon-text-warning');
            break;

          case 'inverse':
          case 'bare':
            break;

          default:
            // if custom icon is set, we don't want to set
            // the text-default class
            classes.add('slds-icon-text-default');
        }

        return classes.toString();
      }

    }

    lwc.registerDecorators(LightningHelptext, {
      publicProps: {
        content: {
          config: 3
        },
        iconName: {
          config: 3
        },
        iconVariant: {
          config: 3
        }
      },
      track: {
        state: 1
      }
    });

    var _lightningHelptext = lwc.registerComponent(LightningHelptext, {
      tmpl: _tmpl$7
    });

    function stylesheet$3(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n[dir=\"rtl\"] input[type=\"tel\"]" + shadowSelector + " {direction: ltr;text-align: right;unicode-bidi: embed;}\n";
    }
    var _implicitStylesheets$3 = [stylesheet$3];

    function stylesheet$4(hostSelector, shadowSelector, nativeShadow) {
      return "slot" + shadowSelector + " {display: inline-block;}\n";
    }
    var _implicitStylesheets$4 = [stylesheet$4];

    function tmpl$8($api, $cmp, $slotset, $ctx) {
      const {
        s: api_slot
      } = $api;
      return [api_slot("", {
        key: 2
      }, [], $slotset)];
    }

    var _tmpl$9 = lwc.registerTemplate(tmpl$8);
    tmpl$8.slots = [""];
    tmpl$8.stylesheets = [];

    if (_implicitStylesheets$4) {
      tmpl$8.stylesheets.push.apply(tmpl$8.stylesheets, _implicitStylesheets$4);
    }
    tmpl$8.stylesheetTokens = {
      hostAttribute: "lightning-primitiveFileDroppableZone_primitiveFileDroppableZone-host",
      shadowAttribute: "lightning-primitiveFileDroppableZone_primitiveFileDroppableZone"
    };

    class LightningPrimitiveFileDroppableZone extends lwc.LightningElement {
      get disabled() {
        return this._disabled || false;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get multiple() {
        return this._multiple || false;
      }

      set multiple(value) {
        this._multiple = normalizeBoolean(value);
      }

      constructor() {
        super();
        this._disabled = void 0;
        this._multiple = void 0;
        this.template.addEventListener('dragover', this.allowDrop.bind(this));
        this.template.addEventListener('dragleave', this.handleDragLeave.bind(this));
        this.template.addEventListener('drop', this.handleOnDrop.bind(this));
      }

      connectedCallback() {
        this.classList.add('slds-file-selector__dropzone');
      }

      setDragOver(dragOver) {
        this.classList.toggle('slds-has-drag-over', dragOver);
      }

      handleDragLeave() {
        this.setDragOver(false);
      }

      handleOnDrop(event) {
        event.preventDefault();
        this.setDragOver(false);

        if (this.disabled) {
          event.stopPropagation();
          return;
        }

        if (!this.meetsMultipleCriteria(event)) {
          event.stopPropagation();
        }
      }

      allowDrop(event) {
        event.preventDefault();

        if (!this.disabled) {
          this.setDragOver(true);
        }
      }

      meetsMultipleCriteria(dragEvent) {
        const files = dragEvent.dataTransfer.files;
        return !(files.length > 1 && !this.multiple);
      }

    }

    lwc.registerDecorators(LightningPrimitiveFileDroppableZone, {
      publicProps: {
        disabled: {
          config: 3
        },
        multiple: {
          config: 3
        }
      },
      track: {
        _disabled: 1,
        _multiple: 1
      }
    });

    var _lightningPrimitiveFileDroppableZone = lwc.registerComponent(LightningPrimitiveFileDroppableZone, {
      tmpl: _tmpl$9
    });

    function tmpl$9($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        gid: api_scoped_id,
        h: api_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-color-picker__custom": true
        },
        key: 2
      }, [api_element("p", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "id": api_scoped_id("color-picker-instructions")
        },
        key: 3
      }, [api_dynamic($cmp.i18n.colorPickerInstructions)]), api_element("div", {
        classMap: {
          "slds-m-bottom_small": true
        },
        style: $cmp.gradientStyle,
        attrs: {
          "data-id": "color-gradient"
        },
        key: 4,
        on: {
          "mousedown": _m3 || ($ctx._m3 = api_bind($cmp.handleMouseDown))
        }
      }, [api_element("canvas", {
        attrs: {
          "width": $cmp.canvasRect.x,
          "height": $cmp.canvasRect.y
        },
        key: 5
      }, []), api_element("a", {
        classMap: {
          "slds-color-picker__range-indicator": true
        },
        styleMap: {
          "position": "absolute",
          "display": "inline"
        },
        attrs: {
          "data-id": "color-anchor",
          "href": "javascript:void(0)",
          "aria-live": "assertive",
          "aria-atomic": "true",
          "aria-describedby": `${api_scoped_id("color-picker-instructions")}`
        },
        key: 6,
        on: {
          "mousedrag": _m0 || ($ctx._m0 = api_bind($cmp.handlePreventDefault)),
          "mousedown": _m1 || ($ctx._m1 = api_bind($cmp.handlePreventDefault)),
          "keydown": _m2 || ($ctx._m2 = api_bind($cmp.handleKeydown))
        }
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 7
      }, [api_dynamic($cmp.computedSaturationAndBrightness)])])]), api_element("div", {
        classMap: {
          "slds-color-picker__hue-and-preview": true
        },
        key: 8
      }, [api_element("label", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "for": `${api_scoped_id("rainbow")}`
        },
        key: 9
      }, [api_dynamic($cmp.i18n.hueInput)]), api_element("input", {
        classMap: {
          "slds-color-picker__hue-slider": true
        },
        attrs: {
          "data-id": "hue-slider",
          "type": "range",
          "min": "0",
          "max": "360",
          "id": api_scoped_id("rainbow")
        },
        props: {
          "value": $cmp._hueValue
        },
        key: 10,
        on: {
          "mousedown": _m4 || ($ctx._m4 = api_bind($cmp.handleDrag)),
          "change": _m5 || ($ctx._m5 = api_bind($cmp.onChange))
        }
      }, []), api_element("span", {
        classMap: {
          "slds-swatch": true
        },
        style: $cmp.thumbnailStyle,
        attrs: {
          "data-id": "color-preview"
        },
        key: 11
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 12
      }, [api_dynamic($cmp._hex)])])]), api_element("div", {
        classMap: {
          "slds-color-picker__custom-inputs": true
        },
        key: 13
      }, [api_element("div", {
        classMap: {
          "slds-form-element": true,
          "slds-color-picker__input-custom-hex": true
        },
        key: 14
      }, [api_element("label", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "for": `${api_scoped_id("input")}`
        },
        key: 15
      }, [api_dynamic($cmp.i18n.hexLabel)]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 16
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "data-primary-input": true,
          "type": "text",
          "id": api_scoped_id("input"),
          "minlength": "4",
          "maxlength": "7",
          "pattern": "^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$",
          "placeholder": "#FFFFFF"
        },
        props: {
          "value": $cmp._hex
        },
        key: 17,
        on: {
          "change": _m6 || ($ctx._m6 = api_bind($cmp.handleHexChange))
        }
      }, [])])]), api_element("div", {
        classMap: {
          "slds-form-element": true
        },
        key: 18
      }, [api_element("label", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "for": `${api_scoped_id("red")}`
        },
        key: 19
      }, [api_element("abbr", {
        attrs: {
          "title": $cmp.i18n.redAbbr
        },
        key: 20
      }, [api_dynamic($cmp.i18n.rInput)])]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 21
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("red"),
          "data-color-name": "red",
          "placeholder": "255"
        },
        props: {
          "value": $cmp._rgb.red
        },
        key: 22,
        on: {
          "change": _m7 || ($ctx._m7 = api_bind($cmp.handleRgbChange))
        }
      }, [])])]), api_element("div", {
        classMap: {
          "slds-form-element": true
        },
        key: 23
      }, [api_element("label", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "for": `${api_scoped_id("green")}`
        },
        key: 24
      }, [api_element("abbr", {
        attrs: {
          "title": $cmp.i18n.greenAbbr
        },
        key: 25
      }, [api_dynamic($cmp.i18n.gInput)])]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 26
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("green"),
          "data-color-name": "green",
          "placeholder": "255"
        },
        props: {
          "value": $cmp._rgb.green
        },
        key: 27,
        on: {
          "change": _m8 || ($ctx._m8 = api_bind($cmp.handleRgbChange))
        }
      }, [])])]), api_element("div", {
        classMap: {
          "slds-form-element": true
        },
        key: 28
      }, [api_element("label", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "for": `${api_scoped_id("blue")}`
        },
        key: 29
      }, [api_element("abbr", {
        attrs: {
          "title": $cmp.i18n.blueAbbr
        },
        key: 30
      }, [api_dynamic($cmp.i18n.bInput)])]), api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 31
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("blue"),
          "data-color-name": "blue",
          "placeholder": "255"
        },
        props: {
          "value": $cmp._rgb.blue
        },
        key: 32,
        on: {
          "change": _m9 || ($ctx._m9 = api_bind($cmp.handleRgbChange))
        }
      }, [])])])]), $cmp._errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "aria-live": "assertive"
        },
        key: 34
      }, [api_dynamic($cmp._errorMessage)]) : null])];
    }

    var _tmpl$a = lwc.registerTemplate(tmpl$9);
    tmpl$9.stylesheets = [];
    tmpl$9.stylesheetTokens = {
      hostAttribute: "lightning-colorPickerCustom_colorPickerCustom-host",
      shadowAttribute: "lightning-colorPickerCustom_colorPickerCustom"
    };

    var labelBInput = 'B';

    var labelBlueAbbr = 'Blue';

    var labelColorPickerInstructions = 'Use arrow keys to select a saturation and brightness, on an x and y axis.';

    var labelErrorMessage = 'Enter a valid hexadecimal value.';

    var labelGInput = 'G';

    var labelGreenAbbr = 'Green';

    var labelHexLabel = 'Hex';

    var labelHueInput = 'Select Hue';

    var labelRInput = 'R';

    var labelRedAbbr = 'Red';

    let idCounter = 0;
    function generateUniqueId(prefix = 'input') {
      idCounter++;
      return `${prefix}-${idCounter}`;
    }

    /**
     Represents an object which keeps track of a user's interacting state.
     @constructor InteractingState
     @param {Object} options - The options object.
     @param {Object} [options.duration=2000] - The number of milliseconds of idle time to wait before exiting the interacting state.
     @param {Object} [options.debounceInteraction=false] - Whether to debounce interaction to ignore consecutive leave-enter interactions.
     **/

    class InteractingState {
      constructor(options) {
        const duration = options && options.duration >= 0 ? options.duration : 2000;
        this.eventemitter = new EventEmitter();
        this._interacting = false;
        this._debouncedLeave = debounce(this.leave.bind(this), duration);
        this._debounceInteraction = options && options.debounceInteraction;
        this._interactedRecently = false;

        if (this._debounceInteraction) {
          // debounce leave until a short time later
          this._debouncedEmitLeave = debounce(() => {
            if (!this._interacting) {
              this._interactedRecently = false;
              this.eventemitter.emit('leave');
            }
          }, 200); // debounce enter until left

          this._debouncedEmitEnter = () => {
            if (!this._interactedRecently) {
              this._interactedRecently = true;
              this.eventemitter.emit('enter');
            }
          };
        }
      }
      /**
       Checks whether or not we are in the interacting state.
       @method InteractingState#isInteracting
       @return {Boolean} - Whether or not we are interacting.
       **/


      isInteracting() {
        return this._interacting;
      }
      /**
       Enters the interacting state.
       @method InteractingState#enter
       @returns {void}
       **/


      enter() {
        if (!this._interacting) {
          this._interacting = true;

          if (this._debounceInteraction) {
            this._debouncedEmitEnter();
          } else {
            this.eventemitter.emit('enter');
          }
        }
      }
      /**
       Registers a handler to execute when we enter the interacting state.
       @method InteractingState#onenter
       @param {Function} handler - The callback function.
       **/


      onenter(handler) {
        this.eventemitter.on('enter', handler);
      }
      /**
       Leaves the interacting state.
       @method InteractingState#leave
       @returns {void}
       **/


      leave() {
        if (this._interacting) {
          this._interacting = false;

          if (this._debounceInteraction) {
            this._debouncedEmitLeave();
          } else {
            this.eventemitter.emit('leave');
          }
        }
      }
      /**
       Registers a handler to execute when we leave the interacting state.
       @method InteractingState#onleave
       @param {Function} handler - The callback function.
       **/


      onleave(handler) {
        this.eventemitter.on('leave', handler);
      }
      /**
       Signals the start of the transition into the interacting state and
       schedules a transition out of the interacting state after an idle
       duration. Calling this method multiple times will reset the timer.
       @method InteractingState#interacting
       @returns {void}
       **/


      interacting() {
        this.enter();

        this._debouncedLeave();
      }

    }
    /**
     Creates a debounced function that delays invoking `func` until after
     `delay` milliseconds have elapsed since the last time the debounced
     function was invoked.
     @function debounce
     @param {Function} func - The function to debounce
     @param {Number} delay - The number of milliseconds to delay
     @param {Object} options - The options object
     @param {Boolean} options.leading - Specify invoking on the leading edge of the timeout
     @return {Function} - debounced function
     **/

    function debounce(func, delay, options) {
      const _options = options || {};

      let invokeLeading = _options.leading;
      let timer;
      return function debounced() {
        const args = Array.prototype.slice.apply(arguments);

        if (invokeLeading) {
          func.apply(this, args);
          invokeLeading = false;
        }

        clearTimeout(timer); // eslint-disable-next-line lwc/no-set-timeout

        timer = setTimeout(function () {
          func.apply(this, args);
          invokeLeading = _options.leading; // reset for next debounce sequence
        }, delay);
      };
    }

    var labelBadInput = 'Enter a valid value.';

    var labelPatternMismatch = 'Your entry does not match the allowed pattern.';

    var labelRangeOverflow = 'The number is too high.';

    var labelRangeUnderflow = 'The number is too low.';

    var labelStepMismatch = 'Your entry isn\'t a valid increment.';

    var labelTooLong = 'Your entry is too long.';

    var labelTooShort = 'Your entry is too short.';

    var labelTypeMismatch = 'You have entered an invalid format.';

    var labelValueMissing = 'Complete this field.';

    const constraintsSortedByPriority = ['customError', 'badInput', 'patternMismatch', 'rangeOverflow', 'rangeUnderflow', 'stepMismatch', 'tooLong', 'tooShort', 'typeMismatch', 'valueMissing'];
    const defaultLabels = {
      badInput: labelBadInput,
      customError: labelBadInput,
      patternMismatch: labelPatternMismatch,
      rangeOverflow: labelRangeOverflow,
      rangeUnderflow: labelRangeUnderflow,
      stepMismatch: labelStepMismatch,
      tooLong: labelTooLong,
      tooShort: labelTooShort,
      typeMismatch: labelTypeMismatch,
      valueMissing: labelValueMissing
    };

    function resolveBestMatch(validity) {
      let validityState;

      if (validity && validity.valid === false) {
        validityState = 'badInput';
        constraintsSortedByPriority.some(stateName => {
          if (validity[stateName] === true) {
            validityState = stateName;
            return true;
          }

          return false;
        });
      }

      return validityState;
    }

    function computeConstraint(valueProvider, constraint) {
      const provider = valueProvider[constraint];

      if (typeof provider === 'function') {
        return provider();
      }

      if (typeof provider === 'boolean') {
        return provider;
      }

      return false;
    } // We're doing the below to avoid exposing the constraintsProvider in the ValidityState


    function newValidityState(constraintsProvider) {
      class ValidityState {
        get valueMissing() {
          return computeConstraint(constraintsProvider, 'valueMissing');
        }

        get typeMismatch() {
          return computeConstraint(constraintsProvider, 'typeMismatch');
        }

        get patternMismatch() {
          return computeConstraint(constraintsProvider, 'patternMismatch');
        }

        get tooLong() {
          return computeConstraint(constraintsProvider, 'tooLong');
        }

        get tooShort() {
          return computeConstraint(constraintsProvider, 'tooShort');
        }

        get rangeUnderflow() {
          return computeConstraint(constraintsProvider, 'rangeUnderflow');
        }

        get rangeOverflow() {
          return computeConstraint(constraintsProvider, 'rangeOverflow');
        }

        get stepMismatch() {
          return computeConstraint(constraintsProvider, 'stepMismatch');
        }

        get customError() {
          return computeConstraint(constraintsProvider, 'customError');
        }

        get badInput() {
          return computeConstraint(constraintsProvider, 'badInput');
        }

        get valid() {
          return !(this.valueMissing || this.typeMismatch || this.patternMismatch || this.tooLong || this.tooShort || this.rangeUnderflow || this.rangeOverflow || this.stepMismatch || this.customError || this.badInput);
        }

      }

      return new ValidityState();
    }

    function buildSyntheticValidity(constraintProvider) {
      return Object.freeze(newValidityState(constraintProvider));
    }
    function getErrorMessage(validity, labelMap) {
      const key = resolveBestMatch(validity);

      if (key) {
        return labelMap[key] ? labelMap[key] : defaultLabels[key];
      }

      return '';
    }
    class FieldConstraintApi {
      constructor(inputComponentProvider, constraintProviders) {
        assert(typeof inputComponentProvider === 'function');
        this._inputComponentProvider = inputComponentProvider;
        this._constraintsProvider = Object.assign({}, constraintProviders);

        if (!this._constraintsProvider.customError) {
          this._constraintsProvider.customError = () => typeof this._customValidityMessage === 'string' && this._customValidityMessage !== '';
        }
      }

      get validity() {
        if (!this._constraint) {
          this._constraint = buildSyntheticValidity(this._constraintsProvider);
        }

        return this._constraint;
      }

      checkValidity() {
        const isValid = this.validity.valid;

        if (!isValid) {
          if (this.inputComponent) {
            this.inputComponent.dispatchEvent(new CustomEvent('invalid', {
              cancellable: true
            }));
          }
        }

        return isValid;
      }

      reportValidity(callback) {
        const valid = this.checkValidity();
        this.inputComponent.classList.toggle('slds-has-error', !valid);

        if (callback) {
          callback(this.validationMessage);
        }

        return valid;
      }

      setCustomValidity(message) {
        this._customValidityMessage = message;
      }

      get validationMessage() {
        return getErrorMessage(this.validity, {
          customError: this._customValidityMessage,
          badInput: this.inputComponent.messageWhenBadInput,
          patternMismatch: this.inputComponent.messageWhenPatternMismatch,
          rangeOverflow: this.inputComponent.messageWhenRangeOverflow,
          rangeUnderflow: this.inputComponent.messageWhenRangeUnderflow,
          stepMismatch: this.inputComponent.messageWhenStepMismatch,
          tooShort: this.inputComponent.messageWhenTooShort,
          tooLong: this.inputComponent.messageWhenTooLong,
          typeMismatch: this.inputComponent.messageWhenTypeMismatch,
          valueMissing: this.inputComponent.messageWhenValueMissing
        });
      }

      get inputComponent() {
        if (!this._inputComponentElement) {
          this._inputComponentElement = this._inputComponentProvider();
        }

        return this._inputComponentElement;
      }

    }
    class FieldConstraintApiWithProxyInput {
      constructor(inputComponent, overrides = {}, inputElementName = 'input') {
        this._inputComponent = inputComponent;
        this._overrides = overrides;
        this._proxyInput = document.createElement(inputElementName);
      }

      setInputAttributes(attributes) {
        this._attributes = attributes;

        this._attributeUpdater = attributeNames => {
          if (!attributes) {
            return;
          }

          if (typeof attributeNames === 'string') {
            this._setAttribute(attributeNames, attributes[attributeNames]());
          } else {
            attributeNames.forEach(attributeName => {
              this._setAttribute(attributeName, attributes[attributeName]());
            });
          }
        };

        return this._attributeUpdater;
      }

      get validity() {
        return this._constraintApi.validity;
      }

      checkValidity() {
        return this._constraintApi.checkValidity();
      }

      reportValidity(callback) {
        return this._constraintApi.reportValidity(callback);
      }

      setCustomValidity(message) {
        this._constraintApi.setCustomValidity(message);

        this._proxyInput.setCustomValidity(message);
      }

      get validationMessage() {
        return this._constraintApi.validationMessage;
      }

      _setAttribute(attributeName, value) {
        if (value !== null && value !== undefined && value !== false) {
          if (attributeName === 'value') {
            if (this._proxyInput.type === 'file') {
              // Can't set value on file
              return;
            }

            this._proxyInput.value = value;
          } else {
            this._proxyInput.setAttribute(attributeName, value);
          }
        } else {
          this._removeAttribute(attributeName);
        }
      }

      _removeAttribute(attributeName) {
        this._proxyInput.removeAttribute(attributeName);
      }

      get _constraintApi() {
        if (!this._privateConstraintApi) {
          this._updateAllAttributes();

          const computeConstraintWithProxyInput = constraintName => {
            const constraintOverride = this._overrides[constraintName];

            if (typeof constraintOverride === 'function') {
              const result = constraintOverride();

              if (typeof result === 'boolean') {
                return !this._proxyInput.hasAttribute('disabled') && !this._proxyInput.hasAttribute('readonly') && result;
              }
            }

            return this._proxyInput.validity[constraintName];
          };

          const constraintsProvider = constraintsSortedByPriority.reduce((provider, constraint) => {
            provider[constraint] = computeConstraintWithProxyInput.bind(this, constraint);
            return provider;
          }, {});
          this._privateConstraintApi = new FieldConstraintApi(this._inputComponent, constraintsProvider);
        }

        return this._privateConstraintApi;
      }

      _updateAllAttributes() {
        if (this._attributes) {
          Object.entries(this._attributes).forEach(([key, valueFunction]) => {
            this._setAttribute(key, valueFunction());
          });
        }
      }

    }

    const VARIANT = {
      STANDARD: 'standard',
      LABEL_HIDDEN: 'label-hidden',
      LABEL_STACKED: 'label-stacked',
      LABEL_INLINE: 'label-inline'
    };
    /**
    A variant normalization utility for attributes.
    @param {Any} value - The value to normalize.
    @return {Boolean} - The normalized value.
    **/

    function normalizeVariant$1(value) {
      return normalizeString(value, {
        fallbackValue: VARIANT.STANDARD,
        validValues: [VARIANT.STANDARD, VARIANT.LABEL_HIDDEN, VARIANT.LABEL_STACKED, VARIANT.LABEL_INLINE]
      });
    }

    function isEmptyString(s) {
      return s === undefined || s === null || typeof s === 'string' && s.trim() === '';
    }

    function fullHexValue(hex) {
      if (hex && hex.length <= 6 && hex.charAt(0) !== '#') {
        hex = '#' + hex;
      }

      const isInputValid = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex);

      if (!isInputValid) {
        hex = '#000000';
      } // Converting 3 digit hex color to 6 digit hex color


      if (hex.length === 4) {
        hex = '#' + hex.charAt(1) + hex.charAt(1) + hex.charAt(2) + hex.charAt(2) + hex.charAt(3) + hex.charAt(3);
      }

      return hex;
    }
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(fullHexValue(hex));

      if (!result) {
        return null;
      }

      return {
        red: parseInt(result[1], 16),
        green: parseInt(result[2], 16),
        blue: parseInt(result[3], 16)
      };
    }
    function rgbToHex(rgb) {
      const r = rgb.red;
      const g = rgb.green;
      const b = rgb.blue;
      const bin = r << 16 | g << 8 | b;
      return function (hex) {
        return new Array(7 - hex.length).join('0') + hex;
      }(bin.toString(16).toUpperCase());
    }
    function rgbToHsl(rgb) {
      const r1 = rgb.red / 255;
      const g1 = rgb.green / 255;
      const b1 = rgb.blue / 255;
      const maxColor = Math.max(r1, g1, b1);
      const minColor = Math.min(r1, g1, b1); // Calculate L:

      let L = (maxColor + minColor) / 2;
      let S = 0;
      let H = 0;

      if (maxColor !== minColor) {
        // Calculate S:
        if (L < 0.5) {
          S = (maxColor - minColor) / (maxColor + minColor);
        } else {
          S = (maxColor - minColor) / (2.0 - maxColor - minColor);
        } // Calculate H:


        if (r1 === maxColor) {
          const x = g1 - b1,
                y = maxColor - minColor;
          H = x / y;
        } else if (g1 === maxColor) {
          const x = b1 - r1,
                y = maxColor - minColor,
                z = x / y;
          H = 2.0 + z;
        } else {
          const x = r1 - g1,
                y = maxColor - minColor,
                z = x / y;
          H = 4.0 + z;
        }
      }

      L *= 100;
      S *= 100;
      H *= 60;

      if (H < 0) {
        H += 360;
      }

      const result = {
        hue: H,
        saturation: S,
        lightness: L
      };
      return result;
    }
    function rgbToPosition(rgb, canvas) {
      const hsv = rgbToHsv(rgb);
      const saturation = hsv.saturation / 100,
            brightness = hsv.brightness / 100;
      const x = canvas.x * saturation;
      const y = canvas.y * (1 - brightness);
      return {
        x,
        y
      };
    }
    function rgbToHsv(rgb) {
      const r = rgb.red / 255;
      const g = rgb.green / 255;
      const b = rgb.blue / 255;
      const max = Math.max(r, g, b),
            min = Math.min(r, g, b);
      const d = max - min,
            s = max === 0 ? 0 : d / max,
            v = max;
      let h, x, y;

      if (max === min) {
        h = 0;
      } else {
        switch (max) {
          case r:
            x = g - b;
            y = x / d;
            h = y + (g < b ? 6 : 0);
            break;

          case g:
            x = b - r;
            y = x / d;
            h = y + 2;
            break;

          case b:
            x = r - g;
            y = x / d;
            h = y + 4;
            break;

          default:
            break;
        }

        h /= 6;
      }

      const result = {
        hue: h * 360,
        saturation: s * 100,
        brightness: v * 100
      };
      return result;
    }

    const i18n$1 = {
      bInput: labelBInput,
      blueAbbr: labelBlueAbbr,
      colorPickerInstructions: labelColorPickerInstructions,
      errorMessage: labelErrorMessage,
      gInput: labelGInput,
      greenAbbr: labelGreenAbbr,
      hexLabel: labelHexLabel,
      hueInput: labelHueInput,
      rInput: labelRInput,
      redAbbr: labelRedAbbr
    };
    const CANVAS = {
      x: 198,
      y: 80
    };

    class LightningColorPickerCustom extends lwc.LightningElement {
      constructor() {
        super();
        this._hueValue = null;
        this._rgb = {
          red: '86',
          green: '121',
          blue: '192'
        };
        this._hex = '#5679C0';
        this._errorMessage = null;
        this._currentColor = null;
        this._initialized = false;
        this.uniqueId = generateUniqueId();
      }

      renderedCallback() {
        if (!this._initialized) {
          this.focus();
          this.gradient();
          this.handleUpdateAnchor();
          this._initialized = true;
        }
      }

      get currentColor() {
        return this._currentColor;
      }

      set currentColor(value) {
        const fullHex = fullHexValue(value);
        this._currentColor = value;
        this._hex = fullHex;
        this._rgb = hexToRgb(fullHex);
      }

      focus() {
        this.anchorElement.focus();
      }

      get i18n() {
        return i18n$1;
      }

      get thumbnailStyle() {
        return `background: ${this._hex || 'hsl(220, 46%, 55%)'};`;
      }

      get gradientStyle() {
        return `background: ${this._hex || 'rgb(0, 85, 255)'}; position: relative;`;
      }

      get canvasRect() {
        return CANVAS;
      }

      get anchorElement() {
        return this.template.querySelector('*[data-id="color-anchor"]');
      }

      get thumbnailElement() {
        return this.template.querySelector('*[data-id="color-preview"]');
      }

      get gradientElement() {
        return this.template.querySelector('*[data-id="color-gradient"]');
      }

      get computedSaturationAndBrightness() {
        const rgb = this._rgb;
        const saturation = rgbToHsv(rgb).saturation || 0;
        const brightness = rgbToHsv(rgb).brightness || 0;
        return `Saturation: ${saturation.toFixed()}%. Brightness: ${brightness.toFixed()}%.`;
      }

      handlePreventDefault(event) {
        event.preventDefault();
      }

      selectColor(event) {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('updatecolor', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            color: event.target.innerText
          }
        }));
      }

      handleMouseDown(event) {
        event.preventDefault();
        this.onMouseDrag(event, true);
      }

      handleDrag(event) {
        this.onMouseDrag(event, false);
      }

      onChange() {
        this.rainbowCursor();
      }

      parseAndLimit(value) {
        let out = value;

        if (!value || parseInt(value, 10) < 0 || isNaN(value)) {
          out = 0;
        } else if (parseInt(value, 10) > 255) {
          out = 255;
        }

        return out;
      }

      handleRgbChange(event) {
        const target = event.currentTarget;
        const value = this.parseAndLimit(target.value); // Fix for no rerender on second bad value attempt

        target.value = value;
        const color = target.getAttribute('data-color-name');

        if (color === 'red') {
          this._rgb.red = value;
        } else if (color === 'green') {
          this._rgb.green = value;
        } else if (color === 'blue') {
          this._rgb.blue = value;
        }

        const rgb = this._rgb;
        const hue = rgbToHsl(rgb).hue;
        const position = this.rgbToPosition(rgb);
        const selectedColor = `#${rgbToHex(rgb)}`;
        this.updateRainbow(hue);
        this.setCanvasColor(hue);
        this.setCanvasCursor(position.x, position.y);
        this.updateSelectedColor(selectedColor);
      }

      handleHexChange(event) {
        const isInputValid = event.srcElement.validity.valid;

        if (isInputValid) {
          const selectedColor = fullHexValue(event.target.value);
          this.classList.remove('slds-has-error');
          this._errorMessage = null;
          const rgb = hexToRgb(selectedColor);
          this._rgb = rgb;
          const hue = rgbToHsl(rgb).hue;
          const position = this.rgbToPosition(rgb);
          this.updateRainbow(hue);
          this.setCanvasColor(hue);
          this.setCanvasCursor(position.x, position.y);
          this.updateSelectedColor(selectedColor);
        } else {
          event.srcElement.classList.add('slds-has-error');
          this._errorMessage = getErrorMessage(event.srcElement.validity, {
            patternMismatch: this.i18n.errorMessage
          });
        }
      }

      updateSelectedColor(selectedColor) {
        this.template.querySelector(`[data-primary-input]`).classList.remove('slds-has-error');
        this._errorMessage = null;
        this._hex = selectedColor;
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('updateselectedcolor', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            color: selectedColor
          }
        }));
      }

      onMouseDrag(event, isGradientCursor) {
        const that = this;
        let drag = false;

        if (isGradientCursor) {
          this.getColorFromGradient(event);
        } else {
          this.rainbowCursor();
        }

        if (this._mousedown && this._mousemove && this._mouseup) {
          return;
        }

        that._mousedown = function () {
          drag = true;
          this._cursorActive = true;
        };

        that._mouseup = function () {
          drag = false;
          this._cursorActive = false;
          window.removeEventListener('mousedown', that._mousedown);
          window.removeEventListener('mouseup', that._mouseup);
          window.removeEventListener('mousemove', that._mousemove);
          that._mousedown = null;
          that._mouseup = null;
          that._mousemove = null;
        };

        that._mousemove = function (evt) {
          if (drag && isGradientCursor) {
            that.getColorFromGradient(evt);
          } else if (drag) {
            that.rainbowCursor();
          }
        };

        window.addEventListener('mousedown', that._mousedown);
        window.addEventListener('mouseup', that._mouseup);
        window.addEventListener('mousemove', that._mousemove);
      }

      gradient() {
        const hue = rgbToHsl(this._rgb).hue;
        this.canvasContext();
        this.setCanvasColor(hue);
        this.updateRainbow(hue);
      }

      getColorFromGradient(event) {
        let cursorPosition;

        if (event.type === 'keydown' && event.key !== 'Tab') {
          cursorPosition = this.gradientCursorPositionFromKeydown(event);
        } else if (event.type === 'mousedown' || event.type === 'mousemove') {
          cursorPosition = this.gradientCursorPosition(event);
        } else {
          return;
        }

        const x = cursorPosition.x;
        const y = cursorPosition.y; // Get the current HUE value and update the canvas & cursor

        this.setCanvasColor(this._hueValue); // set color from gradient

        this.setRGBValues(x, y);
      }

      rainbowCursor() {
        const rainbow = this.template.querySelector('*[data-id="hue-slider"]');
        const position = this._cachePosition || this.rgbToPosition(this._rgb);
        this.setCanvasColor(rainbow.value);
        this.setRGBValues(position.x, position.y);
        this.updateRainbow(rainbow.value);
      }

      updateRainbow(hue) {
        this._hueValue = hue;
      }

      handleUpdateAnchor() {
        const position = this._cachePosition || this.rgbToPosition(this._rgb);
        const anchor = this.anchorElement;
        const offset = anchor.offsetWidth / 2;
        const x = position.x - offset + 5;
        const y = position.y - offset - 5;
        const xPercent = x / this._canvas.width * 100;
        const yPercent = y / this._canvas.height * 100;
        anchor.style.left = `${xPercent}%`;
        anchor.style.top = `${yPercent}%`;
      }

      gradientCursorPosition(event) {
        const canvas = this._canvas;
        const gradientCanvas = canvas.getBoundingClientRect();
        let x = event.clientX - gradientCanvas.left;
        let y = event.clientY - gradientCanvas.top;

        if (x > gradientCanvas.width) {
          x = gradientCanvas.width - 1;
        }

        if (x < 0) {
          x = 0;
        }

        if (y > gradientCanvas.height) {
          y = gradientCanvas.height;
        }

        if (y < 0) {
          y = 0;
        }
        /*
         * Caching the position x & y in the component so that we can use it when moving the rainbow slider
         * instead of calculating the position of x & y each time.
         */


        this._cachePosition = {
          x,
          y
        };
        return {
          x,
          y
        };
      }

      gradientCursorPositionFromKeydown(event) {
        event.preventDefault();
        const canvas = this._canvas;
        const gradientCanvas = canvas.getBoundingClientRect();
        const keyCode = event.keyCode;
        let x, y;

        if (!this._cachePosition) {
          this._cachePosition = this.rgbToPosition(this._rgb);
        }

        const positionMap = {};
        positionMap[keyCodes.left] = {
          x: -1,
          y: 0
        };
        positionMap[keyCodes.up] = {
          x: 0,
          y: -1
        };
        positionMap[keyCodes.right] = {
          x: +1,
          y: 0
        };
        positionMap[keyCodes.down] = {
          x: 0,
          y: +1
        };
        const transform = positionMap[keyCode] ? positionMap[keyCode] : {
          x: 0,
          y: 0
        };
        x = this._cachePosition.x + transform.x;
        y = this._cachePosition.y + transform.y;

        if (x > gradientCanvas.width) {
          x = gradientCanvas.width - 1;
        }

        if (x < 0) {
          x = 0;
        }

        if (y > gradientCanvas.height) {
          y = gradientCanvas.height;
        }

        if (y < 0) {
          y = 0;
        }
        /*
         * Caching the position x & y in the component so that we can use it when moving the rainbow slider
         * instead of calculating the position of x & y each time.
         */


        this._cachePosition = {
          x,
          y
        };
        return {
          x,
          y
        };
      }

      setRGBValues(x, y) {
        const ctx = this._canvasCtx;
        const imageData = ctx.getImageData(x, y, 1, 1).data;
        const rgb = {
          red: imageData[0],
          green: imageData[1],
          blue: imageData[2]
        };
        const color = `#${rgbToHex(rgb)}`;
        this._rgb = rgb;
        this.updateSelectedColor(color);
        this.handleUpdateAnchor();
      }

      setCanvasColor(hue) {
        const ctx = this._canvasCtx; // don't map the gradient onto extreme left and right to make extremes have their max values

        const white = ctx.createLinearGradient(1, 0, this.canvasRect.x - 1, 0);
        white.addColorStop(0, 'rgb(255,255,255)');
        white.addColorStop(1, 'hsl(' + hue + ', 100%, 50%)');
        ctx.fillStyle = white;
        ctx.fillRect(0, 0, this.canvasRect.x, this.canvasRect.y); // starting y is the first line to avoid blending the black into the hue, thus
        // making extreme values unselectable

        const black = ctx.createLinearGradient(0, 1, 0, this.canvasRect.y);
        black.addColorStop(0, 'rgba(0,0,0,0)');
        black.addColorStop(1, 'rgb(0,0,0)');
        ctx.fillStyle = black;
        ctx.fillRect(0, 0, this.canvasRect.x, this.canvasRect.y);
      }

      setCanvasCursor(x, y) {
        const position = {
          x,
          y
        };
        const anchor = this.anchorElement;
        const offset = anchor.offsetWidth / 2;
        x = position.x - offset + 5;
        y = position.y - offset - 5;
        const xPercent = x / this._canvas.width * 100;
        const yPercent = y / this._canvas.height * 100;
        anchor.style.left = `${xPercent}%`;
        anchor.style.top = `${yPercent}%`;
      }

      canvasContext() {
        this._canvas = this.template.querySelector('canvas');
        this._canvasCtx = this._canvas.getContext('2d');
        this._cursorActive = false;
      }

      handleKeydown(event) {
        this.getColorFromGradient(event);
      }

      rgbToPosition(rgb) {
        return rgbToPosition(rgb, this.canvasRect);
      }

    }

    lwc.registerDecorators(LightningColorPickerCustom, {
      publicProps: {
        currentColor: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        _hueValue: 1,
        _rgb: 1,
        _hex: 1,
        _errorMessage: 1,
        _currentColor: 1
      }
    });

    var _lightningColorPickerCustom = lwc.registerComponent(LightningColorPickerCustom, {
      tmpl: _tmpl$a
    });

    function tmpl$a($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        gid: api_scoped_id,
        h: api_element,
        d: api_dynamic,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [api_element("section", {
        classMap: {
          "slds-popover": true,
          "slds-color-picker__selector": true,
          "slds-show": true,
          "slds-is-absolute": true
        },
        attrs: {
          "role": "dialog",
          "aria-label": "Choose a color",
          "aria-describedby": `${api_scoped_id("dialog-body-id")}`
        },
        key: 2,
        on: {
          "updateselectedcolor": _m2 || ($ctx._m2 = api_bind($cmp.handleUpdateSelectedColor)),
          "keydown": _m3 || ($ctx._m3 = api_bind($cmp.handleKeydown))
        }
      }, [api_element("div", {
        classMap: {
          "slds-popover__body": true
        },
        attrs: {
          "id": api_scoped_id("dialog-body-id")
        },
        key: 3
      }, [api_custom_element("lightning-color-picker-custom", _lightningColorPickerCustom, {
        props: {
          "currentColor": $cmp.currentColor
        },
        key: 4
      }, [])]), api_element("footer", {
        classMap: {
          "slds-popover__footer": true
        },
        key: 5
      }, [api_element("div", {
        classMap: {
          "slds-color-picker__selector-footer": true
        },
        key: 6
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_neutral": true
        },
        attrs: {
          "name": "cancel"
        },
        key: 7,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleCancelClick))
        }
      }, [api_dynamic($cmp.i18n.cancelButton)]), api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_brand": true
        },
        attrs: {
          "name": "done"
        },
        key: 8,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleDoneClick))
        }
      }, [api_dynamic($cmp.i18n.doneButton)])])])])];
    }

    var _tmpl$b = lwc.registerTemplate(tmpl$a);
    tmpl$a.stylesheets = [];
    tmpl$a.stylesheetTokens = {
      hostAttribute: "lightning-colorPickerPanel_colorPickerPanel-host",
      shadowAttribute: "lightning-colorPickerPanel_colorPickerPanel"
    };

    var labelCancelButton = 'Cancel';

    var labelCustomTab = 'Custom';

    var labelDefaultTab = 'Default';

    var labelDoneButton = 'Done';

    const i18n$2 = {
      cancelButton: labelCancelButton,
      customTab: labelCustomTab,
      defaultTab: labelDefaultTab,
      doneButton: labelDoneButton
    };
    const DEFAULT_COLOR = '#000000';

    class LightningColorPickerPanel extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.currentColor = void 0;
        this._isCustomTabActive = false;
        this._selectedColor = null;
      }

      connectedCallback() {
        this._selectedColor = this.currentColor || DEFAULT_COLOR;
      }

      get i18n() {
        return i18n$2;
      }

      get computedClassDefault() {
        return classSet({
          'slds-tabs_default__item': true,
          'slds-is-active': !this._isCustomTabActive
        }).toString();
      }

      get computedClassCustom() {
        return classSet({
          'slds-tabs_default__item': true,
          'slds-is-active': this._isCustomTabActive
        }).toString();
      }

      get ariaSelectedDefault() {
        return !this._isCustomTabActive.toString();
      }

      get ariaSelectedCustom() {
        return this._isCustomTabActive.toString();
      }

      handleTabChange(event) {
        event.preventDefault();
        const tabElement = event.currentTarget;

        if (tabElement.classList.contains('slds-is-active')) {
          return;
        }

        this._isCustomTabActive = tabElement.title !== i18n$2.defaultTab;
      }

      handleUpdateSelectedColor(event) {
        this._selectedColor = event.detail.color;
      }

      dispatchUpdateColorEventWithColor(color) {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('updatecolor', {
          composed: true,
          bubbles: true,
          detail: {
            color
          }
        }));
      }

      handleDoneClick() {
        this.dispatchUpdateColorEventWithColor(this._selectedColor);
      }

      handleCancelClick() {
        this.dispatchUpdateColorEventWithColor(this.currentColor);
      }

      handleKeydown(event) {
        if (event.keyCode === keyCodes.escape) {
          event.preventDefault();
          this.dispatchUpdateColorEventWithColor(this.currentColor);
        } else if (event.shiftKey && event.keyCode === keyCodes.tab && event.srcElement.dataset.id === 'color-anchor') {
          event.preventDefault();
          this.template.querySelector('button[name="done"]').focus();
        } else if (!event.shiftKey && event.keyCode === keyCodes.tab && event.srcElement.name === 'done') {
          event.preventDefault();
          this.template.querySelector('lightning-color-picker-custom').focus();
        }
      }

    }

    lwc.registerDecorators(LightningColorPickerPanel, {
      publicProps: {
        currentColor: {
          config: 0
        }
      },
      track: {
        _isCustomTabActive: 1,
        _selectedColor: 1
      }
    });

    var _lightningColorPickerPanel = lwc.registerComponent(LightningColorPickerPanel, {
      tmpl: _tmpl$b
    });

    function tmpl$b($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-color-picker__summary-button": true,
          "slds-button_icon": true,
          "slds-button_icon-more": true
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 2,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleColorPickerToggleClick))
        }
      }, [api_element("span", {
        classMap: {
          "slds-swatch": true
        },
        style: $cmp.colorInputStyle,
        attrs: {
          "data-id": "thumbnail"
        },
        key: 3
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 4
      }, [api_dynamic($cmp.i18n.a11yTriggerText)])]), api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:down",
          "svgClass": "slds-button__icon slds-button__icon_small",
          "variant": "bare"
        },
        key: 5
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true,
          "a11y-color-value": true
        },
        key: 6
      }, [api_dynamic($cmp.value)])]), $cmp._isColorPickerPanelOpen ? api_custom_element("lightning-color-picker-panel", _lightningColorPickerPanel, {
        classMap: {
          "color-picker-panel": true
        },
        props: {
          "currentColor": $cmp.value
        },
        key: 8,
        on: {
          "updatecolor": _m1 || ($ctx._m1 = api_bind($cmp.handleUpdateColorEvent))
        }
      }, []) : null];
    }

    var _tmpl$c = lwc.registerTemplate(tmpl$b);
    tmpl$b.stylesheets = [];
    tmpl$b.stylesheetTokens = {
      hostAttribute: "lightning-primitiveColorpickerButton_primitiveColorpickerButton-host",
      shadowAttribute: "lightning-primitiveColorpickerButton_primitiveColorpickerButton"
    };

    var labelA11yTriggerText = 'Choose a color. Current color: ';

    const i18n$3 = {
      a11yTriggerText: labelA11yTriggerText
    };

    class PrimitiveColorpickerButton extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._isColorPickerPanelOpen = false;
        this._value = '';
        this._disabled = false;
      }

      get value() {
        return this._value;
      }

      set value(value) {
        this._value = value;
      }
      /**
       * If present, the input field is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      focus() {
        const button = this.template.querySelector('button');
        return button && button.focus();
      }

      blur() {
        const button = this.template.querySelector('button');
        return button && button.blur();
      }

      get colorInputStyle() {
        return `background: ${this.value || '#5679C0'};`;
      }

      handleColorPickerToggleClick(event) {
        event.preventDefault();
        this._isColorPickerPanelOpen = !this._isColorPickerPanelOpen;

        if (this._isColorPickerPanelOpen) {
          this.startColorPickerPositioning();
        } else {
          this.stopColorPickerPositioning();
        }
      }

      startColorPickerPositioning() {
        if (!this._autoPosition) {
          this._autoPosition = new AutoPosition(this);
        }

        this._autoPosition.start({
          target: () => this.template.querySelector('button.slds-color-picker__summary-button'),
          element: () => this.template.querySelector('lightning-color-picker-panel').shadowRoot.querySelector('section'),
          align: {
            horizontal: Direction.Left,
            vertical: Direction.Top
          },
          targetAlign: {
            horizontal: Direction.Left,
            vertical: Direction.Bottom
          },
          autoFlip: true
        });
      }

      stopColorPickerPositioning() {
        if (this._autoPosition) {
          this._autoPosition.stop();
        }
      }

      handleUpdateColorEvent(event) {
        event.stopPropagation();
        const detail = event.detail;
        this._isColorPickerPanelOpen = false;
        this.stopColorPickerPositioning();
        this.dispatchEvent(new CustomEvent('change', {
          detail
        }));
      }

      get i18n() {
        return i18n$3;
      }

    }

    PrimitiveColorpickerButton.delegatesFocus = true;

    lwc.registerDecorators(PrimitiveColorpickerButton, {
      publicProps: {
        value: {
          config: 3
        },
        disabled: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur"],
      track: {
        _isColorPickerPanelOpen: 1,
        _value: 1,
        _disabled: 1
      }
    });

    var _lightningPrimitiveColorpickerButton = lwc.registerComponent(PrimitiveColorpickerButton, {
      tmpl: _tmpl$c
    });

    function tmpl$c($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element,
        gid: api_scoped_id,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("button", {
        className: $cmp.computedButtonClass,
        attrs: {
          "name": $cmp.name,
          "title": $cmp.computedTitle,
          "accesskey": $cmp.computedAccessKey,
          "type": $cmp.normalizedType,
          "value": $cmp.value,
          "aria-describedby": api_scoped_id($cmp.computedAriaDescribedBy),
          "aria-label": $cmp.computedAriaLabel,
          "aria-controls": api_scoped_id($cmp.computedAriaControls),
          "aria-expanded": $cmp.computedAriaExpanded,
          "aria-live": $cmp.computedAriaLive,
          "aria-atomic": $cmp.computedAriaAtomic
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 2,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleBlur))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.iconName,
          "svgClass": $cmp.computedIconClass,
          "variant": "bare"
        },
        key: 3
      }, []), $cmp.alternativeText ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 5
      }, [api_dynamic($cmp.alternativeText)]) : null])];
    }

    var _tmpl$d = lwc.registerTemplate(tmpl$c);
    tmpl$c.stylesheets = [];
    tmpl$c.stylesheetTokens = {
      hostAttribute: "lightning-buttonIcon_buttonIcon-host",
      shadowAttribute: "lightning-buttonIcon_buttonIcon"
    };

    function tmpl$d($api, $cmp, $slotset, $ctx) {
      return [];
    }

    var _tmpl$e = lwc.registerTemplate(tmpl$d);
    tmpl$d.stylesheets = [];
    tmpl$d.stylesheetTokens = {
      hostAttribute: "lightning-primitiveButton_primitiveButton-host",
      shadowAttribute: "lightning-primitiveButton_primitiveButton"
    };

    class LightningPrimitiveButton extends lwc.LightningElement {
      get disabled() {
        return this.state.disabled;
      }

      set disabled(value) {
        this.state.disabled = normalizeBoolean(value);
      }

      set accessKey(value) {
        this.state.accesskey = value;
      }

      get accessKey() {
        return this.state.accesskey;
      }

      get computedAccessKey() {
        return this.state.accesskey;
      }

      get title() {
        return this.state.title;
      }

      set title(value) {
        this.state.title = value;
      }

      get ariaLabel() {
        return this.state.ariaLabel;
      }

      set ariaLabel(value) {
        this.state.ariaLabel = value;
      }

      get computedAriaLabel() {
        return this.state.ariaLabel;
      }

      get ariaDescribedBy() {
        return this.state.ariaDescribedBy;
      }

      set ariaDescribedBy(value) {
        this.state.ariaDescribedBy = value;
      }

      get computedAriaDescribedBy() {
        return this.state.ariaDescribedBy;
      }

      get ariaControls() {
        return this.state.ariaControls;
      }

      set ariaControls(value) {
        this.state.ariaControls = value;
      }

      get computedAriaControls() {
        return this.state.ariaControls;
      }

      get ariaExpanded() {
        return this.state.ariaExpanded;
      }

      set ariaExpanded(value) {
        this.state.ariaExpanded = normalizeString(value, {
          fallbackValue: undefined,
          validValues: ['true', 'false']
        });
      }

      get computedAriaExpanded() {
        return this.state.ariaExpanded || null;
      }

      set ariaLive(value) {
        this.state.ariaLive = value;
      }

      get ariaLive() {
        return this.state.ariaLive;
      }

      get computedAriaLive() {
        return this.state.ariaLive;
      }

      get ariaAtomic() {
        return this.state.ariaAtomic || null;
      }

      set ariaAtomic(value) {
        this.state.ariaAtomic = normalizeString(value, {
          fallbackValue: undefined,
          validValues: ['true', 'false']
        });
      }

      get computedAriaAtomic() {
        return this.state.ariaAtomic || null;
      }

      focus() {}

      constructor() {
        super(); // Workaround for an IE11 bug where click handlers on button ancestors
        // receive the click event even if the button element has the `disabled`
        // attribute set.

        this.state = {
          accesskey: null,
          ariaAtomic: null,
          ariaControls: null,
          ariaDescribedBy: null,
          ariaExpanded: null,
          ariaLabel: null,
          ariaLive: null,
          disabled: false
        };

        if (isIE11) {
          this.template.addEventListener('click', event => {
            if (this.disabled) {
              event.stopImmediatePropagation();
            }
          });
        }
      }

    }

    lwc.registerDecorators(LightningPrimitiveButton, {
      publicProps: {
        disabled: {
          config: 3
        },
        accessKey: {
          config: 3
        },
        title: {
          config: 3
        },
        ariaLabel: {
          config: 3
        },
        ariaDescribedBy: {
          config: 3
        },
        ariaControls: {
          config: 3
        },
        ariaExpanded: {
          config: 3
        },
        ariaLive: {
          config: 3
        },
        ariaAtomic: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        state: 1
      }
    });

    var LightningPrimitiveButton$1 = lwc.registerComponent(LightningPrimitiveButton, {
      tmpl: _tmpl$e
    });

    const DEFAULT_SIZE = 'medium';
    const DEFAULT_VARIANT = 'border';
    const DEFAULT_TYPE = 'button';
    /**
     * An icon-only HTML button.
     */

    class LightningButtonIcon extends LightningPrimitiveButton$1 {
      constructor(...args) {
        super(...args);
        this.name = void 0;
        this.value = void 0;
        this.variant = DEFAULT_VARIANT;
        this.iconName = void 0;
        this.iconClass = void 0;
        this.size = DEFAULT_SIZE;
        this.type = DEFAULT_TYPE;
        this.alternativeText = void 0;
        this._order = null;
        this._tooltip = null;
      }

      /**
       * Text to display when the user mouses over or focuses on the button.
       * The tooltip is auto-positioned relative to the button and screen space.
       * @type {string}
       * @param {string} value - The plain text string for the tooltip
       */
      set tooltip(value) {
        if (this._tooltip) {
          this._tooltip.value = value;
        } else if (value) {
          // Note that because the tooltip target is a child element it may not be present in the
          // dom during initial rendering.
          this._tooltip = new Tooltip(value, {
            root: this,
            target: () => this.template.querySelector('button')
          });

          this._tooltip.initialize();
        }
      }

      get tooltip() {
        return this._tooltip ? this._tooltip.value : undefined;
      }

      // this is there because raptor currently doesnt support inheritance
      render() {
        return _tmpl$d;
      }

      get computedTitle() {
        return this.state.title || this.alternativeText || '';
      }

      get normalizedVariant() {
        return normalizeString(this.variant, {
          fallbackValue: DEFAULT_VARIANT,
          validValues: ['bare', 'brand', 'container', 'border', 'border-filled', 'bare-inverse', 'border-inverse']
        });
      }

      get normalizedType() {
        return normalizeString(this.type, {
          fallbackValue: DEFAULT_TYPE,
          validValues: ['button', 'reset', 'submit']
        });
      }

      get normalizedSize() {
        return normalizeString(this.size, {
          fallbackValue: DEFAULT_SIZE,
          validValues: ['xx-small', 'x-small', 'small', 'medium', 'large']
        });
      }

      getVariantBase() {
        return this.normalizedVariant.split('-')[0];
      }

      getVariantModifier() {
        return this.normalizedVariant.split('-')[1] || '';
      }

      get computedButtonClass() {
        const {
          normalizedSize,
          normalizedVariant
        } = this;
        const isBare = this.getVariantBase(normalizedSize) === 'bare';
        const classes = classSet('slds-button');

        if (!isBare) {
          // If the variant is not bare, then size the button instead of the icon
          switch (normalizedSize) {
            case 'small':
              classes.add('slds-button_icon-small');
              break;

            case 'x-small':
              classes.add('slds-button_icon-x-small');
              break;

            case 'xx-small':
              classes.add('slds-button_icon-xx-small');
              break;

            case 'large':
              // There is no `large` modifier for buttons so we should drop down one size to `medium`
              // eslint-disable-next-line no-console
              console.warn(`<lightning-button-icon> The non-bare variants of buttonIcon do not support a size value of "large". Supported values include "xx-small", "x-small", "small", and "medium". Falling back to size value "medium".`);

            /* falls through */

            case 'medium': // Medium is the default size, and the default size doesn't require a size modifier

            default:
          }
        }

        return classes.add({
          'slds-button_icon-bare': isBare,
          'slds-button_icon-container': normalizedVariant === 'container',
          'slds-button_icon-border': normalizedVariant === 'border',
          'slds-button_icon-border-filled': normalizedVariant === 'border-filled',
          'slds-button_icon-border-inverse': normalizedVariant === 'border-inverse',
          'slds-button_icon-inverse': normalizedVariant === 'bare-inverse',
          'slds-button_icon-brand': normalizedVariant === 'brand',
          'slds-button_first': this._order === 'first',
          'slds-button_middle': this._order === 'middle',
          'slds-button_last': this._order === 'last'
        }).toString();
      }

      get computedIconClass() {
        const {
          normalizedSize,
          normalizedVariant
        } = this;
        const isBare = this.getVariantBase(normalizedVariant) === 'bare';
        const iconClass = this.iconClass || '';
        const classes = classSet('slds-button__icon');
        classes.add(iconClass);

        if (isBare) {
          // If the variant is bare, then size the icon instead of the button
          switch (normalizedSize) {
            case 'large':
              classes.add('slds-button__icon_large');
              break;

            case 'small':
              classes.add('slds-button__icon_small');
              break;

            case 'xx-small':
              // There is no `xx-small` modifier for bare so we should drop down one size to `x-small`
              // eslint-disable-next-line no-console
              console.warn(`<lightning-button-icon> The bare variant of buttonIcon does not support a size value of "xx-small". Supported values include "x-small", "small", "medium", and "large". The default is "medium".`);

            /* falls through */

            case 'x-small':
              classes.add('slds-button__icon_x-small');
              break;

            case 'medium': // Medium is the default size, and the default size doesn't require a size modifier

            default:
          }
        }

        if (this.getVariantModifier(normalizedVariant) === 'inverse') {
          classes.add('slds-button_icon-inverse');
        }

        return classes.toString();
      }

      handleFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }
      /**
       * Sets focus on the button.
       */


      focus() {
        this.template.querySelector('button').focus();
      }
      /**
       * {Function} setOrder - Sets the order value of the button when in the context of a button-group or other ordered component
       * @param {String} order -  The order string (first, middle, last)
       */


      setOrder(order) {
        this._order = order;
      }
      /**
       * Once we are connected, we fire a register event so the button-group (or other) component can register
       * the buttons.
       */


      connectedCallback() {
        const privatebuttonregister = new CustomEvent('privatebuttonregister', {
          bubbles: true,
          detail: {
            callbacks: {
              setOrder: this.setOrder.bind(this),
              setDeRegistrationCallback: deRegistrationCallback => {
                this._deRegistrationCallback = deRegistrationCallback;
              }
            }
          }
        });
        this.dispatchEvent(privatebuttonregister);
      }

      renderedCallback() {
        if (this._tooltip && !this._tooltip.initialized) {
          this._tooltip.initialize();
        }
      }

      disconnectedCallback() {
        if (this._deRegistrationCallback) {
          this._deRegistrationCallback();
        }
      }

    }

    LightningButtonIcon.delegatesFocus = true;

    lwc.registerDecorators(LightningButtonIcon, {
      publicProps: {
        name: {
          config: 0
        },
        value: {
          config: 0
        },
        variant: {
          config: 0
        },
        iconName: {
          config: 0
        },
        iconClass: {
          config: 0
        },
        size: {
          config: 0
        },
        type: {
          config: 0
        },
        alternativeText: {
          config: 0
        },
        tooltip: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        _order: 1
      }
    });

    var _lightningButtonIcon = lwc.registerComponent(LightningButtonIcon, {
      tmpl: _tmpl$d
    });

    function stylesheet$5(hostSelector, shadowSelector, nativeShadow) {
      return "[dir=\"rtl\"] .slds-dropdown_left" + shadowSelector + " {left: 0;right: auto;}\n";
    }
    var _implicitStylesheets$5 = [stylesheet$5];

    function tmpl$e($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        k: api_key,
        i: api_iterator,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "for": `${api_scoped_id("select")}`
        },
        key: 2
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 4
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 5
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 6
      }, [api_element("div", {
        classMap: {
          "slds-select_container": true
        },
        key: 7
      }, [api_element("select", {
        classMap: {
          "slds-select": true
        },
        attrs: {
          "id": api_scoped_id("select"),
          "name": $cmp.name,
          "size": $cmp.size,
          "accesskey": $cmp.accessKey,
          "tabindex": api_tab_index($cmp.tabIndex)
        },
        props: {
          "disabled": $cmp.disabled,
          "multiple": $cmp.multiple
        },
        key: 8,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleBlur)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange))
        }
      }, api_iterator($cmp.options, function (option) {
        return api_element("option", {
          attrs: {
            "value": option.value
          },
          key: api_key(10, option.value)
        }, [api_dynamic(option.label)]);
      }))])]), $cmp.errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("help-message"),
          "data-help-message": true,
          "aria-live": "assertive"
        },
        key: 12
      }, [api_dynamic($cmp.errorMessage)]) : null];
    }

    var _tmpl$f = lwc.registerTemplate(tmpl$e);
    tmpl$e.stylesheets = [];
    tmpl$e.stylesheetTokens = {
      hostAttribute: "lightning-primitiveSelect_primitiveSelect-host",
      shadowAttribute: "lightning-primitiveSelect_primitiveSelect"
    };

    var labelRequired = 'required';

    const i18n$4 = {
      required: labelRequired
    };
    const {
      reduce: ArrayReduce
    } = Array.prototype;

    class LightningPrimitiveSelect extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._errorMessage = '';
        this._options = [];
        this._selectedValue = void 0;
        this._variant = void 0;
        this._required = false;
        this._disabled = false;
        this._multiple = false;
        this._fieldLevelHelp = void 0;
        this._size = void 0;
        this._ariaDescribedBy = void 0;
        this._tabIndex = void 0;
        this.label = void 0;
        this.name = void 0;
        this.messageWhenValueMissing = void 0;
        this.accessKey = void 0;
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      set variant(value) {
        this._variant = normalizeVariant$1(value);
        this.updateClassList();
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set multiple(value) {
        this._multiple = normalizeBoolean(value);
      }

      get multiple() {
        return this._multiple;
      }

      set size(newValue) {
        this._size = newValue;
      }

      get size() {
        if (!this.multiple) {
          return null;
        }

        if (this._size === undefined) {
          return '4';
        }

        return this._size;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      get required() {
        return this._required;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get disabled() {
        return this._disabled;
      }

      set value(newValue) {
        this._selectedValue = newValue;

        if (this.connected && newValue) {
          this.selectOptionsByValue(newValue);
        }
      }

      get value() {
        return this._selectedValue;
      }

      set options(newValue) {
        this._options = newValue;

        if (this.connected && newValue) {
          this.selectOptionsByValue(this._selectedValue);
        }
      }

      get options() {
        return this._options;
      }

      get tabIndex() {
        return this._tabIndex;
      }

      set tabIndex(newValue) {
        this._tabIndex = newValue;
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.showHelpMessageIfInvalid());
        this.connected = true;
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      renderedCallback() {
        if (this.options && this._selectedValue !== undefined) {
          this.selectOptionsByValue(this._selectedValue);
        }
      }

      disconnectedCallback() {
        this.connected = false;
      }

      focus() {
        if (this.connected) {
          this.getElement.focus();
        }
      }

      blur() {
        if (this.connected) {
          this.getElement.blur();
        }
      }

      get validity() {
        const missing = !this.disabled && this.required && (this._selectedValue == null || this._selectedValue === '' || this._selectedValue.length === 0);
        return buildSyntheticValidity({
          valueMissing: missing,
          customError: this.customErrorMessage != null && this.customErrorMessage !== ''
        });
      }

      checkValidity() {
        const isValid = this.validity.valid;

        if (!isValid) {
          this.dispatchEvent(new CustomEvent('invalid', {
            cancellable: true
          }));
        }

        return isValid;
      }

      reportValidity() {
        this.showHelpMessageIfInvalid();
        return this.checkValidity();
      }

      setCustomValidity(message) {
        this.customErrorMessage = message;
      }

      showHelpMessageIfInvalid() {
        const validity = this.validity;

        if (validity.valid) {
          this._errorMessage = '';
          this.classList.remove('slds-has-error');
          this.removeAriaDescribedBy();
        } else {
          this.classList.add('slds-has-error');
          this._errorMessage = getErrorMessage(validity, {
            valueMissing: this.messageWhenValueMissing,
            customError: this.customErrorMessage
          });
          this.setAriaDescribedBy(this.computedUniqueErrorMessageElementId);
        }
      }

      get i18n() {
        return i18n$4;
      }

      get errorMessage() {
        return this._errorMessage;
      }

      get getElement() {
        return this.template.querySelector('select');
      }

      get computedUniqueErrorMessageElementId() {
        return getRealDOMId(this.template.querySelector('[data-help-message]'));
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedAriaDescribedBy() {
        return this._ariaDescribedBy;
      }

      handleChange(event) {
        event.preventDefault();
        event.stopPropagation();
        this._selectedValue = this.getSelectedOptionValues();
        this.dispatchChangeEvent();
      }

      handleFocus() {
        this.interactingState.enter();
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.interactingState.leave();
        this.dispatchEvent(new CustomEvent('blur'));
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._selectedValue
          }
        }));
      }

      selectOptionsByValue(optionValue) {
        if (this.multiple) {
          if (Array.isArray(optionValue)) {
            const options = this.template.querySelectorAll('option');
            options.forEach(option => {
              option.selected = optionValue.includes(option.value);
            });
          }
        } else {
          this.getElement.value = optionValue;
        }
      }

      getSelectedOptionValues() {
        if (this.multiple) {
          const options = this.template.querySelectorAll('option');
          return ArrayReduce.call(options, (selectedValues, option) => {
            if (option.selected) {
              selectedValues.push(option.value);
            }

            return selectedValues;
          }, []);
        }

        return this.getElement.value;
      }

      setAriaDescribedBy(val) {
        this.getElement.setAttribute('aria-describedby', val);
      }

      removeAriaDescribedBy() {
        this.getElement.removeAttribute('aria-describedby');
      }

    }

    lwc.registerDecorators(LightningPrimitiveSelect, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        accessKey: {
          config: 0
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        multiple: {
          config: 3
        },
        size: {
          config: 3
        },
        required: {
          config: 3
        },
        disabled: {
          config: 3
        },
        value: {
          config: 3
        },
        options: {
          config: 3
        },
        tabIndex: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        _errorMessage: 1,
        _options: 1,
        _selectedValue: 1,
        _variant: 1,
        _required: 1,
        _disabled: 1,
        _multiple: 1,
        _fieldLevelHelp: 1,
        _size: 1,
        _ariaDescribedBy: 1,
        _tabIndex: 1
      }
    });

    var _lightningPrimitiveSelect = lwc.registerComponent(LightningPrimitiveSelect, {
      tmpl: _tmpl$f
    });

    function tmpl$f($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        k: api_key,
        i: api_iterator,
        ti: api_tab_index
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-datepicker": true,
          "slds-dropdown": true,
          "slds-dropdown_left": true
        },
        attrs: {
          "aria-hidden": "false",
          "aria-label": $cmp.computedAriaLabel,
          "role": "dialog"
        },
        key: 2
      }, [api_element("div", {
        classMap: {
          "slds-datepicker__filter": true,
          "slds-grid": true
        },
        key: 3
      }, [api_element("div", {
        classMap: {
          "slds-datepicker__filter_month": true,
          "slds-grid": true,
          "slds-grid_align-spread": true,
          "slds-grow": true
        },
        key: 4
      }, [api_element("div", {
        classMap: {
          "slds-align-middle": true
        },
        key: 5
      }, [api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:left",
          "variant": "container",
          "alternativeText": $cmp.i18n.previousMonth
        },
        key: 6,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.goToPreviousMonth)),
          "keydown": _m1 || ($ctx._m1 = api_bind($cmp.handlePrevNavKeyDown))
        }
      }, [])]), api_element("h2", {
        classMap: {
          "slds-align-middle": true
        },
        attrs: {
          "aria-atomic": "true",
          "aria-live": "assertive",
          "id": api_scoped_id("month-title")
        },
        key: 7
      }, [api_dynamic($cmp.computedMonthTitle)]), api_element("div", {
        classMap: {
          "slds-align-middle": true
        },
        key: 8
      }, [api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:right",
          "variant": "container",
          "alternativeText": $cmp.i18n.nextMonth
        },
        key: 9,
        on: {
          "click": _m2 || ($ctx._m2 = api_bind($cmp.goToNextMonth))
        }
      }, [])])]), api_element("div", {
        classMap: {
          "slds-shrink-none": true
        },
        key: 10
      }, [api_custom_element("lightning-primitive-select", _lightningPrimitiveSelect, {
        props: {
          "value": $cmp.calendarYear,
          "label": $cmp.i18n.yearSelector,
          "variant": "label-hidden",
          "options": $cmp.computedYearList
        },
        key: 11,
        on: {
          "change": _m3 || ($ctx._m3 = api_bind($cmp.handleYearChange)),
          "click": _m4 || ($ctx._m4 = api_bind($cmp.handleYearSelectClick))
        }
      }, [])])]), api_element("table", {
        classMap: {
          "slds-datepicker__month": true
        },
        attrs: {
          "aria-labelledby": `${api_scoped_id("month-title")}`,
          "role": "grid"
        },
        key: 12
      }, [api_element("thead", {
        key: 13
      }, [api_element("tr", {
        attrs: {
          "id": api_scoped_id("weekdays-element")
        },
        key: 14
      }, api_iterator($cmp.computedWeekdayLabels, function (weekday) {
        return api_element("th", {
          attrs: {
            "id": api_scoped_id(weekday.fullName),
            "scope": "col"
          },
          key: api_key(16, weekday.fullName)
        }, [api_element("abbr", {
          attrs: {
            "title": weekday.fullName
          },
          key: 17
        }, [api_dynamic(weekday.shortName)])]);
      }))]), api_element("tbody", {
        key: 18,
        on: {
          "keydown": _m6 || ($ctx._m6 = api_bind($cmp.handleCalendarKeyDown))
        }
      }, api_iterator($cmp.computedMonth, function (week, index) {
        return api_element("tr", {
          key: api_key(20, week.id)
        }, api_iterator(week.days, function (day) {
          return api_element("td", {
            className: day.className,
            attrs: {
              "role": "gridcell",
              "aria-selected": day.isSelected,
              "aria-disabled": day.isDisabled,
              "aria-current": day.ariaCurrent,
              "tabindex": api_tab_index(day.tabIndex),
              "data-value": day.dateValue
            },
            key: api_key(22, day.dateValue)
          }, [api_element("span", {
            classMap: {
              "slds-day": true
            },
            key: 23,
            on: {
              "click": _m5 || ($ctx._m5 = api_bind($cmp.handleDateClick))
            }
          }, [api_dynamic(day.date)])]);
        }));
      }))]), api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-align_absolute-center": true,
          "slds-text-link": true
        },
        attrs: {
          "name": "today",
          "type": "button"
        },
        key: 24,
        on: {
          "click": _m7 || ($ctx._m7 = api_bind($cmp.handleTodayClick)),
          "keydown": _m8 || ($ctx._m8 = api_bind($cmp.handleTodayKeyDown))
        }
      }, [api_dynamic($cmp.i18n.today)])])];
    }

    var _tmpl$g = lwc.registerTemplate(tmpl$f);
    tmpl$f.stylesheets = [];

    if (_implicitStylesheets$5) {
      tmpl$f.stylesheets.push.apply(tmpl$f.stylesheets, _implicitStylesheets$5);
    }
    tmpl$f.stylesheetTokens = {
      hostAttribute: "lightning-calendar_calendar-host",
      shadowAttribute: "lightning-calendar_calendar"
    };

    var labelAriaLabelMonth = 'Date picker: ';

    var labelNextMonth = 'Next Month';

    var labelPreviousMonth = 'Previous Month';

    var labelToday = 'Today';

    var labelYearSelector = 'Pick a Year';

    function handleKeyDownOnCalendar(event, date, calendarInterface) {
      const tdElement = event.target;

      switch (event.keyCode) {
        case keyCodes.up:
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() - 7);
          calendarInterface.focusDate(date);
          break;

        case keyCodes.down:
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() + 7);
          calendarInterface.focusDate(date);
          break;

        case keyCodes.right:
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() + 1);
          calendarInterface.focusDate(date);
          break;

        case keyCodes.left:
          preventDefaultAndStopPropagation(event);
          date.setDate(date.getDate() - 1);
          calendarInterface.focusDate(date);
          break;

        case keyCodes.enter:
        case keyCodes.space:
          preventDefaultAndStopPropagation(event);
          calendarInterface.selectDate(tdElement);
          break;

        case keyCodes.pageup:
          preventDefaultAndStopPropagation(event);

          if (event.altKey) {
            date.setFullYear(date.getFullYear() - 1);
          } else {
            date.setMonth(date.getMonth() - 1);
          }

          calendarInterface.focusDate(date);
          break;

        case keyCodes.pagedown:
          preventDefaultAndStopPropagation(event);

          if (event.altKey) {
            date.setFullYear(date.getFullYear() + 1);
          } else {
            date.setMonth(date.getMonth() + 1);
          }

          calendarInterface.focusDate(date);
          break;

        case keyCodes.home:
          // eslint-disable-line no-case-declarations
          preventDefaultAndStopPropagation(event);
          const startOfWeek = calendarInterface.getStartOfWeek(date);
          calendarInterface.focusDate(startOfWeek);
          break;

        case keyCodes.end:
          // eslint-disable-line no-case-declarations
          preventDefaultAndStopPropagation(event);
          const endOfWeek = calendarInterface.getStartOfWeek(date);
          endOfWeek.setDate(endOfWeek.getDate() + 6);
          calendarInterface.focusDate(endOfWeek);
          break;

        default:
      }
    }
    function handleKeyDownOnToday(event, calendarInterface) {
      switch (event.keyCode) {
        case keyCodes.tab:
          if (!event.shiftKey) {
            preventDefaultAndStopPropagation(event);
            calendarInterface.focusFirstFocusableElement();
          }

          break;

        default:
      }
    }
    function handleKeyDownOnPreviousMonthNav(event, calendarInterface) {
      switch (event.keyCode) {
        case keyCodes.tab:
          if (event.shiftKey) {
            preventDefaultAndStopPropagation(event);
            calendarInterface.focusLastFocusableElement();
          }

          break;

        default:
      }
    }

    function preventDefaultAndStopPropagation(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    // This is a library built from Globalization's repo
    // https://git.soma.salesforce.com/Globalization/address.js
    // For new versions, copy AddressFormat.js from node_modules/address.js/dist/AddressFormat.js
    // And add "export { address };" at the end.

    /* eslint-disable */
    var data = {
      AE: {
        fmt: '%A%n%S%n%K',
        require: 'AS',
        input: 'ASK'
      },
      AL: {
        fmt: '%A%n%Z%n%C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      EC: {
        _ref: 'AL'
      },
      MU: {
        _ref: 'AL'
      },
      OM: {
        _ref: 'AL'
      },
      AM: {
        fmt: '%A%n%Z%n%C%n%S%n%K',
        require: 'AZCS',
        input: 'AZK'
      },
      AR: {
        fmt: '%A%n%Z %C%n%S%n%K',
        require: 'AZCS',
        input: 'AZCSK'
      },
      CL: {
        _ref: 'AR'
      },
      CV: {
        _ref: 'AR'
      },
      MY: {
        _ref: 'AR'
      },
      UZ: {
        _ref: 'AR'
      },
      AT: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      BA: {
        _ref: 'AT'
      },
      BG: {
        _ref: 'AT'
      },
      CH: {
        _ref: 'AT'
      },
      DE: {
        _ref: 'AT'
      },
      DK: {
        _ref: 'AT'
      },
      DO: {
        _ref: 'AT'
      },
      DZ: {
        _ref: 'AT'
      },
      EE: {
        _ref: 'AT'
      },
      ET: {
        _ref: 'AT'
      },
      FR: {
        _ref: 'AT'
      },
      GE: {
        _ref: 'AT'
      },
      GR: {
        _ref: 'AT'
      },
      IL: {
        _ref: 'AT'
      },
      KW: {
        _ref: 'AT'
      },
      LA: {
        _ref: 'AT'
      },
      LR: {
        _ref: 'AT'
      },
      IS: {
        _ref: 'AT'
      },
      MA: {
        _ref: 'AT'
      },
      MG: {
        _ref: 'AT'
      },
      MK: {
        _ref: 'AT'
      },
      MZ: {
        _ref: 'AT'
      },
      NL: {
        _ref: 'AT'
      },
      NO: {
        _ref: 'AT'
      },
      PL: {
        _ref: 'AT'
      },
      PT: {
        _ref: 'AT'
      },
      PY: {
        _ref: 'AT'
      },
      RO: {
        _ref: 'AT'
      },
      RS: {
        _ref: 'AT'
      },
      SK: {
        _ref: 'AT'
      },
      TJ: {
        _ref: 'AT'
      },
      TN: {
        _ref: 'AT'
      },
      TZ: {
        _ref: 'AT'
      },
      WF: {
        _ref: 'AT'
      },
      AU: {
        fmt: '%A%n%C %S %Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      CA: {
        _ref: 'AU'
      },
      AZ: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      AF: {
        fmt: '%A%n%C%n%Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      FK: {
        _ref: 'AF'
      },
      GB: {
        fmt: '%A%n%C%n%Z%n%S%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      KE: {
        _ref: 'AF'
      },
      LK: {
        _ref: 'AF'
      },
      ZA: {
        _ref: 'AF'
      },
      SH: {
        _ref: 'AF'
      },
      SZ: {
        _ref: 'AF'
      },
      US: {
        fmt: '%A%n%C, %S %Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      BB: {
        _ref: 'US'
      },
      BS: {
        _ref: 'US'
      },
      SO: {
        _ref: 'US'
      },
      ES: {
        fmt: '%A%n%Z %C %S%n%K',
        require: 'AZCS',
        input: 'AZCSK'
      },
      IT: {
        _ref: 'ES'
      },
      UY: {
        _ref: 'ES'
      },
      ID: {
        fmt: '%A%n%C%n%S %Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      IE: {
        _ref: 'ID'
      },
      TH: {
        _ref: 'ID'
      },
      VN: {
        _ref: 'ID'
      },
      HU: {
        fmt: '%C%n%A%n%Z%n%K',
        require: 'CAZ',
        input: 'CAZK'
      },
      BH: {
        fmt: '%A%n%C %Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      BM: {
        _ref: 'BH'
      },
      BN: {
        _ref: 'BH'
      },
      BT: {
        _ref: 'BH'
      },
      KH: {
        _ref: 'BH'
      },
      LB: {
        _ref: 'BH'
      },
      JO: {
        _ref: 'BH'
      },
      MT: {
        _ref: 'BH'
      },
      NP: {
        _ref: 'BH'
      },
      NZ: {
        _ref: 'BH'
      },
      SA: {
        _ref: 'BH'
      },
      BD: {
        fmt: '%A%n%C - %Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      BR: {
        fmt: '%A%n%C-%S%n%Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      CN: {
        fmt: '%K%n%S %C%n%A%n%Z',
        require: 'CAZ',
        input: 'KSCAZ'
      },
      HK: {
        fmt: '%K%C%n%A%n',
        require: 'CA',
        input: 'KCA'
      },
      CO: {
        fmt: '%A%n%C, %S, %Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      CR: {
        fmt: '%A%n%S, %C%n%Z%n%K',
        require: 'ACSZ',
        input: 'ASCZK'
      },
      EG: {
        fmt: '%A%n%C%n%S%n%Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      RU: {
        _ref: 'EG'
      },
      UA: {
        _ref: 'EG'
      },
      FI: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      GT: {
        fmt: '%A%n%Z-%C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      HN: {
        fmt: '%A%n%C, %S%n%Z%n%K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      IQ: {
        _ref: 'HN'
      },
      HR: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      HT: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      IN: {
        fmt: '%A%n%C %Z%n%S%n%K',
        require: 'ACZS',
        input: 'ACZSK'
      },
      NG: {
        _ref: 'IN'
      },
      PE: {
        _ref: 'IN'
      },
      IR: {
        fmt: '%S%n%C%n%A%n%Z%n%K',
        require: 'SCAZ',
        input: 'SCAZK'
      },
      JM: {
        fmt: '%A%n%C%n%S%n%K',
        require: 'ACS',
        input: 'ACSK'
      },
      PA: {
        _ref: 'JM'
      },
      SC: {
        _ref: 'JM'
      },
      SR: {
        _ref: 'JM'
      },
      JP: {
        fmt: '%K%n' + String.fromCharCode(12306) + '%Z%n%S %C%n%A',
        require: 'ZCA',
        input: 'KZSCA'
      },
      EN_JP: {
        fmt: '%A%n%C %S%n%Z %K',
        require: 'ACSZ',
        input: 'ACSZK'
      },
      KG: {
        fmt: '%Z %C%n%A%n%S%n%K',
        require: 'ZCA',
        input: 'ZCAK'
      },
      KR: {
        fmt: '%S %C%n%A%n%Z%n%K',
        require: 'SCAZ',
        input: 'SCAZK'
      },
      KY: {
        fmt: '%A%n%S %Z%n%K',
        require: 'ASZ',
        input: 'ASZK'
      },
      KZ: {
        fmt: '%Z%n%S%n%C%n%A%n%K',
        require: 'ZSCA',
        input: 'ZSCAK'
      },
      LT: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      LV: {
        fmt: '%A%n%C, %Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      MM: {
        _ref: 'LV'
      },
      MC: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      MD: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      MW: {
        fmt: '%A%n%C%n%K',
        require: 'AC',
        input: 'ACK'
      },
      MX: {
        fmt: '%A%n%Z %C, %S%n%K',
        require: 'AZCS',
        input: 'AZCSK'
      },
      NI: {
        fmt: '%A%n%Z%n%C, %S%n%K',
        require: 'AZCS',
        input: 'AZCSK'
      },
      PG: {
        fmt: '%A%n%C %Z %S%n%K',
        require: 'ACZS',
        input: 'ACZSK'
      },
      PH: {
        fmt: '%A, %C%n%Z %S%n%K',
        require: 'ACZS',
        input: 'ACZSK'
      },
      PK: {
        fmt: '%A%n%C-%Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      PR: {
        fmt: '%A%n%C %Z%n%K',
        require: 'ACZ',
        input: 'ACZK'
      },
      SE: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      SG: {
        fmt: '%A%n%C %Z%n%S%n%K',
        require: 'AZ',
        input: 'AZK'
      },
      SI: {
        fmt: '%A%n%Z %C%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      SV: {
        fmt: '%A%n%Z-%C%n%S%n%K',
        require: 'AZCS',
        input: 'AZCSK'
      },
      TR: {
        fmt: '%A%n%Z %C/%S%n%K',
        require: 'AZC',
        input: 'AZCK'
      },
      TW: {
        fmt: '%K%n%Z%n%S %C%n%A',
        require: 'ZSCA',
        input: 'KZSCA'
      },
      VE: {
        fmt: '%A%n%C %Z, %S%n%K',
        require: 'ACZS',
        input: 'ACZSK'
      }
    };
    var languageCodeToCountry = {
      languageCode: {
        ar: 'AE',
        bg: 'BG',
        bn: 'BN',
        bs: 'BA',
        ca: 'ES',
        cs: 'CZ',
        cy: 'GB',
        da: 'DK',
        de: 'DE',
        el: 'GR',
        es: 'ES',
        et: 'ET',
        eu: 'ES',
        fi: 'FI',
        fr: 'FR',
        ga: 'IE',
        hi: 'HI',
        hr: 'HR',
        hu: 'HU',
        hy: 'HY',
        in: 'ID',
        is: 'IS',
        it: 'IT',
        iw: 'IL',
        ja: 'JP',
        ka: 'GE',
        ko: 'KR',
        lb: 'LU',
        lt: 'IT',
        lv: 'LV',
        mk: 'MK',
        ms: 'MY',
        mt: 'MT',
        nl: 'NL',
        no: 'NO',
        pl: 'PL',
        pt: 'PT',
        rm: 'DE',
        ro: 'RO',
        ru: 'RU',
        sh: 'BA',
        sk: 'SK',
        sl: 'SL',
        sq: 'SQ',
        sr: 'RS',
        sv: 'SE',
        ta: 'TA',
        th: 'TH',
        tl: 'PH',
        tr: 'TR',
        uk: 'UK',
        ur: 'UR',
        vi: 'VN',
        zh: 'CN'
      }
    };
    /**
     * Define address format patterns.
     */

    var AddressFormatPattern = Object.freeze({
      /**
       *
       * N: Name (The formatting of names for this field is outside of the scope of the address elements.)
       * O: Organization
       * A: Address Lines (2 or 3 lines address)
       * D: District (Sub-locality): smaller than a city, and could be a neighborhood, suburb or dependent locality.
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * X: Sorting code, for example, CEDEX as used in France
       * n: newline
       */
      A: Symbol('Address Lines'),
      C: Symbol('City'),
      S: Symbol('State'),
      K: Symbol('Country'),
      Z: Symbol('Zip Code'),
      n: Symbol('New Line'),
      fromPlaceHolder: function fromPlaceHolder(placeHolder) {
        switch (placeHolder) {
          case 'A':
            return AddressFormatPattern.A;

          case 'C':
            return AddressFormatPattern.C;

          case 'S':
            return AddressFormatPattern.S;

          case 'K':
            return AddressFormatPattern.K;

          case 'Z':
            return AddressFormatPattern.Z;

          case 'n':
            return AddressFormatPattern.n;
        }

        return null;
      },
      getPlaceHolder: function getPlaceHolder(pattern) {
        switch (pattern) {
          case AddressFormatPattern.A:
            return 'A';

          case AddressFormatPattern.C:
            return 'C';

          case AddressFormatPattern.S:
            return 'S';

          case AddressFormatPattern.K:
            return 'K';

          case AddressFormatPattern.Z:
            return 'Z';

          case AddressFormatPattern.n:
            return 'n';
        }

        return null;
      },
      getData: function getData(pattern, data) {
        if (data) {
          switch (pattern) {
            case AddressFormatPattern.A:
              return data.address;

            case AddressFormatPattern.C:
              return data.city;

            case AddressFormatPattern.S:
              return data.state;

            case AddressFormatPattern.K:
              return data.country;

            case AddressFormatPattern.Z:
              return data.zipCode;

            case AddressFormatPattern.n:
              return data.newLine;
          }
        }

        return null;
      }
    });

    var classCallCheck = function (instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    };

    var createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ('value' in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();
    /**
     * Address token types enum
     *
     * @private
     */


    var AddressTokenTypes = Object.freeze({
      DATA: Symbol('data'),
      STRING: Symbol('string'),
      NEWLINE: Symbol('newline'),
      GROUP: Symbol('group')
    });
    /**
     * AddressToken class
     *
     * @private
     */

    var AddressToken = function () {
      /**
       *
       * @param {AddressTokenTypes} type
       * @param {string} string
       * @param {*} pattern
       */
      function AddressToken(type, string, pattern) {
        classCallCheck(this, AddressToken);
        this.type = type;
        this.string = string;
        this.pattern = pattern;
      }
      /**
       * Construct a string type token
       *
       * @param {string} string String
       * @return {AddressToken} Address Token
       */


      createClass(AddressToken, null, [{
        key: 'string',
        value: function string(_string) {
          return new AddressToken(AddressTokenTypes.STRING, _string);
        }
        /**
         * Construct a data type token
         *
         * @param {pattern} pattern Address Format Pattern
         * @return {AddressToken} Address Token
         */

      }, {
        key: 'data',
        value: function data(pattern) {
          return new AddressToken(AddressTokenTypes.DATA, undefined, pattern);
        }
        /**
         * Construct a new line type token
         *
         * @return {AddressToken} Address Token
         */

      }, {
        key: 'newLine',
        value: function newLine() {
          return new AddressToken(AddressTokenTypes.NEWLINE);
        }
      }]);
      return AddressToken;
    }();
    /**
     * TokenizerState class
     *
     * @private
     */


    var TokenizerState =
    /**
     * Constructor
     *
     * @param {string} pattern
     * @param {int} start
     */
    function TokenizerState(pattern, start) {
      classCallCheck(this, TokenizerState);
      this.pattern = pattern;
      this.start = start;
    };
    /**
     * Tokenize string pattern to AddressToken array
     *
     * @param {TokenizerState} state
     * @param {AddressToken[]} tokens
     * @return {TokenizerState} Tokenizer state
     *
     * @private
     */


    function tokenize(state, tokens) {
      var nextIndex = state.start;

      if (state.pattern) {
        var len = state.pattern.length;

        while (state.start < len) {
          nextIndex = state.pattern.indexOf('%', nextIndex);

          if (nextIndex >= 0 && nextIndex + 1 < len) {
            var placeHolder = state.pattern.substring(nextIndex + 1, nextIndex + 2);

            switch (placeHolder) {
              case 'n':
                {
                  if (nextIndex - state.start > 0) {
                    tokens.push(AddressToken.string(state.pattern.substring(state.start, nextIndex)));
                  }

                  tokens.push(AddressToken.newLine());
                  state.start = nextIndex + 2;
                  nextIndex = state.start;
                  break;
                }

              default:
                {
                  var p = AddressFormatPattern.fromPlaceHolder(placeHolder);

                  if (p) {
                    if (nextIndex - state.start > 0) {
                      tokens.push(AddressToken.string(state.pattern.substring(state.start, nextIndex)));
                    }

                    tokens.push(AddressToken.data(p));
                    state.start = nextIndex + 2;
                    nextIndex = state.start;
                  } else {
                    state.start = nextIndex + 2;
                    nextIndex = state.start;
                  }

                  break;
                }
            }
          } else {
            if (state.start < len) {
              tokens.push(AddressToken.string(state.pattern.substring(state.start)));
            }

            state.start = len;
          }
        }
      }

      return state;
    }
    /**
     * Format line from tokens
     *
     * @param {*} tokens
     * @param {*} data
     * @param {*} ignoreEmptyLines
     * @param {*} firstIndex
     * @param {*} lastIndex
     * @return {string} Formatted line
     *
     * @private
     */


    function formatLineTokens(tokens, data, ignoreEmptyLines, firstIndex, lastIndex) {
      var parts = [];

      for (var index = firstIndex; index <= lastIndex; index++) {
        var token = tokens[index];

        if (!token) {
          continue;
        } else if (token.type == AddressTokenTypes.DATA) {
          // Consume all subsequent data if available
          var dataBuffer = '';
          var lastDataIndex = index;

          for (var dataIndex = index; dataIndex <= lastIndex; dataIndex++) {
            var dataToken = tokens[dataIndex];

            if (!dataToken || dataToken.type != AddressTokenTypes.DATA) {
              break;
            }

            var fieldData = AddressFormatPattern.getData(dataToken.pattern, data);

            if (fieldData) {
              dataBuffer += fieldData;
              lastDataIndex = dataIndex;
            }
          }

          var hasData = dataBuffer && dataBuffer.length > 0; // Output previous string only if there is data before it,
          // or if it is the first on the line

          var hasPreviousData = false;

          if (index - 1 >= firstIndex) {
            var stringToken = tokens[index - 1];

            if (stringToken && stringToken.type == AddressTokenTypes.STRING && stringToken.string) {
              for (var prevIndex = index - 2; prevIndex >= firstIndex; prevIndex--) {
                var prevToken = tokens[prevIndex];

                if (prevToken && prevToken.type == AddressTokenTypes.DATA) {
                  var _fieldData = AddressFormatPattern.getData(prevToken.pattern, data);

                  if (_fieldData) {
                    hasPreviousData = true;
                    break;
                  }
                } else if (prevToken && prevToken.type == AddressTokenTypes.STRING) {
                  // ie. for "%C, %S %Z" without S -> "City, 95100"
                  // Comment this if we want "City 95100" instead
                  // (use the separator between S Z instead of C S)
                  stringToken = prevToken;
                }
              }

              if (!ignoreEmptyLines || hasPreviousData && hasData || index - 1 == firstIndex && hasData) {
                parts.push(stringToken.string);
              }
            }
          }

          if (hasData) {
            parts.push(dataBuffer);
          }

          index = lastDataIndex; // Output next string only if it is the last
          // and there is previous data before it

          if (index + 1 == lastIndex) {
            var _stringToken = tokens[index + 1];

            if (_stringToken && _stringToken.type == AddressTokenTypes.STRING && _stringToken.string) {
              if (!ignoreEmptyLines || hasData || hasPreviousData) {
                parts.push(_stringToken.string);
              }
            } // Consume the last string token


            index = index + 1;
          }
        }
      }

      return parts.join('').trim();
    }
    /**
     * Tokenize address format pattern.
     *
     * @param {AddressToken[]} tokens
     * @param {*} data
     * @param {string} lineBreak
     * @param {boolean} ignoreEmptyLines
     * @return {string} Formatted Address
     *
     * @private
     */


    function formatTokens(tokens, data, lineBreak, ignoreEmptyLines) {
      var lines = [];
      var lineIndex = -1;

      for (var index = 0; index < tokens.length; index++) {
        var doFormat = false;
        var endWithNewLine = false;
        var token = tokens[index];

        switch (token.type) {
          case AddressTokenTypes.NEWLINE:
            {
              if (lineIndex >= 0) {
                doFormat = true;
                endWithNewLine = true;
              } else if (!ignoreEmptyLines) {
                lines.push(''); // Empty line
                // If the pattern ends with a newline

                if (index + 1 == tokens.length) {
                  lines.push(''); // Empty line
                }
              }

              break;
            }

          default:
            {
              lineIndex = lineIndex < 0 ? index : lineIndex;
              doFormat = index + 1 == tokens.length ? true : doFormat;
              break;
            }
        }

        if (doFormat) {
          var line = formatLineTokens(tokens, data, ignoreEmptyLines, lineIndex, endWithNewLine ? index - 1 : index);

          if (!ignoreEmptyLines || line) {
            lines.push(line);
          } // If line ends with a newline, and it is the last line on pattern


          if (!ignoreEmptyLines && endWithNewLine && index + 1 == tokens.length) {
            lines.push('');
          }

          lineIndex = -1;
        }
      }

      return lines.join(lineBreak);
    }
    /**
     * Format address data.
     *
     * @param {*} data Address data being processed.
     * @param {string} pattern Address format pattern.
     * @param {string} lineBreak Line break string to use
     * @param {boolean} ignoreEmptyLines Ignore lines that has no or empty data to replace.
     * @return {string} Formatted address.
     */


    function format(data, pattern, lineBreak, ignoreEmptyLines) {
      // TODO: support escapeHtml to match Java class feature parity
      ignoreEmptyLines = ignoreEmptyLines === false ? false : true; // Defaults to false

      lineBreak = lineBreak || '\n'; // Defaults to <br/> or lf

      var tokens = [];
      tokenize(new TokenizerState(pattern, 0), tokens);
      return formatTokens(tokens, data, lineBreak, ignoreEmptyLines);
    }

    var addressFormatter = {
      format: format
    };
    var CJK_COUNTRIES = ['CN', 'HK', 'TW', 'JP', 'KR', 'KP'];
    var CJK_LANGUAGES = ['zh', 'ja', 'ko'];
    var address = {
      /**
       * Gets the globalization for the specified country code.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {{fmt: string, input: string, require: string}} Format Data
       */
      getAddressInfoForCountry: function getAddressInfoForCountry(langCode, countryCode) {
        var code = this.getCountryFromLocale(langCode, countryCode);

        if (data[code]) {
          // Double check.
          var cloneAddressRep = Object.freeze(Object.assign({}, data[code]));
          return Object.freeze({
            address: cloneAddressRep
          });
        }

        return {};
      },

      /**
       * Get the format pattern.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {string} Address Format Pattern
       */
      getAddressFormat: function getAddressFormat(langCode, countryCode) {
        var code = this.getCountryFromLocale(langCode, countryCode);

        if (data[code]) {
          // Double check.
          return data[code].fmt;
        }

        return '';
      },

      /**
       * Get the input order pattern.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {string} Input Order
       */
      getAddressInputOrder: function getAddressInputOrder(langCode, countryCode) {
        var code = this.getCountryFromLocale(langCode, countryCode);

        if (data[code]) {
          // Double check.
          return data[code].input;
        }

        return '';
      },

      /**
       * Get the input order pattern for all fields.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {string} Input Order
       */
      getAddressInputOrderAllField: function getAddressInputOrderAllField(langCode, countryCode) {
        var code = this.getCountryFromLocale(langCode, countryCode);

        if (data[code]) {
          // Double check.
          var input = data[code].input; // Add missing patterns.

          if (input.indexOf('S') === -1) {
            input = input.replace('K', 'SK');
          }

          if (input.indexOf('C') === -1) {
            input = input.replace('S', 'CS');
          }

          if (input.indexOf('Z') === -1) {
            input = input.replace('C', 'ZC');
          }

          return input;
        }

        return '';
      },

      /**
       * Get required fields.
       * A: Address Lines (2 or 3 lines address)
       * C: City (Locality)
       * S: State (Administrative Area)
       * K: Country
       * Z: ZIP Code / Postal Code
       * n: newline
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @return {string} Required Fields
       */
      getAddressRequireFields: function getAddressRequireFields(langCode, countryCode) {
        var code = this.getCountryFromLocale(langCode, countryCode);

        if (data[code]) {
          // Double check.
          return data[code].require;
        }

        return '';
      },

      /**
       * Format a address values for given language code and country code with specified line break.
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @param {{address: string, country: string, city: string, state: string, zipCode: string}} values Actual Address Data
       * @param {string} lineBreak Line Break
       * @return {string} Formatted Address
       */
      formatAddressAllFields: function formatAddressAllFields(langCode, countryCode, values, lineBreak) {
        var code = this.getCountryFromLocale(langCode, countryCode, values);

        if (data[code]) {
          // Double check.
          var pattern = data[code].fmt; // Some countries don't have City, State or ZIP code. We don't want to
          // lose those data from formatted string.

          if (values.zipCode && pattern.indexOf('%Z') === -1) {
            pattern = pattern.replace('%K', '%Z %K');
          }

          if (values.city && pattern.indexOf('%C') === -1) {
            pattern = pattern.replace('%K', '%C %K');
          }

          if (values.state && pattern.indexOf('%S') === -1) {
            pattern = pattern.replace('%K', '%S %K');
          }

          return this.buildAddressLines(pattern, values, lineBreak, true);
        }

        return '';
      },

      /**
       * Format a address values for given language code and country code with specified line break.
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @param {{address: string, country: string, city: string, state: string, zipCode: string}} values Actual Address Data
       * @param {string} lineBreak Line Break
       * @return {string} Formatted Address
       */
      formatAddress: function formatAddress(langCode, countryCode, values, lineBreak) {
        var code = this.getCountryFromLocale(langCode, countryCode, values);

        if (data[code]) {
          // Double check.
          return this.buildAddressLines(data[code].fmt, values, lineBreak, true);
        }

        return '';
      },

      /**
       * Creates an array of address lines given the format and the values to use.
       *
       * @param {string} pattern
       * @param {{address: string, country: string, city: string, state: string, zipCode: string}} values
       * @param {string} lineBreak
       * @param {string} ignoreEmptyLines
       * @return {string} the text for use in the address
       */
      buildAddressLines: function buildAddressLines(pattern, values, lineBreak, ignoreEmptyLines) {
        return addressFormatter.format(values, pattern, lineBreak, ignoreEmptyLines);
      },

      /**
       * Resolve the reference by tracing down the _ref value.
       * @param {*} data Address Format Data
       * @param {string} countryCode Country Code
       * @return {*} Referenced Address Format Data
       */
      followReferences: function followReferences(data$$1, countryCode) {
        if (data$$1[countryCode] && data$$1[countryCode]._ref) {
          return this.followReferences(data$$1, data$$1[countryCode]._ref);
        }

        return countryCode;
      },

      /**
       * Check strings for Han characters
       *
       * @param {...string} values String values to check against
       * @return {boolean} true if any of string values contain Han script character
       */
      containsHanScript: function containsHanScript() {
        for (var _len = arguments.length, values = Array(_len), _key = 0; _key < _len; _key++) {
          values[_key] = arguments[_key];
        }

        if (!values || !Array.isArray(values)) return false;
        return values.some(function (value) {
          if (!value) return false; // Javascript regex do not work with surrogate pairs so String#match is unusable with supplemental ranges.
          // Iterating a string returns a char that contains one codepoint.
          // Surrogate pairs will be returned as a pair.
          // Unicode block ranges: @see http://www.unicode.org/Public/UCD/latest/ucd/Blocks.txt

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var singleChar = _step.value;
              var codePoint = singleChar.codePointAt(0); // Thank you ES2015

              if (0x2e80 <= codePoint && codePoint <= 0x2eff || // CJK Radicals Supplement
              0x3300 <= codePoint && codePoint <= 0x33ff || // CJK Compatibility
              0xfe30 <= codePoint && codePoint <= 0xfe4f || // CJK Compatibility Forms
              0xf900 <= codePoint && codePoint <= 0xfaff || // CJK Compatibility Ideographs
              0x2f800 <= codePoint && codePoint <= 0x2fa1f || // CJK Compatibility Ideographs Supplement
              0x3000 <= codePoint && codePoint <= 0x303f || // CJK Symbols and Punctuation
              0x4e00 <= codePoint && codePoint <= 0x9fff || // CJK Unified Ideographs
              0x3400 <= codePoint && codePoint <= 0x4dbf || // CJK Unified Ideographs Extension A
              0x20000 <= codePoint && codePoint <= 0x2a6df || // CJK Unified Ideographs Extension B
              0x2a700 <= codePoint && codePoint <= 0x2b73f || // CJK Unified Ideographs Extension C
              0x2b740 <= codePoint && codePoint <= 0x2b81f || // CJK Unified Ideographs Extension D
              0x2b820 <= codePoint && codePoint <= 0x2ceaf || // CJK Unified Ideographs Extension E // Not on core
              0x2ceb0 <= codePoint && codePoint <= 0x2ebef || // CJK Unified Ideographs Extension F // Not on core
              0x3200 <= codePoint && codePoint <= 0x32ff || // Enclosed CJK Letters and Months
              0x31c0 <= codePoint && codePoint <= 0x31ef || // CJK Strokes
              // Chinese
              0x3100 <= codePoint && codePoint <= 0x312f || // Bopomofo
              0x31a0 <= codePoint && codePoint <= 0x31bf || // Bopomofo Extended
              0x2f00 <= codePoint && codePoint <= 0x2fdf || // Kangxi Radicals
              0x2ff0 <= codePoint && codePoint <= 0x2fff || // Ideographic Description Characters
              // Japanese
              0xff00 <= codePoint && codePoint <= 0xffef || // Halfwidth and Fullwidth Forms
              0x3040 <= codePoint && codePoint <= 0x309f || // Hiragana
              0x30a0 <= codePoint && codePoint <= 0x30ff || // Katakana
              0x31f0 <= codePoint && codePoint <= 0x31ff || // Katakana Phonetic Extensions
              0x1b000 <= codePoint && codePoint <= 0x1b0ff || // Kana Supplement
              0x1b100 <= codePoint && codePoint <= 0x1b12f || // Kana Extended-A // Not on core
              // Korean
              0x1100 <= codePoint && codePoint <= 0x11ff || // Hangul Jamo
              0xac00 <= codePoint && codePoint <= 0xd7af || // Hangul Syllables
              0x3130 <= codePoint && codePoint <= 0x318f || // Hangul Compatibility Jamo
              0xa960 <= codePoint && codePoint <= 0xa97f || // Hangul Jamo Extended-A
              0xd7b0 <= codePoint && codePoint <= 0xd7ff // Hangul Jamo Extended-B
              ) {
                  return true;
                }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return false;
        });
      },

      /**
       * Returns the address code (country code) for given locale and data.
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @param {*} values Address Data
       * @return {string} Address Code
       */
      getCountryFromLocale: function getCountryFromLocale(langCode, countryCode, values) {
        if (values) {
          var isCJK = !countryCode && CJK_LANGUAGES.indexOf(langCode.toLowerCase()) >= 0 || countryCode && CJK_COUNTRIES.indexOf(countryCode.toUpperCase()) >= 0;
          var isJA = !countryCode && 'ja' == langCode.toLowerCase() || countryCode && 'JP' == countryCode.toUpperCase(); // English format (ja_en_JP) is only used when all fields do not contain CJK characters

          if (!(isJA && this.containsHanScript(values.address, values.city, values.state, values.country)) && isCJK && !this.containsHanScript(values.address)) {
            return this.getCountryFromLocale(langCode, 'EN_' + countryCode);
          }
        }

        var country = countryCode; // Address format should be always associated to a COUNTRY.
        // If country part is empty, we need to map language to a
        // certain country. For example, "de" -> "DE".

        if (!countryCode && languageCodeToCountry.languageCode[langCode]) {
          country = languageCodeToCountry.languageCode[langCode];
        } // Trace the real data from country reference.


        country = this.followReferences(data, country);

        if (!country || !data[country]) {
          return 'US'; // Always fall back to US format.
        }

        return country;
      },

      /**
       * Get fall back country code.
       *
       * @param {string} langCode Language Code
       * @param {string} countryCode Country Code
       * @param {*} address Address Data
       * @return {string} Address Code
       *
       * @deprecated Use getCountryFromLocale instead
       */
      getFallback: function getFallback(langCode, countryCode, address) {
        return this.getCountryFromLocale(langCode, countryCode);
      }
    };

    // This is a library built from Globalization's repo
    // https://git.soma.salesforce.com/Globalization/name.js
    // This will be added/updated through a build process in the future

    /* eslint-disable */
    var data$1 = {
      DEFAULT: {
        short_f: '%F %L',
        medium_f: '%F %M %L',
        long_f: '%S %F %M %L %X %I',
        input: 'SFMLXI'
      },
      vi: {
        short_f: '%L %F',
        medium_f: '%L %M %F',
        long_f: '%L %M %F %X %I',
        input: 'SLFMXI'
      },
      vi_VN: {
        _ref: 'vi'
      },
      hu: {
        short_f: '%L %F',
        medium_f: '%L %F',
        long_f: '%L %F %M %X %I',
        input: 'SLFMXI'
      },
      hu_HU: {
        _ref: 'hu'
      },
      ja: {
        short_f: '%L %F',
        medium_f: '%L %M %F',
        long_f: '%L %M %F %X %I',
        input: 'SLMFXI'
      },
      ja_JP: {
        _ref: 'ja'
      },
      ko: {
        _ref: 'ja'
      },
      ko_KR: {
        _ref: 'ja'
      },
      zh: {
        _ref: 'ja'
      },
      zh_CN: {
        _ref: 'ja'
      },
      zh_CN_PINYIN: {
        _ref: 'ja'
      },
      zh_CN_STROKE: {
        _ref: 'ja'
      },
      zh_HK: {
        _ref: 'ja'
      },
      zh_HK_STROKE: {
        _ref: 'ja'
      },
      zh_MO: {
        _ref: 'ja'
      },
      zh_SG: {
        _ref: 'ja'
      },
      zh_TW: {
        _ref: 'ja'
      },
      zh_TW_STROKE: {
        _ref: 'ja'
      }
    }; // Define all available fields.

    /**
     S: Salutation
     F: First Name(givenName)
     M: Middle Name
     L: Last Name(familyName)
     X: Suffix
     I: Informal Name
     */

    var fieldConstants = {
      SALUTATION: Symbol('Salutation'),
      FIRST: Symbol('First Name'),
      MIDDLE: Symbol('Middle Name'),
      LAST: Symbol('Last Name'),
      SUFFIX: Symbol('Suffix'),
      INFORMAL: Symbol('Informal Name')
    };

    var _createClass = function () {
      function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ('value' in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
      };
    }();

    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError('Cannot call a class as a function');
      }
    }

    var Format = function Format(parts) {
      _classCallCheck(this, Format);

      this.parts = Object.freeze(parts);
      Object.freeze(this);
    };
    /**
     * Represents a field within the format
     */


    var FieldFormatPart = function FieldFormatPart(field) {
      _classCallCheck(this, FieldFormatPart);

      this.field = field;
      this.type = 'field';
      Object.freeze(this);
    };
    /**
     * Represents text to be output directly
     */


    var TextFormatPart = function TextFormatPart(text) {
      _classCallCheck(this, TextFormatPart);

      this.type = 'text';
      this.text = text;
      Object.freeze(this);
    };

    var fieldFormatParts = Object.freeze({
      SALUTATION: new FieldFormatPart(fieldConstants.SALUTATION),
      FIRST: new FieldFormatPart(fieldConstants.FIRST),
      MIDDLE: new FieldFormatPart(fieldConstants.MIDDLE),
      LAST: new FieldFormatPart(fieldConstants.LAST),
      SUFFIX: new FieldFormatPart(fieldConstants.SUFFIX),
      INFORMAL: new FieldFormatPart(fieldConstants.INFORMAL)
    });

    var FormatParser = function () {
      function FormatParser() {
        _classCallCheck(this, FormatParser);
      }

      _createClass(FormatParser, [{
        key: 'parse',

        /**
         * Parses the format
         * @param {string} fmt the format to be parsed
         * @returns {Format}
         */
        value: function parse(fmt) {
          var nodes = [];
          var textBuffer = ''; // parse the format string

          for (var i = 0; i < fmt.length; i = i + 1) {
            if (fmt[i] === '%') {
              i = i + 1; // move to the next character after %
              // end the last text buffer

              if (textBuffer.length > 0) {
                nodes.push(Object.freeze(new TextFormatPart(textBuffer)));
                textBuffer = '';
              }

              if (i >= fmt.length) {
                throw new Error('Unexpected end of format. Symbol at ' + (i - 1) + ' should be followed by a valid field code');
              }

              var code = fmt[i];

              switch (code) {
                case 'S':
                  nodes.push(fieldFormatParts.SALUTATION);
                  break;

                case 'F':
                  nodes.push(fieldFormatParts.FIRST);
                  break;

                case 'M':
                  nodes.push(fieldFormatParts.MIDDLE);
                  break;

                case 'L':
                  nodes.push(fieldFormatParts.LAST);
                  break;

                case 'X':
                  nodes.push(fieldFormatParts.SUFFIX);
                  break;

                case 'I':
                  nodes.push(fieldFormatParts.INFORMAL);
                  break;

                default:
                  // TODO log the bad symbol and continue
                  break;
              }
            } else {
              // if it wasn't a symbol, then just output the value directly
              textBuffer += fmt[i];
            }
          }

          if (textBuffer.length > 0) {
            nodes.push(new TextFormatPart(textBuffer));
          }

          return new Format(nodes);
        }
      }]);

      return FormatParser;
    }();

    var formatParser = new FormatParser();
    var name = {
      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {{short: string, medium: string, long: string, input: string}} format data
       */
      getNameInfoForLocale: function getNameInfoForLocale(localeStr) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          var cloneNameInfo = Object.freeze(Object.assign({}, data$1[key]));
          return Object.freeze({
            name: cloneNameInfo
          });
        }
      },

      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {string} format pattern
       */
      getNameFormatPatternMedium: function getNameFormatPatternMedium(localeStr) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return data$1[key].medium_f;
        }
      },

      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {string} format pattern
       */
      getNameFormatPatternShort: function getNameFormatPatternShort(localeStr) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return data$1[key].short_f;
        }
      },

      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {string} format pattern
       */
      getNameFormatPatternLong: function getNameFormatPatternLong(localeStr) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return data$1[key].long_f;
        }
      },

      /**
       * S: Salutation
       * F: First Name(givenName)
       * M: Middle Name
       * L: Last Name(familyName)
       * X: Suffix
       * I: Informal Name
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @return {string} input order
       */
      getNameInputOrder: function getNameInputOrder(localeStr) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return data$1[key].input;
        }
      },

      /**
       * Format name values for given locale.
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @param {{first: string, middle: string, last: string, salutation: string, suffix: string, informal: string}} values
       * @returns {string} the formatted name
       */
      formatNameShort: function formatNameShort(localeStr, values) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return this.buildName(data$1[key].short_f, values);
        }
      },

      /**
       * Format name values for given locale.
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @param {{first: string, middle: string, last: string, salutation: string, suffix: string, informal: string}} values
       * @returns {string} the formatted name
       */
      formatNameMedium: function formatNameMedium(localeStr, values) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return this.buildName(data$1[key].medium_f, values);
        }
      },

      /**
       * Format name values for given locale.
       * @param {string} locale string, like zh_CN, zh_CN_PINYIN, or de.
       * @param {{first: string, middle: string, last: string, salutation: string, suffix: string, informal: string}} values
       * @returns {string} the formatted name
       */
      formatNameLong: function formatNameLong(localeStr, values) {
        var key = this.getFallback(localeStr);

        if (data$1[key]) {
          // Double check.
          return this.buildName(data$1[key].long_f, values);
        }
      },

      /**
       * Creates an array of address lines given the format and the values to use.
       * @param {string} pattern
       * @param @param {{first: string, middle: string, last: string, salutation: string, suffix: string, informal: string}} values
       * @returns {string} the text for use in the address
       */
      buildName: function buildName(pattern, values) {
        var format = formatParser.parse(pattern);
        var sb = [];

        for (var i = 0; i < format.parts.length; i++) {
          var part = format.parts[i];

          if (part.type === 'text') {
            sb.push(part.text);
          } else if (part.type === 'field') {
            if (part.field === fieldConstants.SALUTATION) {
              sb.push(values.salutation || '');
            } else if (part.field === fieldConstants.FIRST) {
              sb.push(values.first || '');
            } else if (part.field === fieldConstants.MIDDLE) {
              sb.push(values.middle || '');
            } else if (part.field === fieldConstants.LAST) {
              sb.push(values.last || '');
            } else if (part.field === fieldConstants.SUFFIX) {
              sb.push(values.suffix || '');
            } else if (part.field === fieldConstants.INFORMAL) {
              sb.push(values.informal || '');
            }
          }
        }

        return sb.join('').trim().replace(/  /g, ' ');
      },
      // Resolve the reference by tracing down the _ref value.
      followReferences: function followReferences(key) {
        if (data$1[key] && data$1[key]._ref) {
          return this.followReferences(data$1[key]._ref);
        }

        return key;
      },
      // Get fall back key.
      getFallback: function getFallback(localeStr) {
        // Resolve the reference.
        var key = this.followReferences(localeStr);

        if (!data$1[key]) {
          return 'DEFAULT'; // Always fall back to 'US'.
        }

        return key;
      }
    };

    // This returns the locale tag similar to the lwc @salesforce/i18n/locale and should be replaced once we switch to lwc GVPs
    // The aura locale GVPs are confusing, see the following doc for more details and their lwc equivalent:
    // See https://salesforce.quip.com/M9sPA9xFnRgv

    function getLocaleTag() {
      const localeLanguage = configProvider.getLocale().userLocaleLang; // e.g. 'en'

      const localeCountry = configProvider.getLocale().userLocaleCountry; // e.g. 'CA'

      if (!localeLanguage) {
        return configProvider.getLocale().langLocale.replace(/_/g, '-'); // e.g. 'en_US' -> 'en-US'
      } // should return a valid BCP47 tag


      return localeLanguage + (localeCountry ? '-' + localeCountry : '');
    }

    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/NumberFormat#Parameters

    const POSSIBLE_OPTS = {
      style: true,
      currency: true,
      currencyDisplay: true,
      useGrouping: true,
      minimumIntegerDigits: true,
      minimumFractionDigits: true,
      maximumFractionDigits: true,
      minimumSignificantDigits: true,
      maximumSignificantDigits: true
    };
    const STYLE = {
      DECIMAL: 'decimal',
      CURRENCY: 'currency',
      PERCENT: 'percent'
    };
    const CURRENCY_DISPLAY = {
      CODE: 'code',
      // USD
      SYMBOL: 'symbol',
      // $
      NAME: 'name' // US Dollars

    };
    const SAFE_NUM_LENGTH = 15;
    const numberFormatInstancesCache = {};

    function getStringOfChar(char, amount) {
      return new Array(amount + 1).join(char);
    }

    function getGroupingCount(skeleton) {
      const match = skeleton.match(/,[#0]*\./);
      return match ? match[0].length - 2 : 0;
    }

    function getOptionsUniqueKey$1(options) {
      return Object.keys(options).sort().reduce((prev, optionName) => {
        if (POSSIBLE_OPTS[optionName]) {
          return prev + optionName + options[optionName] + '';
        }

        return prev;
      }, '');
    }

    function toNumber(value, defaultValue) {
      const number = parseInt(value, 10);

      if (isNaN(number)) {
        return defaultValue;
      }

      return number;
    }

    function getFractionPart(options) {
      const minimumDigits = toNumber(options.minimumFractionDigits, 0);
      const maximumDigits = Math.max(toNumber(options.maximumFractionDigits, 0), minimumDigits);
      return '.' + new Array(minimumDigits + 1).join('0') + new Array(maximumDigits - minimumDigits + 1).join('#');
    }

    function updateFractionPart(skeleton, options) {
      const fractionPart = getFractionPart(options);
      return fractionPart ? skeleton.replace(/\.(0|#)*/, fractionPart) : skeleton;
    }

    function updateCurrencySymbol(skeleton, currencyCode, options) {
      const symbol = String.fromCharCode(164);

      if (options.currencyDisplay === CURRENCY_DISPLAY.NAME) {
        // append the currency code at the end.
        return skeleton.replace(symbol, '') + currencyCode;
      }

      return skeleton.replace(symbol, currencyCode);
    }

    function updateIntegerPart(skeleton, options) {
      const minimumIntegerDigits = options.minimumIntegerDigits;
      const groupingCount = getGroupingCount(skeleton);

      if (!minimumIntegerDigits) {
        return skeleton;
      }

      if (minimumIntegerDigits <= groupingCount) {
        return skeleton.replace(/,[#0]*\./, ',' + getStringOfChar('#', groupingCount - minimumIntegerDigits) + getStringOfChar('0', minimumIntegerDigits) + '.');
      }

      return skeleton.replace(/[#0]*\./, getStringOfChar('0', minimumIntegerDigits - groupingCount) + ',' + getStringOfChar('0', groupingCount) + '.');
    }

    function getBestMatchCurrencySymbol(code, currencyDisplay) {
      if (!('Intl' in window)) {
        return code; // fail gracefully.
      }

      const opts = {
        style: 'currency',
        currency: code,
        minimumFractionDigits: 0
      };

      if (currencyDisplay) {
        opts.currencyDisplay = currencyDisplay;
      }

      const nf = getFromCache(opts);
      return nf.format(2).replace(/2/g, '');
    }

    function getCurrency(options) {
      const currencyDisplay = options.currencyDisplay || CURRENCY_DISPLAY.SYMBOL;

      if (currencyDisplay === CURRENCY_DISPLAY.SYMBOL || currencyDisplay === CURRENCY_DISPLAY.NAME) {
        return getBestMatchCurrencySymbol(options.currency, currencyDisplay);
      }

      return options.currency;
    }

    function getFromCache(options) {
      const optionsUniqueKey = getOptionsUniqueKey$1(options);
      let numberFormatInstance = numberFormatInstancesCache[optionsUniqueKey];

      if (numberFormatInstance) {
        return numberFormatInstance;
      }

      numberFormatInstance = new Intl.NumberFormat(getLocaleTag(), options);
      numberFormatInstancesCache[optionsUniqueKey] = numberFormatInstance;
      return numberFormatInstance;
    }

    function exceedsSafeLength(value, maxFractionDigits) {
      const str = value.toString();
      const intPart = str.split('.')[0];
      return intPart.length + toNumber(maxFractionDigits, 0) >= SAFE_NUM_LENGTH;
    }

    function normalizedMinimumFractionDigits(options) {
      const fractionSkeleton = getFallbackFractionSkeleton(options.style);
      const fractionDigits = fractionSkeleton.replace(/[^0]/g, '');
      return fractionDigits.length;
    }

    function normalizedMaximumFractionDigits(options) {
      const fractionSkeleton = getFallbackFractionSkeleton(options.style);
      const fractionDigits = fractionSkeleton.replace(/[^0#]/g, '');
      return Math.max(options.minimumFractionDigits, fractionDigits.length);
    }

    function getFallbackFractionSkeleton(style) {
      const locale = configProvider.getLocale();
      let styleFormat = 'numberFormat';

      if (style === STYLE.CURRENCY) {
        styleFormat = 'currencyFormat';
      } else if (style === STYLE.PERCENT) {
        styleFormat = 'percentFormat';
      }

      const format = locale[styleFormat].split(';')[0];
      return format.split('.')[1] || '';
    }

    function normalizeOptions(options) {
      const locale = configProvider.getLocale();
      const normalizedOpts = Object.assign({}, options);
      normalizedOpts.currency = normalizedOpts.currency || locale.currencyCode;

      if (normalizedOpts.minimumFractionDigits === undefined) {
        normalizedOpts.minimumFractionDigits = normalizedMinimumFractionDigits(normalizedOpts);
      }

      if (normalizedOpts.maximumFractionDigits === undefined || normalizedOpts.maximumFractionDigits < normalizedOpts.minimumFractionDigits) {
        normalizedOpts.maximumFractionDigits = normalizedMaximumFractionDigits(normalizedOpts);
      }

      return normalizedOpts;
    }

    function NumberOptions(options) {
      this.locale = configProvider.getLocale();
      this.options = options || {};
    }

    NumberOptions.prototype.isCurrency = function () {
      return this.options.style === 'currency';
    };

    NumberOptions.prototype.isPercent = function () {
      return this.options.style === 'percent';
    };

    NumberOptions.prototype.isDefaultCurrency = function () {
      return !this.options.currency || this.locale.currencyCode === this.options.currency;
    };

    NumberOptions.prototype.getDefaultSkeleton = function () {
      return this.isCurrency() ? this.locale.currencyFormat : this.isPercent() ? this.locale.percentFormat : this.locale.numberFormat;
    };

    NumberOptions.prototype.getSkeleton = function () {
      const options = this.options;
      const defaultSkeleton = this.getDefaultSkeleton();
      let skeleton = updateFractionPart(defaultSkeleton, options);
      skeleton = updateIntegerPart(skeleton, options);

      if (!this.isDefaultCurrency()) {
        skeleton = updateCurrencySymbol(skeleton, getCurrency(options), options);
      }

      return skeleton;
    };

    /*
     * Regex to test a string for an ISO8601 Date. The following formats are matched.
     * Note that if a time element is present (e.g. 'T'), the string should have a time zone designator (Z or +hh:mm or -hh:mm).
     *
     *  YYYY
     *  YYYY-MM
     *  YYYY-MM-DD
     *  YYYY-MM-DDThh:mmTZD
     *  YYYY-MM-DDThh:mm:ssTZD
     *  YYYY-MM-DDThh:mm:ss.STZD
     *
     *
     * @see: https://www.w3.org/TR/NOTE-datetime
     */
    const ISO8601_STRICT_PATTERN = /^\d{4}(-\d\d(-\d\d(T\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z){1})?)?)?$/i;
    /* Regex to test a string for an ISO8601 partial time or full time:
     * hh:mm
     * hh:mm:ss
     * hh:mm:ss.S
     * full time = partial time + TZD
     */

    const ISO8601_TIME_PATTERN = /^\d\d:\d\d(:\d\d)?(\.\d+)?(([+-]\d\d:\d\d)|Z)?$/i;
    const STANDARD_TIME_FORMAT = 'HH:mm:ss.SSS';
    const STANDARD_DATE_FORMAT = 'YYYY-MM-DD';
    const TIME_SEPARATOR = 'T';
    const TIMEZONE_INDICATOR = /(Z|([+-])(\d{2}):(\d{2}))$/;
    function isValidISODateTimeString(dateTimeString) {
      return isValidISO8601String(dateTimeString) && isValidDate(dateTimeString);
    }
    function isValidISOTimeString(timeString) {
      if (!isValidISO8601TimeString(timeString)) {
        return false;
      }

      const timeOnly = removeTimeZoneSuffix(timeString);
      return isValidDate(`2018-09-09T${timeOnly}Z`);
    }
    function removeTimeZoneSuffix(dateTimeString) {
      if (typeof dateTimeString === 'string') {
        return dateTimeString.split(TIMEZONE_INDICATOR)[0];
      }

      return dateTimeString;
    }

    function isValidISO8601String(dateTimeString) {
      if (typeof dateTimeString !== 'string') {
        return false;
      }

      return ISO8601_STRICT_PATTERN.test(dateTimeString);
    }

    function isValidISO8601TimeString(timeString) {
      if (typeof timeString !== 'string') {
        return false;
      }

      return ISO8601_TIME_PATTERN.test(timeString);
    }

    function isValidDate(value) {
      // Date.parse returns NaN if the argument doesn't represent a valid date
      const timeStamp = Date.parse(value);
      return isFinite(timeStamp);
    }

    // This is a library for all calls to the aura localizationService.
    function isBefore(date1, date2, unit) {
      return configProvider.getLocalizationService().isBefore(date1, date2, unit);
    }
    function isAfter(date1, date2, unit) {
      return configProvider.getLocalizationService().isAfter(date1, date2, unit);
    }
    function formatDateTimeUTC(date) {
      return configProvider.getLocalizationService().formatDateTimeUTC(date);
    }
    function formatDate(dateString, format, locale) {
      return configProvider.getLocalizationService().formatDate(dateString, format, locale);
    }
    function formatDateUTC(dateString, format, locale) {
      return configProvider.getLocalizationService().formatDateUTC(dateString, format, locale);
    }
    function formatTime(timeString, format) {
      return configProvider.getLocalizationService().formatTime(timeString, format);
    }
    function parseDateTimeUTC(dateTimeString) {
      return configProvider.getLocalizationService().parseDateTimeUTC(dateTimeString);
    }
    function parseDateTimeISO8601(dateTimeString) {
      return configProvider.getLocalizationService().parseDateTimeISO8601(dateTimeString);
    }
    function parseDateTime(dateTimeString, format, strictMode) {
      return configProvider.getLocalizationService().parseDateTime(dateTimeString, format, strictMode);
    }
    function syncUTCToWallTime(date, timeZone) {
      let converted = null; // eslint-disable-next-line new-cap

      configProvider.getLocalizationService().UTCToWallTime(date, timeZone, result => {
        converted = result;
      });
      return converted;
    }
    function syncWallTimeToUTC(date, timeZone) {
      let converted = null; // eslint-disable-next-line new-cap

      configProvider.getLocalizationService().WallTimeToUTC(date, timeZone, result => {
        converted = result;
      });
      return converted;
    }
    function toOtherCalendar(date) {
      return configProvider.getLocalizationService().translateToOtherCalendar(date);
    }
    function fromOtherCalendar(date) {
      return configProvider.getLocalizationService().translateFromOtherCalendar(date);
    } // This belongs to localization service; i.e. getLocalizationService().parseTime()
    // Should be removed after it's been added to the localization service

    function parseTime(timeString, format, strictParsing) {
      if (!timeString) {
        return null;
      }

      if (!format) {
        if (!isValidISOTimeString(timeString)) {
          return null;
        }

        return parseDateTimeISO8601(timeString);
      }

      const parseString = timeString.replace(/(\d)([AaPp][Mm])/g, '$1 $2'); // Modifying the time string so that strict parsing doesn't break on minor deviations

      const parseFormat = format.replace(/(\b|[^h])h{2}(?!h)/g, '$1h').replace(/(\b|[^H])H{2}(?!H)/g, '$1H').replace(/(\b|[^m])m{2}(?!m)/g, '$1m').replace(/\s*A/g, ' A').trim();
      const acceptableFormats = [parseFormat]; // We want to be lenient and accept input values with seconds or milliseconds precision.
      // So even though we may display the time as 10:23 AM, we would accept input values like 10:23:30.555 AM.

      acceptableFormats.push(parseFormat.replace('m', 'm:s'), parseFormat.replace('m', 'm:s.S'), parseFormat.replace('m', 'm:s.SS'), parseFormat.replace('m', 'm:s.SSS')); // Start parsing from the most strict format (i.e. time with milliseconds).
      // The strict mode parsing of time strings using parseDateTime seems to be lenient for certain formats

      acceptableFormats.reverse();

      for (let i = 0; i < acceptableFormats.length; i++) {
        const time = parseDateTime(parseString, acceptableFormats[i], strictParsing);

        if (time) {
          return time;
        }
      }

      return null;
    } // This is called from the numberFormat library when the value exceeds the safe length.

    function getNumberFormat(format) {
      return configProvider.getLocalizationService().getNumberFormat(format);
    }

    function numberFormatFallback(options) {
      const skeleton = new NumberOptions(options).getSkeleton();
      return {
        format: value => {
          return getNumberFormat(skeleton).format(value);
        }
      };
    }

    function numberFormat(options) {
      const normalizedOpts = Object.assign({}, normalizeOptions(options));

      if (!('Intl' in window)) {
        return numberFormatFallback(normalizedOpts);
      }

      return {
        format: value => {
          if (value && exceedsSafeLength(value, normalizedOpts.maximumFractionDigits)) {
            return numberFormatFallback(normalizedOpts).format(value);
          }

          const numberFormatInstance = getFromCache(normalizedOpts);
          return numberFormatInstance.format(value);
        }
      };
    }

    const FORMATTING_OPTS = ['weekday', 'year', 'month', 'day', 'hour', 'minute', 'second', 'era'];
    const FORMAT_MAP = {
      weekday: {
        short: 'EEE, ',
        narrow: 'EEE, ',
        long: 'EEEE, '
      },
      month: {
        short: 'MMM ',
        narrow: 'MMM ',
        numeric: 'MMM ',
        '2-digit': 'MMM ',
        long: 'MMMM '
      },
      day: {
        numeric: 'd, ',
        '2-digit': 'dd, '
      },
      year: {
        numeric: 'yyyy ',
        '2-digit': 'yy '
      },
      hour: {
        numeric12: 'h',
        numeric24: 'H',
        '2-digit12': 'hh',
        '2-digit24': 'HH'
      },
      minute: {
        numeric: 'mm',
        '2-digit': 'mm'
      },
      second: {
        numeric: 'ss',
        '2-digit': 'ss'
      },
      timeZoneName: {
        short: '[GMT]Z',
        long: '[GMT]Z'
      }
    };
    const SEPARATORS = [',', ' ', ':'];

    function getWeekDayPart(format, options) {
      const weekdayOptionValue = options.weekday;

      if (FORMAT_MAP.weekday[weekdayOptionValue] !== undefined) {
        format.push(FORMAT_MAP.weekday[weekdayOptionValue]);
      }
    }

    function getMonthPart(format, options) {
      const monthOptionValue = options.month;

      if (FORMAT_MAP.month[monthOptionValue] !== undefined) {
        format.push(FORMAT_MAP.month[monthOptionValue]);
      }
    }

    function getDayPart(format, options) {
      const dayOptionValue = options.day;

      if (FORMAT_MAP.day[dayOptionValue] !== undefined) {
        format.push(FORMAT_MAP.day[dayOptionValue]);
      }
    }

    function getYearPart(format, options) {
      const yearOptionValue = options.year;

      if (FORMAT_MAP.year[yearOptionValue] !== undefined) {
        format.push(FORMAT_MAP.year[yearOptionValue]);
      }
    }

    function getTZPart(format, options) {
      const timeZoneNameOptionValue = options.timeZoneName;

      if (FORMAT_MAP.timeZoneName[timeZoneNameOptionValue] !== undefined) {
        if (options.timeZone === 'UTC') {
          format.push('[GMT]');
        } else {
          format.push(FORMAT_MAP.timeZoneName[timeZoneNameOptionValue]);
        }
      }
    }

    function getTimePart(format, options) {
      const hourOptionValue = options.hour,
            minuteOptionValue = options.minute,
            secondOptionValue = options.second;
      let hasTime = false;
      let hasHourOnly = false; // hour 12 hr or 24 hr

      if (hourOptionValue === 'numeric' || hourOptionValue === '2-digit') {
        hasTime = true;

        if (options.hour12 === false) {
          if (hourOptionValue === 'numeric') {
            format.push(FORMAT_MAP.hour.numeric24);
          } else {
            format.push(FORMAT_MAP.hour['2-digit24']);
          }
        } else if (hourOptionValue === 'numeric') {
          format.push(FORMAT_MAP.hour.numeric12);
        } else {
          format.push(FORMAT_MAP.hour['2-digit12']);
        }

        if (FORMAT_MAP.minute[minuteOptionValue] !== undefined) {
          format.push(':');
        } else if (FORMAT_MAP.second[secondOptionValue] !== undefined) {
          hasHourOnly = true;
        }
      } // minute


      if (FORMAT_MAP.minute[minuteOptionValue] !== undefined) {
        hasTime = true;
        format.push(FORMAT_MAP.minute[minuteOptionValue]);

        if (FORMAT_MAP.second[secondOptionValue] !== undefined) {
          format.push(':');
        }
      } // second


      if (FORMAT_MAP.second[secondOptionValue] !== undefined && !hasHourOnly) {
        hasTime = true;
        format.push(FORMAT_MAP.second[secondOptionValue]);
      } // AM/PM marker


      if (hasTime) {
        format.push(' a ');
      }

      if (hasHourOnly) {
        format.push('[(sec]: ' + FORMAT_MAP.second[secondOptionValue] + '[)]');
      }
    }

    function DateTimeOptions(options) {
      this.options = options || {};
    }

    DateTimeOptions.prototype.hasFormattingOptions = function () {
      return FORMATTING_OPTS.some(opt => {
        return this.options[opt] !== undefined;
      });
    };

    DateTimeOptions.prototype.getSkeleton = function () {
      const format = [];
      getWeekDayPart(format, this.options);
      getMonthPart(format, this.options);
      getDayPart(format, this.options);
      getYearPart(format, this.options);
      getTimePart(format, this.options);
      getTZPart(format, this.options);
      let formatStr = format.join('');
      SEPARATORS.forEach(element => {
        if (formatStr.lastIndexOf(element) === formatStr.length - 1) {
          formatStr = formatStr.slice(0, -1);
        }
      });
      return formatStr;
    };

    const dateTimeFormatInstancesCache = {};
    const POSSIBLE_OPTS$1 = {
      weekday: true,
      era: true,
      year: true,
      month: true,
      day: true,
      hour: true,
      minute: true,
      second: true,
      timeZone: true,
      timeZoneName: true,
      hour12: true
    };

    function getOptionsUniqueKey$2(options) {
      return Object.keys(options).sort().reduce((prev, optionName) => {
        if (POSSIBLE_OPTS$1[optionName]) {
          return prev + optionName + options[optionName] + '';
        }

        return prev;
      }, '');
    }

    function getFromCache$1(options) {
      const optionsUniqueKey = getOptionsUniqueKey$2(options);
      let formatInstance = dateTimeFormatInstancesCache[optionsUniqueKey];

      if (!formatInstance) {
        formatInstance = new Intl.DateTimeFormat(getLocaleTag(), options);
        dateTimeFormatInstancesCache[optionsUniqueKey] = formatInstance;
      }

      return formatInstance;
    }

    function convertAndFormatDate(date, format, timeZone) {
      const translatedDate = toOtherCalendar(date);
      const converted = syncUTCToWallTime(translatedDate, timeZone);
      return formatDateUTC(converted, format);
    }

    function isDate(value) {
      return Object.prototype.toString.call(value) === '[object Date]' && !isNaN(value.getTime());
    }

    function toDate(value) {
      let dateObj = value;

      if (!isDate(value) && (typeof value === 'string' || typeof value === 'number')) {
        dateObj = new Date(isFinite(value) ? parseInt(value, 10) : Date.parse(value));
      }

      return dateObj;
    }

    const isTimeZonesSupported = function () {
      try {
      } catch (err) {
        return false;
      }

      return true;
    }();

    function dateTimeFormatFallback(dto) {
      // localization service will default to $Locale.dateFormat when no format is provided
      const format = dto.hasFormattingOptions() ? dto.getSkeleton() : null;
      const {
        timeZone
      } = dto.options;
      return {
        format: value => {
          // if value is an ISO date string (e.g. 2019-10-25), do not convert between timezones and just format the date
          if (isValidISODateTimeString(value) && value.indexOf(TIME_SEPARATOR) < 0) {
            return formatDate(value);
          } // FIXME use standard methods from localizationService for parsing and formatting instead


          const dateObj = toDate(value);

          if (isDate(dateObj)) {
            if (timeZone === 'UTC') {
              dateObj.setTime(dateObj.getTime() + dateObj.getTimezoneOffset() * 60 * 1000);
            }

            return convertAndFormatDate(dateObj, format, timeZone);
          }

          return '';
        }
      };
    }

    function dateTimeFormat(opts) {
      const options = opts || {};
      const dto = new DateTimeOptions(options);

      if (!('Intl' in window) || !dto.hasFormattingOptions() || !isTimeZonesSupported) {
        return dateTimeFormatFallback(dto);
      }

      return {
        format: value => {
          const dtf = getFromCache$1(options);
          return dtf.format(toDate(value));
        }
      };
    }

    const FALLBACK_LOCALE = 'en-us';
    const symbolsCache = {}; // Copied over from auraLocalizationService: override for locales which are not identified by browsers

    const localeOverrides = {
      no: 'nb',
      no_NO: 'nb',
      // eslint-disable-line camelcase
      tl_PH: 'fil',
      // eslint-disable-line camelcase
      sh_BA: 'hr',
      // eslint-disable-line camelcase
      sh_ME: 'hr',
      // eslint-disable-line camelcase
      sh_CS: 'hr' // eslint-disable-line camelcase

    };
    function getNameOfWeekdays() {
      const locale = getNormalizedLocale();
      const localeCache = symbolsCache[locale];

      if (localeCache && localeCache.weekdays) {
        return localeCache.weekdays;
      }

      const locales = [locale, FALLBACK_LOCALE];
      const fullNameFormatter = new Intl.DateTimeFormat(locales, {
        weekday: 'long',
        timeZone: 'UTC'
      });
      const shortNameFormatter = new Intl.DateTimeFormat(locales, {
        weekday: 'short',
        timeZone: 'UTC'
      });
      const weekdays = [];

      for (let i = 0; i <= 6; i++) {
        // (1970, 0, 4) corresponds to a sunday.
        const date = new Date(Date.UTC(1970, 0, 4 + i));
        weekdays.push({
          fullName: format$1(fullNameFormatter, date),
          shortName: format$1(shortNameFormatter, date)
        });
      }

      if (!symbolsCache[locale]) {
        symbolsCache[locale] = {};
      }

      symbolsCache[locale].weekdays = weekdays;
      return weekdays;
    }
    function getMonthNames() {
      const locale = getNormalizedLocale();
      const localeCache = symbolsCache[locale];

      if (localeCache && localeCache.months) {
        return localeCache.months;
      }

      const locales = [locale, FALLBACK_LOCALE];
      const monthNameFormatter = new Intl.DateTimeFormat(locales, {
        month: 'long'
      });
      const months = [];

      for (let i = 0; i <= 11; i++) {
        const date = new Date(1970, i, 4);
        months.push({
          // we currently only need the fullName
          fullName: format$1(monthNameFormatter, date)
        });
      }

      if (!symbolsCache[locale]) {
        symbolsCache[locale] = {};
      }

      symbolsCache[locale].months = months;
      return months;
    }

    function format$1(dateTimeFormat, date) {
      const formattedDate = dateTimeFormat.format(date);
      return removeIE11Markers(formattedDate);
    }

    function removeIE11Markers(formattedString) {
      // IE11 adds LTR / RTL mark in the formatted date time string
      return formattedString.replace(/[\u200E\u200F]/g, '');
    }

    function getNormalizedLocale() {
      const locale = configProvider.getLocale().langLocale;

      if (locale) {
        return localeOverrides[locale] || locale.toLowerCase().replace('_', '-');
      }

      return FALLBACK_LOCALE;
    }

    function normalizeISODate(value, format) {
      const dateValue = typeof value === 'string' ? value.trim() : value;

      if (!dateValue) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      } // if value is an ISO string, only fetch the date part


      const dateOnlyString = typeof dateValue === 'string' && dateValue.split(TIME_SEPARATOR)[0] || dateValue;
      assert(isValidISODateTimeString(dateOnlyString), `datetime component: The value attribute accepts a valid ISO8601 formatted string ` + `with timezone offset. but we are getting the ${typeof value} value "${value}" instead.`);
      const parsedDate = parseDateTime(dateOnlyString, STANDARD_DATE_FORMAT);

      if (!parsedDate) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      } // convert from Gregorian to Buddhist Calendar if necessary


      const civilDate = toOtherCalendar(parsedDate);
      return {
        isoValue: dateOnlyString,
        displayValue: formatDate(civilDate, format)
      };
    }
    function normalizeISOTime(value, format) {
      // We are not converting the time to the user's timezone. All values are displayed and saved as UTC time values
      const normalizedValue = removeTimeZoneSuffix(value);
      const timeValue = typeof normalizedValue === 'string' ? normalizedValue.trim() : normalizedValue;

      if (!timeValue) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }

      assert(isValidISOTimeString(timeValue), `datetime component: The value attribute accepts a valid ISO8601 formatted string. ` + `but we are getting the ${typeof value} value "${value}" instead.`);
      const parsedTime = parseTime(timeValue);

      if (!parsedTime) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }

      return {
        isoValue: formatTime(parsedTime, STANDARD_TIME_FORMAT),
        displayValue: formatTime(parsedTime, format)
      };
    }
    function normalizeISODateTime(value, timezone, format) {
      const dateTimeValue = typeof value === 'string' ? value.trim() : value;

      if (!dateTimeValue) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }

      assert(isValidISODateTimeString(dateTimeValue), `datetime component: The value attribute accepts a valid ISO8601 formatted string ` + `with timezone offset. but we are getting the ${typeof value} value "${value}" instead.`);
      const parsedDate = parseDateTimeISO8601(dateTimeValue);

      if (!parsedDate) {
        return {
          isoValue: null,
          displayValue: value || ''
        };
      }

      const convertedDate = syncUTCToWallTime(parsedDate, timezone);
      return {
        // We are passing the ISO value without a timezone designator.
        // the native input type='datetime-local' who calls this does not accept timezone offset
        isoValue: removeTimeZoneSuffix(convertedDate.toISOString()),
        displayValue: formatDateTimeUTC(convertedDate, format)
      };
    }
    function normalizeFormattedDate(value, format) {
      const dateValue = typeof value === 'string' ? value.trim() : value;

      if (!dateValue) {
        return null;
      }

      const parsedDate = parseDateTime(dateValue, format || configProvider.getLocale().dateFormat, true);

      if (!parsedDate) {
        return null;
      }

      const gregorianDate = fromOtherCalendar(parsedDate);
      return formatDate(gregorianDate, STANDARD_DATE_FORMAT);
    }
    function normalizeFormattedTime(value, format) {
      const timeValue = typeof value === 'string' ? value.trim() : value;

      if (!timeValue) {
        return null;
      }

      const parsedDate = parseTime(timeValue, format || configProvider.getLocale().timeFormat, true);

      if (!parsedDate) {
        return null;
      }

      return formatTime(parsedDate, STANDARD_TIME_FORMAT);
    } // The value here isn't really formatted, it's always an ISO string in the form isoDate + T + isoTime (without Z).

    function normalizeFormattedDateTime(value, timezone, format) {
      const datetimeValue = typeof value === 'string' ? value.trim() : value;

      if (!datetimeValue) {
        return null;
      } // given that value is an ISO string without Z, the method below is equivalent to parseDateTimeISO8601(value + 'Z')
      // However, parseDateTimeUTC is more concise and doesn't need any manipulation of the input (adding Z).


      const parsedDate = parseDateTimeUTC(datetimeValue, format);

      if (!parsedDate) {
        return null;
      }

      const convertedDate = syncWallTimeToUTC(parsedDate, timezone);
      return convertedDate.toISOString();
    }
    function getToday() {
      const today = getTodayBasedOnTimezone();
      return today.getFullYear() + '-' + pad(today.getMonth() + 1) + '-' + pad(today.getDate());
    }
    function getCurrentTime(timezone) {
      const today = getTodayBasedOnTimezone(timezone);
      return pad(today.getHours()) + ':' + pad(today.getMinutes());
    }

    function getTodayBasedOnTimezone(timezone) {
      const today = new Date();
      today.setTime(today.getTime() + today.getTimezoneOffset() * 60 * 1000); // time in UTC
      // localization service will use $Locale.timezone when no timezone provided

      return syncUTCToWallTime(today, timezone);
    }

    function pad(n) {
      return n < 10 ? '0' + n : n;
    }

    const i18n$5 = {
      ariaLabelMonth: labelAriaLabelMonth,
      nextMonth: labelNextMonth,
      previousMonth: labelPreviousMonth,
      today: labelToday,
      yearSelector: labelYearSelector
    };
    const WEEKS_PER_MONTH = 6;
    const DAYS_PER_WEEK = 7;
    const calendarCache = {}; // cache of calendar cells for a given year/month

    class LightningCalendar extends lwc.LightningElement {
      get value() {
        return this.selectedDate;
      }

      set value(newValue) {
        // if value is an ISO string, only fetch the time part
        const dateOnlyString = typeof newValue === 'string' ? newValue.split(TIME_SEPARATOR)[0] : newValue;

        if (dateOnlyString !== this.selectedDate) {
          this.selectedDate = dateOnlyString;

          if (!this._connected) {
            return;
          }

          const newDate = this.parseDate(dateOnlyString); // if the date is invalid, render today's date

          if (!newDate) {
            this.selectedDate = null;
            this.renderToday();
          } else {
            this.selectDate(newDate);
          }
        }
      }

      constructor() {
        super();
        this.calendarYear = null;
        this.calendarMonth = null;
        this.min = void 0;
        this.max = void 0;
        this.uniqueId = generateUniqueId();
      }

      renderedCallback() {
        this.dispatchEvent(new CustomEvent('ready'));
      }

      connectedCallback() {
        this._connected = true;
        this.todayDate = getToday();
        const renderDate = this.getSelectedDate() || this.getTodaysDate();
        this.renderCalendar(renderDate);
        this.keyboardInterface = this.calendarKeyboardInterface();
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * Sets focus on the focusable date cell in the calendar.
       */


      focus() {
        requestAnimationFrame(() => {
          const dateElement = this.getFocusableDateCell();

          if (dateElement) {
            dateElement.focus();
          }
        });
      }

      get i18n() {
        return i18n$5;
      }

      get computedAriaLabel() {
        const renderedMonth = this.getCalendarDate().getMonth();
        return i18n$5.ariaLabelMonth + getMonthNames()[renderedMonth].fullName;
      }

      get computedMonthTitle() {
        const renderedMonth = this.getCalendarDate().getMonth();
        return getMonthNames()[renderedMonth].fullName;
      }

      get computedWeekdayLabels() {
        const nameOfWeekdays = getNameOfWeekdays();
        const firstDayOfWeek = this.getFirstDayOfWeek();
        const computedWeekdayLabels = []; // We need to adjust the weekday labels to start from the locale's first day of week

        for (let i = firstDayOfWeek; i < nameOfWeekdays.length; i++) {
          computedWeekdayLabels.push(nameOfWeekdays[i]);
        }

        for (let i = 0; i < firstDayOfWeek; i++) {
          computedWeekdayLabels.push(nameOfWeekdays[i]);
        }

        return computedWeekdayLabels;
      }

      get computedSelectElementId() {
        return this.uniqueId + '-select';
      }

      get computedWeekdaysElementId() {
        return this.uniqueId + '-weekdays';
      }

      get computedMonthTitleId() {
        return this.uniqueId + '-month';
      }

      get computedYearList() {
        const sampleDate = new Date();
        const currentYear = sampleDate.getFullYear();
        const minDate = this.parseDate(this.min);
        const maxDate = this.parseDate(this.max);
        const minYear = minDate ? minDate.getFullYear() : currentYear - 100;
        sampleDate.setFullYear(minYear);
        const convertedMinYear = toOtherCalendar(sampleDate).getFullYear();
        const maxYear = maxDate ? maxDate.getFullYear() : currentYear + 100;
        sampleDate.setFullYear(maxYear);
        const convertedMaxYear = toOtherCalendar(sampleDate).getFullYear();
        const yearList = [];

        for (let year = convertedMinYear; year <= convertedMaxYear; year++) {
          yearList.push({
            label: year,
            value: year
          });
        }

        return yearList;
      }

      get computedMonth() {
        if (!this._connected) {
          return [];
        }

        this.removeCurrentlySelectedDateAttributes();
        const selectedDate = this.getSelectedDate();
        const renderDate = this.getCalendarDate();
        const cacheKey = this.getCalendarCacheKey(renderDate, selectedDate);

        if (cacheKey in calendarCache) {
          return calendarCache[cacheKey];
        }

        const todayDate = this.getTodaysDate();
        const focusableDate = this.getInitialFocusDate(todayDate, selectedDate, renderDate);
        const calendarDates = {
          selectedDate,
          renderDate,
          focusableDate,
          todayDate,
          minDate: this.parseDate(this.min),
          maxDate: this.parseDate(this.max)
        };
        const monthCells = [];
        const date = this.getCalendarStartDate(renderDate);

        for (let week = 0; week < WEEKS_PER_MONTH; week++) {
          const weekCells = {
            id: week,
            days: []
          };

          for (let weekday = 0; weekday < DAYS_PER_WEEK; weekday++) {
            const dayCell = this.getDateCellAttributes(date, calendarDates);
            weekCells.days.push(dayCell);
            date.setDate(date.getDate() + 1);
          }

          monthCells.push(weekCells);
        }

        calendarCache[cacheKey] = monthCells;
        return monthCells;
      }

      getDateCellAttributes(date, calendarDates) {
        const isDisabled = !this.dateInCalendar(date, calendarDates.renderDate) || !this.isBetween(date, calendarDates.minDate, calendarDates.maxDate);
        const isSelected = this.isSame(date, calendarDates.selectedDate);
        const isToday = this.isSame(date, calendarDates.todayDate);
        const ariaCurrent = isToday ? 'date' : false;
        const tabIndex = this.isSame(date, calendarDates.focusableDate) ? '0' : false;
        const className = classSet().add({
          'slds-is-today': isToday,
          'slds-is-selected': isSelected,
          'slds-disabled-text': isDisabled
        }).toString();
        return {
          date: date.getDate(),
          dateValue: this.formatDate(date),
          isDisabled,
          isSelected: isSelected ? 'true' : 'false',
          className,
          tabIndex,
          ariaCurrent
        };
      }

      dispatchSelectEvent() {
        this.dispatchEvent(new CustomEvent('select', {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            value: this.selectedDate
          }
        }));
      } // Determines if the date is in the rendered month/year calendar.


      dateInCalendar(date, calendarDate) {
        const renderedCalendar = calendarDate || this.getCalendarDate();
        return date.getMonth() === renderedCalendar.getMonth() && date.getFullYear() === renderedCalendar.getFullYear();
      }

      getInitialFocusDate(todayDate, selectedDate, renderedDate) {
        if (selectedDate && this.dateInCalendar(selectedDate, renderedDate)) {
          return selectedDate;
        }

        if (this.dateInCalendar(todayDate, renderedDate)) {
          return todayDate;
        }

        return new Date(renderedDate.getFullYear(), renderedDate.getMonth(), 1);
      }

      getTodaysDate() {
        if (this.todayDate) {
          return this.parseDate(this.todayDate);
        } // Today's date will be fetched in connectedCallback. In the meantime, use the date based on the device timezone.


        return new Date();
      }

      getSelectedDate() {
        return this.parseDate(this.selectedDate);
      } // returns the month and year in the calendar


      getCalendarDate() {
        if (this.calendarYear) {
          return new Date(this.calendarYear, this.calendarMonth, 1);
        }

        return this.getTodaysDate();
      }

      getCalendarStartDate(renderedDate) {
        const firstDayOfMonth = new Date(renderedDate.getFullYear(), renderedDate.getMonth(), 1);
        return this.getStartOfWeek(firstDayOfMonth);
      }

      getStartOfWeek(dayInWeek) {
        const firstDayOfWeek = this.getFirstDayOfWeek(); // Negative dates in JS will subtract days from the 1st of the given month

        let startDay = dayInWeek.getDay();

        while (startDay !== firstDayOfWeek) {
          dayInWeek.setDate(dayInWeek.getDate() - 1);
          startDay = dayInWeek.getDay();
        }

        return dayInWeek;
      }

      getFirstDayOfWeek() {
        return configProvider.getLocale().firstDayOfWeek - 1; // In Java, week days are 1 - 7
      } // This method is called when a new value is set, or when you click the today button.
      // In both cases, we need to check if newValue is in the currently rendered calendar


      selectDate(newDate) {
        if (this.dateInCalendar(newDate)) {
          const dateElement = this.getElementByDate(this.formatDate(newDate)); // do not select if date is disabled

          if (this.dateElementDisabled(dateElement)) {
            return;
          }

          this.selectDateInCalendar(dateElement);
        } else {
          this.renderCalendar(newDate);
        }
      } // Select a date in current calendar without the need to re-render the calendar


      selectDateInCalendar(dateElement) {
        this.selectedDate = dateElement.getAttribute('data-value');
        this.removeCurrentlySelectedDateAttributes();
        this.addSelectedDateAttributes(dateElement);
      }

      selectDateInCalendarAndDispatchSelect(dateElement) {
        // do not select if date is disabled
        if (this.dateElementDisabled(dateElement)) {
          return;
        }

        this.selectDateInCalendar(dateElement);
        this.dispatchSelectEvent();
      } // we should be able to control the select value with an attribute once we have a select component


      selectYear(year) {
        const sampleDate = new Date();
        sampleDate.setFullYear(year);
        const convertedYear = toOtherCalendar(sampleDate).getFullYear();
        const optionElement = this.template.querySelector(`option[value='${convertedYear}']`);

        if (optionElement) {
          optionElement.selected = true;
        }
      }

      getElementByDate(dateString) {
        return this.template.querySelector(`td[data-value='${dateString}']`);
      }

      getFocusableDateCell() {
        return this.template.querySelector(`td[tabIndex='0']`);
      }

      unfocusDateCell(element) {
        if (element) {
          element.removeAttribute('tabIndex');
        }
      }

      focusDateCell(element) {
        if (element) {
          element.setAttribute('tabIndex', 0);
          element.focus();
        }
      }

      focusElementByDate(date) {
        requestAnimationFrame(() => {
          const element = this.getElementByDate(this.formatDate(date));

          if (element) {
            this.unfocusDateCell(this.getFocusableDateCell());
            this.focusDateCell(element);
          }
        });
      }

      renderCalendar(newDate) {
        this.calendarMonth = newDate.getMonth();
        this.calendarYear = newDate.getFullYear();
        this.selectYear(newDate.getFullYear());
      }

      renderToday() {
        const todaysDate = this.getTodaysDate();

        if (this.dateInCalendar(todaysDate)) {
          this.removeCurrentlySelectedDateAttributes();
          this.unfocusDateCell(this.getFocusableDateCell());
          const todayElement = this.getElementByDate(this.todayDate);
          todayElement.setAttribute('tabIndex', 0);
        } else {
          this.renderCalendar(todaysDate);
        }
      }

      removeCurrentlySelectedDateAttributes() {
        const currentlySelectedElement = this.template.querySelector(`td[class*='slds-is-selected']`);

        if (currentlySelectedElement) {
          currentlySelectedElement.classList.remove('slds-is-selected');
          currentlySelectedElement.setAttribute('aria-selected', 'false');
        }

        this.unfocusDateCell(this.getFocusableDateCell());
      }

      addSelectedDateAttributes(dateElement) {
        this.focusDateCell(dateElement);
        dateElement.classList.add('slds-is-selected');
        dateElement.setAttribute('aria-selected', 'true');
      }

      dateElementDisabled(dateElement) {
        // do not select if date is disabled
        return !dateElement || dateElement.getAttribute('aria-disabled') === 'true';
      }

      handleCalendarKeyDown(event) {
        const dateString = event.target.getAttribute('data-value');
        handleKeyDownOnCalendar(event, this.parseDate(dateString), this.keyboardInterface);
      }

      handleTodayKeyDown(event) {
        handleKeyDownOnToday(event, this.keyboardInterface);
      }

      handlePrevNavKeyDown(event) {
        handleKeyDownOnPreviousMonthNav(event, this.keyboardInterface);
      }

      handleDateClick(event) {
        event.stopPropagation();
        const tdElement = event.target.parentElement;
        this.selectDateInCalendarAndDispatchSelect(tdElement);
      }

      handleTodayClick(event) {
        event.stopPropagation();
        this.selectedDate = this.todayDate;
        this.selectDate(this.getTodaysDate());
        this.dispatchSelectEvent();
      }

      handleYearSelectClick(event) {
        event.stopPropagation();
      }

      handleYearChange(event) {
        event.stopPropagation();
        const sampleDate = new Date();
        sampleDate.setFullYear(event.target.value);
        const convertedYear = fromOtherCalendar(sampleDate).getFullYear();

        if (this.calendarYear !== convertedYear) {
          this.calendarYear = convertedYear;
        }
      }

      goToNextMonth(event) {
        event.stopPropagation();
        const calendarDate = this.getCalendarDate();
        calendarDate.setMonth(calendarDate.getMonth() + 1);
        this.renderCalendar(calendarDate);
      }

      goToPreviousMonth(event) {
        event.stopPropagation();
        const calendarDate = this.getCalendarDate();
        calendarDate.setMonth(calendarDate.getMonth() - 1);
        this.renderCalendar(calendarDate);
      }

      calendarKeyboardInterface() {
        const that = this;
        return {
          focusDate(newDate) {
            if (!that.dateInCalendar(newDate)) {
              that.renderCalendar(newDate);
            }

            that.focusElementByDate(newDate);
          },

          getStartOfWeek(dayInWeek) {
            return that.getStartOfWeek(dayInWeek);
          },

          focusFirstFocusableElement() {
            that.template.querySelector('lightning-button-icon').focus();
          },

          focusLastFocusableElement() {
            that.template.querySelector('button[name="today"]').focus();
          },

          selectDate(dateElement) {
            that.selectDateInCalendarAndDispatchSelect(dateElement);
          }

        };
      }

      formatDate(date) {
        return formatDate(date, STANDARD_DATE_FORMAT);
      }

      parseDate(dateString) {
        return parseDateTime(dateString, STANDARD_DATE_FORMAT, true);
      }

      isSame(date1, date2) {
        if (!date1 || !date2) {
          return false;
        }

        return date1.getFullYear() === date2.getFullYear() && date1.getMonth() === date2.getMonth() && date1.getDate() === date2.getDate() // getDate returns the day in month whereas getDay returns the weekday number
        ;
      }

      isBetween(date, date1, date2) {
        let isBeforeEndDate = true;
        let isAfterStartDate = true;

        if (date2) {
          isBeforeEndDate = isBefore(date, date2, 'day') || this.isSame(date, date2);
        }

        if (date1) {
          isAfterStartDate = isAfter(date, date1, 'day') || this.isSame(date, date1);
        }

        return isBeforeEndDate && isAfterStartDate;
      }

      getCalendarCacheKey(renderDate, selectedDate) {
        let key = renderDate.getFullYear() + '-' + renderDate.getMonth(); // Having the key include min/max seems enough for now.
        // We're not going to complicate things by checking if renderDate falls before/after the min/max.

        key += this.min ? 'min' + this.min : '';
        key += this.max ? 'max' + this.max : '';

        if (selectedDate && this.dateInCalendar(selectedDate, renderDate)) {
          key += '_' + selectedDate.getDate();
        }

        return key;
      }

    }

    lwc.registerDecorators(LightningCalendar, {
      publicProps: {
        min: {
          config: 0
        },
        max: {
          config: 0
        },
        value: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        calendarYear: 1,
        calendarMonth: 1
      }
    });

    var _lightningCalendar = lwc.registerComponent(LightningCalendar, {
      tmpl: _tmpl$g
    });

    function tmpl$g($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-form-element": true,
          "slds-dropdown-trigger": true,
          "slds-dropdown-trigger_click": true,
          "slds-size_1-of-1": true
        },
        attrs: {
          "tabindex": "-1"
        },
        key: 2
      }, [api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "for": `${api_scoped_id("input")}`
        },
        key: 3
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 5
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 6
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true,
          "slds-input-has-icon": true,
          "slds-input-has-icon_right": true
        },
        key: 7
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("input"),
          "name": $cmp.name,
          "placeholder": $cmp.placeholder,
          "aria-label": $cmp.ariaLabel,
          "autocomplete": $cmp.autocomplete
        },
        props: {
          "value": $cmp.displayValue,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 8,
        on: {
          "input": _m0 || ($ctx._m0 = api_bind($cmp.handleInput)),
          "change": _m1 || ($ctx._m1 = api_bind($cmp.handleInputChange)),
          "focus": _m2 || ($ctx._m2 = api_bind($cmp.handleInputFocus)),
          "blur": _m3 || ($ctx._m3 = api_bind($cmp.handleInputBlur)),
          "keydown": _m4 || ($ctx._m4 = api_bind($cmp.handleInputKeydown)),
          "click": _m5 || ($ctx._m5 = api_bind($cmp.handleInputClick))
        }
      }, []), api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        classMap: {
          "slds-input__icon": true,
          "slds-input__icon_right": true
        },
        props: {
          "iconName": "utility:event",
          "variant": "bare",
          "disabled": $cmp.computedIconDisabledState,
          "title": $cmp.i18n.selectDate,
          "alternativeText": $cmp.i18n.selectDate
        },
        key: 9,
        on: {
          "click": _m6 || ($ctx._m6 = api_bind($cmp.handleDatePickerIconClick)),
          "keydown": _m7 || ($ctx._m7 = api_bind($cmp.handleDatePickerIconKeyDown)),
          "focus": _m8 || ($ctx._m8 = api_bind($cmp.handleIconFocus)),
          "blur": _m9 || ($ctx._m9 = api_bind($cmp.handleIconBlur))
        }
      }, []), $cmp.isCalendarVisible ? api_custom_element("lightning-calendar", _lightningCalendar, {
        props: {
          "value": $cmp.value,
          "min": $cmp.min,
          "max": $cmp.max
        },
        key: 11,
        on: {
          "keydown": _m10 || ($ctx._m10 = api_bind($cmp.handleCalendarKeyDown)),
          "select": _m11 || ($ctx._m11 = api_bind($cmp.handleDateSelect)),
          "ready": _m12 || ($ctx._m12 = api_bind($cmp.startPositioning))
        }
      }, []) : null])]), $cmp.errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("error-message"),
          "data-error-message": true,
          "aria-live": "assertive"
        },
        key: 13
      }, [api_dynamic($cmp.errorMessage)]) : null];
    }

    var _tmpl$h = lwc.registerTemplate(tmpl$g);
    tmpl$g.stylesheets = [];
    tmpl$g.stylesheetTokens = {
      hostAttribute: "lightning-datepicker_datepicker-host",
      shadowAttribute: "lightning-datepicker_datepicker"
    };

    var labelInvalidDate = 'Your entry does not match the allowed format {0}.';

    var labelRangeOverflow$1 = 'Value must be {0} or earlier.';

    var labelRangeUnderflow$1 = 'Value must be {0} or later.';

    var labelSelectDate = 'Select a date';

    function handleKeyDownOnDatePickerIcon(event, datepickerInterface) {
      switch (event.keyCode) {
        case keyCodes.enter:
        case keyCodes.space:
          preventDefaultAndStopPropagation$1(event);
          datepickerInterface.showCalendar();
          break;

        case keyCodes.escape:
          preventDefaultAndStopPropagation$1(event);
          datepickerInterface.hideCalendar();
          break;

        default:
      }
    }
    function handleBasicKeyDownBehaviour(event, datepickerInterface) {
      if (!datepickerInterface.isCalendarVisible()) {
        return;
      }

      if (event.keyCode === keyCodes.escape) {
        preventDefaultAndStopPropagation$1(event);
        datepickerInterface.hideCalendar();
      }
    }

    function preventDefaultAndStopPropagation$1(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    const i18n$6 = {
      invalidDate: labelInvalidDate,
      rangeOverflow: labelRangeOverflow$1,
      rangeUnderflow: labelRangeUnderflow$1,
      required: labelRequired,
      selectDate: labelSelectDate
    };
    const ARIA_CONTROLS = 'aria-controls';
    const ARIA_LABEL = 'aria-label';
    const ARIA_LABELLEDBY = 'aria-labelledby';
    const ARIA_DESCRIBEDBY$1 = 'aria-describedby';
    const DATE_STYLE = {
      SHORT: 'short',
      MEDIUM: 'medium',
      LONG: 'long'
    };

    class LightningDatePicker extends lwc.LightningElement {
      get messageWhenBadInput() {
        return this._messageWhenBadInput || this.formatString(this.i18n.invalidDate, this.dateFormat);
      }

      set messageWhenBadInput(message) {
        this._messageWhenBadInput = message;
      }

      get messageWhenRangeOverflow() {
        return this._messageWhenRangeOverflow || this.formatString(this.i18n.rangeOverflow, this.max);
      }

      set messageWhenRangeOverflow(message) {
        this._messageWhenRangeOverflow = message;
      }

      get messageWhenRangeUnderflow() {
        return this._messageWhenRangeUnderflow || this.formatString(this.i18n.rangeUnderflow, this.min);
      }

      set messageWhenRangeUnderflow(message) {
        this._messageWhenRangeUnderflow = message;
      } // setter is required to properly trigger update


      get ariaLabel() {
        return this._ariaLabel;
      }

      set ariaLabel(val) {
        this._ariaLabel = val;
        this.synchronizeA11y();
      }

      set ariaLabelledByElement(el) {
        this._ariaLabelledBy = el;
        this.synchronizeA11y();
      }

      get ariaLabelledByElement() {
        return this._ariaLabelledBy;
      }

      set ariaControlsElement(el) {
        this._ariaControls = el;
        this.synchronizeA11y();
      }

      get ariaControlsElement() {
        return this._ariaControls;
      }

      set ariaDescribedByElements(el) {
        if (Array.isArray(el)) {
          this._ariaDescribedBy = el;
        } else {
          this._ariaDescribedBy = [el];
        }

        this.synchronizeA11y();
      }

      get ariaDescribedByElements() {
        return this._ariaDescribedBy;
      }

      get ariaLabelledbyId() {
        return getRealDOMId(this._ariaLabelledBy);
      }

      get ariaControlsId() {
        return getRealDOMId(this.ariaControlsElement);
      }

      synchronizeA11y() {
        const input = this.template.querySelector('input');

        if (!input) {
          return;
        }

        synchronizeAttrs(input, {
          [ARIA_LABELLEDBY]: this.ariaLabelledbyId,
          [ARIA_DESCRIBEDBY$1]: this.computedAriaDescribedby,
          [ARIA_CONTROLS]: this.ariaControlsId,
          [ARIA_LABEL]: this._ariaLabel
        });
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      get value() {
        return this._value;
      }

      set value(newValue) {
        const normalizedValue = this.normalizeInputValue(newValue);

        if (normalizedValue !== this._value) {
          const normalizedDate = normalizeISODate(normalizedValue, this.dateFormat);
          this._value = normalizedDate.isoValue;
          this._displayValue = normalizedDate.displayValue;
        }
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }

      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant$1(value);
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (this.connected) {
          this.inputElement.focus();
        }
      }
      /**
       * Removes keyboard focus from the input element.
       */


      blur() {
        if (this.connected) {
          this.inputElement.blur();
        }
      }

      showHelpMessage(message) {
        if (!message) {
          this.classList.remove('slds-has-error');
          this._errorMessage = '';
        } else {
          this.classList.add('slds-has-error');
          this._errorMessage = message;
        }
      }

      hasBadInput() {
        return !!this._displayValue && this._value === null;
      }

      get dateStyle() {
        return this._dateStyle;
      }

      set dateStyle(value) {
        this._dateStyle = normalizeString(value, {
          fallbackValue: DATE_STYLE.MEDIUM,
          validValues: [DATE_STYLE.SHORT, DATE_STYLE.MEDIUM, DATE_STYLE.LONG]
        });
        this.dateFormat = this.getDateFormatFromStyle(this._dateStyle);
        const normalizedDate = normalizeISODate(this._value, this.dateFormat);
        this._displayValue = normalizedDate.displayValue;
      }

      constructor() {
        super();
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        this._value = null;
        this._calendarVisible = false;
        this._displayValue = null;
        this._errorMessage = '';
        this._fieldLevelHelp = void 0;
        this._variant = void 0;
        this.label = void 0;
        this.name = void 0;
        this.max = void 0;
        this.min = void 0;
        this.placeholder = void 0;
        this.autocomplete = void 0;
        this.messageWhenValueMissing = void 0;
        this._ariaLabelledBy = void 0;
        this._ariaControls = void 0;
        this._ariaDescribedBy = [];
        this.uniqueId = generateUniqueId();
      }

      connectedCallback() {
        this.connected = true;
        this.keyboardInterface = this.datepickerKeyboardInterface();
        this.documentClickHandler = this.getClickHandler.bind(this);
        this.interactingState = new InteractingState({
          debounceInteraction: true
        });
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          if (this.connected) {
            this.dispatchEvent(new CustomEvent('blur'));
          }
        });
      }

      disconnectedCallback() {
        this.connected = false; // make sure the click handler has been removed from the document

        document.removeEventListener('click', this.documentClickHandler);
      }

      get i18n() {
        return i18n$6;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedUniqueErrorMessageElementId() {
        const el = this.template.querySelector('[data-error-message]');
        return getRealDOMId(el);
      }

      get isCalendarVisible() {
        return this._calendarVisible;
      }

      get displayValue() {
        return this._displayValue;
      }

      get errorMessage() {
        return this._errorMessage;
      }

      get computedIconDisabledState() {
        return this.disabled || this.readOnly;
      }

      get computedAriaDescribedby() {
        const ariaValues = [];

        if (this.errorMessage) {
          ariaValues.push(this.computedUniqueErrorMessageElementId);
        }

        this._ariaDescribedBy.forEach(item => {
          const id = getRealDOMId(item);

          if (id) {
            ariaValues.push(id);
          }
        });

        return normalizeAriaAttribute(ariaValues);
      }

      handleInputChange(event) {
        event.stopPropagation(); // keeping the display value in sync with the element's value

        this._displayValue = event.currentTarget.value;
        this._value = this.parseFormattedDate(this._displayValue);
        this.dispatchChangeEvent();
      }

      handleInput() {
        // IE11 fires an input event along with the click event when the element has a placeholder.
        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/101220/
        // remove this block when we stop support for IE11
        const normalizedInputValue = this.normalizeInputValue(this.inputElement.value);

        if (this._displayValue === normalizedInputValue) {
          return;
        } // keeping the display value in sync with the element's value


        this._displayValue = this.inputElement.value; // Making sure that the focus remains on the input and we're not triggering leave

        this.hideCalendarAndFocusTrigger();
      }

      handleInputFocus() {
        this.interactingState.enter();
      }

      handleInputBlur() {
        if (!this.isCalendarVisible) {
          if (this._value !== null) {
            const normalizedDate = normalizeISODate(this._value, this.dateFormat);
            this._displayValue = normalizedDate.displayValue;
          }

          this.interactingState.leave();
        }
      }

      handleInputClick(event) {
        if (this.readOnly) {
          return;
        }

        this.calendarTrigger = event.target;
        this.showCalendar();
      }

      handleIconBlur() {
        if (!this.isCalendarVisible) {
          this.interactingState.leave();
        }
      }

      handleIconFocus() {
        this.interactingState.enter();
      }

      handleDatePickerIconClick(event) {
        if (this.readOnly || this.disabled) {
          return;
        }

        this.calendarTrigger = event.target;
        this.showAndFocusCalendar();
      }

      handleInputKeydown(event) {
        this.calendarTrigger = event.target;
        handleBasicKeyDownBehaviour(event, this.keyboardInterface);
      }

      handleDatePickerIconKeyDown(event) {
        this.calendarTrigger = event.target;
        handleKeyDownOnDatePickerIcon(event, this.keyboardInterface);
      }

      handleCalendarKeyDown(event) {
        handleBasicKeyDownBehaviour(event, this.keyboardInterface);
      }

      handleDateSelect(event) {
        event.stopPropagation();
        this._value = event.detail.value;
        this._displayValue = normalizeISODate(this._value, this.dateFormat).displayValue;
        this.hideCalendarAndFocusTrigger();
        this.dispatchChangeEvent();
      }

      showAndFocusCalendar() {
        this.showCalendar();
        requestAnimationFrame(() => {
          this.focusCalendar();
        });
      }

      hideCalendarAndFocusTrigger() {
        this.hideCalendar();
        this.calendarTrigger.focus(); // in the case where the input already has focus, we should re-enter to make sure we are not triggering leave

        this.interactingState.enter();
      }

      focusCalendar() {
        const calendar = this.template.querySelector('lightning-calendar');

        if (calendar) {
          calendar.focus();
        }
      }

      startPositioning() {
        if (!this._relationship) {
          this._relationship = startPositioning(this, {
            target: () => this.template.querySelector('input'),
            element: () => this.template.querySelector('lightning-calendar').shadowRoot.querySelector('div'),
            align: {
              horizontal: Direction.Right,
              vertical: Direction.Top
            },
            targetAlign: {
              horizontal: Direction.Right,
              vertical: Direction.Bottom
            },
            autoFlip: true,
            // Auto flip direction if not have enough space
            leftAsBoundary: true // horizontal flip uses target left as boundary

          });
        } else {
          this._relationship.reposition();
        }
      }

      stopPositioning() {
        if (this._relationship) {
          stopPositioning(this._relationship);
          this._relationship = null;
        }
      }

      showCalendar() {
        if (!this.isCalendarVisible) {
          this.interactingState.enter(); // Async bind the click handler because we are currently handling a
          // click event and we don't want to immediately close the calendar.

          requestAnimationFrame(() => {
            this.addDocumentClickHandler();
          });
          this.rootElement.classList.add('slds-is-open');
          this._calendarVisible = true;
        }
      }

      hideCalendar() {
        if (this.isCalendarVisible) {
          this.removeDocumentClickHandler();
          this.rootElement.classList.remove('slds-is-open');
          this.stopPositioning();
          this._calendarVisible = false;
          this.interactingState.leave();
        }
      }

      get rootElement() {
        return this.template.querySelector('div');
      }

      get inputElement() {
        return this.template.querySelector('input');
      }

      get dateFormat() {
        if (!this._dateFormat) {
          this._dateFormat = this.getDateFormatFromStyle();
        }

        return this._dateFormat;
      }

      set dateFormat(value) {
        this._dateFormat = value;
      }

      getDateFormatFromStyle(dateStyle) {
        let dateFormat;

        switch (dateStyle) {
          case DATE_STYLE.SHORT:
            dateFormat = configProvider.getLocale().shortDateFormat;
            break;

          case DATE_STYLE.LONG:
            dateFormat = configProvider.getLocale().longDateFormat;
            break;

          default:
            dateFormat = configProvider.getLocale().dateFormat;
            break;
        }

        return dateFormat;
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._value
          }
        }));
      }

      addDocumentClickHandler() {
        document.addEventListener('click', this.documentClickHandler);
      }

      removeDocumentClickHandler() {
        document.removeEventListener('click', this.documentClickHandler);
      }

      getClickHandler(event) {
        const rootElement = this.rootElement;

        if (!rootElement.contains(event.target)) {
          this.hideCalendar();
        }
      }

      datepickerKeyboardInterface() {
        const that = this;
        return {
          showCalendar() {
            that.showAndFocusCalendar();
          },

          hideCalendar() {
            that.hideCalendarAndFocusTrigger();
          },

          isCalendarVisible() {
            return that.isCalendarVisible;
          }

        };
      }

      normalizeInputValue(value) {
        if (!value || value === '') {
          return null;
        }

        return value;
      }

      parse(dateString) {
        // We cannot use parseDateTimeISO8601 here because that method does not have a strict flag. If the value is not an ISO string, that method will parse using the native Date()
        // Alternatively we could call isValidISODateTimeString and then parseDateTimeISO8601.
        return parseDateTime(dateString, STANDARD_DATE_FORMAT, true);
      }

      get allowedDateFormats() {
        // this method can't be static because at the time this file is interpreted,
        // getLocale don't have the injected Locale in the config provider.
        const locale = configProvider.getLocale(); // We should prioritize the long, because a long date matched with the medium format. An issue in aura?
        // Ex: September 8, 2017 when be parsed with the medium format, returns a valid iso date.

        return [locale.longDateFormat, locale.dateFormat, locale.shortDateFormat];
      }
      /**
       * Parses the input date and sets the dateFormat used to parse the displayValue
       * if it is a valid Date.
       *
       * @param {String} displayValue - The input date.
       * @return {null | string} - A normalized formatted date if displayValue is valid. null otherwise.
       */


      parseFormattedDate(displayValue) {
        const allowedFormats = this.allowedDateFormats;
        const n = allowedFormats.length;
        let i = 0,
            value = null;

        do {
          value = normalizeFormattedDate(displayValue, allowedFormats[i]);
          i++;
        } while (value === null && i < n);

        return value;
      }

      formatString(str, ...args) {
        return str.replace(/{(\d+)}/g, (match, i) => {
          return args[i];
        });
      }

    }

    LightningDatePicker.delegatesFocus = true;

    lwc.registerDecorators(LightningDatePicker, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        max: {
          config: 0
        },
        min: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        autocomplete: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageWhenBadInput: {
          config: 3
        },
        messageWhenRangeOverflow: {
          config: 3
        },
        messageWhenRangeUnderflow: {
          config: 3
        },
        ariaLabel: {
          config: 3
        },
        ariaLabelledByElement: {
          config: 3
        },
        ariaControlsElement: {
          config: 3
        },
        ariaDescribedByElements: {
          config: 3
        },
        value: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        dateStyle: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur", "showHelpMessage", "hasBadInput"],
      track: {
        _disabled: 1,
        _readonly: 1,
        _required: 1,
        _value: 1,
        _calendarVisible: 1,
        _displayValue: 1,
        _errorMessage: 1,
        _fieldLevelHelp: 1,
        _variant: 1
      }
    });

    var _lightningDatepicker = lwc.registerComponent(LightningDatePicker, {
      tmpl: _tmpl$h
    });

    function stylesheet$6(hostSelector, shadowSelector, nativeShadow) {
      return ".slds-inline-logo" + shadowSelector + " {height: 1rem;margin-top: 1rem;margin-bottom: 1rem;}\n";
    }
    var _implicitStylesheets$6 = [stylesheet$6];

    function tmpl$h($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        k: api_key,
        h: api_element,
        i: api_iterator,
        f: api_flatten
      } = $api;
      return api_flatten([$cmp.hasParts ? api_iterator($cmp.text, function (item) {
        return [item.part.highlight ? api_element("strong", {
          key: api_key(5, item.key)
        }, [api_dynamic(item.part.text)]) : null, !item.part.highlight ? api_dynamic(item.part.text) : null];
      }) : [], !$cmp.hasParts ? api_dynamic($cmp.text) : null]);
    }

    var _tmpl$i = lwc.registerTemplate(tmpl$h);
    tmpl$h.stylesheets = [];
    tmpl$h.stylesheetTokens = {
      hostAttribute: "lightning-baseComboboxFormattedText_baseComboboxFormattedText-host",
      shadowAttribute: "lightning-baseComboboxFormattedText_baseComboboxFormattedText"
    };

    class LightningBaseComboboxFormattedText extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._text = '';
        this.hasParts = void 0;
      }

      get text() {
        return this._text;
      }

      set text(value) {
        this.hasParts = Array.isArray(value) && value.length > 0;

        if (this.hasParts) {
          // Generate keys for LWC DOM
          this._text = value.map((part, i) => ({
            part,
            key: i
          }));
        } else {
          this._text = value;
        }
      }

    }

    lwc.registerDecorators(LightningBaseComboboxFormattedText, {
      publicProps: {
        text: {
          config: 3
        }
      },
      track: {
        _text: 1,
        hasParts: 1
      }
    });

    var _lightningBaseComboboxFormattedText = lwc.registerComponent(LightningBaseComboboxFormattedText, {
      tmpl: _tmpl$i
    });

    function tmpl$i($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        h: api_element,
        d: api_dynamic
      } = $api;
      return [api_element("span", {
        classMap: {
          "slds-media__figure": true
        },
        key: 2
      }, [api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "size": $cmp.iconSize,
          "alternativeText": $cmp.item.iconAlternativeText,
          "iconName": $cmp.item.iconName
        },
        key: 3
      }, [])]), api_element("span", {
        classMap: {
          "slds-media__body": true
        },
        key: 4
      }, [api_element("span", {
        classMap: {
          "slds-listbox__option-text": true,
          "slds-listbox__option-text_entity": true
        },
        key: 5
      }, [!$cmp.textHasParts ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.item.text
        },
        key: 7
      }, [api_dynamic($cmp.item.text)]) : null, $cmp.textHasParts ? api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText, {
        classMap: {
          "slds-truncate": true
        },
        props: {
          "title": $cmp.text,
          "text": $cmp.item.text
        },
        key: 9
      }, []) : null]), $cmp.hasSubText ? api_element("span", {
        classMap: {
          "slds-listbox__option-meta": true,
          "slds-listbox__option-meta_entity": true
        },
        key: 11
      }, [!$cmp.subTextHasParts ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.item.subText
        },
        key: 13
      }, [api_dynamic($cmp.item.subText)]) : null, $cmp.subTextHasParts ? api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText, {
        classMap: {
          "slds-truncate": true
        },
        props: {
          "title": $cmp.subText,
          "text": $cmp.item.subText
        },
        key: 15
      }, []) : null]) : null]), $cmp.item.rightIconName ? api_element("span", {
        classMap: {
          "slds-media__figure": true,
          "slds-media__figure_reverse": true
        },
        key: 17
      }, [api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "size": $cmp.rightIconSize,
          "alternativeText": $cmp.item.rightIconAlternativeText,
          "iconName": $cmp.item.rightIconName
        },
        key: 18
      }, [])]) : null];
    }

    var card = lwc.registerTemplate(tmpl$i);
    tmpl$i.stylesheets = [];
    tmpl$i.stylesheetTokens = {
      hostAttribute: "lightning-baseComboboxItem_card-host",
      shadowAttribute: "lightning-baseComboboxItem_card"
    };

    function tmpl$j($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        h: api_element,
        d: api_dynamic
      } = $api;
      return [api_element("span", {
        classMap: {
          "slds-media__figure": true,
          "slds-listbox__option-icon": true
        },
        key: 2
      }, [$cmp.item.iconName ? api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "alternativeText": $cmp.item.iconAlternativeText,
          "iconName": $cmp.item.iconName,
          "size": "x-small"
        },
        key: 4
      }, []) : null]), api_element("span", {
        classMap: {
          "slds-media__body": true
        },
        key: 5
      }, [!$cmp.textHasParts ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.item.text
        },
        key: 7
      }, [api_dynamic($cmp.item.text)]) : null, $cmp.textHasParts ? api_custom_element("lightning-base-combobox-formatted-text", _lightningBaseComboboxFormattedText, {
        classMap: {
          "slds-truncate": true
        },
        props: {
          "text": $cmp.item.text,
          "title": $cmp.text
        },
        key: 9
      }, []) : null])];
    }

    var inline = lwc.registerTemplate(tmpl$j);
    tmpl$j.stylesheets = [];
    tmpl$j.stylesheetTokens = {
      hostAttribute: "lightning-baseComboboxItem_inline-host",
      shadowAttribute: "lightning-baseComboboxItem_inline"
    };

    class LightningBaseComboboxItem extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.item = {};
      }

      connectedCallback() {
        // We want to make sure that the item has 'aria-selected' if it's selectable
        if (this.item.selectable) {
          this.setAttribute('aria-selected', 'false');
        }

        if (this.item.type === 'option-inline') {
          this.classList.add('slds-media_small', 'slds-listbox__option_plain');
        } else {
          this.classList.add('slds-listbox__option_entity');
        }
      }

      get textHasParts() {
        const text = this.item.text;
        return text && Array.isArray(text) && text.length > 0;
      }

      get subTextHasParts() {
        const subText = this.item.subText;
        return subText && Array.isArray(subText) && subText.length > 0;
      } // Return html based on the specified item type


      render() {
        if (this.item.type === 'option-card') {
          return card;
        }

        return inline;
      }

      highlight() {
        this.toggleHighlight(true);
      }

      removeHighlight() {
        this.toggleHighlight(false);
      }

      toggleHighlight(highlighted) {
        if (this.item.selectable) {
          this.setAttribute('aria-selected', highlighted ? 'true' : 'false');
          this.classList.toggle('slds-has-focus', highlighted);
        }
      } // Parts are needed for highlighting


      partsToText(parts) {
        if (parts && Array.isArray(parts) && parts.length > 0) {
          return parts.map(part => part.text).join('');
        }

        return parts;
      }

      get rightIconSize() {
        return this.item.rightIconSize || 'small';
      }

      get iconSize() {
        return this.item.iconSize || 'small';
      }

      get text() {
        return this.partsToText(this.item.text);
      }

      get subText() {
        return this.partsToText(this.item.subText);
      }

      get hasSubText() {
        const subText = this.item.subText;
        return subText && subText.length > 0;
      }

    }

    lwc.registerDecorators(LightningBaseComboboxItem, {
      publicProps: {
        item: {
          config: 0
        }
      },
      publicMethods: ["highlight", "removeHighlight"]
    });

    var _lightningBaseComboboxItem = lwc.registerComponent(LightningBaseComboboxItem, {
      tmpl: _tmpl$1
    });

    function tmpl$k($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        gid: api_scoped_id,
        b: api_bind,
        h: api_element,
        d: api_dynamic,
        k: api_key,
        i: api_iterator,
        f: api_flatten
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14
      } = $ctx;
      return [api_element("div", {
        className: $cmp.computedDropdownTriggerClass,
        attrs: {
          "role": "combobox",
          "aria-expanded": $cmp.computedAriaExpanded,
          "aria-haspopup": "listbox"
        },
        key: 2,
        on: {
          "click": _m14 || ($ctx._m14 = api_bind($cmp.handleTriggerClick))
        }
      }, [api_element("div", {
        className: $cmp.computedFormElementClass,
        attrs: {
          "role": "none"
        },
        key: 3
      }, [$cmp.hasInputPill ? api_custom_element("lightning-icon", _lightningIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-combobox__input-entity-icon": true
        },
        props: {
          "iconName": $cmp.inputPill.iconName,
          "alternativeText": $cmp.inputPill.iconAlternativeText,
          "size": "x-small"
        },
        key: 5
      }, []) : null, api_element("input", {
        className: $cmp.computedInputClass,
        attrs: {
          "id": api_scoped_id("input"),
          "type": "text",
          "role": "textbox",
          "autocomplete": "off",
          "name": $cmp.name,
          "placeholder": $cmp.computedPlaceholder,
          "maxlength": $cmp.inputMaxlength,
          "aria-autocomplete": $cmp.computedAriaAutocomplete,
          "aria-label": $cmp.inputLabel
        },
        props: {
          "value": $cmp.computedInputValue,
          "disabled": $cmp.disabled,
          "readOnly": $cmp._inputReadOnly
        },
        key: 6,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
          "select": _m1 || ($ctx._m1 = api_bind($cmp.handleInputSelect)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleTextChange)),
          "input": _m3 || ($ctx._m3 = api_bind($cmp.handleInput)),
          "keydown": _m4 || ($ctx._m4 = api_bind($cmp.handleInputKeyDown)),
          "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleBlur))
        }
      }, []), $cmp.hasInputPill ? api_element("div", {
        classMap: {
          "slds-input__icon-group": true,
          "slds-input__icon-group_right": true
        },
        key: 8
      }, [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_icon": true,
          "slds-input__icon": true,
          "slds-input__icon_right": true
        },
        attrs: {
          "type": "button",
          "title": $cmp.i18n.pillCloseButtonAlternativeText
        },
        key: 9,
        on: {
          "click": _m6 || ($ctx._m6 = api_bind($cmp.handlePillRemove))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:close",
          "variant": "bare",
          "svgClass": "slds-button__icon"
        },
        key: 10
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 11
      }, [api_dynamic($cmp.i18n.pillCloseButtonAlternativeText)])])]) : null, !$cmp.hasInputPill ? api_element("div", {
        classMap: {
          "slds-input__icon-group": true,
          "slds-input__icon-group_right": true
        },
        key: 13
      }, [$cmp.showInputActivityIndicator ? api_element("div", {
        classMap: {
          "slds-spinner": true,
          "slds-spinner_brand": true,
          "slds-spinner_x-small": true,
          "slds-input__spinner": true
        },
        attrs: {
          "role": "status"
        },
        key: 15
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 16
      }, [api_dynamic($cmp.i18n.loadingText)]), api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 17
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 18
      }, [])]) : null, $cmp.inputIconName ? api_custom_element("lightning-icon", _lightningIcon, {
        classMap: {
          "slds-input__icon": true,
          "slds-input__icon_right": true
        },
        props: {
          "alternativeText": $cmp.inputIconAlternativeText,
          "iconName": $cmp.inputIconName,
          "size": $cmp.inputIconSize
        },
        key: 20
      }, []) : null]) : null]), api_element("div", {
        className: $cmp.computedDropdownClass,
        attrs: {
          "id": api_scoped_id("dropdown-element"),
          "data-dropdown-element": true,
          "role": "listbox"
        },
        key: 21,
        on: {
          "scroll": _m9 || ($ctx._m9 = api_bind($cmp.handleListboxScroll)),
          "mousedown": _m10 || ($ctx._m10 = api_bind($cmp.handleDropdownMouseDown)),
          "mouseup": _m11 || ($ctx._m11 = api_bind($cmp.handleDropdownMouseUp)),
          "mouseleave": _m12 || ($ctx._m12 = api_bind($cmp.handleDropdownMouseLeave)),
          "click": _m13 || ($ctx._m13 = api_bind($cmp.handleOptionClick))
        }
      }, $cmp._hasDropdownOpened ? api_flatten([api_iterator($cmp._items, function (item) {
        return [!item.items ? api_custom_element("lightning-base-combobox-item", _lightningBaseComboboxItem, {
          classMap: {
            "slds-media": true,
            "slds-listbox__option": true,
            "slds-media_center": true
          },
          attrs: {
            "data-item-id": item.id,
            "data-value": item.value
          },
          props: {
            "role": "option",
            "item": item,
            "id": api_scoped_id(item.id)
          },
          key: api_key(25, item.value),
          on: {
            "mouseenter": _m7 || ($ctx._m7 = api_bind($cmp.handleOptionMouseEnter))
          }
        }, []) : null, item.items ? api_element("ul", {
          attrs: {
            "role": "group",
            "aria-label": item.label
          },
          key: api_key(27, item.label)
        }, api_flatten([item.label ? api_element("li", {
          classMap: {
            "slds-listbox__item": true
          },
          attrs: {
            "role": "presentation"
          },
          key: 29
        }, [api_element("div", {
          classMap: {
            "slds-media": true,
            "slds-listbox__option": true,
            "slds-listbox__option_plain": true,
            "slds-media_small": true
          },
          attrs: {
            "role": "presentation"
          },
          key: 30
        }, [api_element("h3", {
          classMap: {
            "slds-text-title_caps": true
          },
          attrs: {
            "role": "presentation",
            "title": item.label
          },
          key: 31
        }, [api_dynamic(item.label)])])]) : null, api_iterator(item.items, function (groupItem) {
          return api_element("li", {
            classMap: {
              "slds-listbox__item": true
            },
            attrs: {
              "role": "presentation"
            },
            key: api_key(33, groupItem.value)
          }, [api_custom_element("lightning-base-combobox-item", _lightningBaseComboboxItem, {
            classMap: {
              "slds-media": true,
              "slds-listbox__option": true,
              "slds-media_center": true
            },
            attrs: {
              "data-item-id": groupItem.id,
              "data-value": groupItem.value
            },
            props: {
              "role": "option",
              "item": groupItem,
              "id": api_scoped_id(groupItem.id)
            },
            key: 34,
            on: {
              "mouseenter": _m8 || ($ctx._m8 = api_bind($cmp.handleOptionMouseEnter))
            }
          }, [])]);
        })])) : null];
      }), $cmp.showDropdownActivityIndicator ? api_element("div", {
        classMap: {
          "slds-listbox__item": true
        },
        attrs: {
          "role": "presentation"
        },
        key: 36
      }, [api_element("div", {
        classMap: {
          "slds-align_absolute-center": true,
          "slds-p-top_medium": true
        },
        key: 37
      }, [api_element("div", {
        classMap: {
          "slds-spinner": true,
          "slds-spinner_x-small": true,
          "slds-spinner_inline": true
        },
        attrs: {
          "role": "status"
        },
        key: 38
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 39
      }, [api_dynamic($cmp.i18n.loadingText)]), api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 40
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 41
      }, [])])])]) : null, $cmp.showAttribution ? api_element("div", {
        classMap: {
          "slds-align_absolute-center": true
        },
        key: 43
      }, [api_element("img", {
        classMap: {
          "slds-inline-logo": true
        },
        attrs: {
          "src": $cmp.attributionLogoUrl,
          "alt": $cmp.attributionLogoAssistiveText,
          "title": $cmp.attributionLogoAssistiveText
        },
        key: 44
      }, [])]) : null]) : [])])];
    }

    var _tmpl$j = lwc.registerTemplate(tmpl$k);
    tmpl$k.stylesheets = [];

    if (_implicitStylesheets$6) {
      tmpl$k.stylesheets.push.apply(tmpl$k.stylesheets, _implicitStylesheets$6);
    }
    tmpl$k.stylesheetTokens = {
      hostAttribute: "lightning-baseCombobox_baseCombobox-host",
      shadowAttribute: "lightning-baseCombobox_baseCombobox"
    };

    var labelAriaSelectedOptions = 'Selected Options:';

    var labelDeselectOptionKeyboard = 'Press delete or backspace to remove';

    var labelLoadingText = 'Loading';

    var labelPillCloseButtonAlternativeText = 'Clear Selection';

    function preventDefaultAndStopPropagation$2(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    function handleEnterKey({
      event,
      currentIndex,
      dropdownInterface
    }) {
      preventDefaultAndStopPropagation$2(event);

      if (dropdownInterface.isDropdownVisible() && currentIndex >= 0) {
        dropdownInterface.selectByIndex(currentIndex);
      } else {
        dropdownInterface.openDropdownIfNotEmpty();
      }
    }

    function handlePageUpOrDownKey({
      event,
      currentIndex,
      dropdownInterface
    }) {
      preventDefaultAndStopPropagation$2(event);

      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }

      const pageUpDownOptionSkipCount = 10;

      if (dropdownInterface.getTotalOptions() > 0) {
        requestAnimationFrame(() => {
          let highlightIndex = 0;

          if (event.key === 'PageUp') {
            highlightIndex = Math.max(currentIndex - pageUpDownOptionSkipCount, 0);
          } else {
            // Jump 10 options down
            highlightIndex = Math.min(currentIndex + pageUpDownOptionSkipCount, dropdownInterface.getTotalOptions() - 1);
          }

          dropdownInterface.highlightOptionWithIndex(highlightIndex);
        });
      }
    }

    function handleHomeOrEndKey({
      event,
      dropdownInterface
    }) {
      // If not a read-only input we want the default browser behaviour
      if (!dropdownInterface.isInputReadOnly()) {
        return;
      }

      preventDefaultAndStopPropagation$2(event);

      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }

      if (dropdownInterface.getTotalOptions() > 0) {
        requestAnimationFrame(() => {
          const highlightIndex = event.key === 'Home' ? 0 : dropdownInterface.getTotalOptions() - 1;
          dropdownInterface.highlightOptionWithIndex(highlightIndex);
        });
      }
    }

    function handleUpOrDownKey({
      event,
      currentIndex,
      dropdownInterface
    }) {
      preventDefaultAndStopPropagation$2(event);

      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }

      const isUpKey = event.key === 'Up' || event.key === 'ArrowUp';
      let nextIndex;

      if (currentIndex >= 0) {
        nextIndex = isUpKey ? currentIndex - 1 : currentIndex + 1;

        if (nextIndex >= dropdownInterface.getTotalOptions()) {
          nextIndex = 0;
        } else if (nextIndex < 0) {
          nextIndex = dropdownInterface.getTotalOptions() - 1;
        }
      } else {
        nextIndex = isUpKey ? dropdownInterface.getTotalOptions() - 1 : 0;
      }

      if (dropdownInterface.getTotalOptions() > 0) {
        requestAnimationFrame(() => {
          dropdownInterface.highlightOptionWithIndex(nextIndex);
        });
      }
    }

    function handleEscapeOrTabKey({
      event,
      dropdownInterface
    }) {
      if (dropdownInterface.isDropdownVisible()) {
        event.stopPropagation();
        dropdownInterface.closeDropdown();
      }
    }

    function handleTypedCharacters({
      event,
      currentIndex,
      dropdownInterface
    }) {
      if (!dropdownInterface.isDropdownVisible()) {
        dropdownInterface.openDropdownIfNotEmpty();
      }

      if (dropdownInterface.isInputReadOnly()) {
        // The element should be read only, it's a work-around for IE11 as it will still make editable an input
        // that has focus and was dynamically changed to be readonly on focus change. Remove once we no longer
        // support IE11
        event.preventDefault();
        requestAnimationFrame(() => runActionOnBufferedTypedCharacters(event, dropdownInterface.highlightOptionWithText.bind(this, currentIndex || 0)));
      }
    }

    const eventKeyToHandlerMap = {
      Enter: handleEnterKey,
      PageUp: handlePageUpOrDownKey,
      PageDown: handlePageUpOrDownKey,
      Home: handleHomeOrEndKey,
      End: handleHomeOrEndKey,
      Down: handleUpOrDownKey,
      // IE11/Edge specific
      Up: handleUpOrDownKey,
      // IE11/Edge specific
      ArrowUp: handleUpOrDownKey,
      ArrowDown: handleUpOrDownKey,
      Esc: handleEscapeOrTabKey,
      // IE11/Edge specific
      Escape: handleEscapeOrTabKey,
      Tab: handleEscapeOrTabKey
    };
    function handleKeyDownOnInput({
      event,
      currentIndex,
      dropdownInterface
    }) {
      const parameters = {
        event,
        currentIndex,
        dropdownInterface
      };

      if (eventKeyToHandlerMap[event.key]) {
        eventKeyToHandlerMap[event.key](parameters);
      } else {
        handleTypedCharacters(parameters);
      }
    }

    class BaseComboboxEvents {
      constructor(baseCombobox) {
        this.dispatchEvent = baseCombobox.dispatchEvent.bind(baseCombobox);
      }

      dispatchPillRemove(pill) {
        this.dispatchEvent(new CustomEvent('pillremove', {
          detail: {
            item: pill
          }
        }));
      }

      dispatchEndReached() {
        this.dispatchEvent(new CustomEvent('endreached'));
      }

      dispatchFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      dispatchBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }

      dispatchTextInput(text) {
        this.dispatchEvent(new CustomEvent('textinput', {
          detail: {
            text
          }
        }));
      }

      dispatchTextChange(text) {
        this.dispatchEvent(new CustomEvent('textchange', {
          detail: {
            text
          }
        }));
      }

      dispatchSelect(value) {
        this.dispatchEvent(new CustomEvent('select', {
          detail: {
            value
          }
        }));
      }

      dispatchDropdownOpen() {
        this.dispatchEvent(new CustomEvent('dropdownopen'));
      }

      dispatchDropdownOpenRequest() {
        this.dispatchEvent(new CustomEvent('dropdownopenrequest'));
      }

    }

    const i18n$7 = {
      ariaSelectedOptions: labelAriaSelectedOptions,
      deselectOptionKeyboard: labelDeselectOptionKeyboard,
      pillCloseButtonAlternativeText: labelPillCloseButtonAlternativeText,
      loadingText: labelLoadingText
    };
    const SMALL_MIN_HEIGHT = '2.25rem';
    const MEDIUM_MIN_HEIGHT = '6.75rem';
    const ARIA_CONTROLS$1 = 'aria-controls';
    const ARIA_LABELLEDBY$1 = 'aria-labelledby';
    const ARIA_DESCRIBEDBY$2 = 'aria-describedby';
    const ARIA_LABEL$1 = 'aria-label';
    const ARIA_ACTIVEDESCENDANT = 'aria-activedescendant';

    class LightningBaseCombobox extends lwc.LightningElement {
      constructor() {
        super();
        this.inputText = '';
        this.inputIconName = 'utility:down';
        this.inputIconSize = 'x-small';
        this.inputIconAlternativeText = void 0;
        this.inputMaxlength = void 0;
        this.showInputActivityIndicator = false;
        this.dropdownAlignment = 'left';
        this.placeholder = 'Select an Item';
        this.inputLabel = void 0;
        this.name = void 0;
        this.inputPill = void 0;
        this.attributionLogoUrl = void 0;
        this.attributionLogoAssistiveText = void 0;
        this._showDropdownActivityIndicator = false;
        this._items = [];
        this._disabled = false;
        this._dropdownVisible = false;
        this._hasDropdownOpened = false;
        this._highlightedOptionElementId = null;
        this._variant = void 0;
        this._dropdownHeight = 'standard';
        this._readonly = false;
        this._logoLoaded = false;
        this._inputDescribedBy = [];
        this._inputAriaControls = void 0;
        this._activeElementDomId = void 0;
        this._events = new BaseComboboxEvents(this);
      }

      renderedCallback() {
        this.dispatchEvent(new CustomEvent('ready', {
          detail: {
            id: this.inputId,
            name: this.name
          }
        }));
        this.synchronizeA11y();
      }

      connectedCallback() {
        this.classList.add('slds-combobox_container');
        this._connected = true;
        this._keyboardInterface = this.dropdownKeyboardInterface();
      }

      disconnectedCallback() {
        this._connected = false;
        this._listBoxElementCache = undefined;
      }

      get inputControlsElement() {
        return this._inputAriaControls;
      }

      set inputControlsElement(el) {
        this._inputAriaControls = el;
        this.synchronizeA11y();
      }

      get inputDescribedByElements() {
        return this._inputDescribedBy;
      }

      set inputDescribedByElements(elements) {
        if (Array.isArray(elements)) {
          this._inputDescribedBy = elements;
        } else {
          this._inputDescribedBy = [elements];
        }

        this.synchronizeA11y();
      }

      get inputLabelledByElement() {
        return this._inputLabelledBy;
      }

      set inputLabelledByElement(el) {
        this._inputLabelledBy = el;
        this.synchronizeA11y();
      }

      get inputLabelledById() {
        return getRealDOMId(this._inputLabelledBy);
      }

      get inputAriaControlsId() {
        return getRealDOMId(this._inputAriaControls);
      }

      get inputId() {
        return getRealDOMId(this.template.querySelector('input'));
      }

      get computedAriaDescribedBy() {
        const ariaValues = [];

        this._inputDescribedBy.forEach(el => {
          ariaValues.push(getRealDOMId(el));
        });

        return normalizeAriaAttribute(ariaValues);
      }

      get dropdownHeight() {
        return this._dropdownHeight;
      }

      set dropdownHeight(height) {
        this._dropdownHeight = normalizeString(height, {
          fallbackValue: 'standard',
          validValues: ['standard', 'small']
        });
      }

      get showDropdownActivityIndicator() {
        return this._showDropdownActivityIndicator;
      }

      set showDropdownActivityIndicator(value) {
        this._showDropdownActivityIndicator = normalizeBoolean(value);

        if (this._connected) {
          if (this._showDropdownActivityIndicator) {
            if (this._shouldOpenDropDown) {
              this.openDropdownIfNotEmpty();
            }
          } else if (this._dropdownVisible && this.isDropdownEmpty) {
            this.closeDropdown();
          }
        }
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);

        if (this._disabled && this._dropdownVisible) {
          this.closeDropdown();
        }
      }

      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);

        if (this._readonly && this._dropdownVisible) {
          this.closeDropdown();
        }
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeString(value, {
          fallbackValue: VARIANT.STANDARD,
          validValues: [VARIANT.STANDARD, 'lookup']
        });
      }

      get items() {
        return this._unprocessedItems;
      }

      set items(items = []) {
        this._unprocessedItems = items;

        if (this._connected) {
          if (this._hasDropdownOpened) {
            // The dropdown has already been opened at least once, so process the items immediately
            this.updateItems(items);

            if (this._dropdownVisible) {
              // The dropdown is visible but there are no items to show, close it
              if (this.isDropdownEmpty) {
                this.closeDropdown();
              } else {
                // We have new items, update highlight
                this.highlightDefaultItem(); // Since the items have changed, the positioning should be recomputed

                this.startDropdownAutoPositioning();
              }
            }
          }

          if (this._shouldOpenDropDown) {
            this.openDropdownIfNotEmpty();
          }
        }
      }

      highlightInputText() {
        if (this._connected) {
          // Safari has issues with invoking set selection range immediately in the 'focus' handler, instead
          // we'd be doing it in an animation frame. Remove the requestAnimationFrame once/if this is fixed
          // in Safari
          requestAnimationFrame(() => {
            const {
              inputElement
            } = this;
            inputElement.setSelectionRange(0, inputElement.value.length);
          });
        }
      }

      get showAttribution() {
        return this.attributionLogoUrl;
      }

      focus() {
        if (this._connected) {
          this.inputElement.focus();
        }
      }

      focusAndOpenDropdownIfNotEmpty() {
        if (this._connected) {
          if (!this._inputHasFocus) {
            this.focus();
          }

          this.openDropdownIfNotEmpty();
        }
      }

      blur() {
        if (this._connected) {
          this.inputElement.blur();
        }
      }

      synchronizeA11y() {
        const input = this.template.querySelector('input');

        if (!input) {
          return;
        }

        synchronizeAttrs(input, {
          [ARIA_LABELLEDBY$1]: this.inputLabelledById,
          [ARIA_DESCRIBEDBY$2]: this.computedAriaDescribedBy,
          [ARIA_ACTIVEDESCENDANT]: this._activeElementDomId,
          [ARIA_CONTROLS$1]: this.computedInputControls,
          [ARIA_LABEL$1]: this.inputLabel
        });
      }

      itemId(index) {
        return this.inputId + '-' + index;
      }

      itemIndexFromId(id) {
        // Extracts the index from an item id.
        return parseInt(id.substring(id.lastIndexOf('-') + 1), 10);
      }

      processItem(item) {
        const itemCopy = {}; // Supported item properties:
        // 'type' (string): option-inline, option-card
        // 'highlight' (boolean): Whether to highlight the item when dropdown opens
        // 'iconName': left icon name
        // 'iconSize': left icon size
        // 'iconAlternativeText': assistive text for the left icon
        // 'rightIconName': right icon name
        // 'rightIconSize': right icon size
        // 'rightIconAlternativeText': assistive text for the right icon
        // 'text': text to display
        // 'subText': sub-text to display (only option-card supports it)
        // 'value': value associated with the option

        itemCopy.type = item.type;
        itemCopy.iconName = item.iconName;
        itemCopy.iconSize = item.iconSize;
        itemCopy.iconAlternativeText = item.iconAlternativeText;
        itemCopy.rightIconName = item.rightIconName;
        itemCopy.rightIconSize = item.rightIconSize;
        itemCopy.rightIconAlternativeText = item.rightIconAlternativeText;
        itemCopy.text = item.text;
        itemCopy.subText = item.subText;
        itemCopy.value = item.value; // extra metadata needed

        itemCopy.selectable = ['option-card', 'option-inline'].indexOf(item.type) >= 0;

        if (itemCopy.selectable) {
          itemCopy.index = this._selectableItems;
          itemCopy.id = this.itemId(itemCopy.index);
          this._selectableItems += 1;

          if (item.highlight) {
            this._highlightedItemIndex = itemCopy.index;
          }
        }

        return itemCopy;
      }

      get _inputReadOnly() {
        return this._readonly || this.variant === VARIANT.STANDARD || this.hasInputPill;
      }

      get computedAriaAutocomplete() {
        if (this.hasInputPill) {
          // no aria-autocomplete when pill is showing
          return null;
        }

        return this._inputReadOnly ? 'none' : 'list';
      }

      get computedPlaceholder() {
        return this.hasInputPill ? this.inputPill.label : this.placeholder;
      }

      get computedInputValue() {
        return this.hasInputPill ? this.inputPill.label : this.inputText;
      }

      handleListboxScroll(event) {
        // We don't want this to bubble up to the modal which due to event retargeting wouldn't be able
        // to know what is actually being scrolled and thus may lead to the scrolling of the modal
        event.stopPropagation();
        const listbox = event.target;
        const height = listbox.getBoundingClientRect().height;
        const maxScroll = listbox.scrollHeight - height;
        const bottomReached = listbox.scrollTop >= maxScroll;

        if (bottomReached) {
          this._events.dispatchEndReached();
        }
      }

      get listboxElement() {
        if (!this._listBoxElementCache) {
          this._listBoxElementCache = this.template.querySelector('[role="listbox"]');
        }

        return this._listBoxElementCache;
      }

      get computedUniqueElementId() {
        return this.inputId;
      }

      get computedUniqueDropdownElementId() {
        return getRealDOMId(this.template.querySelector('[data-dropdown-element]'));
      }

      get computedInputControls() {
        const ariaValues = [this.computedUniqueDropdownElementId];

        if (this.inputControlsElement) {
          ariaValues.push(this.inputAriaControlsId);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get i18n() {
        return i18n$7;
      }

      get computedDropdownTriggerClass() {
        return classSet('slds-combobox slds-dropdown-trigger slds-dropdown-trigger_click').add({
          'slds-is-open': this._dropdownVisible
        }).toString();
      }

      get computedDropdownClass() {
        const alignment = this.dropdownAlignment;
        return classSet('slds-listbox slds-listbox_vertical slds-dropdown slds-dropdown_fluid').add({
          'slds-dropdown_length-with-icon-10': this._dropdownHeight === 'standard',
          'slds-dropdown_length-with-icon-5': this._dropdownHeight === 'small',
          'slds-dropdown_left': alignment === 'left' || alignment === 'auto',
          'slds-dropdown_center': alignment === 'center',
          'slds-dropdown_right': alignment === 'right',
          'slds-dropdown_bottom': alignment === 'bottom-center',
          'slds-dropdown_bottom slds-dropdown_right slds-dropdown_bottom-right': alignment === 'bottom-right',
          'slds-dropdown_bottom slds-dropdown_left slds-dropdown_bottom-left': alignment === 'bottom-left'
        }).toString();
      }

      get computedInputClass() {
        const classes = classSet('slds-input slds-combobox__input');

        if (this.hasInputPill) {
          classes.add('slds-combobox__input-value');
        } else {
          classes.add({
            'slds-input-has-icon_group-right': this.showInputActivityIndicator
          });
        }

        return classes.toString();
      }

      get _shouldOpenDropDown() {
        // If items were empty and through a user interaction the dropdown should have opened, and if the
        // component still has the focus we'll open it on items update instead.
        return !this.dropdownDisabled && this._inputHasFocus && this._requestedDropdownOpen;
      }

      get dropdownDisabled() {
        return this.readOnly || this.disabled;
      }

      handleOptionClick(event) {
        if (event.target.hasAttribute('aria-selected')) {
          event.stopPropagation();
          event.preventDefault();
          this.selectOptionAndCloseDropdown(event.target);
        }
      }

      handleOptionMouseEnter(event) {
        if (event.target.hasAttribute('aria-selected')) {
          this.highlightOption(event.target);
        }
      }

      handleDropdownMouseLeave() {
        this.removeHighlight(); // This is to account for when a user makes a mousedown press on the dropdown and then leaves the dropdown
        // area, it would leave the dropdown open even though the focus would no longer be on the input

        if (!this._inputHasFocus) {
          this.closeDropdown();
        }
      }

      handleTriggerClick(event) {
        event.stopPropagation();
        this.allowBlur();

        if (this.dropdownDisabled) {
          return;
        }

        if (!this.hasInputPill) {
          // toggle dropdown only for readonly combobox, only open the dropdown otherwise
          // if it's not already opened.
          if (this._inputReadOnly) {
            if (this._dropdownVisible) {
              this.closeDropdown();
            } else {
              this.openDropdownIfNotEmpty();
            }
          } else {
            this.openDropdownIfNotEmpty();
          }

          this.inputElement.focus();
        }
      }

      handlePillKeyDown(event) {
        if (this.dropdownDisabled) {
          return;
        } // 'Del' is IE11 specific, remove once IE11 is no longer supported


        if (event.key === 'Delete' || event.key === 'Del') {
          this.handlePillRemove();
        }
      }

      handleInputKeyDown(event) {
        if (this.dropdownDisabled) {
          return;
        }

        if (this.hasInputPill) {
          this.handlePillKeyDown(event);
        } else {
          handleKeyDownOnInput({
            event,
            currentIndex: this.getCurrentHighlightedOptionIndex(),
            dropdownInterface: this._keyboardInterface
          });
        }
      }

      handleTextChange() {
        this._events.dispatchTextChange(this.inputElement.value);
      }

      handleFocus() {
        this._inputHasFocus = true;

        this._events.dispatchFocus();
      }

      handleInput() {
        this._events.dispatchTextInput(this.inputElement.value);
      }

      handleBlur() {
        this._inputHasFocus = false;

        if (this._cancelBlur) {
          return;
        }

        this.closeDropdown();

        this._events.dispatchBlur();
      }

      handleDropdownMouseDown(event) {
        const mainButton = 0;

        if (event.button === mainButton) {
          this.cancelBlur();
        }
      }

      handleDropdownMouseUp() {
        // We need this to make sure that if a scrollbar is being dragged with the mouse, upon release
        // of the drag we allow blur, otherwise the dropdown would not close on blur since we'd have cancel blur
        // set
        this.allowBlur();
      }

      highlightOption(option) {
        this.removeHighlight();

        if (option) {
          option.highlight();
          this._highlightedOptionElement = option;
          this._highlightedOptionElementId = option.getAttribute('data-item-id'); // active element is a component id getter works properly

          this._activeElementDomId = option.id;
        }

        this.synchronizeA11y();
      }

      highlightOptionAndScrollIntoView(optionElement) {
        if (this._selectableItems.length === 0 || !optionElement) {
          return;
        }

        this.highlightOption(optionElement);
        scrollIntoViewIfNeeded(optionElement, this.listboxElement);
      }

      removeHighlight() {
        const option = this._highlightedOptionElement;

        if (option) {
          option.removeHighlight();
          this._highlightedOptionElement = null;
          this._highlightedOptionElementId = null;
          this._activeElementDomId = null;
        }
      }

      selectOptionAndCloseDropdown(optionElement) {
        this.closeDropdown();
        this.inputElement.focus();
        const value = optionElement.getAttribute('data-value');

        this._events.dispatchSelect(value);
      }

      handleInputSelect(event) {
        event.stopPropagation();
      }

      openDropdownIfNotEmpty() {
        if (this._dropdownVisible) {
          // Already visible
          return;
        }

        const noOptions = !Array.isArray(this.items) || this.items.length === 0;

        if (noOptions) {
          // Dispatch dropdown open request
          this._events.dispatchDropdownOpenRequest();
        } // Do not open if there's nothing to show in the dropdown (eg. no options and no dropdown activity indicator)


        if (this.isDropdownEmpty) {
          // We use this attribute to flag whether an attempt has been made via user-interaction
          // to open the dropdown
          this._requestedDropdownOpen = true;
          return;
        }

        if (!this._hasDropdownOpened) {
          if (this._unprocessedItems) {
            this.updateItems(this._unprocessedItems);
          }

          this._hasDropdownOpened = true;
        }

        this._requestedDropdownOpen = false;
        this._dropdownVisible = true;
        this.startDropdownAutoPositioning();
        this.highlightDefaultItem();

        this._events.dispatchDropdownOpen();
      }

      closeDropdown() {
        if (!this._dropdownVisible) {
          // Already closed
          return;
        }

        this.stopDropdownPositioning();
        this.removeHighlight();
        this._dropdownVisible = false;
      }

      findOptionElementByIndex(index) {
        return this.template.querySelector(`[data-item-id="${this.itemId(index)}"]`);
      }

      allowBlur() {
        this._cancelBlur = false;
      }

      cancelBlur() {
        this._cancelBlur = true;
      }

      getCurrentHighlightedOptionIndex() {
        if (this._highlightedOptionElementId && this._highlightedOptionElementId.length > 0) {
          return this.itemIndexFromId(this._highlightedOptionElementId);
        }

        return -1;
      }

      get inputElement() {
        return this.template.querySelector('input');
      }

      startDropdownAutoPositioning() {
        if (this.dropdownAlignment !== 'auto') {
          return;
        }

        if (!this._autoPosition) {
          this._autoPosition = new AutoPosition(this);
        }

        this._autoPosition.start({
          target: () => this.template.querySelector('input'),
          element: () => this.template.querySelector('div.slds-dropdown'),
          align: {
            horizontal: Direction.Left,
            vertical: Direction.Top
          },
          targetAlign: {
            horizontal: Direction.Left,
            vertical: Direction.Bottom
          },
          autoFlip: true,
          alignWidth: true,
          autoShrinkHeight: true,
          minHeight: this.isDropdownHeightSmall ? SMALL_MIN_HEIGHT : MEDIUM_MIN_HEIGHT
        });
      }

      stopDropdownPositioning() {
        if (this._autoPosition) {
          this._autoPosition.stop();
        }
      }

      get hasInputPill() {
        return this.inputPill && Object.keys(this.inputPill).length > 0;
      }

      handlePillRemove() {
        this.inputElement.focus();

        this._events.dispatchPillRemove(this.inputPill);
      }

      get computedFormElementClass() {
        const hasIcon = this.hasInputPill && this.inputPill.iconName;
        return classSet('slds-combobox__form-element slds-input-has-icon').add({
          'slds-input-has-icon_right': !hasIcon,
          'slds-input-has-icon_left-right': hasIcon
        }).toString();
      }

      get computedAriaExpanded() {
        return this._dropdownVisible ? 'true' : 'false';
      }

      updateItems(items) {
        if (!items) {
          return;
        }

        assert(Array.isArray(items), '"items" must be an array');
        this._selectableItems = 0;
        this._highlightedItemIndex = 0;
        this._items = items.map(item => {
          if (item.items) {
            // This is a group
            const groupCopy = {
              label: item.label
            };
            groupCopy.items = item.items.map(groupItem => {
              return this.processItem(groupItem);
            });
            return groupCopy;
          }

          return this.processItem(item);
        });
      }

      highlightDefaultItem() {
        this.removeHighlight();
        requestAnimationFrame(() => {
          this.highlightOptionAndScrollIntoView(this.findOptionElementByIndex(this._highlightedItemIndex));
        });
      }

      get isDropdownEmpty() {
        // If the activity indicator is showing then it's not empty
        return !this.showDropdownActivityIndicator && (!Array.isArray(this.items) || this.items.length === 0);
      }

      get isDropdownHeightSmall() {
        if (this.isDropdownEmpty) {
          return true;
        } // Check how many items could be present in dropdown.
        // >= 3, will be have MEDIUM_MIN_HEIGHT
        // < 3, will be have SMALL_MIN_HEIGHT


        let count = this._items ? this._items.length : 0;

        if (count === 1) {
          count += this._items[0].items ? this._items[0].items.length : 0;
        } else if (count === 2) {
          count += this._items[0].items ? this._items[0].items.length : 0;
          count += this._items[1].items ? this._items[1].items.length : 0;
        }

        return count < 3;
      }

      dropdownKeyboardInterface() {
        const that = this;
        return {
          getTotalOptions() {
            return that._selectableItems;
          },

          selectByIndex(index) {
            that.selectOptionAndCloseDropdown(that.findOptionElementByIndex(index));
          },

          highlightOptionWithIndex(index) {
            that.highlightOptionAndScrollIntoView(that.findOptionElementByIndex(index));
          },

          isInputReadOnly() {
            return that._inputReadOnly;
          },

          highlightOptionWithText(currentIndex, text) {
            // This only supports a flat structure, groups are not supported
            for (let index = currentIndex + 1; index < that._items.length; index++) {
              const option = that._items[index];

              if (option.selectable && option.text && option.text.toLowerCase().indexOf(text.toLowerCase()) === 0) {
                that.highlightOptionAndScrollIntoView(that.findOptionElementByIndex(index));
                return;
              }
            }

            for (let index = 0; index < currentIndex; index++) {
              const option = that._items[index];

              if (option.selectable && option.text && option.text.toLowerCase().indexOf(text.toLowerCase()) === 0) {
                that.highlightOptionAndScrollIntoView(that.findOptionElementByIndex(index));
                return;
              }
            }
          },

          isDropdownVisible() {
            return that._dropdownVisible;
          },

          openDropdownIfNotEmpty() {
            that.openDropdownIfNotEmpty();
          },

          closeDropdown() {
            that.closeDropdown();
          }

        };
      }

    }

    LightningBaseCombobox.delegatesFocus = true;

    lwc.registerDecorators(LightningBaseCombobox, {
      publicProps: {
        inputText: {
          config: 0
        },
        inputIconName: {
          config: 0
        },
        inputIconSize: {
          config: 0
        },
        inputIconAlternativeText: {
          config: 0
        },
        inputMaxlength: {
          config: 0
        },
        showInputActivityIndicator: {
          config: 0
        },
        dropdownAlignment: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        inputLabel: {
          config: 0
        },
        name: {
          config: 0
        },
        inputPill: {
          config: 0
        },
        attributionLogoUrl: {
          config: 0
        },
        attributionLogoAssistiveText: {
          config: 0
        },
        inputControlsElement: {
          config: 3
        },
        inputDescribedByElements: {
          config: 3
        },
        inputLabelledByElement: {
          config: 3
        },
        dropdownHeight: {
          config: 3
        },
        showDropdownActivityIndicator: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        variant: {
          config: 3
        },
        items: {
          config: 3
        }
      },
      publicMethods: ["highlightInputText", "focus", "focusAndOpenDropdownIfNotEmpty", "blur"],
      track: {
        _showDropdownActivityIndicator: 1,
        _items: 1,
        _disabled: 1,
        _dropdownVisible: 1,
        _hasDropdownOpened: 1,
        _highlightedOptionElementId: 1,
        _variant: 1,
        _dropdownHeight: 1,
        _readonly: 1,
        _logoLoaded: 1
      }
    });

    var _lightningBaseCombobox = lwc.registerComponent(LightningBaseCombobox, {
      tmpl: _tmpl$j
    });

    function scrollIntoViewIfNeeded(element, scrollingParent) {
      const parentRect = scrollingParent.getBoundingClientRect();
      const findMeRect = element.getBoundingClientRect();

      if (findMeRect.top < parentRect.top) {
        if (element.offsetTop + findMeRect.height < parentRect.height) {
          // If element fits by scrolling to the top, then do that
          scrollingParent.scrollTop = 0;
        } else {
          // Otherwise, top align the element
          scrollingParent.scrollTop = element.offsetTop;
        }
      } else if (findMeRect.bottom > parentRect.bottom) {
        // bottom align the element
        scrollingParent.scrollTop += findMeRect.bottom - parentRect.bottom;
      }
    }

    function tmpl$l($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        gid: api_scoped_id
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        key: 2
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 4
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 5
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 6
      }, [api_custom_element("lightning-base-combobox", _lightningBaseCombobox, {
        props: {
          "dropdownHeight": "small",
          "name": $cmp.name,
          "variant": "lookup",
          "placeholder": $cmp.placeholder,
          "disabled": $cmp.disabled,
          "readOnly": $cmp.readOnly,
          "items": $cmp.items,
          "inputText": $cmp.displayValue,
          "inputIconName": "utility:clock",
          "inputLabel": $cmp.ariaLabel,
          "inputControlsElement": $cmp.ariaControlsElement,
          "inputLabelledByElement": $cmp.ariaLabelledByElement,
          "dropdownAlignment": "auto"
        },
        key: 7,
        on: {
          "ready": _m0 || ($ctx._m0 = api_bind($cmp.handleReady)),
          "textchange": _m1 || ($ctx._m1 = api_bind($cmp.handleInputChange)),
          "textinput": _m2 || ($ctx._m2 = api_bind($cmp.handleTextInput)),
          "dropdownopenrequest": _m3 || ($ctx._m3 = api_bind($cmp.handleDropdownOpenRequest)),
          "focus": _m4 || ($ctx._m4 = api_bind($cmp.handleFocus)),
          "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleBlur)),
          "select": _m6 || ($ctx._m6 = api_bind($cmp.handleTimeSelect))
        }
      }, [])]), $cmp._errorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("error-message"),
          "data-error-message": true,
          "aria-live": "assertive"
        },
        key: 9
      }, [api_dynamic($cmp._errorMessage)]) : null];
    }

    var _tmpl$k = lwc.registerTemplate(tmpl$l);
    tmpl$l.stylesheets = [];
    tmpl$l.stylesheetTokens = {
      hostAttribute: "lightning-timepicker_timepicker-host",
      shadowAttribute: "lightning-timepicker_timepicker"
    };

    /* returns the closes time in the list that should be highlighted in case the value is not in the list. E.g.
    - if value is 16:18 and the list has 15 minute intervals, returns 16:30
    */

    function getTimeToHighlight(value, step) {
      const selectedTime = parseTime(value);

      if (!selectedTime) {
        return null;
      }

      selectedTime.setSeconds(0, 0);
      let closestHour = selectedTime.getHours();
      let closestMinute = selectedTime.getMinutes();
      const mod = closestMinute % step;
      const quotient = Math.floor(closestMinute / step);

      if (mod !== 0) {
        const multiplier = mod < step / 2 ? quotient : quotient + 1;
        closestMinute = multiplier * step;

        if (closestMinute >= 60) {
          if (closestHour === 23) {
            closestMinute -= step;
          } else {
            closestMinute = 0;
            closestHour++;
          }
        }

        selectedTime.setHours(closestHour);
        selectedTime.setMinutes(closestMinute);
      }

      return formatTime(selectedTime, STANDARD_TIME_FORMAT);
    }

    const i18n$8 = {
      invalidDate: labelInvalidDate,
      rangeOverflow: labelRangeOverflow$1,
      rangeUnderflow: labelRangeUnderflow$1,
      required: labelRequired
    };
    const STEP = 15; // in minutes

    const TIME_STYLE = {
      SHORT: 'short',
      MEDIUM: 'medium',
      LONG: 'long'
    };

    class LightningTimePicker extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._disabled = false;
        this._required = false;
        this._displayValue = null;
        this._value = null;
        this._items = [];
        this._fieldLevelHelp = void 0;
        this._variant = 'lookup';
        this._mainInputId = void 0;
        this._errorMessage = void 0;
        this._readonly = true;
        this._describedByElements = [];
        this.label = void 0;
        this.name = void 0;
        this.max = void 0;
        this.min = void 0;
        this.placeholder = '';
        this.ariaLabelledByElement = void 0;
        this.ariaControlsElement = void 0;
        this.ariaLabel = void 0;
        this.messageWhenValueMissing = void 0;
        this._ariaDescribedByElements = void 0;
      }

      get messageWhenBadInput() {
        return this._messageWhenBadInput || this.formatString(i18n$8.invalidDate, this.timeFormat);
      }

      set messageWhenBadInput(message) {
        this._messageWhenBadInput = message;
      }

      get messageWhenRangeOverflow() {
        // using isoValue since the manually entered time could have seconds/milliseconds and the locale format generally doesn't have this precision
        return this._messageWhenRangeOverflow || this.formatString(i18n$8.rangeOverflow, normalizeISOTime(this.max, this.timeFormat).isoValue);
      }

      set messageWhenRangeOverflow(message) {
        this._messageWhenRangeOverflow = message;
      }

      get messageWhenRangeUnderflow() {
        return this._messageWhenRangeUnderflow || this.formatString(i18n$8.rangeUnderflow, normalizeISOTime(this.min, this.timeFormat).isoValue);
      }

      set messageWhenRangeUnderflow(message) {
        this._messageWhenRangeUnderflow = message;
      }

      set ariaDescribedByElements(el) {
        if (Array.isArray(el)) {
          this._ariaDescribedByElements = el;
        } else {
          this.ariaDescribedByElements = [el];
        }
      }

      get ariaDescribedByElements() {
        return this._ariaDescribedByElements;
      }

      get value() {
        return this._value;
      }

      set value(newValue) {
        const normalizedValue = this.normalizeInputValue(newValue);

        if (normalizedValue !== this._value) {
          const normalizedTime = normalizeISOTime(normalizedValue, this.timeFormat);
          this._value = normalizedTime.isoValue;
          this._displayValue = normalizedTime.displayValue;
        }
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);

        if (this._readonly) {
          this._variant = VARIANT.STANDARD;
        }
      }

      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      hasBadInput() {
        return !!this._displayValue && this._value === null;
      }

      showHelpMessage(message) {
        if (!message) {
          this.classList.remove('slds-has-error');
          this._errorMessage = '';
        } else {
          this.classList.add('slds-has-error');
          this._errorMessage = message;
        }
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant$1(value);
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (this.connected) {
          this.getCombobox().focus();
        }
      }
      /**
       * Removes keyboard focus from the input element.
       */


      blur() {
        if (this.connected) {
          this.getCombobox().blur();
        }
      }

      get timeStyle() {
        return this._timeStyle;
      }

      set timeStyle(value) {
        this._timeStyle = normalizeString(value, {
          fallbackValue: TIME_STYLE.SHORT,
          validValues: [TIME_STYLE.SHORT, TIME_STYLE.MEDIUM, TIME_STYLE.LONG]
        });
        this.timeFormat = this.getTimeFormatFromStyle(this._timeStyle);
        const normalizedDate = normalizeISOTime(this._value, this.timeFormat);
        this._displayValue = normalizedDate.displayValue;
      }

      connectedCallback() {
        this.connected = true;
      }

      disconnectedCallback() {
        this.connected = false;
      }

      synchronizeA11y() {
        const label = this.template.querySelector('label');
        const comboBox = this.template.querySelector('lightning-base-combobox');
        let describedByElements = [];

        if (this._ariaDescribedByElements) {
          describedByElements = describedByElements.concat(this._ariaDescribedByElements);
        }

        const errorMessage = this.template.querySelector('[data-error-message]');

        if (errorMessage) {
          describedByElements.push(errorMessage);
        }

        comboBox.inputDescribedByElements = describedByElements;
        synchronizeAttrs(label, {
          for: this._mainInputId
        });
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      get displayValue() {
        return this._displayValue;
      }

      get items() {
        return this._items;
      }

      get i18n() {
        return i18n$8;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      handleReady(e) {
        this._mainInputId = e.detail.id;
      }

      buildTimeList() {
        // We should always display the options in the short style since m/l will add an extra :00 to the options.
        const optionsTimeFormat = configProvider.getLocale().shortTimeFormat;
        const timeList = [];
        const minTime = parseTime(this.normalizeInputValue(this.min));
        const minHour = minTime ? minTime.getHours() : 0;
        const maxTime = parseTime(this.normalizeInputValue(this.max));
        const maxHour = maxTime ? maxTime.getHours() + 1 : 24;
        const date = new Date();

        for (let hour = minHour; hour < maxHour; hour++) {
          for (let minutes = 0; minutes < 60; minutes += STEP) {
            date.setHours(hour, minutes);
            date.setSeconds(0, 0);

            if (this.isBeforeMinTime(date, minTime)) {
              continue; // eslint-disable-line no-continue
            }

            if (this.isAfterMaxTime(date, maxTime)) {
              break;
            } // @todo: should we always display it short in the combobox given that it makes no sense?


            timeList.push({
              type: 'option-inline',
              text: this.format(date, optionsTimeFormat),
              value: this.format(date)
            });
          }
        }

        return timeList;
      }

      get timeList() {
        if (!this._timeList) {
          this._timeList = this.buildTimeList();
        }

        if (!this._value) {
          return this._timeList;
        }

        const timeToHighlight = getTimeToHighlight(this._value, STEP);

        const timeList = this._timeList.map(item => {
          const itemCopy = Object.assign({}, item);

          if (item.value === this._value) {
            itemCopy.iconName = 'utility:check';
          }

          if (item.value === timeToHighlight) {
            itemCopy.highlight = true;
          }

          return itemCopy;
        });

        return timeList;
      }

      get timeFormat() {
        if (!this._timeFormat) {
          this._timeFormat = this.getTimeFormatFromStyle();
        }

        return this._timeFormat;
      }

      set timeFormat(value) {
        this._timeFormat = value;
      }

      getCombobox() {
        return this.template.querySelector('lightning-base-combobox');
      }

      handleFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleInputChange(event) {
        event.preventDefault();
        event.stopPropagation(); // keeping the display value in sync with the element's value

        this._displayValue = event.detail.text;
        this._value = this.parseFormattedTime(this._displayValue);
        this._items = this.timeList;
        this.dispatchChangeEvent();
      }

      handleTextInput(event) {
        event.preventDefault();
        event.stopPropagation(); // keeping the display value in sync with the element's value

        this._displayValue = event.detail.text;
      }

      handleTimeSelect(event) {
        event.stopPropagation(); // for some reason this event is fired without detail from grouped-combobox

        if (!event.detail) {
          return;
        }

        this._value = event.detail.value;
        this._displayValue = normalizeISOTime(this._value, this.timeFormat).displayValue;
        this._items = this.timeList;
        this.dispatchChangeEvent();
      }

      handleDropdownOpenRequest() {
        this._items = this.timeList;
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._value
          }
        }));
      }

      normalizeInputValue(value) {
        if (!value || value === '') {
          return null;
        }

        return removeTimeZoneSuffix(value);
      }

      format(date, formatString) {
        return formatTime(date, formatString || STANDARD_TIME_FORMAT);
      }

      isBeforeMinTime(date, minTime) {
        const minDate = minTime || parseTime(this.normalizeInputValue(this.min));
        return minDate ? isBefore(date, minDate, 'minute') : false;
      }

      isAfterMaxTime(date, maxTime) {
        const maxDate = maxTime || parseTime(this.normalizeInputValue(this.max));
        return maxDate ? isAfter(date, maxDate, 'minute') : false;
      }

      getTimeFormatFromStyle(timeStyle) {
        let timeFormat;

        switch (timeStyle) {
          case TIME_STYLE.MEDIUM:
          case TIME_STYLE.LONG:
            timeFormat = configProvider.getLocale().timeFormat;
            break;

          default:
            timeFormat = configProvider.getLocale().shortTimeFormat;
            break;
        }

        return timeFormat;
      }

      get allowedTimeFormats() {
        // this method can't be static because at the time this file is interpreted,
        // getLocale don't have the injected Locale in the config provider.
        const locale = configProvider.getLocale(); // the locale.timeFormat is the medium format. Locale dont supports a large
        // time format at the moment.

        return [locale.timeFormat, locale.shortTimeFormat];
      }
      /**
       * Parses the input time and sets the timeFormat used to parse the displayValue
       * if it is a valid time.
       *
       * @param {String} displayValue - The input date.
       * @return {null | string} - A normalized formatted time if displayValue is valid. null otherwise.
       */


      parseFormattedTime(displayValue) {
        const allowedFormats = this.allowedTimeFormats;
        const n = allowedFormats.length;
        let i = 0,
            value = null;

        do {
          value = normalizeFormattedTime(displayValue, allowedFormats[i]);
          i++;
        } while (value === null && i < n);

        if (value !== null) {
          this.timeFormat = allowedFormats[i - 1];
        }

        return value;
      }

      formatString(str, ...args) {
        return str.replace(/{(\d+)}/g, (match, i) => {
          return args[i];
        });
      }

    }

    LightningTimePicker.delegatesFocus = true;

    lwc.registerDecorators(LightningTimePicker, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        max: {
          config: 0
        },
        min: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        ariaLabelledByElement: {
          config: 0
        },
        ariaControlsElement: {
          config: 0
        },
        ariaLabel: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageWhenBadInput: {
          config: 3
        },
        messageWhenRangeOverflow: {
          config: 3
        },
        messageWhenRangeUnderflow: {
          config: 3
        },
        ariaDescribedByElements: {
          config: 3
        },
        value: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        timeStyle: {
          config: 3
        }
      },
      publicMethods: ["hasBadInput", "showHelpMessage", "focus", "blur"],
      track: {
        _disabled: 1,
        _required: 1,
        _displayValue: 1,
        _value: 1,
        _items: 1,
        _fieldLevelHelp: 1,
        _variant: 1,
        _mainInputId: 1,
        _errorMessage: 1,
        _readonly: 1,
        _describedByElements: 1
      }
    });

    var _lightningTimepicker = lwc.registerComponent(LightningTimePicker, {
      tmpl: _tmpl$k
    });

    function tmpl$m($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        gid: api_scoped_id
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-form": true,
          "slds-form_compound": true
        },
        attrs: {
          "tabindex": "-1"
        },
        key: 2
      }, [api_element("fieldset", {
        classMap: {
          "slds-form-element": true
        },
        key: 3
      }, [api_element("legend", {
        className: $cmp.computedLabelClass,
        key: 4
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 6
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 7
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 8
      }, [api_element("div", {
        classMap: {
          "slds-form-element__group": true
        },
        key: 9
      }, [api_element("div", {
        classMap: {
          "slds-form-element__row": true
        },
        key: 10
      }, [api_custom_element("lightning-datepicker", _lightningDatepicker, {
        classMap: {
          "slds-form-element": true
        },
        props: {
          "value": $cmp.dateValue,
          "min": $cmp.dateMin,
          "max": $cmp.dateMax,
          "label": $cmp.i18n.date,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "placeholder": $cmp.placeholder,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled,
          "autocomplete": $cmp.autocomplete,
          "dateStyle": $cmp.dateStyle
        },
        key: 11,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleDatepickerFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleDatepickerBlur)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleDateChange))
        }
      }, []), api_custom_element("lightning-timepicker", _lightningTimepicker, {
        classMap: {
          "slds-form-element": true
        },
        props: {
          "value": $cmp.timeValue,
          "label": $cmp.i18n.time,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "timeStyle": $cmp.timeStyle,
          "placeholder": $cmp.placeholder,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 12,
        on: {
          "focus": _m3 || ($ctx._m3 = api_bind($cmp.handleTimepickerFocus)),
          "blur": _m4 || ($ctx._m4 = api_bind($cmp.handleTimepickerBlur)),
          "change": _m5 || ($ctx._m5 = api_bind($cmp.handleTimeChange))
        }
      }, [])])])]), $cmp.customErrorMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "data-error-message": true,
          "id": api_scoped_id("errormessage"),
          "aria-live": "assertive"
        },
        key: 14
      }, [api_dynamic($cmp.customErrorMessage)]) : null])])];
    }

    var _tmpl$l = lwc.registerTemplate(tmpl$m);
    tmpl$m.stylesheets = [];
    tmpl$m.stylesheetTokens = {
      hostAttribute: "lightning-datetimepicker_datetimepicker-host",
      shadowAttribute: "lightning-datetimepicker_datetimepicker"
    };

    var labelDate = 'Date';

    var labelTime = 'Time';

    const i18n$9 = {
      date: labelDate,
      rangeOverflow: labelRangeOverflow$1,
      rangeUnderflow: labelRangeUnderflow$1,
      required: labelRequired,
      time: labelTime
    };

    class LightningDateTimePicker extends lwc.LightningElement {
      // getters and setters necessary to trigger sync
      set timeAriaControls(val) {
        this._timeAriaControls = val;
        this.synchronizeA11y();
      }

      get timeAriaControls() {
        return this._timeAriaControls;
      }

      set timeAriaLabelledBy(val) {
        this._timeAriaLabelledBy = val;
        this.synchronizeA11y();
      }

      get timeAriaLabelledBy() {
        return this._timeAriaLabelledBy;
      }

      set timeAriaDescribedBy(val) {
        this._timeAriaDescribedBy = val;
        this.synchronizeA11y();
      }

      get timeAriaDescribedBy() {
        return this._timeAriaDescribedBy;
      }

      get messageWhenBadInput() {
        if (this._messageWhenBadInput) {
          return this._messageWhenBadInput;
        } else if (this.hasBadDateInput) {
          return this.getDatepicker().messageWhenBadInput;
        } else if (this.hasBadTimeInput) {
          return this.getTimepicker().messageWhenBadInput;
        }

        return null;
      }

      set messageWhenBadInput(message) {
        this._messageWhenBadInput = message;
      }

      get messageWhenRangeOverflow() {
        return this._messageWhenRangeOverflow || this.formatString(i18n$9.rangeOverflow, this.formattedMax);
      }

      set messageWhenRangeOverflow(message) {
        this._messageWhenRangeOverflow = message;
      }

      get messageWhenRangeUnderflow() {
        return this._messageWhenRangeUnderflow || this.formatString(i18n$9.rangeUnderflow, this.formattedMin);
      }

      set messageWhenRangeUnderflow(message) {
        this._messageWhenRangeUnderflow = message;
      }

      get max() {
        return this.maxValue;
      }

      set max(newValue) {
        this.maxValue = newValue;
        this.calculateFormattedMaxValue();
      }

      get min() {
        return this.minValue;
      }

      set min(newValue) {
        this.minValue = newValue;
        this.calculateFormattedMinValue();
      }

      get value() {
        return this._value;
      }

      set value(newValue) {
        const normalizedValue = this.normalizeInputValue(newValue);

        if (normalizedValue !== this._value) {
          if (!this.connected) {
            // we set the values in connectedCallback to make sure timezone is available.
            this._initialValue = normalizedValue;
            return;
          }

          this.setDateAndTimeValues(normalizedValue);
        }
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }

      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant$1(value);
      }
      /**
       * Sets focus on the date input element.
       */


      focus() {
        if (this.connected) {
          this.getDatepicker().focus();
        }
      }
      /**
       * Removes keyboard focus from the input elements.
       */


      blur() {
        if (this.connected) {
          this.getDatepicker().blur();
          this.getTimepicker().blur();
        }
      }

      hasBadInput() {
        return this.connected && (this.hasBadDateInput || this.hasBadTimeInput);
      }

      get hasBadDateInput() {
        return this.getDatepicker().hasBadInput();
      }

      get hasBadTimeInput() {
        const timeBadInput = this.getTimepicker().hasBadInput();
        const timeMissing = this.required && this._dateValue && !this._timeValue;
        return timeMissing || timeBadInput;
      }

      showHelpMessage(message) {
        if (!this.connected) {
          return;
        }

        if (!message) {
          this.clearHelpMessage();
          return;
        }

        if (this.hasBadDateInput && !this._messageWhenBadInput) {
          this.clearHelpMessage();
          this.getDatepicker().showHelpMessage(message);
          return;
        }

        if (this.hasBadTimeInput && !this._messageWhenBadInput) {
          this.clearHelpMessage();
          this.getTimepicker().showHelpMessage(message);
          return;
        }

        this.classList.add('slds-has-error');
        this._customErrorMessage = message;
      }

      clearHelpMessage() {
        this.classList.remove('slds-has-error');
        this._customErrorMessage = '';
        this.getDatepicker().showHelpMessage('');
        this.getTimepicker().showHelpMessage('');
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__legend slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get i18n() {
        return i18n$9;
      }

      get dateValue() {
        return this._dateValue;
      }

      get timeValue() {
        return this._timeValue;
      }

      get customErrorMessage() {
        return this._customErrorMessage;
      }

      get dateMin() {
        return this._dateMin;
      }

      get dateMax() {
        return this._dateMax;
      }

      get errorMessageElementId() {
        return getRealDOMId(this.template.querySelector('[data-error-message'));
      }

      get computedDateAriaDescribedBy() {
        const ariaValues = [];

        if (this.customErrorMessage) {
          ariaValues.push(this.errorMessageElementId);
        }

        if (this.dateAriaDescribedBy) {
          ariaValues.push(this.dateAriaDescribedBy);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedTimeAriaDescribedBy() {
        const ariaValues = [];

        if (this.customErrorMessage) {
          ariaValues.push(this.errorMessageElementId);
        }

        if (this.timeAriaDescribedBy) {
          ariaValues.push(this.timeAriaDescribedBy);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      constructor() {
        super();
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        this._fieldLevelHelp = void 0;
        this._variant = void 0;
        this._value = null;
        this._dateValue = null;
        this._timeValue = null;
        this._customErrorMessage = '';
        this._dateMin = void 0;
        this._dateMax = void 0;
        this.label = void 0;
        this.name = void 0;
        this.timezone = void 0;
        this.placeholder = '';
        this.dateStyle = void 0;
        this.timeStyle = void 0;
        this.timeAriaLabel = void 0;
        this.autocomplete = void 0;
        this.dateAriaControls = void 0;
        this.dateAriaLabel = void 0;
        this.dateAriaLabelledBy = void 0;
        this.dateAriaDescribedBy = void 0;
        this.messageWhenValueMissing = void 0;
        this.uniqueId = generateUniqueId();
      }

      synchronizeA11y() {
        const datepicker = this.template.querySelector('lightning-datepicker');
        const timepicker = this.template.querySelector('lightning-timepicker');

        if (datepicker) {
          synchronizeAttrs(datepicker, {
            ariaLabelledByElement: this.dateAriaLabelledBy,
            ariaDescribedByElements: this.computedDateAriaDescribedBy,
            ariaControlsElement: this.dateAriaControls,
            'aria-label': this.dateAriaLabel
          });
        }

        if (timepicker) {
          synchronizeAttrs(timepicker, {
            ariaLabelledByElement: this.timeAriaLabelledBy,
            ariaDescribedByElements: this.computedTimeAriaDescribedBy,
            ariaControlsElement: this.timeAriaControls,
            'aria-label': this.timeAriaLabel
          });
        }
      }

      connectedCallback() {
        this.classList.add('slds-form_compound');
        this.calculateFormattedMinValue();
        this.calculateFormattedMaxValue();
        this.connected = true; // we set the initial values here in order to make sure timezone is available.

        this.setDateAndTimeValues(this._initialValue);
        this.interactingState = new InteractingState();
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          this.dispatchEvent(new CustomEvent('blur'));
        });
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      disconnectedCallback() {
        this.connected = false;
      }

      getTimepicker() {
        return this.template.querySelector('lightning-timepicker');
      }

      getDatepicker() {
        return this.template.querySelector('lightning-datepicker');
      }

      handleDatepickerFocus() {
        this._dateFocus = true;
        this.interactingState.enter();
      }

      handleTimepickerFocus() {
        this._timeFocus = true;
        this.interactingState.enter();
      }

      handleDatepickerBlur() {
        this._dateFocus = false; // timepicker fires focus before datepicker fires blur

        if (!this._timeFocus) {
          this.interactingState.leave();
        }
      }

      handleTimepickerBlur() {
        this._timeFocus = false; // datepicker fires focus before timepicker fires blur

        if (!this._dateFocus) {
          this.interactingState.leave();
        }
      }

      handleDateChange(event) {
        event.stopPropagation(); // for some reason this event is fired without detail from listbox

        if (!event.detail) {
          return;
        }

        this._dateValue = event.detail.value;

        if (this._dateValue) {
          this._timeValue = this._timeValue || getCurrentTime(this.timezone);
        }

        this.updateValue();
      }

      handleTimeChange(event) {
        event.stopPropagation(); // for some reason this event is fired without detail from listbox

        if (!event.detail) {
          return;
        }

        this._timeValue = event.detail.value;
        this.updateValue();
      }

      updateValue() {
        const dateValue = this._dateValue;
        const timeValue = this._timeValue;

        if (dateValue && timeValue) {
          const dateTimeString = dateValue + TIME_SEPARATOR + timeValue;
          this._value = normalizeFormattedDateTime(dateTimeString, this.timezone);
          this.dispatchChangeEvent();
        } else if (!dateValue) {
          this._value = null;
          this._timeValue = null;
          this.dispatchChangeEvent();
        }
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._value
          }
        }));
      }

      normalizeInputValue(value) {
        if (!value || value === '') {
          return null;
        }

        return value;
      }

      setDateAndTimeValues(value) {
        const normalizedValue = normalizeISODateTime(value, this.timezone).isoValue;
        const isDateOnly = normalizedValue && value.indexOf(TIME_SEPARATOR) < 0;

        if (isDateOnly) {
          this._dateValue = value;
          this._value = this._dateValue;
          return;
        }

        const dateAndTime = this.separateDateTime(normalizedValue);
        this._dateValue = dateAndTime && dateAndTime[0];
        this._timeValue = dateAndTime && dateAndTime[1];
        this._value = normalizedValue;
      }

      calculateFormattedMinValue() {
        if (!this.min) {
          return;
        }

        const normalizedDate = normalizeISODateTime(this.min, this.timezone);
        this._dateMin = this.separateDateTime(normalizedDate.isoValue)[0];
        this.formattedMin = normalizedDate.displayValue;
      }

      calculateFormattedMaxValue() {
        if (!this.max) {
          return;
        }

        const normalizedDate = normalizeISODateTime(this.max, this.timezone);
        this._dateMax = this.separateDateTime(normalizedDate.isoValue)[0];
        this.formattedMax = normalizedDate.displayValue;
      }

      separateDateTime(isoString) {
        return typeof isoString === 'string' ? isoString.split(TIME_SEPARATOR) : null;
      }

      formatString(str, ...args) {
        return str.replace(/{(\d+)}/g, (match, i) => {
          return args[i];
        });
      }

    }

    LightningDateTimePicker.delegatesFocus = true;

    lwc.registerDecorators(LightningDateTimePicker, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        timezone: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        dateStyle: {
          config: 0
        },
        timeStyle: {
          config: 0
        },
        timeAriaLabel: {
          config: 0
        },
        autocomplete: {
          config: 0
        },
        timeAriaControls: {
          config: 3
        },
        timeAriaLabelledBy: {
          config: 3
        },
        timeAriaDescribedBy: {
          config: 3
        },
        dateAriaControls: {
          config: 0
        },
        dateAriaLabel: {
          config: 0
        },
        dateAriaLabelledBy: {
          config: 0
        },
        dateAriaDescribedBy: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageWhenBadInput: {
          config: 3
        },
        messageWhenRangeOverflow: {
          config: 3
        },
        messageWhenRangeUnderflow: {
          config: 3
        },
        max: {
          config: 3
        },
        min: {
          config: 3
        },
        value: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur", "hasBadInput", "showHelpMessage"],
      track: {
        _disabled: 1,
        _readonly: 1,
        _required: 1,
        _fieldLevelHelp: 1,
        _variant: 1,
        _value: 1,
        _dateValue: 1,
        _timeValue: 1,
        _customErrorMessage: 1,
        _dateMin: 1,
        _dateMax: 1
      }
    });

    var _lightningDatetimepicker = lwc.registerComponent(LightningDateTimePicker, {
      tmpl: _tmpl$l
    });

    function tmpl$n($api, $cmp, $slotset, $ctx) {
      const {
        h: api_element,
        t: api_text,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14,
        _m15,
        _m16,
        _m17,
        _m18,
        _m19,
        _m20,
        _m21,
        _m22,
        _m23,
        _m24,
        _m25,
        _m26,
        _m27,
        _m28,
        _m29,
        _m30,
        _m31,
        _m32,
        _m33,
        _m34,
        _m35,
        _m36,
        _m37,
        _m38,
        _m39,
        _m40
      } = $ctx;
      return [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "data-aria": true
        },
        key: 2
      }, []), $cmp.isTypeSimple ? api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "for": `${api_scoped_id("input")}`
        },
        key: 4
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 6
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]) : null, $cmp.isTypeSimple ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 7
      }, []) : null : null, $cmp.isTypeSimple ? api_element("div", {
        className: $cmp.computedFormElementClass,
        key: 8
      }, [api_element("input", {
        classMap: {
          "slds-input": true
        },
        attrs: {
          "type": $cmp._internalType,
          "id": api_scoped_id("input"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "autocomplete": $cmp.autocomplete,
          "max": $cmp.normalizedMax,
          "min": $cmp.normalizedMin,
          "step": $cmp.step,
          "maxlength": $cmp.maxLength,
          "minlength": $cmp.minLength,
          "pattern": $cmp.pattern,
          "placeholder": $cmp.placeholder,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 9,
        on: {
          "blur": _m0 || ($ctx._m0 = api_bind($cmp.handleBlur)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange)),
          "input": _m3 || ($ctx._m3 = api_bind($cmp.handleInput)),
          "keypress": _m4 || ($ctx._m4 = api_bind($cmp.handleKeyPress)),
          "touchend": _m5 || ($ctx._m5 = api_bind($cmp.handleTouchEnd))
        }
      }, []), $cmp.isTypeSearch ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:search",
          "variant": "bare",
          "svgClass": "slds-input__icon slds-input__icon_left slds-icon-text-default"
        },
        key: 11
      }, []) : null, $cmp.isTypeSearch ? api_element("div", {
        classMap: {
          "slds-input__icon-group": true,
          "slds-input__icon-group_right": true
        },
        key: 12
      }, [$cmp.isLoading ? api_element("div", {
        classMap: {
          "slds-spinner": true,
          "slds-spinner_brand": true,
          "slds-spinner_x-small": true,
          "slds-input__spinner": true
        },
        attrs: {
          "role": "status"
        },
        key: 14
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 15
      }, [api_dynamic($cmp.i18n.loading)]), api_element("div", {
        classMap: {
          "slds-spinner__dot-a": true
        },
        key: 16
      }, []), api_element("div", {
        classMap: {
          "slds-spinner__dot-b": true
        },
        key: 17
      }, [])]) : null, $cmp._showClearButton ? api_element("button", {
        classMap: {
          "slds-input__icon": true,
          "slds-input__icon_right": true,
          "slds-button": true,
          "slds-button_icon": true
        },
        attrs: {
          "data-element-id": "searchClear"
        },
        key: 19,
        on: {
          "blur": _m6 || ($ctx._m6 = api_bind($cmp.handleBlur)),
          "click": _m7 || ($ctx._m7 = api_bind($cmp.clearAndSetFocusOnInput))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:clear",
          "variant": "bare",
          "svgClass": "slds-button__icon"
        },
        key: 20
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 21
      }, [api_dynamic($cmp.i18n.clear)])]) : null]) : null]) : null, $cmp.isTypeToggle ? api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 23
      }, [api_element("label", {
        classMap: {
          "slds-checkbox_toggle": true,
          "slds-grid": true
        },
        attrs: {
          "for": `${api_scoped_id("checkbox-toggle")}`
        },
        key: 24
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 26
      }, [api_text("*")]) : null, api_element("span", {
        className: $cmp.computedLabelClass,
        key: 27
      }, [api_dynamic($cmp.label)]), api_element("input", {
        attrs: {
          "type": "checkbox",
          "id": api_scoped_id("checkbox-toggle"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 28,
        on: {
          "blur": _m8 || ($ctx._m8 = api_bind($cmp.handleBlur)),
          "focus": _m9 || ($ctx._m9 = api_bind($cmp.handleFocus)),
          "change": _m10 || ($ctx._m10 = api_bind($cmp.handleChange))
        }
      }, []), api_element("span", {
        classMap: {
          "slds-checkbox_faux_container": true
        },
        attrs: {
          "id": api_scoped_id("toggle-description"),
          "data-toggle-description": true,
          "aria-live": "assertive"
        },
        key: 29
      }, [api_element("span", {
        classMap: {
          "slds-checkbox_faux": true
        },
        key: 30
      }, []), api_element("span", {
        classMap: {
          "slds-checkbox_on": true
        },
        key: 31
      }, [api_dynamic($cmp.messageToggleActive)]), api_element("span", {
        classMap: {
          "slds-checkbox_off": true
        },
        key: 32
      }, [api_dynamic($cmp.messageToggleInactive)])])])]) : null, $cmp.isTypeCheckbox ? !$cmp.isStandardVariant ? api_element("label", {
        classMap: {
          "slds-checkbox__label": true
        },
        attrs: {
          "for": `${api_scoped_id("checkbox")}`
        },
        key: 35
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 37
      }, [api_text("*")]) : null, api_element("span", {
        className: $cmp.computedLabelClass,
        key: 38
      }, [api_dynamic($cmp.label)])]) : null : null, $cmp.isTypeCheckbox ? !$cmp.isStandardVariant ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 39
      }, []) : null : null : null, $cmp.isTypeCheckbox ? api_element("div", {
        className: $cmp.computedFormElementClass,
        key: 40
      }, [api_element("span", {
        className: $cmp.computedCheckboxClass,
        key: 41
      }, [$cmp.isStandardVariant ? $cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 44
      }, [api_text("*")]) : null : null, api_element("input", {
        attrs: {
          "type": "checkbox",
          "id": api_scoped_id("checkbox"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 45,
        on: {
          "blur": _m11 || ($ctx._m11 = api_bind($cmp.handleBlur)),
          "focus": _m12 || ($ctx._m12 = api_bind($cmp.handleFocus)),
          "change": _m13 || ($ctx._m13 = api_bind($cmp.handleChange))
        }
      }, []), !$cmp.isStandardVariant ? api_element("span", {
        classMap: {
          "slds-checkbox_faux": true
        },
        key: 47
      }, []) : null, $cmp.isStandardVariant ? api_element("label", {
        classMap: {
          "slds-checkbox__label": true
        },
        attrs: {
          "for": `${api_scoped_id("checkbox")}`
        },
        key: 49
      }, [api_element("span", {
        classMap: {
          "slds-checkbox_faux": true
        },
        key: 50
      }, []), api_element("span", {
        className: $cmp.computedLabelClass,
        key: 51
      }, [api_dynamic($cmp.label)])]) : null, $cmp.isStandardVariant ? $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 52
      }, []) : null : null])]) : null, $cmp.isTypeCheckboxButton ? api_element("div", {
        classMap: {
          "slds-checkbox_add-button": true
        },
        key: 54
      }, [api_element("input", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "type": "checkbox",
          "id": api_scoped_id("checkbox-button"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 55,
        on: {
          "blur": _m14 || ($ctx._m14 = api_bind($cmp.handleBlur)),
          "focus": _m15 || ($ctx._m15 = api_bind($cmp.handleFocus)),
          "change": _m16 || ($ctx._m16 = api_bind($cmp.handleChange))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-checkbox_faux": true
        },
        attrs: {
          "for": `${api_scoped_id("checkbox-button")}`
        },
        key: 56
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 57
      }, [api_dynamic($cmp.label)])])]) : null, $cmp.isTypeRadio ? api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 59
      }, [api_element("span", {
        classMap: {
          "slds-radio": true
        },
        key: 60
      }, [api_element("input", {
        attrs: {
          "type": "radio",
          "id": api_scoped_id("radio"),
          "accesskey": $cmp.accesskey,
          "name": $cmp.name
        },
        props: {
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 61,
        on: {
          "blur": _m17 || ($ctx._m17 = api_bind($cmp.handleBlur)),
          "focus": _m18 || ($ctx._m18 = api_bind($cmp.handleFocus)),
          "change": _m19 || ($ctx._m19 = api_bind($cmp.handleChange))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-radio__label": true
        },
        attrs: {
          "for": `${api_scoped_id("radio")}`
        },
        key: 62
      }, [api_element("span", {
        classMap: {
          "slds-radio_faux": true
        },
        key: 63
      }, []), api_element("span", {
        className: $cmp.computedLabelClass,
        key: 64
      }, [api_dynamic($cmp.label)])])])]) : null, $cmp.isTypeFile ? api_element("span", {
        className: $cmp.computedLabelClass,
        attrs: {
          "id": api_scoped_id("form-label"),
          "data-form-label": true
        },
        key: 66
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 68
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]) : null, $cmp.isTypeFile ? api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 69
      }, [api_element("div", {
        classMap: {
          "slds-file-selector": true,
          "slds-file-selector_files": true
        },
        key: 70,
        on: {
          "drop": _m24 || ($ctx._m24 = api_bind($cmp.handleDropFiles))
        }
      }, [api_custom_element("lightning-primitive-file-droppable-zone", _lightningPrimitiveFileDroppableZone, {
        props: {
          "multiple": $cmp.multiple,
          "disabled": $cmp.disabled
        },
        key: 71
      }, [api_element("input", {
        classMap: {
          "slds-file-selector__input": true,
          "slds-assistive-text": true
        },
        attrs: {
          "type": "file",
          "id": api_scoped_id("input-file"),
          "aria-label": $cmp.computedAriaLabel,
          "accesskey": $cmp.accesskey,
          "accept": $cmp.accept,
          "name": $cmp.name
        },
        props: {
          "multiple": $cmp.multiple,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled
        },
        key: 72,
        on: {
          "blur": _m20 || ($ctx._m20 = api_bind($cmp.handleBlur)),
          "click": _m21 || ($ctx._m21 = api_bind($cmp.handleFileClick)),
          "focus": _m22 || ($ctx._m22 = api_bind($cmp.handleFocus)),
          "change": _m23 || ($ctx._m23 = api_bind($cmp.handleChange))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-file-selector__body": true
        },
        attrs: {
          "id": api_scoped_id("file-selector-label"),
          "data-file-selector-label": true,
          "for": `${api_scoped_id("input-file")}`
        },
        key: 73
      }, [api_element("span", {
        classMap: {
          "slds-file-selector__button": true,
          "slds-button": true,
          "slds-button_neutral": true
        },
        key: 74
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:upload",
          "variant": "bare",
          "svgClass": "slds-button__icon slds-button__icon_left"
        },
        key: 75
      }, []), api_dynamic($cmp.i18n.inputFileButtonLabel)]), api_element("span", {
        classMap: {
          "slds-file-selector__text": true,
          "slds-medium-show": true
        },
        key: 76
      }, [api_dynamic($cmp.i18n.inputFileBodyText)])])])])]) : null, $cmp.isTypeColor ? api_element("div", {
        classMap: {
          "slds-color-picker": true
        },
        key: 78
      }, [api_element("div", {
        classMap: {
          "slds-color-picker__summary": true
        },
        key: 79
      }, [api_element("label", {
        className: $cmp.computedColorLabelClass,
        attrs: {
          "for": `${api_scoped_id("color")}`
        },
        key: 80
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 82
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), api_custom_element("lightning-primitive-colorpicker-button", _lightningPrimitiveColorpickerButton, {
        props: {
          "value": $cmp.value,
          "disabled": $cmp.disabled
        },
        key: 83,
        on: {
          "blur": _m25 || ($ctx._m25 = api_bind($cmp.handleBlur)),
          "focus": _m26 || ($ctx._m26 = api_bind($cmp.handleFocus)),
          "change": _m27 || ($ctx._m27 = api_bind($cmp.handleColorChange))
        }
      }, []), api_element("div", {
        classMap: {
          "slds-form-element": true,
          "slds-color-picker__summary-input": true
        },
        key: 84
      }, [api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 85
      }, [api_element("input", {
        classMap: {
          "slds-input": true,
          "slds-m-right_x-small": true
        },
        attrs: {
          "type": "text",
          "id": api_scoped_id("color"),
          "name": $cmp.name,
          "autocomplete": $cmp.autocomplete,
          "accesskey": $cmp.accesskey,
          "aria-label": $cmp.computedAriaLabel,
          "minlength": "4",
          "maxlength": "7",
          "placeholder": $cmp.placeholder,
          "pattern": $cmp.pattern
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 86,
        on: {
          "blur": _m28 || ($ctx._m28 = api_bind($cmp.handleBlur)),
          "focus": _m29 || ($ctx._m29 = api_bind($cmp.handleFocus)),
          "change": _m30 || ($ctx._m30 = api_bind($cmp.handleChange)),
          "input": _m31 || ($ctx._m31 = api_bind($cmp.handleInput))
        }
      }, [])])]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 87
      }, []) : null])]) : null, $cmp.isTypeDesktopDate ? api_custom_element("lightning-datepicker", _lightningDatepicker, {
        props: {
          "max": $cmp.max,
          "min": $cmp.min,
          "label": $cmp.label,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "ariaLabel": $cmp.ariaLabel,
          "dateStyle": $cmp.dateStyle,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "autocomplete": $cmp.autocomplete,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "messageWhenRangeOverflow": $cmp.messageWhenRangeOverflow,
          "messageWhenRangeUnderflow": $cmp.messageWhenRangeUnderflow,
          "disabled": $cmp.disabled
        },
        key: 89,
        on: {
          "change": _m32 || ($ctx._m32 = api_bind($cmp.handleChange)),
          "blur": _m33 || ($ctx._m33 = api_bind($cmp.handleBlur)),
          "focus": _m34 || ($ctx._m34 = api_bind($cmp.handleFocus))
        }
      }, []) : null, $cmp.isTypeDesktopTime ? api_custom_element("lightning-timepicker", _lightningTimepicker, {
        props: {
          "max": $cmp.max,
          "min": $cmp.min,
          "label": $cmp.label,
          "name": $cmp.name,
          "ariaLabel": $cmp.ariaLabel,
          "variant": $cmp.variant,
          "timeStyle": $cmp.timeStyle,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "messageWhenRangeOverflow": $cmp.messageWhenRangeOverflow,
          "messageWhenRangeUnderflow": $cmp.messageWhenRangeUnderflow,
          "disabled": $cmp.disabled
        },
        key: 91,
        on: {
          "change": _m35 || ($ctx._m35 = api_bind($cmp.handleChange)),
          "blur": _m36 || ($ctx._m36 = api_bind($cmp.handleBlur)),
          "focus": _m37 || ($ctx._m37 = api_bind($cmp.handleFocus))
        }
      }, []) : null, $cmp.isTypeDesktopDateTime ? api_custom_element("lightning-datetimepicker", _lightningDatetimepicker, {
        props: {
          "dateAriaControls": $cmp.dateAriaControls,
          "dateAriaLabel": $cmp.dateAriaLabel,
          "dateAriaLabelledBy": $cmp.dateAriaLabelledBy,
          "dateAriaDescribedBy": $cmp.dateAriaDescribedBy,
          "dateStyle": $cmp.dateStyle,
          "timeStyle": $cmp.timeStyle,
          "timeAriaControls": $cmp.timeAriaControls,
          "timeAriaLabel": $cmp.timeAriaLabel,
          "timeAriaLabelledBy": $cmp.timeAriaLabelledBy,
          "timeAriaDescribedBy": $cmp.timeAriaDescribedBy,
          "max": $cmp.max,
          "min": $cmp.min,
          "timezone": $cmp.timezone,
          "label": $cmp.label,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "placeholder": $cmp.placeholder,
          "required": $cmp.required,
          "readOnly": $cmp.readOnly,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "autocomplete": $cmp.autocomplete,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "messageWhenRangeOverflow": $cmp.messageWhenRangeOverflow,
          "messageWhenRangeUnderflow": $cmp.messageWhenRangeUnderflow,
          "disabled": $cmp.disabled
        },
        key: 93,
        on: {
          "change": _m38 || ($ctx._m38 = api_bind($cmp.handleChange)),
          "blur": _m39 || ($ctx._m39 = api_bind($cmp.handleBlur)),
          "focus": _m40 || ($ctx._m40 = api_bind($cmp.handleFocus))
        }
      }, []) : null, $cmp._helpMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("help-message"),
          "data-help-message": true,
          "role": "alert"
        },
        key: 95
      }, [api_dynamic($cmp._helpMessage)]) : null];
    }

    var _tmpl$m = lwc.registerTemplate(tmpl$n);
    tmpl$n.stylesheets = [];

    if (_implicitStylesheets$3) {
      tmpl$n.stylesheets.push.apply(tmpl$n.stylesheets, _implicitStylesheets$3);
    }
    tmpl$n.stylesheetTokens = {
      hostAttribute: "lightning-input_input-host",
      shadowAttribute: "lightning-input_input"
    };

    var labelInputFileBodyText = 'Or drop files';

    var labelInputFileButtonLabel = 'Upload Files';

    var labelMessageToggleActive = 'Active';

    var labelMessageToggleInactive = 'Inactive';

    var labelClearInput = 'Clear';

    var labelLoadingIndicator = 'Loading';

    function normalizeInput(value) {
      if (typeof value === 'number' || typeof value === 'string') {
        return value;
      }

      return '';
    }
    function normalizeDate(value) {
      return normalizeISODate(value).isoValue || '';
    }
    function normalizeTime(value) {
      return normalizeISOTime(value, STANDARD_TIME_FORMAT).isoValue || '';
    } // Converts value to the user's timezone and formats it in a way that will be accepted by the input

    function normalizeUTCDateTime(value, timezone) {
      return normalizeISODateTime(value, timezone).isoValue || '';
    } // parses the input value and converts it back to UTC from the user's timezone

    function normalizeDateTimeToUTC(value, timezone) {
      return normalizeFormattedDateTime(value, timezone) || '';
    }

    const i18n$a = {
      a11yTriggerText: labelA11yTriggerText,
      inputFileBodyText: labelInputFileBodyText,
      inputFileButtonLabel: labelInputFileButtonLabel,
      messageToggleActive: labelMessageToggleActive,
      messageToggleInactive: labelMessageToggleInactive,
      required: labelRequired,
      clear: labelClearInput,
      loading: labelLoadingIndicator
    };
    const ARIA_CONTROLS$2 = 'aria-controls';
    const ARIA_LABEL$2 = 'aria-label';
    const ARIA_LABELEDBY = 'aria-labelledby';
    const ARIA_DESCRIBEDBY$3 = 'aria-describedby';
    /*
    * This component supports the regular native input types, with the addition of toggle, checkbox-button and color.
    * Furthermore the file type supports a droppable zone, search has a clear button, number has formatting.
    * Input changes (native oninput event) triggers an onchange event,
    *     the native even is stopped, the dispatched custom event has a value that points to the state of the component
    *     in case of files it's the files uploaded (via droppable zone or through the upload button),
    *     checked for radio and checkbox, checkbox-button, and just straight input's value for everything else
    *
    *
    * _Toggle_ (always has an aria-describedby, on error has an additional one, default label text for active and inactive
    * states)
    * _File_ (as it has a droppable zone, the validity returned would have to be valid - unless a custom error message was
    *    passed)
    * _Search_ (it has the clear button and the icon)
    * _Number_ (formatting when not in focus, when in focus shows raw value)
    *
    * */

    const VALID_NUMBER_FORMATTERS = ['decimal', 'percent', 'percent-fixed', 'currency'];
    const DEFAULT_COLOR$1 = '#000000';
    const DEFAULT_FORMATTER = VALID_NUMBER_FORMATTERS[0];
    /**
     * Returns an aria string with all the non-autolinked values removed
     * @param {String} values space sperated list of ids
     * @returns {String} The aria values with the non-auto linked ones removed
     */

    function filterNonAutoLink(values) {
      const ariaValues = values.split(/\s+/);
      return ariaValues.filter(value => {
        return !!value.match(/^auto-link/);
      }).join(' ');
    }
    /**
     * Represents interactive controls that accept user input depending on the type attribute.
     */


    class LightningInput extends lwc.LightningElement {
      /**
       * Text that is displayed when the field is empty, to prompt the user for a valid entry.
       * @type {string}
       *
       */

      /**
       * Specifies the name of an input element.
       * @type {string}
       *
       */

      /**
       * Text label for the input.
       * @type {string}
       * @required
       *
       */

      /**
       * Error message to be displayed when a bad input is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a pattern mismatch is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a range overflow is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a range underflow is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a step mismatch is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when the value is too short.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when the value is too long.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when a type mismatch is detected.
       * @type {string}
       *
       */

      /**
       * Error message to be displayed when the value is missing.
       * @type {string}
       *
       */

      /**
       * Text shown for the active state of a toggle. The default is "Active".
       * @type {string}
       */

      /**
       * Text shown for the inactive state of a toggle. The default is "Inactive".
       * @type {string}
       */

      /**
       * Describes the input to assistive technologies.
       * @type {string}
       */

      /**
       * Controls autofilling of the field. Input types that support autocomplete are
       * email, search, tel, text, and url. Set the attribute to pass
       * through autocomplete values to be interpreted by the browser.
       * @type {string}
       */
      constructor() {
        super();
        this.placeholder = void 0;
        this.name = void 0;
        this.label = void 0;
        this.messageWhenBadInput = void 0;
        this.messageWhenPatternMismatch = void 0;
        this.messageWhenRangeOverflow = void 0;
        this.messageWhenRangeUnderflow = void 0;
        this.messageWhenStepMismatch = void 0;
        this.messageWhenTooShort = void 0;
        this.messageWhenTooLong = void 0;
        this.messageWhenTypeMismatch = void 0;
        this.messageWhenValueMissing = void 0;
        this.messageToggleActive = i18n$a.messageToggleActive;
        this.messageToggleInactive = i18n$a.messageToggleInactive;
        this.ariaLabel = void 0;
        this.autocomplete = void 0;
        this._timeAriaDescribedBy = void 0;
        this._timeAriaLabelledBy = void 0;
        this._timeAriaControls = void 0;
        this._dateAriaControls = void 0;
        this._dateAriaDescribedBy = void 0;
        this._dateAriaLabelledBy = void 0;
        this._value = '';
        this._type = 'text';
        this._pattern = void 0;
        this._max = void 0;
        this._min = void 0;
        this._step = void 0;
        this._disabled = false;
        this._readOnly = false;
        this._required = false;
        this._checked = false;
        this._isLoading = false;
        this._multiple = false;
        this._timezone = false;
        this._helpMessage = null;
        this._isColorPickerPanelOpen = false;
        this._fieldLevelHelp = void 0;
        this._accesskey = void 0;
        this._maxLength = void 0;
        this._minLength = void 0;
        this._accept = void 0;
        this._variant = void 0;
        this._connected = void 0;
        this._formatter = DEFAULT_FORMATTER;
        this._showRawNumber = false;
        this._initialValueSet = false;
        this._files = null;
        this.dateStyle = void 0;
        this.timeStyle = void 0;
        this.dateAriaLabel = void 0;
        this.ariaObserver = new ContentMutation(this); // Native Shadow Root will return [native code].
        // Our synthetic method will return the function source.

        this.isNative = this.template.querySelector.toString().match(/\[native code\]/);
      }
      /**
       * Reserved for internal use.
       * @type {number}
       *
       */


      get formatFractionDigits() {
        return this._formatFractionDigits;
      }

      set formatFractionDigits(value) {
        this._formatFractionDigits = value;

        if (this._connected && this.isTypeNumber) {
          this.inputElement.value = this.displayedValue;
        }
      }

      set timeAriaControls(refs) {
        this._timeAriaControls = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._timeAriaControls = ref;
        });
      }
      /**
       * A space-separated list of element IDs whose presence or content is controlled by the
       * time input when type='datetime'. On mobile devices, this is merged with aria-controls
       * and date-aria-controls to describe the native date time input.
       * @type {string}
       */


      get timeAriaControls() {
        return this._timeAriaControls;
      }
      /**
       * The display style of the date when type='date' or type='datetime'. Valid values are
       * short, medium (default), and long. The format of each style is specific to the locale.
       * On mobile devices this attribute has no effect.
       * @type {string}
       * @default medium
       */


      set dateAriaLabelledBy(refs) {
        this._dateAriaLabelledBy = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._dateAriaLabelledBy = ref;
        });
      }
      /**
       * A space-separated list of element IDs that provide labels for the date input when type='datetime'.
       * On mobile devices, this is merged with aria-labelled-by and time-aria-labelled-by to describe
       * the native date time input.
       * @type {string}
       */


      get dateAriaLabelledBy() {
        return this._dateAriaLabelledBy;
      }

      set timeAriaLabelledBy(refs) {
        this._timeAriaLabelledBy = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._timeAriaLabelledBy = ref;
        });
      }
      /**
       * A space-separated list of element IDs that provide labels for the time input when type='datetime'.
       * On mobile devices, this is merged with aria-labelled-by and date-aria-labelled-by to describe
       * the native date time input.
       * @type {string}
       *
       */


      get timeAriaLabelledBy() {
        return this._timeAriaLabelledBy;
      }

      set timeAriaDescribedBy(refs) {
        this._timeAriaDescribedBy = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._timeAriaDescribedBy = ref;
        });
      }
      /**
       * A space-separated list of element IDs that provide descriptive labels for the time input when
       * type='datetime'. On mobile devices, this is merged with aria-described-by and date-aria-described-by
       * to describe the native date time input.
       *  @type {string}
       *
       */


      get timeAriaDescribedBy() {
        return this._timeAriaDescribedBy;
      }

      set dateAriaControls(refs) {
        this._dateAriaControls = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._dateAriaControls = ref;
        });
      }
      /**
       * A space-separated list of element IDs whose presence or content is controlled by the
       * date input when type='datetime'. On mobile devices, this is merged with aria-controls
       * and time-aria-controls to describe the native date time input.
       * @type {string}
       *
       */


      get dateAriaControls() {
        return this._dateAriaControls;
      }

      set dateAriaDescribedBy(refs) {
        this._dateAriaDescribedBy = refs;
        this.ariaObserver.connectLiveIdRef(refs, ref => {
          this._dateAriaDescribedBy = ref;
        });
      }
      /**
       * A space-separated list of element IDs that provide descriptive labels for the date input when
       * type='datetime'. On mobile devices, this is merged with aria-described-by and time-aria-described-by
       * to describe the native date time input.
       * @type {string}
       */


      get dateAriaDescribedBy() {
        return this._dateAriaDescribedBy;
      }

      set ariaControls(refs) {
        this._ariaControls = refs;
        this.ariaObserver.link('input', 'aria-controls', refs, '[data-aria]');
      }
      /**
       * A space-separated list of element IDs whose presence or content is controlled by the input.
       * @type {string}
       */


      get ariaControls() {
        return this._ariaControls;
      }

      set ariaLabelledBy(refs) {
        this._ariaLabelledBy = refs;
        this.ariaObserver.link('input', 'aria-labelledby', refs, '[data-aria]');
      }
      /**
       * A space-separated list of element IDs that provide labels for the input.
       * @type {string}
       */


      get ariaLabelledBy() {
        // native version returns the auto linked value
        if (this.isNative) {
          const ariaValues = this.template.querySelector('input').getAttribute('aria-labelledby');
          return filterNonAutoLink(ariaValues);
        }

        return this._ariaLabelledBy;
      }

      set ariaDescribedBy(refs) {
        this._ariaDescribedBy = refs;
        this.ariaObserver.link('input', 'aria-describedby', refs, '[data-aria]');
      }
      /**
       * A space-separated list of element IDs that provide descriptive labels for the input.
       * @type {string}
       */


      get ariaDescribedBy() {
        if (this.isNative) {
          // in native case return the linked value
          const ariaValues = this.template.querySelector('input').getAttribute('aria-describedby');
          return filterNonAutoLink(ariaValues);
        }

        return this._ariaDescribedBy;
      }

      synchronizeA11y() {
        const input = this.template.querySelector('input');
        const datepicker = this.template.querySelector('lightning-datepicker');
        const timepicker = this.template.querySelector('lightning-timepicker');

        if (datepicker) {
          synchronizeAttrs(datepicker, {
            ariaLabelledByElement: this.ariaLabelledBy,
            ariaDescribedByElements: this.ariaDescribedBy,
            ariaControlsElement: this.ariaControls,
            [ARIA_LABEL$2]: this.computedAriaLabel
          });
          return;
        }

        if (timepicker) {
          synchronizeAttrs(timepicker, {
            ariaLabelledByElement: this.ariaLabelledBy,
            ariaDescribedByElements: this.ariaDescribedBy,
            ariaControlsElement: this.ariaControls,
            [ARIA_LABEL$2]: this.computedAriaLabel
          });
          return;
        }

        if (!input) {
          return;
        }

        synchronizeAttrs(input, {
          [ARIA_LABELEDBY]: this.computedAriaLabelledBy,
          [ARIA_DESCRIBEDBY$3]: this.computedAriaDescribedBy,
          [ARIA_CONTROLS$2]: this.computedAriaControls,
          [ARIA_LABEL$2]: this.computedAriaLabel
        });
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
        this.validateRequiredAttributes();
        this._connected = true;
        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.reportValidity());
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this._connected = false;
        this._initialValueSet = false;
        this._inputElement = undefined;
      }

      renderedCallback() {
        if (!this._initialValueSet && this.inputElement) {
          this.inputElement.value = this.displayedValue;

          if (this.isTypeCheckable) {
            this.inputElement.checked = this._checked;
          }

          this._initialValueSet = true;
        }

        this.ariaObserver.sync();
        this.synchronizeA11y();
      }
      /**
       * String value with the formatter to be used for number input. Valid values include
       * decimal, percent, percent-fixed, and currency.
       * @type {string}
       */


      get formatter() {
        return this._formatter;
      }

      set formatter(value) {
        this._formatter = normalizeString(value, {
          fallbackValue: DEFAULT_FORMATTER,
          validValues: VALID_NUMBER_FORMATTERS
        });

        this._updateInputDisplayValueIfTypeNumber();
      }
      /**
       * The type of the input. This value defaults to text.
       * @type {string}
       * @default text
       */


      get type() {
        return this._type;
      }

      set type(value) {
        const normalizedValue = normalizeString(value);
        this._type = normalizedValue === 'datetime' ? 'datetime-local' : normalizedValue;
        this.validateType(normalizedValue);
        this._inputElementRefreshNeeded = true;

        if (this._connected) {
          // The type is being changed after render, which means the input element may be different (eg. changing
          // from text to 'checkbox', so we need to set the initial value again
          this._initialValueSet = false;
        }

        this._updateProxyInputAttributes(['type', 'value', 'max', 'min', 'required', 'pattern']);
      }
      /**
       * For the search type only. If present, a spinner is displayed to indicate that data is loading.
       * @type {boolean}
       * @default false
       */


      get isLoading() {
        return this._isLoading;
      }

      set isLoading(value) {
        this._isLoading = normalizeBoolean(value);
      }
      /**
       * Specifies the regular expression that the input's value is checked against.
       * This attribute is supported for text, search, url, tel, email, and password types.
       * @type {string}
       *
       */


      get pattern() {
        if (this.isTypeColor) {
          return '^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$';
        }

        return this._pattern;
      }

      set pattern(value) {
        this._pattern = value;

        this._updateProxyInputAttributes('pattern');
      }
      /**
       * The maximum number of characters allowed in the field.
       * @type {number}
       */


      get maxLength() {
        return this._maxLength;
      }

      set maxLength(value) {
        this._maxLength = value;

        this._updateProxyInputAttributes('maxlength');
      }
      /**
       * Specifies the types of files that the server accepts. This attribute can be used only when type='file'.
       * @type {string}
       */


      get accept() {
        return this._accept;
      }

      set accept(value) {
        this._accept = value;

        this._updateProxyInputAttributes('accept');
      }
      /**
       * The minimum number of characters allowed in the field.
       * @type {number}
       */


      get minLength() {
        return this._minLength;
      }

      set minLength(value) {
        this._minLength = value;

        this._updateProxyInputAttributes('minlength');
      } // number and date/time

      /**
       * The maximum acceptable value for the input.  This attribute can be used only with number,
       * range, date, time, and datetime input types. For number and range type, the max value is a
       * decimal number. For the date, time, and datetime types, the max value must use a valid string for the type.
       * @type {decimal|string}
       */


      get max() {
        return this._max;
      }

      set max(value) {
        this._max = value;

        this._updateProxyInputAttributes('max');
      }
      /**
       * The minimum acceptable value for the input. This attribute can be used only with number,
       * range, date, time, and datetime input types. For number and range types, the min value
       * is a decimal number. For the date, time, and datetime types, the min value must use a valid string for the type.
       * @type {decimal|string}
       */


      get min() {
        return this._min;
      }

      set min(value) {
        this._min = value;

        this._updateProxyInputAttributes('min');
      }
      /**
       * Granularity of the value, specified as a positive floating point number.
       * Use 'any' when granularity is not a concern. This value defaults to 1.
       * @type {decimal|string}
       * @default 1
       */


      get step() {
        const stepNotSupportedYet = this.isTypeDateTime || this.isTypeTime; // The step attribute is broken on IE11; e.g. 123.45 with step=0.01 returns stepMismatch. See W-5356698 for details.

        const nativeStepBroken = this.isTypeNumber && isIE11;

        if (stepNotSupportedYet || nativeStepBroken) {
          return 'any';
        }

        return this._step;
      }

      set step(value) {
        this._step = normalizeInput(value);

        this._updateProxyInputAttributes('step');

        this._calculateFractionDigitsFromStep(value);

        this._updateInputDisplayValueIfTypeNumber();
      }
      /**
       * If present, the checkbox is selected.
       * @type {boolean}
       * @default false
       */


      get checked() {
        // checkable inputs can be part of a named group, in that case there won't be a change event thrown and so
        // the internal tracking _checked would be out of sync with the actual input value.
        if (this.isTypeCheckable && this._initialValueSet) {
          return this.inputElement.checked;
        }

        return this._checked;
      }

      set checked(value) {
        this._checked = normalizeBoolean(value);

        this._updateProxyInputAttributes('checked');

        if (this._connected) {
          this.inputElement.checked = this._checked;
        }
      }
      /**
       * Specifies that a user can enter more than one value. This attribute can be used only when type='file' or type='email'.
       * @type {boolean}
       * @default false
       */


      get multiple() {
        return this._multiple;
      }

      set multiple(value) {
        this._multiple = normalizeBoolean(value);

        this._updateProxyInputAttributes('multiple');
      }
      /**
       * Specifies the value of an input element.
       * @type {object}
       */


      get value() {
        return this._value;
      }

      set value(value) {
        this._value = normalizeInput(value);

        this._updateProxyInputAttributes('value'); // Setting value of a type file isn't allowed, but due to the design of Aura/LWC interop layer
        // it will try to set the value after a change event


        if (!this.isTypeFile) {
          // Again, due to the interop layer we need to check whether the value being set
          // is different, otherwise we're duplicating the sets on the input, which result
          // in different bugs like Japanese IME duplication of characters in Safari (likely a browser bug) or
          // character position re-set in IE11.
          if (this._connected && this.inputElement.value !== this.displayedValue) {
            this.inputElement.value = this.displayedValue;
          }
        }
      }
      /**
       * The variant changes the appearance of an input field.
       * Accepted variants include standard, label-inline, label-hidden, and label-stacked.
       * This value defaults to standard, which displays the label above the field.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and input field.
       * Use label-stacked to place the label above the input field.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant$1(value);
        this.updateClassList();
      }
      /**
       * If present, the input field is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);

        this._updateProxyInputAttributes('disabled');
      }
      /**
       * If present, the input field is read-only and cannot be edited by users.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this._readOnly;
      }

      set readOnly(value) {
        this._readOnly = normalizeBoolean(value);

        this._updateProxyInputAttributes('readonly');
      }
      /**
       * If present, the input field must be filled out before the form is submitted.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);

        this._updateProxyInputAttributes('required');
      }
      /**
       * Specifies the time zone used when type='datetime' only. This value defaults to the user's Salesforce time zone setting.
       * @type {string}
       *
       */


      get timezone() {
        return this._timezone || configProvider.getLocale().timezone;
      }

      set timezone(value) {
        this._timezone = value; // mobile date/time normalization of value/max/min depends on timezone, so we need to update here as well

        this._updateProxyInputAttributes(['value', 'max', 'min']);
      }
      /**
       * A FileList that contains selected files. This attribute can be used only when type='file'.
       * @type {object}
       *
       */


      get files() {
        if (this.isTypeFile) {
          return lwc.unwrap(this._files);
        }

        return null;
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       *
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * Checks if the input is valid.
       * @returns {boolean} Indicates whether the element meets all constraint validations.
       */


      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Sets a custom error message to be displayed when a form is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       */


      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */


      reportValidity() {
        return this._constraint.reportValidity(message => {
          if (this._connected && !this.isNativeInput) {
            this.inputElement.showHelpMessage(message);
          } else {
            this._helpMessage = message;
          }
        });
      }

      get isNativeInput() {
        return !(this.isTypeDesktopDate || this.isTypeDesktopDateTime || this.isTypeDesktopTime);
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }
      /**
       * Help text detailing the purpose and function of the input.
       * This attribute isn't supported for file, radio, toggle, and checkbox-button types.
       * @type {string}
       *
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (this._connected) {
          this.inputElement.focus();
        }
      }
      /**
       * Removes keyboard focus from the input element.
       */


      blur() {
        if (this._connected) {
          this.inputElement.blur();
        }
      }
      /**
       * Displays error messages on invalid fields.
       * An invalid field fails at least one constraint validation and returns false when checkValidity() is called.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      get computedAriaControls() {
        const ariaValues = []; // merge all date & time arias on mobile since it's displayed as a single field

        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaControls);
          ariaValues.push(this.timeAriaControls);
        }

        if (this.ariaControls) {
          ariaValues.push(this.ariaControls);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedAriaLabel() {
        const ariaValues = []; // merge all date & time arias on mobile since it's displayed as a single field

        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaLabel);
          ariaValues.push(this.timeAriaLabel);
        }

        if (this.ariaLabel) {
          ariaValues.push(this.ariaLabel);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedAriaLabelledBy() {
        const ariaValues = [];

        if (this.isTypeFile) {
          ariaValues.push(this.computedUniqueFileElementLabelledById);
        } // merge all date & time arias on mobile since it's displayed as a single field


        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaLabelledBy);
          ariaValues.push(this.timeAriaLabelledBy);
        }

        if (this.ariaLabelledBy) {
          ariaValues.push(this.ariaLabelledBy);
        }

        return normalizeAriaAttribute(ariaValues);
      }

      get computedAriaDescribedBy() {
        const ariaValues = [];

        if (this._helpMessage) {
          ariaValues.push(this.computedUniqueHelpElementId);
        } // The toggle type is described by a secondary element


        if (this.isTypeToggle) {
          ariaValues.push(this.computedUniqueToggleElementDescribedById);
        } // merge all date & time arias on mobile since it's displayed as a single field


        if (this.isTypeMobileDateTime) {
          ariaValues.push(this.dateAriaDescribedBy);
          ariaValues.push(this.timeAriaDescribedBy);
        }

        if (this.ariaDescribedBy) {
          ariaValues.push(this.ariaDescribedBy);
        }

        return normalizeAriaAttribute(ariaValues);
      }
      /**
       * Specifies a shortcut key to activate or focus an element.
       * @type {string}
       *
       */


      get accessKey() {
        return this._accesskey;
      }

      set accessKey(newValue) {
        this._accesskey = newValue;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get isLabelStacked() {
        return this.variant === VARIANT.LABEL_STACKED;
      }

      get accesskey() {
        return this._accesskey;
      }

      get isTypeCheckable() {
        return this.isTypeCheckbox || this.isTypeCheckboxButton || this.isTypeRadio || this.isTypeToggle;
      }

      get colorInputElementValue() {
        return this.validity.valid && this.value ? this.value : DEFAULT_COLOR$1;
      }

      get colorInputStyle() {
        return `background: ${this.value || '#5679C0'};`;
      }

      get computedUniqueHelpElementId() {
        return getRealDOMId(this.template.querySelector('[data-help-message]'));
      }

      get computedUniqueToggleElementDescribedById() {
        if (this.isTypeToggle) {
          const toggle = this.template.querySelector('[data-toggle-description]');
          return getRealDOMId(toggle);
        }

        return null;
      }

      get computedUniqueFormLabelId() {
        if (this.isTypeFile) {
          const formLabel = this.template.querySelector('[data-form-label]');
          return getRealDOMId(formLabel);
        }

        return null;
      }

      get computedUniqueFileSelectorLabelId() {
        if (this.isTypeFile) {
          const fileBodyLabel = this.template.querySelector('[data-file-selector-label]');
          return getRealDOMId(fileBodyLabel);
        }

        return null;
      }

      get computedUniqueFileElementLabelledById() {
        if (this.isTypeFile) {
          const labelIds = [this.computedUniqueFormLabelId, this.computedUniqueFileSelectorLabelId];
          return labelIds.join(' ');
        }

        return null;
      }

      get computedFormElementClass() {
        const classes = classSet('slds-form-element__control slds-grow');

        if (this.isTypeSearch) {
          classes.add('slds-input-has-icon slds-input-has-icon_left-right');
        }

        return classes.toString();
      }

      get i18n() {
        return i18n$a;
      }

      get computedLabelClass() {
        const classnames = classSet('slds-form-element__label');

        if (this.isTypeCheckable || this.isTypeFile) ; else if (this.isTypeToggle) {
          classnames.add('slds-m-bottom_none');
        } else {
          classnames.add('slds-no-flex');
        }

        return classnames.add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedNumberClass() {
        return classSet('slds-input').add({
          'slds-is-disabled': this.disabled
        }).toString();
      }

      get computedColorLabelClass() {
        return classSet('slds-color-picker__summary-label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedCheckboxClass() {
        return classSet('slds-checkbox').add({
          'slds-checkbox_standalone': !this.isStandardVariant
        }).toString();
      }

      get normalizedMax() {
        return this.normalizeDateTimeString(this.max);
      }

      get normalizedMin() {
        return this.normalizeDateTimeString(this.min);
      }

      get isTypeNumber() {
        return this.type === 'number';
      }

      get isTypeSearch() {
        return this.type === 'search';
      }

      get isTypeToggle() {
        return this.type === 'toggle';
      }

      get isTypeText() {
        return this.type === 'text';
      }

      get isTypeCheckbox() {
        return this.type === 'checkbox';
      }

      get isTypeRadio() {
        return this.type === 'radio';
      }

      get isTypeCheckboxButton() {
        return this.type === 'checkbox-button';
      }

      get isTypeFile() {
        return this.type === 'file';
      }

      get isTypeColor() {
        return this.type === 'color';
      }

      get isTypeDate() {
        return this.type === 'date';
      }

      get isTypeDateTime() {
        return this.type === 'datetime' || this.type === 'datetime-local';
      }

      get isTypeTime() {
        return this.type === 'time';
      }

      get isTypeMobileDate() {
        return this.isTypeDate && !this.isDesktopBrowser();
      }

      get isTypeDesktopDate() {
        return this.isTypeDate && this.isDesktopBrowser();
      }

      get isTypeMobileDateTime() {
        return this.isTypeDateTime && !this.isDesktopBrowser();
      }

      get isTypeDesktopDateTime() {
        return this.isTypeDateTime && this.isDesktopBrowser();
      }

      get isTypeMobileTime() {
        return this.isTypeTime && !this.isDesktopBrowser();
      }

      get isTypeDesktopTime() {
        return this.isTypeTime && this.isDesktopBrowser();
      }

      get isTypeSimple() {
        return !this.isTypeCheckbox && !this.isTypeCheckboxButton && !this.isTypeToggle && !this.isTypeRadio && !this.isTypeFile && !this.isTypeColor && !this.isTypeDesktopDate && !this.isTypeDesktopDateTime && !this.isTypeDesktopTime;
      }

      get inputElement() {
        if (!this._connected) {
          return undefined;
        }

        if (!this._inputElement || this._inputElementRefreshNeeded) {
          let inputElement;

          if (this.isTypeDesktopDate) {
            inputElement = this.template.querySelector('lightning-datepicker');
          } else if (this.isTypeDesktopDateTime) {
            inputElement = this.template.querySelector('lightning-datetimepicker');
          } else if (this.isTypeDesktopTime) {
            inputElement = this.template.querySelector('lightning-timepicker');
          } else {
            inputElement = this.template.querySelector('input');
          }

          this._inputElementRefreshNeeded = false;
          this._inputElement = inputElement;
        }

        return this._inputElement;
      }

      get nativeInputType() {
        let inputType = 'text';

        if (this.isTypeSimple) {
          inputType = this.type;
        } else if (this.isTypeToggle || this.isTypeCheckboxButton || this.isTypeCheckbox) {
          inputType = 'checkbox';
        } else if (this.isTypeRadio) {
          inputType = 'radio';
        } else if (this.isTypeFile) {
          inputType = 'file';
        } else if (this.isTypeDateTime) {
          inputType = 'datetime-local';
        } else if (this.isTypeTime) {
          inputType = 'time';
        } else if (this.isTypeDate) {
          inputType = 'date';
        }

        return inputType;
      }

      clearAndSetFocusOnInput(event) {
        this.interactingState.enter();
        this.inputElement.value = '';

        this._updateValueAndValidityAttribute('');

        this.dispatchChangeEventWithDetail({
          value: this._value
        });
        this.inputElement.focus(); // button is removed from template, but
        // event still is propagated, For example, captured by panel,
        // then cause panel think is clicked outside.

        event.stopPropagation();
      }

      dispatchChangeEventWithDetail(detail) {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail
        }));
      }

      getFormattedValue(value) {
        if (!this.isTypeNumber) {
          return value;
        }

        if (isEmptyString(value)) {
          return '';
        }

        let formattedValue = value;
        let inputValue = value; // set formatter style & default options

        const formatStyle = this.formatter;
        const formatOptions = {
          style: formatStyle
        }; // Use the min/max fraction digits from the formatFractionDigits provided by the user if available.
        // Otherwise, use the number of digits calculated from step

        if (this._formatFractionDigits !== undefined) {
          formatOptions.minimumFractionDigits = this._formatFractionDigits;
          formatOptions.maximumFractionDigits = this._formatFractionDigits;
        } else if (this._calculatedFractionDigits !== undefined) {
          formatOptions.minimumFractionDigits = this._calculatedFractionDigits;
          formatOptions.maximumFractionDigits = this._calculatedFractionDigits;
        }

        if (formatStyle === 'percent-fixed') {
          // percent-fixed just uses percent format and divides the value by 100
          // before passing to the library, this is to deal with the
          // fact that percentages in salesforce are 0-100, not 0-1
          formatOptions.style = 'percent';
          const inputValueAsString = inputValue.toString();
          const normalisedNumberInPercent = parseFloat(inputValue) / 100; // If the number contains fraction digits and is not in an exponent format

          if (inputValueAsString.indexOf('.') > 0 && inputValueAsString.indexOf('e') < 0) {
            // Depending on the input number, division by 100 may lead to rounding errors
            // (e.g 0.785 / 100 is 0.007850000000000001), so we need to round back
            // to the correct precision, that is - existing number of fractional digits
            // plus extra 2 for division by 100.
            inputValue = normalisedNumberInPercent.toFixed(inputValueAsString.split('.')[1].length + 2);
          } else {
            inputValue = normalisedNumberInPercent;
          }
        }

        try {
          formattedValue = numberFormat(formatOptions).format(inputValue) || '';
        } catch (ignore) {// ignore any errors
        }

        return formattedValue;
      }

      validateType(type) {
        assert(type !== 'hidden', `<lightning-input> The type attribute value "hidden" is invalid. Use a regular <input type="hidden"> instead.`);
        assert(type !== 'submit' && type !== 'reset' && type !== 'image' && type !== 'button', `<lightning-input> The type attribute value "${type}" is invalid. Use <lightning:button> instead.`);

        if (this.isTypeRadio) {
          assert(!this.required, `<lightning-input> The required attribute is not supported on radio inputs directly. It should be implemented at the radio group level.`);
        }
      }

      validateRequiredAttributes() {
        const {
          label
        } = this;
        assert(typeof label === 'string' && label.length, `<lightning-input> The required label attribute value "${label}" is invalid.`);
      }

      handleFileClick() {
        this.inputElement.value = null;

        this._updateValueAndValidityAttribute(null);
      }

      handleDropFiles(event) {
        // drop doesn't trigger focus nor blur, so set state to interacting
        // and auto leave when there's no more action
        this.interactingState.interacting();
        this.fileUploadedViaDroppableZone = true;
        this._files = event.dataTransfer && event.dataTransfer.files;

        this._updateProxyInputAttributes('required');

        this.dispatchChangeEventWithDetail({
          files: lwc.unwrap(this._files)
        });
      } // We need this handler to account for mobile platforms' soft keyboards.
      // The type of the underlying native input for type="number" needs to be changed before the focus event is triggered,
      // this way the correct soft keyboard is shown on iOS, and on Android you don't need to tap twice to get the
      // keyboard to show.
      //
      // The minor side-effect of this is that if a touch drag ends on the input, the input will change type and
      // displayed value without the focus being triggered.


      handleTouchEnd() {
        if (this._connected && this.isTypeNumber) {
          this._switchInputTypeToNumber();
        }
      }

      handleFocus() {
        this.interactingState.enter();

        if (this.isTypeColor) {
          this._isColorPickerPanelOpen = false;
        }

        if (this._connected && this.isTypeNumber) {
          this._switchInputTypeToNumber();
        } // W-6176985: IE11 input when set value, will move cursor to beginning.
        // This fix is only for input type=number on IE11, and force the cursor to the end.


        if (isIE11 && this.isTypeNumber) {
          const length = this.inputElement.value.length;
          this.inputElement.selectionStart = length;
          this.inputElement.selectionEnd = length;
        }

        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur(event) {
        this.interactingState.leave();

        if (this._connected && this.isTypeNumber) {
          // Don't need to change type to text and show the formatted number when value is empty.
          // This also fixes the issue where the component resets to empty string when
          // there's invalid value since input in badInput validity state gives us back an empty
          // string instead of the invalid value.
          this._showRawNumber = isEmptyString(this._value);

          if (!this._showRawNumber) {
            this.inputElement.type = 'text';
            this.inputElement.value = this.displayedValue;
          }
        }

        if (!event.relatedTarget || !this.template.contains(event.relatedTarget)) {
          this.dispatchEvent(new CustomEvent('blur'));
        }
      }

      handleChange(event) {
        event.stopPropagation();

        if (this.isTypeSimple && this.value === event.target.value) {
          return;
        }

        this.dispatchChangeEvent();
      }

      handleInput(event) {
        event.stopPropagation();

        if (this.isTypeSimple && this.value === event.target.value) {
          return;
        }

        this.dispatchChangeEvent();
      }

      handleKeyPress(event) {
        if (this.isTypeNumber && !this.isFunctionKeyStroke(event) && !this.isValidNumericKeyStroke(event)) {
          event.preventDefault();
        }
      }

      dispatchChangeEvent() {
        this.interactingState.enter();
        const detail = {};

        if (this.isTypeCheckable) {
          this._updateCheckedAndValidityAttribute(this.inputElement.checked);

          detail.checked = this._checked;
        } else if (this.isTypeFile) {
          this._files = this.inputElement.files; // this.template.querySelector returns a proxy, and .files would also be proxied
          // we're unwrapping it here so that native apis can be used on it

          detail.files = lwc.unwrap(this._files);

          this._updateProxyInputAttributes('required');
        }

        if (!this.isTypeCheckable) {
          detail.value = this.inputElement.value;

          if (this.isTypeMobileDateTime) {
            detail.value = normalizeDateTimeToUTC(detail.value, this.timezone);
          } else if (this.isTypeMobileTime) {
            detail.value = normalizeTime(detail.value);
          }

          this._updateValueAndValidityAttribute(detail.value);
        }

        this.dispatchChangeEventWithDetail(detail);
      }

      get _showClearButton() {
        return this.isTypeSearch && this._value !== undefined && this._value !== null && this._value !== '';
      }

      handleColorPickerToggleClick(event) {
        event.preventDefault(); // Don't want error state inside panel

        if (!this.validity.valid) {
          this.inputElement.value = DEFAULT_COLOR$1;

          this._updateValueAndValidityAttribute(DEFAULT_COLOR$1);

          this._helpMessage = null;
          this.classList.remove('slds-has-error');
          this.dispatchChangeEventWithDetail({
            value: DEFAULT_COLOR$1
          });
        }
      }

      handleColorChange(event) {
        const selectedColor = event.detail.color;

        if (selectedColor !== this.inputElement.value) {
          this.inputElement.value = selectedColor;

          this._updateValueAndValidityAttribute(selectedColor);

          this.focus();
          this.dispatchChangeEventWithDetail({
            value: selectedColor
          });
        }

        this.template.querySelector('lightning-primitive-colorpicker-button').focus();
      }

      isNonPrintableKeyStroke(keyCode) {
        return Object.keys(keyCodes).some(code => keyCodes[code] === keyCode);
      }

      isFunctionKeyStroke(event) {
        return event.ctrlKey || event.metaKey || this.isNonPrintableKeyStroke(event.keyCode);
      }

      isValidNumericKeyStroke(event) {
        return /^[0-9eE.,+-]$/.test(event.key);
      }

      isDesktopBrowser() {
        return configProvider.getFormFactor() === 'DESKTOP';
      }

      normalizeDateTimeString(value) {
        let result = value;

        if (this.isTypeDate) {
          result = normalizeDate(value);
        } else if (this.isTypeTime) {
          result = normalizeTime(value);
        } else if (this.isTypeDateTime) {
          result = normalizeUTCDateTime(value, this.timezone);
        }

        return result;
      }

      get displayedValue() {
        if (this.isTypeNumber && !this._showRawNumber) {
          return this.getFormattedValue(this._value);
        }

        if (this.isTypeMobileDate || this.isTypeMobileDateTime || this.isTypeMobileTime) {
          return this.normalizeDateTimeString(this._value);
        }

        return this._value;
      }

      get _internalType() {
        if (this.isTypeNumber) {
          return 'text';
        }

        return this._type;
      }

      get isStandardVariant() {
        return this.variant === VARIANT.STANDARD || this.variant === VARIANT.LABEL_HIDDEN;
      }

      _updateValueAndValidityAttribute(value) {
        this._value = value;

        this._updateProxyInputAttributes('value');
      }

      _updateCheckedAndValidityAttribute(value) {
        this._checked = value;

        this._updateProxyInputAttributes('checked');
      }

      _calculateFractionDigitsFromStep(step) {
        // clear any previous value if set
        this._calculatedFractionDigits = undefined;

        if (step && step !== 'any') {
          let numDecimals = 0; // calculate number of decimals using step

          const decimals = String(step).split('.')[1]; // we're parsing the decimals to account for cases where the step is
          // '1.0'

          if (decimals && parseInt(decimals, 10) > 0) {
            numDecimals = decimals.length;
          }

          this._calculatedFractionDigits = numDecimals;
        }
      }

      get _ignoreRequired() {
        // If uploading via the drop zone or via the input directly, we should
        // ignore the required flag as a file has been uploaded
        return this.isTypeFile && this._required && (this.fileUploadedViaDroppableZone || this._files && this._files.length > 0);
      }

      _updateProxyInputAttributes(attributes) {
        if (this._constraintApiProxyInputUpdater) {
          this._constraintApiProxyInputUpdater(attributes);
        }
      }

      get _constraint() {
        if (!this._constraintApi) {
          const overrides = {
            badInput: () => {
              if (!this._connected) {
                return false;
              }

              if (this.isTypeNumber && this.getFormattedValue(this._value) === 'NaN') {
                return true;
              }

              if (!this.isNativeInput) {
                return this.inputElement.hasBadInput();
              }

              return this.inputElement.validity.badInput;
            },
            tooLong: () => // since type=number is type=text in the dom when not in focus
            // we should always return false as maxlength doesn't apply
            this.isNativeInput && !this.isTypeNumber && this._connected && this.inputElement.validity.tooLong,
            tooShort: () => // since type=number is type=text in the dom when not in focus
            // we should always return false as minlength doesn't apply
            this.isNativeInput && !this.isTypeNumber && this._connected && this.inputElement.validity.tooShort,
            patternMismatch: () => this.isNativeInput && this._connected && this.inputElement.validity.patternMismatch
          }; // FF, IE and Safari don't support type datetime-local,
          // IE and Safari don't support type date or time
          // we need to defer to the base component to check rangeOverflow/rangeUnderflow.
          // Due to the custom override, changing the type to or from datetime/time would affect the validation

          if (this.isTypeDesktopDateTime || this.isTypeDesktopTime || this.isTypeDesktopDate) {
            overrides.rangeOverflow = () => {
              // input type='time' is timezone agnostic, so we should remove the timezone designator before comparison
              const max = this.isTypeDesktopTime ? normalizeTime(this.max) : this.max;
              return isAfter(this.value, max);
            };

            overrides.rangeUnderflow = () => {
              // input type='time' is timezone agnostic, so we should remove the timezone designator before comparison
              const min = this.isTypeDesktopTime ? normalizeTime(this.min) : this.min;
              return isBefore(this.value, min);
            };
          }

          this._constraintApi = new FieldConstraintApiWithProxyInput(() => {
            // The date/time components display their own errors and have custom messages for badInput and rangeOverflow/Underflow.
            if (!this.isNativeInput) {
              return this.inputElement;
            }

            return this;
          }, overrides);
          this._constraintApiProxyInputUpdater = this._constraint.setInputAttributes({
            type: () => this.nativeInputType,
            // We need to normalize value so that it's consumable by the proxy input (otherwise the value
            // will be invalid for the native input)
            value: () => this.normalizeDateTimeString(this.value),
            checked: () => this.checked,
            maxlength: () => this.maxLength,
            minlength: () => this.minLength,
            // 'pattern' depends on type
            pattern: () => this.pattern,
            // 'max' and 'min' depend on type and timezone
            max: () => this.normalizedMax,
            min: () => this.normalizedMin,
            step: () => this.step,
            accept: () => this.accept,
            multiple: () => this.multiple,
            disabled: () => this.disabled,
            readonly: () => this.readOnly,
            // depends on type and whether an upload has been made
            required: () => this.required && !this._ignoreRequired
          });
        }

        return this._constraintApi;
      }

      _updateInputDisplayValueIfTypeNumber() {
        // Displayed value depends on the format number, so if we're not showing the raw
        // number we should update the value
        if (this._connected && this.isTypeNumber && !this._showRawNumber && this.inputElement) {
          this.inputElement.value = this.displayedValue;
        }
      }

      _switchInputTypeToNumber() {
        this._showRawNumber = true;
        this.inputElement.value = this.displayedValue;
        this.inputElement.inputMode = 'decimal'; // The below check is needed due to a bug in Firefox with switching the
        // type to/from 'number'.
        // Remove the check once https://bugzilla.mozilla.org/show_bug.cgi?id=981248 is fixed

        const isFirefox = navigator.userAgent.indexOf('Firefox') >= 0;

        if (isFirefox) {
          if (this.validity.badInput) {
            // reset value manually for Firefox to emulate the behaviour of
            // a native input type number
            this.inputElement.value = '';
          }
        } else {
          this.inputElement.type = 'number';
        }
      }

    }

    LightningInput.delegatesFocus = true;

    lwc.registerDecorators(LightningInput, {
      publicProps: {
        placeholder: {
          config: 0
        },
        name: {
          config: 0
        },
        label: {
          config: 0
        },
        messageWhenBadInput: {
          config: 0
        },
        messageWhenPatternMismatch: {
          config: 0
        },
        messageWhenRangeOverflow: {
          config: 0
        },
        messageWhenRangeUnderflow: {
          config: 0
        },
        messageWhenStepMismatch: {
          config: 0
        },
        messageWhenTooShort: {
          config: 0
        },
        messageWhenTooLong: {
          config: 0
        },
        messageWhenTypeMismatch: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageToggleActive: {
          config: 0
        },
        messageToggleInactive: {
          config: 0
        },
        ariaLabel: {
          config: 0
        },
        autocomplete: {
          config: 0
        },
        formatFractionDigits: {
          config: 3
        },
        timeAriaControls: {
          config: 3
        },
        dateStyle: {
          config: 0
        },
        timeStyle: {
          config: 0
        },
        dateAriaLabel: {
          config: 0
        },
        dateAriaLabelledBy: {
          config: 3
        },
        timeAriaLabelledBy: {
          config: 3
        },
        timeAriaDescribedBy: {
          config: 3
        },
        dateAriaControls: {
          config: 3
        },
        dateAriaDescribedBy: {
          config: 3
        },
        ariaControls: {
          config: 3
        },
        ariaLabelledBy: {
          config: 3
        },
        ariaDescribedBy: {
          config: 3
        },
        formatter: {
          config: 3
        },
        type: {
          config: 3
        },
        isLoading: {
          config: 3
        },
        pattern: {
          config: 3
        },
        maxLength: {
          config: 3
        },
        accept: {
          config: 3
        },
        minLength: {
          config: 3
        },
        max: {
          config: 3
        },
        min: {
          config: 3
        },
        step: {
          config: 3
        },
        checked: {
          config: 3
        },
        multiple: {
          config: 3
        },
        value: {
          config: 3
        },
        variant: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        timezone: {
          config: 3
        },
        files: {
          config: 1
        },
        validity: {
          config: 1
        },
        fieldLevelHelp: {
          config: 3
        },
        accessKey: {
          config: 3
        }
      },
      publicMethods: ["checkValidity", "setCustomValidity", "reportValidity", "focus", "blur", "showHelpMessageIfInvalid"],
      track: {
        _timeAriaDescribedBy: 1,
        _timeAriaLabelledBy: 1,
        _timeAriaControls: 1,
        _dateAriaControls: 1,
        _dateAriaDescribedBy: 1,
        _dateAriaLabelledBy: 1,
        _value: 1,
        _type: 1,
        _pattern: 1,
        _max: 1,
        _min: 1,
        _step: 1,
        _disabled: 1,
        _readOnly: 1,
        _required: 1,
        _checked: 1,
        _isLoading: 1,
        _multiple: 1,
        _timezone: 1,
        _helpMessage: 1,
        _isColorPickerPanelOpen: 1,
        _fieldLevelHelp: 1,
        _accesskey: 1,
        _maxLength: 1,
        _minLength: 1,
        _accept: 1,
        _variant: 1,
        _connected: 1
      }
    });

    var _lightningInput = lwc.registerComponent(LightningInput, {
      tmpl: _tmpl$m
    });
    LightningInput.interopMap = {
      exposeNativeEvent: {
        change: true,
        focus: true,
        blur: true
      }
    };

    function stylesheet$7(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$7 = [stylesheet$7];

    function stylesheet$8(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$8 = [stylesheet$8];

    function tmpl$o($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        ti: api_tab_index,
        b: api_bind,
        k: api_key,
        i: api_iterator
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9
      } = $ctx;
      return [api_element("div", {
        attrs: {
          "role": "group",
          "aria-labelledby": `${api_scoped_id("group-label")}`
        },
        key: 2
      }, [api_element("div", {
        className: $cmp.computedGroupLabelClass,
        attrs: {
          "id": api_scoped_id("group-label")
        },
        key: 3
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 5
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 6
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 7
      }, [api_element("div", {
        classMap: {
          "slds-dueling-list": true
        },
        key: 8,
        on: {
          "focusin": _m8 || ($ctx._m8 = api_bind($cmp.handleFocus)),
          "focusout": _m9 || ($ctx._m9 = api_bind($cmp.handleBlur))
        }
      }, [api_element("div", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "id": api_scoped_id("assertive-thing"),
          "aria-live": "assertive"
        },
        key: 9
      }, []), api_element("div", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "id": api_scoped_id("keyboard-interacton")
        },
        key: 10
      }, [api_dynamic($cmp.i18n.componentAssistiveText)]), api_element("div", {
        className: $cmp.computedLeftColumnClass,
        key: 11
      }, [api_element("span", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "id": api_scoped_id("source-list-label")
        },
        key: 12
      }, [api_dynamic($cmp.sourceLabel)]), api_element("div", {
        className: $cmp.computedListboxContainerClass,
        style: $cmp.computedColumnStyle,
        key: 13
      }, [api_element("ul", {
        classMap: {
          "slds-listbox": true,
          "slds-listbox_vertical": true
        },
        attrs: {
          "data-source-list": true,
          "id": api_scoped_id("source-list"),
          "aria-describedby": `${api_scoped_id("keyboard-interacton")}`,
          "aria-labelledby": `${api_scoped_id("source-list-label")}`,
          "aria-multiselectable": "true",
          "role": "listbox",
          "aria-disabled": $cmp.ariaDisabled
        },
        key: 14
      }, api_iterator($cmp.computedSourceList, function (option, index) {
        return api_element("li", {
          classMap: {
            "slds-listbox__item": true
          },
          attrs: {
            "role": "presentation"
          },
          key: api_key(16, option.value)
        }, [api_element("div", {
          className: option.classList,
          attrs: {
            "aria-selected": option.selected,
            "role": "option",
            "tabindex": api_tab_index(option.tabIndex),
            "data-index": index,
            "data-value": option.value,
            "data-type": $cmp.computedSourceListId
          },
          key: 17,
          on: {
            "click": _m0 || ($ctx._m0 = api_bind($cmp.handleOptionClick)),
            "keydown": _m1 || ($ctx._m1 = api_bind($cmp.handleOptionKeyDown))
          }
        }, [api_element("span", {
          classMap: {
            "slds-media__body": true
          },
          key: 18
        }, [api_element("span", {
          classMap: {
            "slds-truncate": true
          },
          attrs: {
            "title": option.label
          },
          key: 19
        }, [api_dynamic(option.label)])])])]);
      }))]), $cmp.showActivityIndicator ? api_element("div", {
        key: 20
      }, [api_custom_element("lightning-spinner", _lightningSpinner, {
        props: {
          "size": "small",
          "variant": "brand",
          "alternativeText": $cmp.i18n.loadingText
        },
        key: 21
      }, [])]) : null]), api_element("div", {
        classMap: {
          "slds-dueling-list__column": true
        },
        key: 22
      }, [api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:right",
          "variant": "container",
          "disabled": $cmp.moveButtonsDisabled,
          "title": $cmp.addButtonLabel,
          "alternativeText": $cmp.addButtonLabel
        },
        key: 23,
        on: {
          "click": _m2 || ($ctx._m2 = api_bind($cmp.handleRightButtonClick))
        }
      }, []), api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:left",
          "variant": "container",
          "disabled": $cmp.moveButtonsDisabled,
          "title": $cmp.removeButtonLabel,
          "alternativeText": $cmp.removeButtonLabel
        },
        key: 24,
        on: {
          "click": _m3 || ($ctx._m3 = api_bind($cmp.handleLeftButtonClick))
        }
      }, [])]), api_element("div", {
        classMap: {
          "slds-dueling-list__column": true,
          "slds-dueling-list__column_responsive": true
        },
        key: 25
      }, [api_element("span", {
        classMap: {
          "slds-form-element__label": true
        },
        attrs: {
          "id": api_scoped_id("selected-list-label")
        },
        key: 26
      }, [api_dynamic($cmp.selectedLabel)]), api_element("div", {
        className: $cmp.computedListboxContainerClass,
        style: $cmp.computedColumnStyle,
        key: 27
      }, [api_element("ul", {
        classMap: {
          "slds-listbox": true,
          "slds-listbox_vertical": true
        },
        attrs: {
          "data-selected-list": true,
          "id": api_scoped_id("selected-list"),
          "aria-describedby": `${api_scoped_id("keyboard-interacton")}`,
          "aria-labelledby": `${api_scoped_id("selected-list-label")}`,
          "aria-multiselectable": "true",
          "role": "listbox",
          "aria-disabled": $cmp.ariaDisabled
        },
        key: 28
      }, api_iterator($cmp.computedSelectedList, function (option, index) {
        return api_element("li", {
          classMap: {
            "slds-listbox__item": true
          },
          attrs: {
            "role": "presentation"
          },
          key: api_key(30, option.value)
        }, [api_element("div", {
          className: option.classList,
          attrs: {
            "aria-selected": option.selected,
            "role": "option",
            "tabindex": api_tab_index(option.tabIndex),
            "data-index": index,
            "data-value": option.value,
            "data-type": $cmp.computedSelectedListId
          },
          key: 31,
          on: {
            "click": _m4 || ($ctx._m4 = api_bind($cmp.handleOptionClick)),
            "keydown": _m5 || ($ctx._m5 = api_bind($cmp.handleOptionKeyDown))
          }
        }, [api_element("span", {
          classMap: {
            "slds-media__body": true
          },
          key: 32
        }, [api_element("span", {
          classMap: {
            "slds-truncate": true
          },
          attrs: {
            "title": option.label
          },
          key: 33
        }, [api_dynamic(option.label)])]), option.isLocked ? api_element("span", {
          classMap: {
            "slds-media__figure": true,
            "slds-media__figure_reverse": true
          },
          key: 35
        }, [api_custom_element("lightning-icon", _lightningIcon, {
          props: {
            "iconName": "utility:lock",
            "size": "x-small",
            "alternativeText": $cmp.computedLockAssistiveText
          },
          key: 36
        }, [])]) : null])]);
      }))])]), !$cmp.disableReordering ? api_element("div", {
        classMap: {
          "slds-dueling-list__column": true
        },
        key: 38
      }, [api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:up",
          "variant": "container",
          "disabled": $cmp.disabled,
          "title": $cmp.upButtonLabel,
          "alternativeText": $cmp.upButtonLabel
        },
        key: 39,
        on: {
          "click": _m6 || ($ctx._m6 = api_bind($cmp.handleUpButtonClick))
        }
      }, []), api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        props: {
          "iconName": "utility:down",
          "variant": "container",
          "disabled": $cmp.disabled,
          "title": $cmp.downButtonLabel,
          "alternativeText": $cmp.downButtonLabel
        },
        key: 40,
        on: {
          "click": _m7 || ($ctx._m7 = api_bind($cmp.handleDownButtonClick))
        }
      }, [])]) : null])]), $cmp.errorMessage ? api_element("span", {
        classMap: {
          "slds-has-error": true,
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("error-message"),
          "aria-live": "assertive"
        },
        key: 42
      }, [api_dynamic($cmp.errorMessage)]) : null])];
    }

    var _tmpl$n = lwc.registerTemplate(tmpl$o);
    tmpl$o.stylesheets = [];

    if (_implicitStylesheets$8) {
      tmpl$o.stylesheets.push.apply(tmpl$o.stylesheets, _implicitStylesheets$8);
    }
    tmpl$o.stylesheetTokens = {
      hostAttribute: "lightning-dualListbox_dualListbox-host",
      shadowAttribute: "lightning-dualListbox_dualListbox"
    };

    var labelComponentAssistiveText = 'Press Ctrl (Cmd on Mac) + Left Arrow or Ctrl (Cmd on Mac) + Right Arrow to move items between lists.';

    var labelDownButtonAssistiveText = 'Move selection down';

    var labelMaxError = 'Select at most {0} options';

    var labelMaxHelp = ' [and a maximum of {0}]';

    var labelMinErrorPlural = 'Select at least {0} options';

    var labelMinErrorSingular = 'Select at least 1 option';

    var labelMinHelp = ' [and a minimum of {0}]';

    var labelMinRequiredErrorPlural = 'At least {0} options must be selected';

    var labelMinRequiredErrorSingular = 'At least 1 option must be selected';

    var labelOptionLockAssistiveText = ': item cannot be removed from {0}';

    var labelRequiredError = 'An option must be selected';

    var labelRequiredOptionError = '{0} must be selected';

    var labelUpButtonAssistiveText = 'Move selection up';

    var labelMoveSelectionToAssistiveText = 'Move selection to {0}';

    function preventDefaultAndStopPropagation$3(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    function setFocusOnNextOption(option, moveUp, intf) {
      const index = parseInt(option.getAttribute('data-index'), 10);
      const i = index + (moveUp ? -1 : 1);
      const options = intf.getElementsOfList(option.getAttribute('data-type'));
      const next = options[i];

      if (next) {
        next.focus();
      }
    }

    function selectNextOption(option, moveUp, intf) {
      const selected = option.getAttribute('aria-selected') === 'true';
      const index = parseInt(option.getAttribute('data-index'), 10);
      const i = index + (selected ? moveUp ? -1 : 1 : 0);
      const options = intf.getElementsOfList(option.getAttribute('data-type'));
      const next = options[i];

      if (next) {
        intf.updateSelectedOptions(next, true, false);
      }
    }

    function selectNextOptionFromShift(option, moveUp, isMultiple, intf) {
      const curr = parseInt(option.getAttribute('data-index'), 10);

      if (intf.getShiftIndex() < 0) {
        intf.setShiftIndex(curr);
        intf.setLastShift(moveUp);
      }

      const next = curr + (intf.getLastShift() !== moveUp ? 0 : moveUp ? -1 : 1);
      const pos = next < intf.getShiftIndex();
      const shiftAdd = pos === moveUp || intf.getShiftIndex() === next;
      const options = intf.getElementsOfList(option.getAttribute('data-type'));
      const nextOption = options[next];

      if (nextOption) {
        intf.updateSelectedOptions(nextOption, shiftAdd, true);
        intf.setLastShift(moveUp);
      }
    }

    function handleKeyDownOnOption(event, keyboardInterface) {
      if (event.metaKey || event.ctrlKey) {
        keyboardInterface.setShiftIndex(-1);
        const keyCodesA = 'A'.charCodeAt(0);
        const selected = event.target.getAttribute('aria-selected') === 'true';

        switch (event.keyCode) {
          case keyCodes.up:
            preventDefaultAndStopPropagation$3(event);
            setFocusOnNextOption(event.target, true, keyboardInterface);
            break;

          case keyCodes.down:
            preventDefaultAndStopPropagation$3(event);
            setFocusOnNextOption(event.target, false, keyboardInterface);
            break;

          case keyCodes.right:
            preventDefaultAndStopPropagation$3(event);
            keyboardInterface.moveOptionsBetweenLists(true);
            break;

          case keyCodes.left:
            preventDefaultAndStopPropagation$3(event);
            keyboardInterface.moveOptionsBetweenLists(false);
            break;

          case keyCodes.space:
            preventDefaultAndStopPropagation$3(event);
            keyboardInterface.updateSelectedOptions(event.target, !selected, true);
            break;

          case keyCodesA:
            preventDefaultAndStopPropagation$3(event);
            keyboardInterface.selectAllOptions(event.target);
            break;

          default: // do nothing

        }
      } else if (event.shiftKey) {
        switch (event.keyCode) {
          case keyCodes.up:
            preventDefaultAndStopPropagation$3(event);
            selectNextOptionFromShift(event.target, true, true, keyboardInterface);
            break;

          case keyCodes.down:
            preventDefaultAndStopPropagation$3(event);
            selectNextOptionFromShift(event.target, false, true, keyboardInterface);
            break;

          default: // do nothing

        }
      } else {
        keyboardInterface.setShiftIndex(-1);

        switch (event.keyCode) {
          case keyCodes.up:
            preventDefaultAndStopPropagation$3(event);
            selectNextOption(event.target, true, keyboardInterface);
            break;

          case keyCodes.down:
            preventDefaultAndStopPropagation$3(event);
            selectNextOption(event.target, false, keyboardInterface);
            break;

          default: // do nothing

        }
      }
    }

    function _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$2(target, key, source[key]); }); } return target; }

    function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    const i18n$b = {
      componentAssistiveText: labelComponentAssistiveText,
      downButtonAssistiveText: labelDownButtonAssistiveText,
      maxError: labelMaxError,
      maxHelp: labelMaxHelp,
      minErrorPlural: labelMinErrorPlural,
      minErrorSingular: labelMinErrorSingular,
      minHelp: labelMinHelp,
      minRequiredErrorPlural: labelMinRequiredErrorPlural,
      minRequiredErrorSingular: labelMinRequiredErrorSingular,
      optionLockAssistiveText: labelOptionLockAssistiveText,
      required: labelRequired,
      requiredError: labelRequiredError,
      requiredOptionError: labelRequiredOptionError,
      upButtonAssistiveText: labelUpButtonAssistiveText,
      moveSelectionToAssistiveText: labelMoveSelectionToAssistiveText,
      loadingText: labelLoadingText
    };
    /**
     * A pair of listboxes that enables multiple options to be selected and reordered.
     */

    class LightningDualListbox extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.sourceLabel = void 0;
        this.selectedLabel = void 0;
        this.label = void 0;
        this.options = void 0;
        this.min = 0;
        this.max = void 0;
        this.name = void 0;
        this._showActivityIndicator = false;
        this._requiredOptions = [];
        this._selectedValues = [];
        this._variant = void 0;
        this._disabled = void 0;
        this._disableReordering = false;
        this._required = false;
        this._addButtonLabel = void 0;
        this._removeButtonLabel = void 0;
        this._upButtonLabel = void 0;
        this._downButtonLabel = void 0;
        this._size = void 0;
        this.errorMessage = '';
        this.highlightedOptions = [];
        this.focusableInSource = void 0;
        this.focusableInSelected = void 0;
        this.isFocusOnList = false;
        this.messageWhenValueMissing = i18n$b.requiredError;
        this.fieldLevelHelp = void 0;
      }

      /**
       * Error message to be displayed when a range overflow is detected.
       * @type {string}
       */
      get messageWhenRangeOverflow() {
        return this._messageWhenRangeOverflow || this._overflowMessage;
      }

      set messageWhenRangeOverflow(message) {
        this._messageWhenRangeOverflow = message;
      }
      /**
       * Error message to be displayed when a range underflow is detected.
       * @type {string}
       */


      get messageWhenRangeUnderflow() {
        return this._messageWhenRangeUnderflow || this._underflowMessage;
      }

      set messageWhenRangeUnderflow(message) {
        this._messageWhenRangeUnderflow = message;
      }
      /**
       * If present, the listbox is disabled and users cannot interact with it.
       * @type {string}
       */


      get disabled() {
        return this._disabled || false;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, the user must add an item to the selected listbox before submitting the form.
       * @type {string}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }
      /**
       * A list of default options that are included in the selected options listbox. This list is populated with values from the options attribute.
       * @type {list}
       */


      get value() {
        return this._selectedValues;
      }

      set value(newValue) {
        this._selectedValues = newValue || [];

        if (this._connected) {
          this.addRequiredOptionsToValue();
        }
      }
      /**
       * A list of required options that cannot be removed from selected options listbox. This list is populated with values from the options attribute.
       * @type {list}
       */


      get requiredOptions() {
        return this._requiredOptions;
      }

      set requiredOptions(newValue) {
        this._requiredOptions = newValue || [];

        if (this._connected) {
          this.addRequiredOptionsToValue();
        }
      }
      /**
       * The variant changes the appearance of the dual listbox.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and dual listbox.
       * Use label-stacked to place the label above the dual listbox.
       * @type {string}
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant$1(value);
        this.updateClassList();
      }

      set size(value) {
        this._size = value;
      }
      /**
       * Number of items that display in the listboxes before vertical scrollbars are displayed. Determines the vertical size of the listbox.
       * @type {number}
       * @default
       */


      get size() {
        return this._size;
      }
      /**
       * Help text detailing the purpose and function of the dual listbox.
       * @type {string}
       */


      set disableReordering(value) {
        this._disableReordering = normalizeBoolean(value);
      }
      /**
       * If present, the Up and Down buttons used for reordering the selected list items are hidden.
       * @type {boolean}
       * @default false
       */


      get disableReordering() {
        return this._disableReordering;
      }
      /**
       * If present, a spinner is displayed in the first listbox to indicate loading activity.
       * @type {boolean}
       * @default false
       */


      get showActivityIndicator() {
        return this._showActivityIndicator;
      }

      set showActivityIndicator(value) {
        this._showActivityIndicator = normalizeBoolean(value);
      }
      /**
       * Sets focus on the first option from either list.
       * If the source list doesn't contain any options, the first option on the selected list is focused on.
       */


      focus() {
        // focus on the first option from either list
        // if nothing on source, then it'll pick the one on selected
        const firstOption = this.template.querySelector(`div[data-index='0']`);

        if (firstOption) {
          firstOption.focus();
          this.updateSelectedOptions(firstOption, true, false);
        }
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * Returns the valid attribute value (Boolean) on the ValidityState object.
       * @returns {boolean} Indicates whether the dual listbox meets all constraint validations.
       */


      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */


      reportValidity() {
        return this._constraint.reportValidity(message => {
          this.errorMessage = message;
        });
      }
      /**
       * Sets a custom error message to be displayed when the dual listbox value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message
       *     is reset.
       */


      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }
      /**
       * Displays an error message if the dual listbox value is required.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
        this.keyboardInterface = this.selectKeyboardInterface();
        this._connected = true;
        this.addRequiredOptionsToValue(); // debounceInteraction since DualListbox has multiple focusable elements

        this.interactingState = new InteractingState({
          debounceInteraction: true
        });
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          this.showHelpMessageIfInvalid();
          this.dispatchEvent(new CustomEvent('blur'));
        });
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      renderedCallback() {
        this.assertRequiredAttributes();

        if (this.disabled) {
          return;
        }

        if (this.optionToFocus) {
          // value could have an apostrophe, which is why we need to escape it otherwise the queryselector will not work
          const option = this.template.querySelector(`div[data-value='${this.optionToFocus.replace(/'/g, "\\'")}']`);

          if (option) {
            this.isFocusOnList = true;
            option.focus();
          }
        }
      }

      get computedUniqueId() {
        return this.uniqueId;
      }

      get computedSourceListId() {
        return getRealDOMId(this.template.querySelector('[data-source-list]'));
      }

      get computedSelectedListId() {
        return getRealDOMId(this.template.querySelector('[data-selected-list]'));
      }

      get ariaDisabled() {
        // aria-disabled works only with String not Boolean value
        return String(this.disabled);
      }

      get computedSourceList() {
        let sourceListOptions = [];

        if (this.options) {
          const required = this.requiredOptions;
          const values = this.value;
          sourceListOptions = this.options.filter(option => values.indexOf(option.value) === -1 && required.indexOf(option.value) === -1);
        }

        return this.computeListOptions(sourceListOptions, this.focusableInSource);
      }

      get computedSelectedList() {
        const selectedListOptions = [];

        if (this.options) {
          const optionsMap = {};
          this.options.forEach(option => {
            optionsMap[option.value] = _objectSpread$2({}, option);
          });
          this.value.forEach(optionValue => {
            const option = optionsMap[optionValue];

            if (option) {
              option.isSelected = true;
            }
          });
          this.requiredOptions.forEach(optionValue => {
            const option = optionsMap[optionValue];

            if (option) {
              option.isLocked = true;
            }
          }); // add selected items in the given order

          this.value.forEach(optionValue => {
            const option = optionsMap[optionValue];

            if (option) {
              selectedListOptions.push(option);
            }
          });
        }

        return this.computeListOptions(selectedListOptions, this.focusableInSelected);
      }

      computeListOptions(options, focusableOptionValue) {
        if (options.length > 0) {
          const focusableOption = options.find(option => {
            return option.value === focusableOptionValue;
          });
          const focusableValue = focusableOption ? focusableOption.value : options[0].value;
          return options.map(option => {
            return this.computeOptionProperties(option, focusableValue);
          });
        }

        return [];
      }

      computeOptionProperties(option, focusableValue) {
        const isSelected = this.highlightedOptions.indexOf(option.value) > -1;
        const classList = classSet('slds-listbox__option slds-listbox__option_plain slds-media slds-media_small slds-media_inline').add({
          'slds-is-selected': isSelected
        }).toString();
        return _objectSpread$2({}, option, {
          tabIndex: option.value === focusableValue ? '0' : '-1',
          selected: isSelected ? 'true' : 'false',
          classList
        });
      }

      get computedLeftColumnClass() {
        return classSet('slds-dueling-list__column slds-dueling-list__column_responsive').add({
          'slds-is-relative': this.showActivityIndicator
        }).toString();
      }

      get computedColumnStyle() {
        if (this.isNumber(this.size)) {
          // From the SLDS page on how to adjust the height: lightningdesignsystem.com/components/dueling-picklist/#Responsive
          const newHeight = parseInt(this.size, 10) * 2.25 + 1;
          return `height:${newHeight}rem`;
        }

        return '';
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedGroupLabelClass() {
        return classSet('slds-form-element__label slds-form-element__legend').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedListboxContainerClass() {
        return classSet('slds-dueling-list__options').add({
          'slds-is-disabled': this.disabled
        }).toString();
      }

      get computedLockAssistiveText() {
        return this.formatString(this.i18n.optionLockAssistiveText, this.selectedLabel);
      }

      get i18n() {
        return i18n$b;
      }

      getRightButtonAssistiveText() {
        return this.formatString(i18n$b.moveSelectionToAssistiveText, this.selectedLabel);
      }
      /**
       * Label for add button.
       * @type {string}
       * @default Move selection to {selectedLabel}
       */


      get addButtonLabel() {
        if (this._addButtonLabel) {
          return this._addButtonLabel;
        }

        return this.getRightButtonAssistiveText();
      }

      set addButtonLabel(value) {
        this._addButtonLabel = value;
      }

      getLeftButtonAssistiveText() {
        return this.formatString(i18n$b.moveSelectionToAssistiveText, this.sourceLabel);
      }
      /**
       * Label for remove button.
       * @type {string}
       * @default "Move selection to {sourceLabel}"
       */


      get removeButtonLabel() {
        if (this._removeButtonLabel) {
          return this._removeButtonLabel;
        }

        return this.getLeftButtonAssistiveText();
      }

      set removeButtonLabel(value) {
        this._removeButtonLabel = value;
      }
      /**
       * Label for up button.
       * @type {string}
       * @default "Move selection up"
       */


      get upButtonLabel() {
        return this._upButtonLabel || this.i18n.upButtonAssistiveText;
      }

      set upButtonLabel(value) {
        this._upButtonLabel = value;
      }
      /**
       * Label for down button.
       * @type {string}
       * @default "Move selection down"
       */


      get downButtonLabel() {
        return this._downButtonLabel || this.i18n.downButtonAssistiveText;
      }

      set downButtonLabel(value) {
        this._downButtonLabel = value;
      }

      get moveButtonsDisabled() {
        return this.disabled || this.showActivityIndicator;
      }

      handleOptionClick(event) {
        this.interactingState.interacting();

        if (this.disabled) {
          return;
        }

        const selectMultiple = event.metaKey || event.ctrlKey || event.shiftKey;
        const option = event.currentTarget;

        if (event.shiftKey) {
          this.selectAllFromLastSelectedToOption(option, false);
          return;
        }

        const selected = selectMultiple && option.getAttribute('aria-selected') === 'true';
        this.updateSelectedOptions(option, !selected, selectMultiple);
        this.shiftIndex = -1;
      }

      handleFocus(event) {
        this.interactingState.enter(); // select the focused option if entering a listbox

        const element = event.target;

        if (element.role === 'option') {
          if (!this.isFocusOnList) {
            this.isFocusOnList = true;
            this.updateSelectedOptions(element, true, false);
          }
        }
      }

      handleBlur(event) {
        this.interactingState.leave();
        const element = event.target;

        if (element.role !== 'option') {
          this.isFocusOnList = false;
        }
      }

      handleRightButtonClick() {
        this.interactingState.interacting();
        this.moveOptionsBetweenLists(true);
      }

      handleLeftButtonClick() {
        this.interactingState.interacting();
        this.moveOptionsBetweenLists(false);
      }

      handleUpButtonClick() {
        this.interactingState.interacting();
        this.changeOrderOfOptionsInList(true);
      }

      handleDownButtonClick() {
        this.interactingState.interacting();
        this.changeOrderOfOptionsInList(false);
      }

      handleOptionKeyDown(event) {
        this.interactingState.interacting();

        if (this.disabled) {
          return;
        }

        handleKeyDownOnOption(event, this.keyboardInterface);
      }

      moveOptionsBetweenLists(addToSelect, retainFocus) {
        const isValidList = addToSelect ? this.selectedList === this.computedSourceListId : this.selectedList === this.computedSelectedListId;

        if (!isValidList) {
          return;
        }

        const toMove = this.highlightedOptions;
        const values = this.computedSelectedList.map(option => option.value);
        const required = this.requiredOptions;
        let newValues = [];

        if (addToSelect) {
          newValues = values.concat(toMove);
        } else {
          newValues = values.filter(value => toMove.indexOf(value) === -1 || required.indexOf(value) > -1);
        }

        const oldSelectedValues = this._selectedValues;
        this._selectedValues = newValues;
        const invalidMove = this.validity.valueMissing || this.validity.rangeOverflow && this.selectedList === this.computedSourceListId || this.validity.rangeUnderflow && this.selectedList === this.computedSelectedListId;

        if (invalidMove || toMove.length === 0) {
          this.showHelpMessageIfInvalid();
          this._selectedValues = oldSelectedValues;
          return;
        }

        if (retainFocus) {
          const listId = addToSelect ? this.computedSelectedListId : this.computedSourceListId;
          this.selectedList = listId;
          this.updateFocusableOption(listId, toMove[0]);
        } else {
          this.interactingState.leave();
          this.isFocusOnList = false;
          this.highlightedOptions = [];
          this.optionToFocus = null;
        }

        this.dispatchChangeEvent(newValues);
      }

      changeOrderOfOptionsInList(moveUp) {
        const elementList = this.getElementsOfList(this.selectedList);
        const values = this.computedSelectedList.map(option => option.value);
        const toMove = values.filter(option => this.highlightedOptions.indexOf(option) > -1);
        const validSelection = toMove.length === 0 || this.selectedList !== this.computedSelectedListId;

        if (validSelection) {
          return;
        }

        let start = moveUp ? 0 : toMove.length - 1;
        let index = values.indexOf(toMove[start]);
        const validMove = moveUp && index === 0 || !moveUp && index === values.length - 1;

        if (validMove) {
          return;
        }

        if (moveUp) {
          while (start < toMove.length) {
            index = values.indexOf(toMove[start]);
            this.swapOptions(index, index - 1, values, elementList);
            start++;
          }
        } else {
          while (start > -1) {
            index = values.indexOf(toMove[start]);
            this.swapOptions(index, index + 1, values, elementList);
            start--;
          }
        }

        this._selectedValues = values;
        this.updateFocusableOption(this.selectedList, toMove[0]);
        this.optionToFocus = null;
        this.dispatchChangeEvent(values);
      }

      selectAllFromLastSelectedToOption(option, all) {
        const listId = option.getAttribute('data-type');
        this.updateCurrentSelectedList(listId, true);
        const options = this.getElementsOfList(listId);
        const end = all ? 0 : this.getOptionIndex(option);
        this.lastSelected = this.lastSelected < 0 ? end : this.lastSelected;
        const start = all ? options.length : this.lastSelected;
        let val, select;
        this.highlightedOptions = [];

        for (let i = 0; i < options.length; i++) {
          select = (i - start) * (i - end) <= 0;

          if (select) {
            val = options[i].getAttribute('data-value');
            this.highlightedOptions.push(val);
          }
        }
      }

      updateSelectedOptions(option, select, isMultiple) {
        const value = option.getAttribute('data-value');
        const listId = this.getListId(option);
        const optionIndex = this.getOptionIndex(option);
        this.updateCurrentSelectedList(listId, isMultiple);

        if (select) {
          if (this.highlightedOptions.indexOf(value) === -1) {
            this.highlightedOptions.push(value);
          }
        } else {
          this.highlightedOptions.splice(this.highlightedOptions.indexOf(value), 1);
        }

        this.updateFocusableOption(listId, value);
        this.lastSelected = optionIndex;
      }

      addRequiredOptionsToValue() {
        if (!this.options || !this.options.length || !this._requiredOptions || !this._requiredOptions.length) {
          // no options/requiredOptions, just ignore
          return;
        }

        const numOfSelectedValues = this._selectedValues.length;
        const allValues = this.options.map(option => option.value);

        const requiredValues = this._requiredOptions.filter(option => allValues.includes(option)); // add required options to the selected values as they are already displayed in the selected list


        this._selectedValues = [...new Set([...requiredValues, ...this._selectedValues])];

        if (numOfSelectedValues !== this._selectedValues.length) {
          // value was changed
          this.dispatchChangeEvent(this._selectedValues);
        }
      }

      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => !this.disabled && this.required && this.computedSelectedList.length < 1,
            rangeUnderflow: () => this.computedSelectedList.length < this.min,
            rangeOverflow: () => this.computedSelectedList.length > this.max
          });
        }

        return this._constraintApi;
      }

      get _overflowMessage() {
        const minHelpMsg = this.min > 0 ? this.formatString(this.i18n.minHelp, this.min) : '';
        return this.formatString(this.i18n.maxError, this.max) + minHelpMsg;
      }

      get _underflowMessage() {
        const maxHelpMsg = this.max ? this.formatString(this.i18n.maxHelp, this.max) : '';
        const minRequiredError = this.min > 1 ? this.formatString(this.i18n.minRequiredErrorPlural, this.min) : this.i18n.minRequiredErrorSingular;
        const minError = this.min > 1 ? this.formatString(this.i18n.minErrorPlural, this.min) : this.i18n.minErrorSingular;
        return this.required ? minRequiredError + maxHelpMsg : minError + maxHelpMsg;
      }

      updateCurrentSelectedList(currentList, isMultiple) {
        if (this.selectedList !== currentList || !isMultiple) {
          if (this.selectedList) {
            this.highlightedOptions = [];
            this.lastSelected = -1;
          }

          this.selectedList = currentList;
        }
      }

      dispatchChangeEvent(values) {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: values
          }
        }));
      }

      assertRequiredAttributes() {
        assert(!!this.label, `<lightning-dual-listbox> Missing required "label" attribute.`);
        assert(!!this.sourceLabel, `<lightning-dual-listbox> Missing required "sourceLabel" attribute.`);
        assert(!!this.selectedLabel, `<lightning-dual-listbox> Missing required "selectedLabel" attribute.`);
        assert(!!this.options, `<lightning-dual-listbox> Missing required "options" attribute.`);
      }

      swapOptions(i, j, array) {
        const temp = array[i];
        array[i] = array[j];
        array[j] = temp;
      }

      formatString(str, ...args) {
        if (str) {
          return str.replace(/{(\d+)}/g, (match, i) => {
            return typeof args[i] !== 'undefined' ? args[i] : match;
          });
        }

        return '';
      }

      getElementsOfList(listId) {
        const elements = this.template.querySelectorAll(`div[data-type='${listId}']`);
        return elements ? elements : [];
      }

      selectKeyboardInterface() {
        const that = this;
        that.shiftIndex = -1;
        that.lastShift = null;
        return {
          getShiftIndex() {
            return that.shiftIndex;
          },

          setShiftIndex(value) {
            that.shiftIndex = value;
          },

          getLastShift() {
            return that.lastShift;
          },

          setLastShift(value) {
            that.lastShift = value;
          },

          getElementsOfList(listId) {
            return that.getElementsOfList(listId);
          },

          selectAllOptions(option) {
            that.selectAllFromLastSelectedToOption(option, true);
          },

          updateSelectedOptions(option, select, isMultiple) {
            that.updateSelectedOptions(option, select, isMultiple);
          },

          moveOptionsBetweenLists(addToSelect) {
            that.moveOptionsBetweenLists(addToSelect, true);
          }

        };
      }

      getOptionIndex(optionElement) {
        return parseInt(optionElement.getAttribute('data-index'), 10);
      }

      getListId(optionElement) {
        return getRealDOMId(optionElement.parentElement.parentElement);
      }

      updateFocusableOption(listId, value) {
        if (listId === this.computedSourceListId) {
          this.focusableInSource = value;
        } else if (listId === this.computedSelectedListId) {
          this.focusableInSelected = value;
        }

        this.optionToFocus = value;
      }

      isNumber(value) {
        return value !== '' && value !== null && isFinite(value);
      }

    }

    lwc.registerDecorators(LightningDualListbox, {
      publicProps: {
        sourceLabel: {
          config: 0
        },
        selectedLabel: {
          config: 0
        },
        label: {
          config: 0
        },
        options: {
          config: 0
        },
        min: {
          config: 0
        },
        max: {
          config: 0
        },
        name: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        messageWhenRangeOverflow: {
          config: 3
        },
        messageWhenRangeUnderflow: {
          config: 3
        },
        disabled: {
          config: 3
        },
        required: {
          config: 3
        },
        value: {
          config: 3
        },
        requiredOptions: {
          config: 3
        },
        variant: {
          config: 3
        },
        size: {
          config: 3
        },
        fieldLevelHelp: {
          config: 0
        },
        disableReordering: {
          config: 3
        },
        showActivityIndicator: {
          config: 3
        },
        validity: {
          config: 1
        },
        addButtonLabel: {
          config: 3
        },
        removeButtonLabel: {
          config: 3
        },
        upButtonLabel: {
          config: 3
        },
        downButtonLabel: {
          config: 3
        }
      },
      publicMethods: ["focus", "checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        _showActivityIndicator: 1,
        _requiredOptions: 1,
        _selectedValues: 1,
        _variant: 1,
        _disabled: 1,
        _disableReordering: 1,
        _required: 1,
        _addButtonLabel: 1,
        _removeButtonLabel: 1,
        _upButtonLabel: 1,
        _downButtonLabel: 1,
        _size: 1,
        errorMessage: 1,
        highlightedOptions: 1,
        focusableInSource: 1,
        focusableInSelected: 1
      }
    });

    var _lightningDualListbox = lwc.registerComponent(LightningDualListbox, {
      tmpl: _tmpl$n
    });

    function stylesheet$9(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$9 = [stylesheet$9];

    function tmpl$p($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        gid: api_scoped_id
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        key: 2
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 4
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp._fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp._fieldLevelHelp
        },
        key: 5
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 6
      }, [api_custom_element("lightning-base-combobox", _lightningBaseCombobox, {
        props: {
          "name": $cmp.name,
          "disabled": $cmp.disabled,
          "placeholder": $cmp.placeholder,
          "items": $cmp._items,
          "inputText": $cmp._selectedLabel,
          "inputIconSize": "xx-small",
          "inputIconName": "utility:down",
          "showDropdownActivityIndicator": $cmp.spinnerActive,
          "dropdownAlignment": $cmp.dropdownAlignment
        },
        key: 7,
        on: {
          "dropdownopen": _m0 || ($ctx._m0 = api_bind($cmp.handleDropdownOpen)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleBlur)),
          "ready": _m3 || ($ctx._m3 = api_bind($cmp.handleComboboxReady)),
          "select": _m4 || ($ctx._m4 = api_bind($cmp.handleSelect))
        }
      }, [])]), $cmp._helpMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("help-text"),
          "data-help-text": true,
          "aria-live": "assertive"
        },
        key: 9
      }, [api_dynamic($cmp._helpMessage)]) : null];
    }

    var _tmpl$o = lwc.registerTemplate(tmpl$p);
    tmpl$p.stylesheets = [];

    if (_implicitStylesheets$9) {
      tmpl$p.stylesheets.push.apply(tmpl$p.stylesheets, _implicitStylesheets$9);
    }
    tmpl$p.stylesheetTokens = {
      hostAttribute: "lightning-combobox_combobox-host",
      shadowAttribute: "lightning-combobox_combobox"
    };

    var labelPlaceholder = 'Select an Option';

    const i18n$c = {
      required: labelRequired,
      placeholder: labelPlaceholder
    };
    /**
     * A widget that provides an input field that is readonly,
     * accompanied by a dropdown list of selectable options.
     */

    class LightningCombobox extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._ariaLabelledBy = '';
        this._ariaDescribedBy = '';
        this._fieldLevelHelp = '';
        this._selectedLabel = '';
        this._disabled = false;
        this._readOnly = false;
        this._spinnerActive = false;
        this._required = false;
        this.label = void 0;
        this.dropdownAlignment = 'left';
        this.placeholder = i18n$c.placeholder;
        this.messageWhenValueMissing = void 0;
        this.name = void 0;
        this._items = [];
        this._variant = void 0;
        this._helpMessage = void 0;
        this._labelForId = void 0;
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.showHelpMessageIfInvalid()); // The connected logic here is needed because at the point when @api setters
        // are called other values may not have been set yet, so it could happen that the 'value' was set, but 'options'
        // are not available, or that the 'options' and 'value' have been set but 'multiple' hasn't been set yet.
        // So here we make sure that we start processing the data only once the element is actually in DOM, which
        // should be beneficial for performance as well

        this.connected = true;
        this._items = this.generateItems(this.options);

        if (this.options && this.selectedValue !== undefined) {
          this.updateSelectedOptions();
        }
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this.connected = false;
      }
      /**
       * Reserved for internal use. Use the standard aria-labelledby instead. A space-separated list of element IDs that provide labels for the combobox.
       * @type {string}
       */


      get ariaLabelledBy() {
        return this._ariaLabelledBy;
      }

      set ariaLabelledBy(labelledBy) {
        this._ariaLabelledBy = labelledBy;
      }
      /**
       * Reserved for internal use. Use the standard aria-describedby instead. A space-separated list of element IDs that provide descriptive labels for the combobox.
       * @type {string}
       */


      get ariaDescribedBy() {
        return this._ariaDescribedBy;
      }

      set ariaDescribedBy(describedBy) {
        this._ariaDescribedBy = describedBy;
      }
      /**
       * Help text detailing the purpose and function of the combobox.
       * @type {string}
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }
      /**
       * The variant changes the appearance of the combobox.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and combobox.
       * Use label-stacked to place the label above the combobox.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant$1(value);
        this.updateClassList();
      }
      /**
       * Specifies the value of an input element.
       * @type {object}
       */


      get value() {
        return this.selectedValue;
      }

      set value(newValue) {
        // There are some cases where this won't work correctly
        // See https://git.soma.salesforce.com/raptor/raptor/issues/457
        if (newValue !== this.selectedValue) {
          this.selectedValue = newValue;

          if (this.connected && this.options) {
            this.updateSelectedOptions();
          }
        }
      }
      /**
       * A list of options that are available for selection. Each option has the following attributes: label and value.
       * @type {object[]}
       * @required
       */


      get options() {
        return this._options || [];
      }

      set options(newValue) {
        this._options = normalizeArray(newValue);

        if (this.connected) {
          this._items = this.generateItems(this._options);
          this.updateSelectedOptions();
        }
      }
      /**
       * If present, the combobox is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled || this._readOnly || false;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, the combobox is read-only.
       * A read-only combobox is also disabled.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this.disabled;
      }

      set readOnly(value) {
        this._readOnly = normalizeBoolean(value);
      }
      /**
       * If present, a value must be selected before the form can be submitted.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }
      /**
       * If present, a spinner is displayed below the menu items to indicate loading activity.
       * @type {boolean}
       * @default false
       */


      get spinnerActive() {
        return this._spinnerActive;
      }

      set spinnerActive(value) {
        this._spinnerActive = normalizeBoolean(value);
      }
      /**
       * Sets focus on the combobox.
       */


      focus() {
        if (this.connected) {
          this.getBaseComboboxElement().focus();
        }
      }
      /**
       * Removes focus from the combobox.
       */


      blur() {
        if (this.connected) {
          this.getBaseComboboxElement().blur();
        }
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       * @required
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * Returns the valid attribute value (Boolean) on the ValidityState object.
       * @returns {boolean} Indicates whether the combobox has any validity errors.
       */


      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the combobox.
       */


      reportValidity() {
        return this._constraint.reportValidity(message => {
          this._helpMessage = message;
        });
      }
      /**
       * Sets a custom error message to be displayed when the combobox value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message
       * is reset.
       */


      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }
      /**
       * Shows the help message if the combobox is in an invalid state.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      handleComboboxReady(e) {
        this._labelForId = e.detail.id;
      }

      synchronizeA11y() {
        synchronizeAttrs(this.template.querySelector('label'), {
          for: this._labelForId
        });
        const baseCombobox = this.template.querySelector('lightning-base-combobox');
        baseCombobox.inputLabelledByElement = this.ariaLabelledBy;
        baseCombobox.inputDescribedByElements = this.computedAriaDescribedBy;
      }

      get i18n() {
        return i18n$c;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedAriaDescribedBy() {
        const describedByElements = [];

        if (this._helpMessage) {
          const helpText = this.template.querySelector('[data-help-text]');
          describedByElements.push(helpText);
        }

        if (typeof this.ariaDescribedBy === 'string') {
          describedByElements.push(this.ariaDescribedBy);
        }

        return describedByElements;
      }

      handleSelect(event) {
        if (event.detail.value === this.selectedValue) {
          return;
        }

        this.selectedValue = event.detail.value;
        this.updateSelectedOptions();
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this.selectedValue
          }
        }));
      }

      handleFocus() {
        this.interactingState.enter();
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.interactingState.leave();
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleDropdownOpen() {
        this.dispatchEvent(new CustomEvent('open'));
      }

      updateSelectedOptions() {
        this.updateSelectedLabelFromValue(this.selectedValue);
        this.markOptionSelectedFromValue(this.selectedValue);
      }

      markOptionSelectedFromValue(value) {
        if (this._items) {
          const selectedItem = this._items.find(item => item.value === value); // de-select previously selected item


          if (this._selectedItem) {
            this._selectedItem.iconName = undefined;
            this._selectedItem.highlight = false;
          }

          this._selectedItem = selectedItem;

          if (selectedItem) {
            selectedItem.iconName = 'utility:check';
            this._selectedItem.highlight = true;
          } // Make a shallow copy to trigger an update on the combobox


          this._items = this._items.slice();
        }
      }

      updateSelectedLabelFromValue(newValue) {
        this._selectedLabel = this.getOptionLabelByValue(newValue);
      }

      getOptionLabelByValue(value) {
        const foundOption = this.options.find(option => option.value === value);

        if (foundOption) {
          return foundOption.label;
        }

        return '';
      }

      generateItems(options) {
        return options.map(option => {
          return {
            type: 'option-inline',
            text: option.label,
            highlight: this.value === option.value,
            value: option.value
          };
        });
      }

      getBaseComboboxElement() {
        return this.template.querySelector('lightning-base-combobox');
      }

      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => !this.disabled && this.required && isEmptyString(this.selectedValue)
          });
        }

        return this._constraintApi;
      }

    }

    LightningCombobox.delegatesFocus = true;

    lwc.registerDecorators(LightningCombobox, {
      publicProps: {
        label: {
          config: 0
        },
        dropdownAlignment: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        name: {
          config: 0
        },
        ariaLabelledBy: {
          config: 3
        },
        ariaDescribedBy: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        value: {
          config: 3
        },
        options: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        spinnerActive: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        _ariaLabelledBy: 1,
        _ariaDescribedBy: 1,
        _fieldLevelHelp: 1,
        _selectedLabel: 1,
        _disabled: 1,
        _readOnly: 1,
        _spinnerActive: 1,
        _required: 1,
        _items: 1,
        _variant: 1,
        _helpMessage: 1
      }
    });

    var _lightningCombobox = lwc.registerComponent(LightningCombobox, {
      tmpl: _tmpl$o
    });

    function tmpl$q($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9
      } = $ctx;
      return [$cmp.isDesktop ? $cmp.multiple ? api_custom_element("lightning-dual-listbox", _lightningDualListbox, {
        props: {
          "label": $cmp.label,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "value": $cmp.internalValue,
          "options": $cmp.options,
          "size": $cmp.size,
          "disabled": $cmp.disabled,
          "required": $cmp.required,
          "showActivityIndicator": $cmp.showActivityIndicator,
          "disableReordering": $cmp.disableReordering,
          "sourceLabel": $cmp.i18n.available,
          "selectedLabel": $cmp.i18n.chosen
        },
        key: 4,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleBlur)),
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.isDesktop ? !$cmp.multiple ? api_custom_element("lightning-combobox", _lightningCombobox, {
        props: {
          "label": $cmp.label,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "name": $cmp.name,
          "placeholder": $cmp.placeholder,
          "variant": $cmp.variant,
          "value": $cmp.internalValue,
          "options": $cmp.options,
          "disabled": $cmp.disabled,
          "required": $cmp.required,
          "spinnerActive": $cmp.showActivityIndicator,
          "dropdownAlignment": "auto"
        },
        key: 6,
        on: {
          "focus": _m3 || ($ctx._m3 = api_bind($cmp.handleFocus)),
          "blur": _m4 || ($ctx._m4 = api_bind($cmp.handleBlur)),
          "change": _m5 || ($ctx._m5 = api_bind($cmp.handleChange)),
          "open": _m6 || ($ctx._m6 = api_bind($cmp.handleOpen))
        }
      }, []) : null : null, !$cmp.isDesktop ? api_custom_element("lightning-primitive-select", _lightningPrimitiveSelect, {
        props: {
          "label": $cmp.label,
          "multiple": $cmp.multiple,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "name": $cmp.name,
          "variant": $cmp.variant,
          "value": $cmp.internalValue,
          "options": $cmp.options,
          "size": $cmp.size,
          "disabled": $cmp.disabled,
          "required": $cmp.required
        },
        key: 8,
        on: {
          "focus": _m7 || ($ctx._m7 = api_bind($cmp.handleFocus)),
          "blur": _m8 || ($ctx._m8 = api_bind($cmp.handleBlur)),
          "change": _m9 || ($ctx._m9 = api_bind($cmp.handleChange))
        }
      }, []) : null];
    }

    var _tmpl$p = lwc.registerTemplate(tmpl$q);
    tmpl$q.stylesheets = [];

    if (_implicitStylesheets$7) {
      tmpl$q.stylesheets.push.apply(tmpl$q.stylesheets, _implicitStylesheets$7);
    }
    tmpl$q.stylesheetTokens = {
      hostAttribute: "lightning-picklist_picklist-host",
      shadowAttribute: "lightning-picklist_picklist"
    };

    var labelNoneLabel = '--None--';

    var labelAvailable = 'Available';

    var labelChosen = 'Chosen';

    const i18n$d = {
      noneLabel: labelNoneLabel,
      available: labelAvailable,
      chosen: labelChosen
    };

    class LightningPicklist extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._internalValue = void 0;
        this._picklistValue = void 0;
        this._options = void 0;
        this._required = false;
        this._disabled = false;
        this._size = 4;
        this._showActivityIndicator = false;
        this._fieldLevelHelp = void 0;
        this.label = void 0;
        this.name = void 0;
        this.placeholder = void 0;
        this.variant = void 0;
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      set value(newValue) {
        this._picklistValue = newValue;

        if (this.connected) {
          this._internalValue = this.getInternalValue(newValue);
        }
      }

      get value() {
        return this._picklistValue;
      } // only works for multi-select picklists


      set size(value) {
        this._size = this.normalizeSize(value);
      }

      get size() {
        return this._size;
      }

      set options(newOptions) {
        this._options = newOptions;

        if (this.connected) {
          this.updatePicklistOptions(newOptions);
        }
      }

      get options() {
        return this._options;
      }

      set multiple(value) {
        this._multiple = normalizeBoolean(value);
      }

      get multiple() {
        return this._multiple || false;
      }

      set required(value) {
        this._required = normalizeBoolean(value); // reset the flag that hides the required indicator when we have no options

        this._requiredButDisabled = false;
      }

      get required() {
        return this._required;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value); // There are two ways a picklist could end up in a disabled state:
        // 1- explicitly setting disabled and 2- when the picklist has no options
        // If the element is explicitly set to be disabled, it should always remain disabled even when new options are provided

        this._externalDisabled = value;
      }

      get disabled() {
        return this._disabled;
      }

      set showActivityIndicator(value) {
        this._showActivityIndicator = normalizeBoolean(value);
      }

      get showActivityIndicator() {
        return this._showActivityIndicator || false;
      }

      connectedCallback() {
        this.updatePicklistOptions(this._options, true);
        this.connected = true;
      }

      disconnectedCallback() {
        this.connected = false;
      }

      focus() {
        this.getElement.focus();
      }

      blur() {
        this.getElement.blur();
      }

      get validity() {
        return this.getElement.validity;
      }

      checkValidity() {
        return this.validity.valid;
      }

      setCustomValidity(message) {
        this.getElement.setCustomValidity(message);
      }

      reportValidity() {
        return this.getElement.reportValidity();
      }

      showHelpMessageIfInvalid() {
        this.getElement.showHelpMessageIfInvalid();
      }

      get i18n() {
        return i18n$d;
      }

      get internalValue() {
        return this._internalValue;
      }

      get getElement() {
        return this.template.querySelector('lightning-combobox,lightning-dual-listbox,lightning-primitive-select');
      } // disable reordering functionality on dual-listbox


      get disableReordering() {
        return true;
      }

      get isDesktop() {
        return configProvider.getFormFactor() === 'DESKTOP';
      }

      updatePicklistOptions(options, addMissingValues) {
        const newOptions = options ? [...options] : [];
        const existingInternalValue = this.internalValue !== undefined ? this.internalValue : this.getInternalValue(this._picklistValue);

        if (addMissingValues) {
          this.addMissingValuesToOptions(newOptions, existingInternalValue);
        }

        this.maybeAddNoneOption(newOptions);
        this._options = newOptions;
        this.updateDisabledState(options);
        this.updateRequiredState(options);
        const value = this.getValueToSelect(this.options, existingInternalValue);
        this._internalValue = value;

        if (!this.isSameValue(value, existingInternalValue)) {
          this._picklistValue = this.getPicklistValue(value);
          this.dispatchChangeEvent();
        }
      }

      isSameValue(value1, value2) {
        if (Array.isArray(value1) && Array.isArray(value2)) {
          return value1.sort().join(',') === value2.sort().join(',');
        }

        return value1 === value2;
      }

      handleChange(event) {
        event.preventDefault();
        event.stopPropagation();
        this._picklistValue = this.getPicklistValue(event.detail.value);
        this._internalValue = this.getInternalValue(event.detail.value);
        this.dispatchChangeEvent();
      }

      handleFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleOpen() {
        // fire internal event for some force components to leverage
        // e.g. to display the spinner while loading more picklist values
        this.dispatchEvent(new CustomEvent('open'));
      }

      maybeAddNoneOption(options) {
        if (this.shouldAddNoneOption(options.length)) {
          this.addOption(options, this.i18n.noneLabel, '');
        }
      }

      addOption(options, label, value) {
        options.unshift({
          label,
          value
        });
      }

      shouldDisablePicklist(options) {
        if (!options || options.length === 0) {
          return true;
        }

        return false;
      }

      shouldAddNoneOption(numberOfOptions) {
        if (this.multiple) {
          return false;
        }

        if (this.required && numberOfOptions === 1) {
          return false;
        }

        return true;
      }

      updateDisabledState(options) {
        this._disabled = this._externalDisabled !== undefined ? normalizeBoolean(this._externalDisabled) : this.shouldDisablePicklist(options);
      }

      updateRequiredState(options) {
        const shouldDisable = this.shouldDisablePicklist(options);

        if (shouldDisable) {
          if (this._required) {
            // when disabling the picklist, we should remove the required indicator
            this._required = false;
            this._requiredButDisabled = true;
          }

          if (this.connected && this.validity.valueMissing) {
            // if we're disabling the picklist, we should make sure any existing valueMissing message is cleared
            requestAnimationFrame(() => {
              this.showHelpMessageIfInvalid();
            });
          }
        } else if (this._requiredButDisabled) {
          // we now have some options and are not going to have a disabled picklist, so we'll put the required flag back to what it was before
          this._requiredButDisabled = false;
          this._required = true;
        }
      }

      getValueToSelect(options, existingValue) {
        if (!options || options.length === 0) {
          return this.multiple ? [] : '';
        }

        if (this.isValueInOptions(existingValue, options)) {
          return existingValue;
        }

        if (this.multiple) {
          return [];
        }

        if (this.shouldAddNoneOption([...options].length)) {
          return '';
        }

        return options[0].value;
      }

      isValueInOptions(value, options) {
        if (!options || options.length === 0) {
          return false;
        }

        const valueIsInOptions = valueToCheck => options.some(option => {
          return option.value === valueToCheck;
        });

        let valueExists = false;

        if (Array.isArray(value)) {
          valueExists = value.every(valueToCheck => {
            return valueIsInOptions(valueToCheck);
          });
        } else {
          valueExists = valueIsInOptions(value);
        }

        return valueExists;
      } // If values are missing from the options, we will add them to the options.
      // However, since we don't have the label, the same value will be used as label
      // See W-4829389


      addMissingValuesToOptions(newOptions, value) {
        if (!value || Array.isArray(value) && value.length === 0) {
          return;
        }

        const valueIsInOptions = valueToCheck => {
          return newOptions.some(option => {
            return option.value === valueToCheck;
          });
        };

        const maybeAddOption = valueToCheck => {
          if (!valueIsInOptions(valueToCheck)) {
            // Since we don't have the label, we will use the value instead
            this.addOption(newOptions, valueToCheck, valueToCheck);
          }
        };

        if (Array.isArray(value)) {
          value.forEach(valueToCheck => {
            maybeAddOption(valueToCheck);
          });
        } else {
          maybeAddOption(value);
        }
      }

      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this._picklistValue
          }
        }));
      }

      getPicklistValue(value) {
        // multi select picklists should have a ';' separated value string
        if (this.multiple && Array.isArray(value)) {
          return value.join(';');
        }

        return value;
      } // This is the value that is passed into the subcomponents dual-listbox and combobox.
      // In the case of dual-listbox, the component accepts an array of selected values.


      getInternalValue(value) {
        if (this.multiple) {
          if (Array.isArray(value)) {
            return value;
          }

          return typeof value === 'string' && value !== '' && value.split(';') || [];
        }

        return value;
      }

      normalizeSize(value) {
        const parsedValue = parseInt(value, 10);

        if (isNaN(parsedValue) || parsedValue < 3 || parsedValue > 10) {
          // A picklist field can only have a size between 3 and 10 when created declaratively
          // however, there seems to be cases where the size can be outside of this range.
          // In such cases, we will use the default value instead of throwing an error
          return 4;
        }

        return parsedValue;
      }

    }

    LightningPicklist.delegatesFocus = true;

    lwc.registerDecorators(LightningPicklist, {
      publicProps: {
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        variant: {
          config: 0
        },
        fieldLevelHelp: {
          config: 3
        },
        value: {
          config: 3
        },
        size: {
          config: 3
        },
        options: {
          config: 3
        },
        multiple: {
          config: 3
        },
        required: {
          config: 3
        },
        disabled: {
          config: 3
        },
        showActivityIndicator: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "setCustomValidity", "reportValidity", "showHelpMessageIfInvalid"],
      track: {
        _internalValue: 1,
        _picklistValue: 1,
        _options: 1,
        _required: 1,
        _disabled: 1,
        _size: 1,
        _showActivityIndicator: 1,
        _fieldLevelHelp: 1
      }
    });

    var _lightningPicklist = lwc.registerComponent(LightningPicklist, {
      tmpl: _tmpl$p
    });

    function tmpl$r($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        k: api_key,
        i: api_iterator
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_element("fieldset", {
        classMap: {
          "slds-form-element": true
        },
        key: 2
      }, [api_element("legend", {
        className: $cmp.computedLegendClass,
        key: 3
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 5
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 7
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 8
      }, [api_element("div", {
        classMap: {
          "slds-form-element__group": true
        },
        key: 9
      }, api_iterator($cmp.fieldsMetaData, function (field, index) {
        return api_element("div", {
          classMap: {
            "slds-form-element__row": true
          },
          key: api_key(11, field.name)
        }, [field.isInput ? api_custom_element("lightning-input", _lightningInput, {
          attrs: {
            "data-field": field.name
          },
          props: {
            "name": field.name,
            "label": field.label,
            "value": field.value,
            "maxLength": field.maxlength,
            "placeholder": field.placeholder,
            "required": field.required,
            "disabled": $cmp.disabled,
            "readOnly": $cmp.readOnly
          },
          key: 13,
          on: {
            "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFocus)),
            "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleBlur)),
            "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange))
          }
        }, []) : null, field.isCombobox ? api_custom_element("lightning-picklist", _lightningPicklist, {
          attrs: {
            "data-field": field.name
          },
          props: {
            "name": field.name,
            "label": field.label,
            "value": field.value,
            "options": field.options,
            "disabled": $cmp.disabled,
            "placeholder": field.placeholder
          },
          key: 15,
          on: {
            "focus": _m3 || ($ctx._m3 = api_bind($cmp.handleFocus)),
            "blur": _m4 || ($ctx._m4 = api_bind($cmp.handleBlur)),
            "change": _m5 || ($ctx._m5 = api_bind($cmp.handleChange))
          }
        }, []) : null]);
      }))])])];
    }

    var _tmpl$q = lwc.registerTemplate(tmpl$r);
    tmpl$r.stylesheets = [];

    if (_implicitStylesheets$2) {
      tmpl$r.stylesheets.push.apply(tmpl$r.stylesheets, _implicitStylesheets$2);
    }
    tmpl$r.stylesheetTokens = {
      hostAttribute: "lightning-inputName_inputName-host",
      shadowAttribute: "lightning-inputName_inputName"
    };

    var labelFirstName = 'First Name';

    var labelInformalName = 'Informal Name';

    var labelLastName = 'Last Name';

    var labelMiddleName = 'Middle Name';

    var labelNone = 'None';

    var labelSalutation = 'Salutation';

    var labelSuffix = 'Suffix';

    const FORMAT_CODE_MAP = {
      L: 'lastName',
      M: 'middleName',
      F: 'firstName',
      S: 'salutation',
      X: 'suffix',
      I: 'informalName'
    };
    const parseFieldsFormat = function (format) {
      if (isValidLocaleFormat(format)) {
        return format.toUpperCase().split(/(?=[A-Z])/).map(formatCode => FORMAT_CODE_MAP[formatCode]);
      }

      return [];
    };
    const getFieldsOrder = function () {
      const locale = getLocaleTag().replace(/-/g, '_');
      const inputOrder = parseFieldsFormat(name.getNameInputOrder(locale));
      return inputOrder;
    };

    function isValidLocaleFormat(value) {
      return typeof value === 'string' && /^[LMFSXI]+$/i.test(value);
    }

    const FIELD_TYPE = {
      INPUT: 'input',
      PICKLIST: 'combobox'
    };
    const DEFAULT_MAXLENGTH = 40;
    const DEFAULT_FIELD_META = {
      salutation: {
        inputType: FIELD_TYPE.PICKLIST
      },
      firstName: {},
      middleName: {},
      informalName: {},
      lastName: {
        maxlength: 80,
        required: true
      },
      suffix: {}
    };
    const i18n$e = {
      firstName: labelFirstName,
      informalName: labelInformalName,
      lastName: labelLastName,
      middleName: labelMiddleName,
      none: labelNone,
      required: labelRequired,
      salutation: labelSalutation,
      suffix: labelSuffix
    };
    /**
     * Represents a name compound field.
     */

    class LightningInputName extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.label = void 0;
        this.options = void 0;
        this.fieldsToDisplay = ['firstName', 'salutation', 'lastName'];
        this._salutation = '';
        this._lastName = '';
        this._firstName = '';
        this._middleName = '';
        this._informalName = '';
        this._suffix = '';
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        this._variant = void 0;
        this._fieldLevelHelp = void 0;
      }

      connectedCallback() {
        this._connected = true;
        this.classList.add('slds-form-element', 'slds-form-compound');
        this.updateClassList();
        this.interactingState = new InteractingState({
          debounceInteraction: true
        });
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          this.showHelpMessageIfInvalid();
          this.dispatchEvent(new CustomEvent('blur'));
        });
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * Displays the Salutation field as a dropdown menu. An array of label-value pairs must be provided using the options attribute.
       * @type {string}
       *
       */


      get salutation() {
        return this._salutation;
      }

      set salutation(value) {
        this._salutation = value;
      }
      /**
       * Displays the First Name field.
       * @type {string}
       *
       */


      get firstName() {
        return this._firstName;
      }

      set firstName(value) {
        this._firstName = value;
      }
      /**
       * Displays the Middle Name field.
       * @type {string}
       *
       */


      get middleName() {
        return this._middleName;
      }

      set middleName(value) {
        this._middleName = value;
      }
      /**
       * Displays the Informal Name field.
       * @type {string}
       *
       */


      get informalName() {
        return this._informalName;
      }

      set informalName(value) {
        this._informalName = value;
      }
      /**
       * Displays the Last Name field.
       * @type {string}
       *
       */


      get lastName() {
        return this._lastName;
      }

      set lastName(value) {
        this._lastName = value;
      }
      /**
       * Displays the Suffix field.
       * @type {string}
       *
       */


      get suffix() {
        return this._suffix;
      }

      set suffix(value) {
        this._suffix = value;
      }
      /**
       * If present, the input name field is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, the input name field is read-only and cannot be edited.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }
      /**
       * If present, the input name field must be filled out before the form is submitted.
       * A red asterisk is displayed on the Last Name field. An error
       * message is displayed if a user interacts with the Last Name
       * field and does not provide a value.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }
      /**
       * The variant changes the appearance of a name compound field.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and name fields.
       * Use label-stacked to place the label above the name fields.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant$1(value);
        this.updateClassList();
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }
      /**
       * Help text detailing the purpose and function of the input.
       * @type {string}
       *
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }
      /**
       * Sets focus on the first input field.
       */


      focus() {
        this.template.querySelector('[data-field]').focus();
      }
      /**
       * Removes keyboard focus from the input element.
       */


      blur() {
        const inputs = this.template.querySelectorAll('[data-field]');

        for (let i = 0; i < inputs.length; i++) {
          inputs[i].blur();
        }
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       *
       */


      get validity() {
        return this._combinedConstraint.validity;
      }
      /**
       * @returns {boolean} Indicates whether the element meets all constraint validations.
       */


      checkValidity() {
        return this._combinedConstraint.checkValidity();
      }
      /**
       * Displays error messages on the latitude or longitude field if the coordinates are invalid.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }
      /**
       * Sets a custom error message to be displayed for the input name fields when
       * the input value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       * @param {string} fieldName - The name of the input name field.
       */


      setCustomValidityForField(message, fieldName) {
        assert(DEFAULT_FIELD_META[fieldName] !== undefined, `Invalid 'fieldName': ${fieldName}`);

        this._fieldConstraints[fieldName].setCustomValidity(message);
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */


      reportValidity() {
        const valid = this.checkValidity();

        if (!this._connected) {
          return valid;
        }

        this.fieldsToDisplay.forEach(field => {
          this._reportValidityForField(field);
        });
        return valid;
      }

      get i18n() {
        return i18n$e;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLegendClass() {
        return classSet('slds-form-element__label slds-form-element__legend').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      handleFocus() {
        this.interactingState.enter();
      }

      handleBlur(event) {
        this.interactingState.leave();
        const field = event.target.dataset.field;

        this._reportValidityForField(field);
      }

      handleChange(event) {
        event.stopPropagation();
        const value = event.detail.value;
        const fieldName = event.target.dataset.field;

        if (this.getFieldValue(fieldName) === value) {
          // Value didn't change. No need to dispatch.
          return;
        } // update the value for changing field


        this[fieldName] = value;
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            salutation: this.salutation,
            firstName: this.firstName,
            middleName: this.middleName,
            lastName: this.lastName,
            informalName: this.informalName,
            suffix: this.suffix,
            validity: this.validity
          }
        }));
      }

      initializeFieldsMetaData(fieldsOrder) {
        const fields = []; // setup what fields are needed with the field name

        fieldsOrder.forEach(fieldName => {
          fields.push({
            name: fieldName
          });
        });
        return fields;
      }

      getFieldObject(field) {
        const fieldDefault = DEFAULT_FIELD_META[field];
        const value = this[field];
        const label = this.i18n[field];
        const fieldsToDisplay = this.fieldsToDisplay.map(fieldName => {
          return fieldName.toUpperCase();
        });

        if (fieldsToDisplay.indexOf(field.toUpperCase()) > -1) {
          return {
            isInput: fieldDefault.inputType !== 'combobox',
            isCombobox: fieldDefault.inputType === 'combobox',
            required: fieldDefault.required && this.required,
            options: this.options,
            placeholder: fieldDefault.inputType === 'combobox' ? this.i18n.none : label,
            maxlength: fieldDefault.maxlength || DEFAULT_MAXLENGTH,
            name: field,
            label,
            value
          };
        }

        return null;
      }

      get fieldsMetaData() {
        const fieldsOrder = getFieldsOrder();
        const fieldsData = this.initializeFieldsMetaData(fieldsOrder);
        const fields = [];
        fieldsData.forEach(row => {
          const fieldName = row.name;
          const fieldObject = this.getFieldObject(fieldName);

          if (fieldObject) {
            fields.push(fieldObject);
          }
        });
        return fields;
      }

      getFieldValue(fieldName) {
        return this[fieldName];
      }

      getFieldElement(fieldName) {
        return this.template.querySelector(`[data-field="${fieldName}"]`);
      }

      get _fieldConstraints() {
        if (!this._fieldConstraintApis) {
          // For every field to display create an appropriate constraint
          this._fieldConstraintApis = Object.keys(DEFAULT_FIELD_META).reduce((constraints, field) => {
            constraints[field] = new FieldConstraintApi(() => this.getFieldElement(field), {
              valueMissing: () => !this.disabled && this.required && this.fieldsToDisplay.indexOf(field) >= 0 && DEFAULT_FIELD_META[field].required && isEmptyString(this[field])
            });
            return constraints;
          }, {});
        }

        return this._fieldConstraintApis;
      }

      get _combinedConstraint() {
        if (!this._combinedConstraintApi) {
          this._combinedConstraintApi = new FieldConstraintApi(() => this, {
            customError: () => Object.values(this._fieldConstraints).some(constraint => constraint.validity.customError),
            valueMissing: () => Object.values(this._fieldConstraints).some(constraint => constraint.validity.valueMissing)
          });
        }

        return this._combinedConstraintApi;
      }

      _reportValidityForField(field) {
        if (this._fieldConstraints[field]) {
          this._fieldConstraints[field].reportValidity(helpMessage => {
            const fieldElement = this.getFieldElement(field);
            fieldElement.setCustomValidity(helpMessage);
            fieldElement.reportValidity();
          });
        }
      }

    }

    LightningInputName.delegatesFocus = true;

    lwc.registerDecorators(LightningInputName, {
      publicProps: {
        label: {
          config: 0
        },
        options: {
          config: 0
        },
        fieldsToDisplay: {
          config: 0
        },
        salutation: {
          config: 3
        },
        firstName: {
          config: 3
        },
        middleName: {
          config: 3
        },
        informalName: {
          config: 3
        },
        lastName: {
          config: 3
        },
        suffix: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        variant: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "showHelpMessageIfInvalid", "setCustomValidityForField", "reportValidity"],
      track: {
        _salutation: 1,
        _lastName: 1,
        _firstName: 1,
        _middleName: 1,
        _informalName: 1,
        _suffix: 1,
        _disabled: 1,
        _readonly: 1,
        _required: 1,
        _variant: 1,
        _fieldLevelHelp: 1
      }
    });

    var _lightningInputName = lwc.registerComponent(LightningInputName, {
      tmpl: _tmpl$q
    });

    function stylesheet$a(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$a = [stylesheet$a];

    function tmpl$s($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("iframe", {
        style: $cmp.frameStyle,
        attrs: {
          "src": $cmp.src,
          "title": $cmp.title,
          "width": $cmp.width,
          "height": $cmp.height
        },
        key: 2,
        on: {
          "load": _m0 || ($ctx._m0 = api_bind($cmp.handleContentLoad))
        }
      }, [])];
    }

    var _tmpl$r = lwc.registerTemplate(tmpl$s);
    tmpl$s.stylesheets = [];
    tmpl$s.stylesheetTokens = {
      hostAttribute: "lightning-primitiveIframe_primitiveIframe-host",
      shadowAttribute: "lightning-primitiveIframe_primitiveIframe"
    };

    // Closure to hold the APIs if and when available
    let DispatcherCount = 1;
    const Domains = [];

    function generateDispatchId() {
      return `lightningIframeMessage-${DispatcherCount++}`;
    }
    function registerDomain(domain) {
      if (!domain || domain === '') {
        return;
      }

      const found = Domains.find(item => item.domain === domain);

      if (found) {
        found.ref += 1;
      } else {
        Domains.push({
          domain,
          ref: 1
        });
      }
    }
    function unregisterDomain(domain) {
      if (!domain || domain === '') {
        return;
      }

      const index = Domains.findIndex(item => item.domain === domain);

      if (index >= 0) {
        const found = Domains[index];
        found.ref -= 1;

        if (found.ref === 0) {
          Domains.splice(index, 1);
        }
      }
    }
    function registerMessageHandler(handler) {
      const dispatchId = generateDispatchId();
      return dispatchId;
    }
    function createMessage(dispatcherId, event, params) {
      params.cmpId = dispatcherId;
      return {
        event,
        arguments: params
      };
    }
    function postMessage(handler, message, domain, useObject) {
      if (handler) {
        handler(useObject ? message : JSON.stringify(message || {}), domain);
      }
    }

    /**
     * Class representing primitive iframe.
     * @extends Element
     */

    class LightningPrimitiveIframe extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.src = void 0;
        this.domain = void 0;
        this.width = '100%';
        this.height = '100%';
        this.frameStyle = '';
        this.title = void 0;
      }

      connectedCallback() {
        registerDomain(this.src);
      }

      disconnectedCallback() {
        unregisterDomain(this.src);
      }

      handleContentLoad() {
        const iframeload = new CustomEvent('iframeload', {
          detail: {
            callbacks: {
              postToWindow: this.postToWindow.bind(this)
            }
          }
        });
        this.contentWindow = this.template.querySelector('iframe').contentWindow;
        this.dispatchEvent(iframeload);
      }

      postToWindow(message) {
        if (this.contentWindow) {
          this.contentWindow.postMessage(message, this.domain);
        }
      }

    }

    lwc.registerDecorators(LightningPrimitiveIframe, {
      publicProps: {
        src: {
          config: 0
        },
        domain: {
          config: 0
        },
        width: {
          config: 0
        },
        height: {
          config: 0
        },
        frameStyle: {
          config: 0
        },
        title: {
          config: 0
        }
      },
      publicMethods: ["postToWindow"]
    });

    var _lightningPrimitiveIframe = lwc.registerComponent(LightningPrimitiveIframe, {
      tmpl: _tmpl$r
    });

    function tmpl$t($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element,
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [$cmp._isLoaded ? api_element("label", {
        className: $cmp.computedLabelClass,
        key: 3
      }, [api_dynamic($cmp.label)]) : null, $cmp._isLoaded ? api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 4
      }, [api_custom_element("lightning-base-combobox", _lightningBaseCombobox, {
        className: $cmp.computedLookupComboboxClass,
        props: {
          "variant": "lookup",
          "items": $cmp._items,
          "disabled": $cmp.disabled,
          "dropdownAlignment": "auto",
          "placeholder": $cmp.placeholder,
          "inputText": $cmp.inputText,
          "inputIconName": $cmp._inputIconName,
          "showInputActivityIndicator": $cmp.showActivityIndicator,
          "attributionLogoUrl": $cmp._googleLogoUrl,
          "attributionLogoAssistiveText": $cmp._googleLogoText
        },
        key: 5,
        on: {
          "textinput": _m0 || ($ctx._m0 = api_bind($cmp.handleTextInput)),
          "select": _m1 || ($ctx._m1 = api_bind($cmp.handleSelect)),
          "ready": _m2 || ($ctx._m2 = api_bind($cmp.handleComboboxReady))
        }
      }, [])]) : null, api_custom_element("lightning-primitive-iframe", _lightningPrimitiveIframe, {
        styleMap: {
          "display": "none"
        },
        props: {
          "src": $cmp.apiSrc,
          "domain": $cmp.apiDomain
        },
        key: 6,
        on: {
          "iframeload": _m3 || ($ctx._m3 = api_bind($cmp.handleIframeLoad))
        }
      }, [])];
    }

    var _tmpl$s = lwc.registerTemplate(tmpl$t);
    tmpl$t.stylesheets = [];
    tmpl$t.stylesheetTokens = {
      hostAttribute: "lightning-lookupAddress_lookupAddress-host",
      shadowAttribute: "lightning-lookupAddress_lookupAddress"
    };

    function toHighlightParts(text, matchedSubstrings) {
      text = text || '';
      matchedSubstrings = matchedSubstrings || [];
      const parts = [];
      let last = 0;
      let index = 0;

      while (last < text.length && index < matchedSubstrings.length) {
        const part = matchedSubstrings[index++];

        if (part.offset > last) {
          parts.push({
            text: text.substring(last, part.offset),
            highlight: false
          });
        }

        last = part.offset + part.length;
        parts.push({
          text: text.substring(part.offset, last),
          highlight: true
        });
      }

      if (last < text.length) {
        parts.push({
          text: text.substring(last),
          highlight: false
        });
      }

      return parts;
    }

    const INTERNAL_GOOGLE_LOGO = `/projRes/ui-force-components/img/powered_by_google.png`;
    const POWERED_BY_GOOGLE = 'powered by Google';

    const DEFAULT_LOCATION = {
      lat: 37.790091,
      lng: -122.396848
    };
    const getCurrentPosition = navigator && navigator.geolocation && navigator.geolocation.getCurrentPosition ? navigator.geolocation.getCurrentPosition.bind(navigator.geolocation) : (success, error) => error && error();
    function getLocation() {
      return new Promise(resolve => {
        getCurrentPosition(position => {
          resolve({
            lat: position.coords.latitude,
            lng: position.coords.longitude
          });
        }, () => resolve(DEFAULT_LOCATION));
      });
    }

    const DEFAULT_TYPES = ['geocode'];
    const DEBOUNCE_PERIOD = 250;
    const DOMAIN_PREFIX = guid();
    const EVENT_NAME = {
      INITIALIZE_PLACE_API: 'initialize',
      QUERY_PLACE_AUTOCOMPLETE: 'queryAddress',
      QUERY_PLACE_DETAIL: 'selectAddress',
      PLACE_AUTOCOMPLETE: 'force:showAddressSuggestions',
      PLACE_DETAIL: 'force:saveAddressLookup'
    };

    class LightningLookupAddress extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.label = void 0;
        this.inputText = '';
        this.placeholder = void 0;
        this._inputIconName = 'utility:search';
        this._items = void 0;
        this._showActivityIndicator = void 0;
        this._variant = void 0;
        this._disabled = void 0;
        this._isLoaded = false;
        this._googleLogoUrl = void 0;
        this._googleLogoText = POWERED_BY_GOOGLE;
        this._labelForId = void 0;
        this.placeIconName = 'utility:checkin';
        this.secureDomain = `https://${DOMAIN_PREFIX}${configProvider.getCoreInfo().untrustedContentDomain}:${configProvider.getCoreInfo().securePort}`;
        this.apiDomain = `*`;
        this.apiSrc = `${this.secureDomain}/lightningmaps/mapsloader?resource=placeApi&locale=${configProvider.getLocale().userLocaleLang}`;
      }

      connectedCallback() {
        this._items = [];
        this._dispatchId = registerMessageHandler(event => {
          this.handleMessage(event);
        });
        this._debouncedTextInput = debounce(text => {
          this._requestSuggestions(text);
        }, DEBOUNCE_PERIOD);
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant$1(value);
      }

      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);

        if (this._disabled && this._dropdownVisible) {
          this.closeDropdown();
        }
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      renderedCallback() {
        const label = this.template.querySelector('label');

        if (label) {
          synchronizeAttrs(label, {
            for: this._labelForId
          });
          label.setAttribute('for', this._labelForId);
        }
      }

      handleComboboxReady(e) {
        this._labelForId = e.detail.id;
      }

      handleMessage(data) {
        this._showActivityIndicator = false;

        if (!this._googleLogoUrl) {
          this._googleLogoUrl = INTERNAL_GOOGLE_LOGO;
        }

        if (data.event === EVENT_NAME.PLACE_AUTOCOMPLETE) {
          this._processAutoComplete(data.arguments.addresses);
        } else if (data.event === EVENT_NAME.PLACE_DETAIL) {
          this.dispatchChangeEvent(data.arguments);
        }
      }

      _requestSuggestions(matchString) {
        if (matchString) {
          this._showActivityIndicator = true;
          this.sendMessage(EVENT_NAME.QUERY_PLACE_AUTOCOMPLETE, {
            matchString
          });
        } else {
          this._items = [];
        }
      }

      handleTextInput(evt) {
        this.inputText = evt.detail.text;

        this._debouncedTextInput(evt.detail.text);
      }

      handleIframeLoad(event) {
        this._handler = event.detail.callbacks.postToWindow;
        this._isLoaded = true;
        getLocation().then(location => {
          this.sendMessage(EVENT_NAME.INITIALIZE_PLACE_API, {
            types: DEFAULT_TYPES,
            location
          });
        });
      }

      sendMessage(event, params) {
        if (this._handler) {
          const message = createMessage(this._dispatchId, event, params || {});
          postMessage(this._handler, message, '*');
        }
      }

      handleSelect(evt) {
        if (evt.detail.value) {
          this._showActivityIndicator = true;
          this.sendMessage(EVENT_NAME.QUERY_PLACE_DETAIL, {
            addressCmpId: this._dispatchId,
            placeId: evt.detail.value
          });
        }
      }

      _processAutoComplete(suggestions) {
        this._showActivityIndicator = false;
        this._items = [];

        if (suggestions) {
          this._items = suggestions.map(suggestion => {
            const mainText = suggestion.structured_formatting.main_text;
            const secondaryText = suggestion.structured_formatting.secondary_text;
            const matchedSubstrings = suggestion.structured_formatting.main_text_matched_substrings;
            const parts = toHighlightParts(mainText, matchedSubstrings);
            return {
              type: 'option-card',
              text: parts,
              iconName: this.placeIconName,
              subText: secondaryText,
              value: suggestion.place_id
            };
          });
        }
      }

      dispatchChangeEvent(address) {
        this.dispatchEvent(new CustomEvent('change', {
          detail: {
            address
          }
        }));
      }

    }

    lwc.registerDecorators(LightningLookupAddress, {
      publicProps: {
        label: {
          config: 0
        },
        inputText: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        variant: {
          config: 3
        },
        disabled: {
          config: 3
        }
      },
      track: {
        _inputIconName: 1,
        _items: 1,
        _showActivityIndicator: 1,
        _variant: 1,
        _disabled: 1,
        _isLoaded: 1
      }
    });

    var _lightningLookupAddress = lwc.registerComponent(LightningLookupAddress, {
      tmpl: _tmpl$s
    });

    function stylesheet$b(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$b = [stylesheet$b];

    function tmpl$u($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "for": `${api_scoped_id("input")}`
        },
        key: 2
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 4
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 5
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true,
          "slds-grow": true
        },
        key: 6
      }, [api_element("textarea", {
        classMap: {
          "slds-textarea": true
        },
        attrs: {
          "id": api_scoped_id("input"),
          "aria-describedby": api_scoped_id($cmp.computedUniqueHelpElementId),
          "name": $cmp.name,
          "maxlength": $cmp.maxLength,
          "minlength": $cmp.minLength,
          "placeholder": $cmp.placeholder,
          "accesskey": $cmp.accessKey
        },
        props: {
          "readOnly": $cmp.readOnly,
          "disabled": $cmp.disabled,
          "required": $cmp.required
        },
        key: 7,
        on: {
          "input": _m0 || ($ctx._m0 = api_bind($cmp.handleInput)),
          "change": _m1 || ($ctx._m1 = api_bind($cmp.handleChange)),
          "focus": _m2 || ($ctx._m2 = api_bind($cmp.handleFocus)),
          "blur": _m3 || ($ctx._m3 = api_bind($cmp.handleBlur))
        }
      }, [api_dynamic($cmp._defaultValue)])]), $cmp._helpMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "id": api_scoped_id("help-message"),
          "data-help-message": true,
          "aria-live": "assertive"
        },
        key: 9
      }, [api_dynamic($cmp._helpMessage)]) : null];
    }

    var _tmpl$t = lwc.registerTemplate(tmpl$u);
    tmpl$u.stylesheets = [];

    if (_implicitStylesheets$b) {
      tmpl$u.stylesheets.push.apply(tmpl$u.stylesheets, _implicitStylesheets$b);
    }
    tmpl$u.stylesheetTokens = {
      hostAttribute: "lightning-textarea_textarea-host",
      shadowAttribute: "lightning-textarea_textarea"
    };

    const i18n$f = {
      required: labelRequired
    };
    /**
     * Represents a multiline text input field.
     */

    class LightningTextarea extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.label = void 0;
        this.placeholder = void 0;
        this.name = void 0;
        this.messageWhenBadInput = void 0;
        this.messageWhenTooShort = void 0;
        this.messageWhenTooLong = void 0;
        this.messageWhenValueMissing = void 0;
        this.accessKey = void 0;
        this._maxLength = void 0;
        this._minLength = void 0;
        this._defaultValue = '';
        this._disabled = false;
        this._required = false;
        this._readOnly = false;
        this._variant = void 0;
        this._helpMessage = void 0;
        this._fieldLevelHelp = void 0;
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
        this._connected = true;
        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.showHelpMessageIfInvalid());
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      synchronizeA11y() {
        const input = this.template.querySelector('textarea');
        synchronizeAttrs(input, {
          'aria-describedby': this.computedUniqueHelpElementId
        });
      }

      renderedCallback() {
        // IE11: This is needed to work-around IE11 issue where it would append default value to the place holder,
        // instead of actually setting the value on the textarea element.
        if (!this._rendered) {
          this._rendered = true;
          this.inputElement.value = this._defaultValue;
          this.synchronizeA11y();
        }

        this.synchronizeA11y();
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * The maximum number of characters allowed in the textarea.
       * @type {number}
       */


      get maxLength() {
        return this._maxLength;
      }

      set maxLength(value) {
        this._maxLength = value;

        this._updateProxyInputAttributes('maxlength');
      }
      /**
       * The minimum number of characters allowed in the textarea.
       * @type {number}
       */


      get minLength() {
        return this._minLength;
      }

      set minLength(value) {
        this._minLength = value;

        this._updateProxyInputAttributes('minlength');
      }
      /**
       * The value of the textarea input, also used as the default value during init.
       * @type {string}
       */


      get value() {
        return this._value;
      }

      set value(value) {
        // W-5026729 - On IE11, set same value again, will trigger another input event.
        if (this._value !== value) {
          this._value = value || '';

          if (this._connected) {
            // We're connected, so no longer need to update the default value, change the actual value instead
            this.inputElement.value = this._value;
          } else {
            this._defaultValue = this._value;
          }
        }

        this._updateProxyInputAttributes('value');
      }
      /**
       * If present, the textarea field is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);

        this._updateProxyInputAttributes('disabled');
      }
      /**
       * If present, the textarea field is read-only and cannot be edited.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this._readOnly;
      }

      set readOnly(value) {
        this._readOnly = normalizeBoolean(value);

        this._updateProxyInputAttributes('readonly');
      }
      /**
       * If present, the textarea field must be filled out before the form can be submitted.
       * @type {boolean}
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);

        this._updateProxyInputAttributes('required');
      }
      /**
       * The variant changes the appearance of the textarea.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and textarea.
       * Use label-stacked to place the label above the textarea.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant$1(value);
        this.updateClassList();
      }
      /**
       * Represents the validity states of the textarea input, with respect to constraint validation.
       * @type {object}
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * Returns the valid attribute value (Boolean) on the ValidityState object.
       * @returns {boolean} Indicates whether the textarea meets all constraint validations.
       */


      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the textarea.
       */


      reportValidity() {
        return this._constraint.reportValidity(message => {
          this._helpMessage = message;
        });
      }
      /**
       * Sets a custom error message to be displayed when the textarea value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       */


      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }
      /**
       * Displays error messages on invalid fields.
       * An invalid field fails at least one constraint validation and returns false when checkValidity() is called.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }
      /**
       * The help text that appears in a popover.
       * Set field-level help to provide an informational tooltip on the textarea input field.
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }
      /**
       * Sets focus on the textarea field.
       */


      focus() {
        if (this._connected) {
          this.inputElement.focus();
        }
      }
      /**
       * Removes focus from the textarea field.
       */


      blur() {
        if (this._connected) {
          this.inputElement.blur();
        }
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get i18n() {
        return i18n$f;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      handleFocus() {
        this.interactingState.enter();
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.interactingState.leave();
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleChange(event) {
        // we only fire change event oninput
        // so stop native event here
        event.stopPropagation();
      }

      handleInput(event) {
        event.stopPropagation(); // If the current value is the same as it was prior to last update, don't fire the event.
        // This allows us to fix an issue with IE11 which fires an 'input' event every time the placeholder
        // is changed, since the value isn't affected we're effectively ignoring such events.

        if (!this._connected || this._value === event.target.value) {
          return;
        }

        this.interactingState.interacting();
        this._value = this.inputElement.value;

        this._updateProxyInputAttributes('value');

        this.dispatchEvent(new CustomEvent('change', {
          bubbles: true,
          composed: true,
          detail: {
            value: this._value
          }
        }));
      }

      get inputElement() {
        return this.template.querySelector('textarea');
      }

      get computedUniqueHelpElementId() {
        const helpMessage = this.template.querySelector('[data-help-message]');
        return getRealDOMId(helpMessage);
      }

      _updateProxyInputAttributes(attributes) {
        if (this._constraintApiProxyInputUpdater) {
          this._constraintApiProxyInputUpdater(attributes);
        }
      }

      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApiWithProxyInput(() => this, {
            // Override validity.valueMissing, which was broken in Edge until May 2018.
            // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/291588/
            valueMissing: () => this._required && isEmptyString(this._value),
            tooShort: () => this._connected && this.inputElement.validity.tooShort,
            tooLong: () => this._connected && this.inputElement.validity.tooLong
          }, 'textarea');
          this._constraintApiProxyInputUpdater = this._constraint.setInputAttributes({
            value: () => this.value,
            maxlength: () => this.maxLength,
            minlength: () => this.minLength,
            disabled: () => this.disabled,
            readonly: () => this.readOnly,
            required: () => this.required
          });
        }

        return this._constraintApi;
      }

    }

    LightningTextarea.delegatesFocus = true;

    lwc.registerDecorators(LightningTextarea, {
      publicProps: {
        label: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        name: {
          config: 0
        },
        messageWhenBadInput: {
          config: 0
        },
        messageWhenTooShort: {
          config: 0
        },
        messageWhenTooLong: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        accessKey: {
          config: 0
        },
        maxLength: {
          config: 3
        },
        minLength: {
          config: 3
        },
        value: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        variant: {
          config: 3
        },
        validity: {
          config: 1
        },
        fieldLevelHelp: {
          config: 3
        }
      },
      publicMethods: ["checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid", "focus", "blur"],
      track: {
        _maxLength: 1,
        _minLength: 1,
        _defaultValue: 1,
        _disabled: 1,
        _required: 1,
        _readOnly: 1,
        _variant: 1,
        _helpMessage: 1,
        _fieldLevelHelp: 1
      }
    });

    var _lightningTextarea = lwc.registerComponent(LightningTextarea, {
      tmpl: _tmpl$t
    });
    LightningTextarea.interopMap = {
      exposeNativeEvent: {
        change: true,
        focus: true,
        blur: true
      }
    };

    function tmpl$v($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        k: api_key,
        i: api_iterator,
        f: api_flatten
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9
      } = $ctx;
      return [api_element("fieldset", {
        classMap: {
          "slds-form-element": true
        },
        key: 2
      }, [api_element("legend", {
        className: $cmp.computedLegendClass,
        key: 3
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 5
      }, [api_text("*")]) : null, api_dynamic($cmp.addressLabel)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 6
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 7
      }, [api_element("div", {
        classMap: {
          "slds-form-element__group": true
        },
        key: 8
      }, api_flatten([$cmp.showAddressLookup ? api_element("div", {
        classMap: {
          "slds-form-element__row": true,
          "slds-grow": true
        },
        key: 10
      }, [api_custom_element("lightning-lookup-address", _lightningLookupAddress, {
        classMap: {
          "slds-form-element": true,
          "slds-show": true,
          "slds-size_6-of-6": true
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 11,
        on: {
          "change": _m0 || ($ctx._m0 = api_bind($cmp.handleAddress))
        }
      }, [])]) : null, api_iterator($cmp.domFieldsMeta, function (row, index) {
        return api_element("div", {
          classMap: {
            "slds-form-element__row": true
          },
          key: api_key(13, row.name)
        }, api_iterator(row, function (field) {
          return [field.isInput ? api_custom_element("lightning-input", _lightningInput, {
            className: field.classnames,
            attrs: {
              "data-field": field.name
            },
            props: {
              "label": field.label,
              "name": field.name,
              "value": field.value,
              "maxLength": field.maxlength,
              "placeholder": field.placeholder,
              "required": field.required,
              "disabled": $cmp.disabled,
              "readOnly": $cmp.readOnly
            },
            key: api_key(16, field.name),
            on: {
              "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
              "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleBlur)),
              "change": _m3 || ($ctx._m3 = api_bind($cmp.handleChange))
            }
          }, []) : null, field.isTextArea ? api_custom_element("lightning-textarea", _lightningTextarea, {
            className: field.classnames,
            attrs: {
              "data-field": field.name
            },
            props: {
              "name": field.name,
              "label": field.label,
              "value": field.value,
              "maxLength": field.maxlength,
              "placeholder": field.placeholder,
              "required": field.required,
              "disabled": $cmp.disabled,
              "readOnly": $cmp.readOnly
            },
            key: api_key(18, field.name),
            on: {
              "focus": _m4 || ($ctx._m4 = api_bind($cmp.handleFocus)),
              "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleBlur)),
              "change": _m6 || ($ctx._m6 = api_bind($cmp.handleChange))
            }
          }, []) : null, field.isPicklist ? api_custom_element("lightning-picklist", _lightningPicklist, {
            className: field.classnames,
            attrs: {
              "data-field": field.name
            },
            props: {
              "name": field.name,
              "label": field.label,
              "options": field.options,
              "value": field.value,
              "placeholder": field.placeholder,
              "required": field.required,
              "disabled": $cmp.disabled
            },
            key: api_key(20, field.name),
            on: {
              "focus": _m7 || ($ctx._m7 = api_bind($cmp.handleFocus)),
              "blur": _m8 || ($ctx._m8 = api_bind($cmp.handleBlur)),
              "change": _m9 || ($ctx._m9 = api_bind($cmp.handleChange))
            }
          }, []) : null];
        }));
      })]))])])];
    }

    var _tmpl$u = lwc.registerTemplate(tmpl$v);
    tmpl$v.stylesheets = [];

    if (_implicitStylesheets$a) {
      tmpl$v.stylesheets.push.apply(tmpl$v.stylesheets, _implicitStylesheets$a);
    }
    tmpl$v.stylesheetTokens = {
      hostAttribute: "lightning-inputAddress_inputAddress-host",
      shadowAttribute: "lightning-inputAddress_inputAddress"
    };

    const FORMAT_CODE_MAP$1 = {
      A: 'street',
      C: 'city',
      S: 'province',
      Z: 'postalCode',
      K: 'country'
    };
    const parseLocaleFormat = function (format) {
      if (isValidFieldFormat(format)) {
        return format.toUpperCase().split(/(?=[A-Z])/).map(formatCode => FORMAT_CODE_MAP$1[formatCode]);
      }

      return [];
    };
    function getInputOrder(langCode, countryCode, hasCountryPicklist) {
      let inputOrder = address.getAddressInputOrderAllField(langCode, countryCode); // always show country picklist as the first field
      // to match aloha behavior

      if (hasCountryPicklist) {
        inputOrder = 'K' + inputOrder.replace('K', '');
      }

      return parseLocaleFormat(inputOrder);
    }
    function getRequiredFields(langCode, countryCode) {
      const requireFields = address.getAddressRequireFields(langCode, countryCode);
      return parseLocaleFormat(requireFields);
    }

    function isValidFieldFormat(value) {
      return typeof value === 'string' && /^[ACSZK]+$/i.test(value);
    }

    // diviisble by 2 and 3, easy for arranging rows with
    // [1/2 field + 1/2 field] and [1/3 field + 2/3 field]
    const MAX_ROW_WIDTH = 6;
    const FIELD_WIDTHS = {
      street: {
        width: 6
      },
      city: {
        width: 4
      },
      province: {
        width: 2
      },
      postalCode: {
        width: 4
      },
      country: {
        width: 2
      }
    };
    function getFieldWidth(fieldName) {
      return FIELD_WIDTHS[fieldName];
    }
    function getFieldWidthClass(field) {
      return `slds-size_${field.width}-of-${MAX_ROW_WIDTH}`;
    }
    function distributeFieldWidth(row) {
      if (row.length === 1) {
        row[0].width = MAX_ROW_WIDTH;
      } else if (row.length > 1) {
        const totalRowWidth = row.reduce((sum, field) => {
          return sum + field.width;
        }, 0);

        if (totalRowWidth < MAX_ROW_WIDTH) {
          row.forEach(field => {
            field.width = MAX_ROW_WIDTH / row.length;
          });
        }
      }
    }
    function getTransformedFieldsMetaForLayout(fieldsMeta, inputOrder) {
      const layoutMetadata = []; // distribute fields to different rows

      let row = [];
      let rowWidth = 0;
      inputOrder.forEach(name => {
        const field = fieldsMeta[name];
        rowWidth += field.width;

        if (rowWidth > MAX_ROW_WIDTH) {
          layoutMetadata.push(row);
          row = [];
          rowWidth = field.width;
        }

        row.push(field);
      });
      layoutMetadata.push(row); // distribute width evenly

      layoutMetadata.forEach(rowFields => {
        distributeFieldWidth(rowFields);
      });
      return layoutMetadata;
    }

    const FIELD_TYPE$1 = {
      TEXTAREA: 'textarea',
      INPUT: 'input',
      PICKLIST: 'combobox'
    };
    const i18n$g = {
      required: labelRequired
    };
    /**
     * Represents an address compound field.
     */

    class LightningInputAddress extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.addressLabel = void 0;
        this.streetLabel = void 0;
        this.cityLabel = void 0;
        this.provinceLabel = void 0;
        this.countryLabel = void 0;
        this.postalCodeLabel = void 0;
        this.provinceOptions = void 0;
        this.countryOptions = void 0;
        this._showAddressLookup = void 0;
        this._fieldLevelHelp = void 0;
        this._variant = void 0;
        this._street = '';
        this._city = '';
        this._province = '';
        this._country = '';
        this._postalCode = '';
        this._disabled = false;
        this._readonly = false;
        this._required = false;
      }

      connectedCallback() {
        this._connected = true;
        this.classList.add('slds-form-element', 'slds-form_compound');
        this.updateClassList();
        this.interactingState = new InteractingState({
          debounceInteraction: true
        });
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          this.reportValidity();
          this.dispatchEvent(new CustomEvent('blur'));
        });
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * The street field of the address.
       * @type {string}
       *
       */


      get street() {
        return this._street;
      }

      set street(value) {
        this._street = value;
      }
      /**
       * The city field of the address.
       * @type {string}
       *
       */


      get city() {
        return this._city;
      }

      set city(value) {
        this._city = value;
      }
      /**
       * The province field of the address. If province-options is provided, this province value is selected by default.
       * @type {string}
       *
       */


      get province() {
        return this._province;
      }

      set province(value) {
        this._province = value;
      }
      /**
       * The country field of the address. If country-options is provided, this country value is selected by default.
       * @type {string}
       *
       */


      get country() {
        return this._country;
      }

      set country(value) {
        this._country = value;
      }
      /**
       * The postal code field of the address.
       * @type {string}
       *
       */


      get postalCode() {
        return this._postalCode;
      }

      set postalCode(value) {
        this._postalCode = value;
      }
      /**
       * If present, the address fields are disabled and users cannot interact with them.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, address lookup using Google Maps is enabled.
       * @type {boolean}
       * @default false
       */


      get showAddressLookup() {
        return this._showAddressLookup;
      }

      set showAddressLookup(value) {
        this._showAddressLookup = normalizeBoolean(value);
      }
      /**
       * If present, the address fields are read-only and cannot be edited.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }
      /**
       * If present, the address fields must be filled before the form is submitted.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }
      /**
       * The variant changes the appearance of an input address field.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and input address field.
       * Use label-stacked to place the label above the input address field.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant$1(value);
        this.updateClassList();
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }
      /**
       * Help text detailing the purpose and function of the input.
       * @type {string}
       *
       */


      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       *
       */


      get validity() {
        return this._combinedConstraint.validity;
      }
      /**
       * Checks if the input is valid.
       * @returns {boolean} Indicates whether the element meets all constraint validations.
       */


      checkValidity() {
        return this._combinedConstraint.checkValidity();
      }
      /**
       * Displays error messages on the address fields if the values are invalid.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }
      /**
       * Sets a custom error message to be displayed for the specified fieldName when
       * the input address value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       * @param {string} fieldName - Name of the field, which must be one of the following: street, city, province, postalCode, country.
       */


      setCustomValidityForField(message, fieldName) {
        assert(this.fieldsMeta[fieldName] !== undefined, `Invalid 'fieldName': ${fieldName}`);

        this._fieldConstraints[fieldName].setCustomValidity(message);
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */


      reportValidity() {
        const valid = this.checkValidity();

        if (!this._connected) {
          return valid;
        }

        this.inputOrder.forEach(field => {
          this._reportValidityForField(field);
        });
        return valid;
      }
      /**
       * Sets focus on the first input element.
       */


      focus() {
        this.template.querySelector('[data-field]').focus();
      }
      /**
       * Removes focus from all input fields.
       */


      blur() {
        Array.prototype.forEach.call(this.template.querySelectorAll('[data-field]'), field => field.blur());
      }

      get searchAddressButtonDisabled() {
        return this.disabled || this.readOnly;
      }

      get i18n() {
        return i18n$g;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLegendClass() {
        return classSet('slds-form-element__label slds-form-element__legend').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get fieldsTypeMeta() {
        return {
          street: {
            name: 'street',
            maxlength: 255,
            type: FIELD_TYPE$1.TEXTAREA
          },
          city: {
            name: 'city',
            maxlength: 40,
            type: FIELD_TYPE$1.INPUT
          },
          province: {
            name: 'province',
            maxlength: 80,
            type: Array.isArray(this.provinceOptions) ? FIELD_TYPE$1.PICKLIST : FIELD_TYPE$1.INPUT
          },
          postalCode: {
            name: 'postalCode',
            maxlength: 20,
            type: FIELD_TYPE$1.INPUT
          },
          country: {
            name: 'country',
            maxlength: 80,
            type: Array.isArray(this.countryOptions) ? FIELD_TYPE$1.PICKLIST : FIELD_TYPE$1.INPUT
          }
        };
      }

      get inputOrder() {
        const hasCountryPicklist = this.fieldsTypeMeta.country.type === FIELD_TYPE$1.PICKLIST;
        const [langCode, countryCode] = getLocaleTag().split('-');
        return getInputOrder(langCode, countryCode, hasCountryPicklist);
      }

      get requiredFields() {
        const [langCode, countryCode] = getLocaleTag().split('-');
        return getRequiredFields(langCode, countryCode);
      }

      get fieldsMeta() {
        const fieldsMeta = {};
        this.inputOrder.forEach(name$$1 => {
          fieldsMeta[name$$1] = Object.assign({}, this.fieldsTypeMeta[name$$1], getFieldWidth(name$$1));
        });
        this.requiredFields.forEach(name$$1 => {
          fieldsMeta[name$$1].required = true;
        });
        return fieldsMeta;
      }

      get domFieldsMeta() {
        let rowKey = 0;
        const out = getTransformedFieldsMetaForLayout(this.fieldsMeta, this.inputOrder).map(row => {
          const rowList = row.map(field => {
            const {
              name: name$$1,
              type,
              required,
              maxlength
            } = field;
            const label = this.getFieldLabel(name$$1);
            const widthClass = getFieldWidthClass(field);
            return {
              isInput: type === FIELD_TYPE$1.INPUT,
              isPicklist: type === FIELD_TYPE$1.PICKLIST,
              isTextArea: type === FIELD_TYPE$1.TEXTAREA,
              value: this.getFieldValue(name$$1),
              options: this.getFieldOptions(name$$1),
              required: this.required && !!required,
              classnames: `slds-form-element slds-show ${widthClass}`,
              placeholder: label,
              label,
              maxlength,
              name: name$$1
            };
          });
          rowList.name = rowKey++;
          return rowList;
        });
        return out;
      }

      handleAddress(evt) {
        const address$$1 = evt.detail.address || {};
        this.street = address$$1.street || '';
        this.city = address$$1.city || '';
        this.province = address$$1.state || '';
        this.country = address$$1.country || '';
        this.postalCode = address$$1.postalCode || '';
        this.dispatchAddressChangeEvent();
      }

      handleFocus() {
        this.interactingState.enter();
      }

      handleBlur(event) {
        this.interactingState.leave();
        const field = event.target.dataset.field;

        this._reportValidityForField(field);
      }

      handleChange(event) {
        event.stopPropagation();
        const fieldName = event.target.dataset.field;
        const value = event.detail.value;

        if (this.getFieldValue(fieldName) === value) {
          // Value didn't change. No need to dispatch.
          return;
        }

        this[fieldName] = value;
        this.dispatchAddressChangeEvent();
      }

      dispatchAddressChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            street: this.street,
            city: this.city,
            province: this.province,
            country: this.country,
            postalCode: this.postalCode,
            validity: this.validity
          }
        }));
      }

      getFieldValue(fieldName) {
        return this[fieldName];
      }

      getFieldOptions(fieldName) {
        return this[`${fieldName}Options`];
      }

      getFieldLabel(fieldName) {
        return this[`${fieldName}Label`];
      }

      getFieldElement(fieldName) {
        return this.template.querySelector(`[data-field="${fieldName}"]`);
      }

      get _fieldConstraints() {
        if (!this._fieldConstraintApis) {
          // For every field to display create an appropriate constraint
          this._fieldConstraintApis = ['street', 'city', 'province', 'country', 'postalCode'].reduce((constraints, field) => {
            constraints[field] = new FieldConstraintApi(() => this.getFieldElement(field), {
              valueMissing: () => !this.disabled && this.required && this.requiredFields.indexOf(field) >= 0 && isEmptyString(this[field])
            });
            return constraints;
          }, {});
        }

        return this._fieldConstraintApis;
      }

      get _combinedConstraint() {
        if (!this._combinedConstraintApi) {
          this._combinedConstraintApi = new FieldConstraintApi(() => this, {
            customError: () => Object.values(this._fieldConstraints).some(constraint => constraint.validity.customError),
            valueMissing: () => Object.values(this._fieldConstraints).some(constraint => constraint.validity.valueMissing)
          });
        }

        return this._combinedConstraintApi;
      }

      _reportValidityForField(field) {
        if (this._fieldConstraints[field]) {
          this._fieldConstraints[field].reportValidity(helpMessage => {
            const fieldElement = this.getFieldElement(field);
            fieldElement.setCustomValidity(helpMessage);
            fieldElement.reportValidity();
          });
        }
      }

    }

    LightningInputAddress.delegatesFocus = true;

    lwc.registerDecorators(LightningInputAddress, {
      publicProps: {
        addressLabel: {
          config: 0
        },
        streetLabel: {
          config: 0
        },
        cityLabel: {
          config: 0
        },
        provinceLabel: {
          config: 0
        },
        countryLabel: {
          config: 0
        },
        postalCodeLabel: {
          config: 0
        },
        provinceOptions: {
          config: 0
        },
        countryOptions: {
          config: 0
        },
        street: {
          config: 3
        },
        city: {
          config: 3
        },
        province: {
          config: 3
        },
        country: {
          config: 3
        },
        postalCode: {
          config: 3
        },
        disabled: {
          config: 3
        },
        showAddressLookup: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        variant: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["checkValidity", "showHelpMessageIfInvalid", "setCustomValidityForField", "reportValidity", "focus", "blur"],
      track: {
        _showAddressLookup: 1,
        _fieldLevelHelp: 1,
        _variant: 1,
        _street: 1,
        _city: 1,
        _province: 1,
        _country: 1,
        _postalCode: 1,
        _disabled: 1,
        _readonly: 1,
        _required: 1
      }
    });

    var _lightningInputAddress = lwc.registerComponent(LightningInputAddress, {
      tmpl: _tmpl$u
    });

    function stylesheet$c(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$c = [stylesheet$c];

    function stylesheet$d(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$d = [stylesheet$d];

    function tmpl$w($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("span", {
        context: {
          lwc: {
            dom: "manual"
          }
        },
        key: 2,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleClick))
        }
      }, [])];
    }

    var _tmpl$v = lwc.registerTemplate(tmpl$w);
    tmpl$w.stylesheets = [];
    tmpl$w.stylesheetTokens = {
      hostAttribute: "lightning-formattedRichText_formattedRichText-host",
      shadowAttribute: "lightning-formattedRichText_formattedRichText"
    };

    const linkRegex = new RegExp(`${tagRegexString}|${urlRegexString}|${emailRegexString}`, 'gi');

    const createHttpLink = function (match) {
      const href = createHttpHref(match);
      return `<a href="${href}" target="_blank" rel="noopener">${match}</a>`;
    };

    const createEmailLink = function (match) {
      const href = createEmailHref(match);
      return `<a href="${href}">${match}</a>`;
    };

    const linkify = function (text) {
      if (typeof text !== 'string') {
        return '';
      }

      return text.replace(linkRegex, (match, tagMatch, hrefMatch, emailMatch) => {
        if (tagMatch) {
          return tagMatch;
        } else if (hrefMatch) {
          const endsWithQuote = hrefMatch.endsWith('&quot');
          let href = hrefMatch;

          if (endsWithQuote) {
            href = hrefMatch.slice(0, hrefMatch.lastIndexOf('&quot'));
          }

          return createHttpLink(href) + (endsWithQuote ? '&quot' : '');
        } else if (emailMatch) {
          return createEmailLink(emailMatch);
        }

        return match;
      });
    };

    const tagsWhitelist = Object.freeze(['a', 'abbr', 'acronym', 'address', 'b', 'br', 'big', 'blockquote', 'caption', 'cite', 'code', 'col', 'colgroup', 'del', 'div', 'dl', 'dd', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'ins', 'kbd', 'li', 'ol', 'mark', 'p', 'param', 'pre', 'q', 's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'tt', 'u', 'ul', 'var', 'strike', 'font']);
    const attrWhitelist = Object.freeze(['accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'coords', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'span', 'srclang', 'start', 'src', 'step', 'style', 'summary', 'tabindex', 'target', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', 'data-fileid']);
    const richTextConfig = Object.freeze({
      ALLOWED_TAGS: tagsWhitelist,
      ALLOWED_ATTR: attrWhitelist,
      ALLOW_UNKNOWN_PROTOCOLS: false
    });

    const GET_LINK_INFO_EVENT = 'lightningroutingservicegetlinkinfo';
    const urlTypes = {
      standard: 'standard_webPage'
    };
    /*
     * Mock getLinkInfo
     *
     * @returns {Promise[LinkInfo]}
     */

    function getLinkInfo(element, stateRef) {
      return new Promise((resolve, reject) => {
        // eslint-disable-next-line lightning-global/no-custom-event-identifier-arguments
        const getLinkInfoEvent = new CustomEvent(GET_LINK_INFO_EVENT, {
          detail: {
            stateRef,
            callback: (err, linkInfo) => {
              if (err) {
                reject(err);
              } else {
                resolve(linkInfo);
              }
            }
          },
          bubbles: true,
          composed: true,
          cancelable: true
        });
        element.dispatchEvent(getLinkInfoEvent);
      });
    }
    /**
     * Determines the route for the given url and updates the element
     * state with the correct url and dispatcher.
     *
     * @param {HTMLElement} element Element from which to dispatch the routing event
     * @param {Object} url Link to route, target Target of the link
     * @param {function} callback on the returned LinkInfo
     *
     * @returns {Promise} Promise[LinkInfo]
     */

    function updateRawLinkInfo(element, {
      url,
      target
    }) {
      if (url === undefined || url === null) {
        // eslint-disable-next-line no-console
        console.error('url must be specified');
      }

      if (target === '_blank') {
        // Have a no-op dispatcher if target is blank
        return new Promise(resolve => {
          resolve({
            url,
            dispatcher: () => {}
          });
        });
      }

      return getLinkInfo(element, {
        stateType: urlTypes.standard,
        attributes: {
          url,
          target
        }
      });
    }

    function _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$3(target, key, source[key]); }); } return target; }

    function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    /**
     * Displays rich text that's formatted with whitelisted tags and attributes.
     * Other tags and attributes are removed and only their text content is displayed.
     */

    class LightningFormattedRichText extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.initialRender = true;
        this._value = '';
        this._disableLinkify = false;
        this.connected = false;
        this.clean = false;
      }

      /**
       * If present, the component does not create links in the rich text.
       * @type {boolean}
       * @default false
       */
      get disableLinkify() {
        return this._disableLinkify;
      }

      set disableLinkify(val) {
        this._disableLinkify = normalizeBoolean(val);
        this.renderRichText();
      }
      /**
       * Sets the rich text to display.
       * @type {string}
       *
       */


      get value() {
        return this._value;
      }

      set value(val) {
        this._value = val;
        this.renderRichText();
      }

      renderedCallback() {
        if (this.initialRender) {
          this.renderRichText();
          this.initialRender = false;
        }
      }

      connectedCallback() {
        this.classList.add('slds-rich-text-editor__output');
        this.connected = true;
      }

      disconnectedCallback() {
        this.connected = false;
      }

      handleClick(event) {
        const eventTarget = event.target; // Don't do anything if it's not an anchor

        if (eventTarget.tagName !== 'A') {
          return;
        }

        const href = eventTarget.href; // Grab the link info onclick and dispatch

        updateRawLinkInfo(this, {
          url: href,
          target: eventTarget.target
        }).then(linkInfo => {
          eventTarget.href = linkInfo.url;
          linkInfo.dispatcher(event);
        });
      }

      sanitize(value) {
        this.clean = false;
        let displayValue;
        let computedRichTextConfig = richTextConfig;

        if (hasOnlyAllowedVideoIframes(value)) {
          // richTextConfig is shared across all formatted-rich-text components;
          // so create and modify copy of richTextConfig to whitelist iframes for each component
          computedRichTextConfig = _objectSpread$3({}, richTextConfig, {
            ALLOWED_TAGS: richTextConfig.ALLOWED_TAGS.concat(['iframe'])
          });
        }

        try {
          displayValue = configProvider.sanitizeDOM(value, computedRichTextConfig);
          this.clean = true;
        } catch (e) {
          // eslint-disable-next-line no-console
          console.warn(`<lightning-formatted-rich-text> Exception caught when attempting to sanitize: `, e);
          displayValue = value;
          this.clean = false;
        }

        return displayValue;
      }

      renderRichText() {
        if (this.connected) {
          const richText = this.sanitize(this.disableLinkify ? this.value : linkify(this.value));
          const container = this.getContainer();

          if (this.clean) {
            // eslint-disable-next-line lwc/no-inner-html
            container.innerHTML = richText;
          } else {
            const textNode = document.createTextNode(richText);

            while (container.hasChildNodes()) {
              container.removeChild(container.lastChild);
            }

            container.appendChild(textNode);
          }
        }
      }

      getContainer() {
        return this.template.querySelector('span');
      }

    }

    lwc.registerDecorators(LightningFormattedRichText, {
      publicProps: {
        disableLinkify: {
          config: 3
        },
        value: {
          config: 3
        }
      }
    });

    var _lightningFormattedRichText = lwc.registerComponent(LightningFormattedRichText, {
      tmpl: _tmpl$v
    });

    function tmpl$x($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        gid: api_scoped_id,
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("button", {
        className: $cmp.computedButtonClass,
        attrs: {
          "name": $cmp.name,
          "accesskey": $cmp.computedAccessKey,
          "title": $cmp.computedTitle,
          "type": $cmp.normalizedType,
          "value": $cmp.value,
          "aria-describedby": api_scoped_id($cmp.computedAriaDescribedBy),
          "aria-label": $cmp.computedAriaLabel,
          "aria-controls": api_scoped_id($cmp.computedAriaControls),
          "aria-expanded": $cmp.computedAriaExpanded,
          "aria-live": $cmp.computedAriaLive,
          "aria-atomic": $cmp.computedAriaAtomic
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 2,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleButtonFocus)),
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleButtonBlur))
        }
      }, [$cmp.showIconLeft ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.iconName,
          "svgClass": $cmp.computedIconClass,
          "variant": "bare"
        },
        key: 4
      }, []) : null, api_dynamic($cmp.label), $cmp.showIconRight ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.iconName,
          "svgClass": $cmp.computedIconClass,
          "variant": "bare"
        },
        key: 6
      }, []) : null])];
    }

    var _tmpl$w = lwc.registerTemplate(tmpl$x);
    tmpl$x.stylesheets = [];
    tmpl$x.stylesheetTokens = {
      hostAttribute: "lightning-button_button-host",
      shadowAttribute: "lightning-button_button"
    };

    /**
     * A clickable element used to perform an action.
     */

    class LightningButton extends LightningPrimitiveButton$1 {
      constructor(...args) {
        super(...args);
        this.name = void 0;
        this.value = void 0;
        this.label = void 0;
        this.variant = 'neutral';
        this.iconName = void 0;
        this.iconPosition = 'left';
        this.type = 'button';
        this.title = null;
        this._order = null;
      }

      render() {
        return _tmpl$w;
      }

      get computedButtonClass() {
        return classSet('slds-button').add({
          'slds-button_neutral': this.normalizedVariant === 'neutral',
          'slds-button_brand': this.normalizedVariant === 'brand',
          'slds-button_outline-brand': this.normalizedVariant === 'brand-outline',
          'slds-button_destructive': this.normalizedVariant === 'destructive',
          'slds-button_text-destructive': this.normalizedVariant === 'destructive-text',
          'slds-button_inverse': this.normalizedVariant === 'inverse',
          'slds-button_success': this.normalizedVariant === 'success',
          'slds-button_first': this._order === 'first',
          'slds-button_middle': this._order === 'middle',
          'slds-button_last': this._order === 'last'
        }).toString();
      }

      get computedTitle() {
        return this.title;
      }

      get normalizedVariant() {
        return normalizeString(this.variant, {
          fallbackValue: 'neutral',
          validValues: ['base', 'neutral', 'brand', 'destructive', 'inverse', 'success']
        });
      }

      get normalizedType() {
        return normalizeString(this.type, {
          fallbackValue: 'button',
          validValues: ['button', 'reset', 'submit']
        });
      }

      get normalizedIconPosition() {
        return normalizeString(this.iconPosition, {
          fallbackValue: 'left',
          validValues: ['left', 'right']
        });
      }

      get showIconLeft() {
        return this.iconName && this.normalizedIconPosition === 'left';
      }

      get showIconRight() {
        return this.iconName && this.normalizedIconPosition === 'right';
      }

      get computedIconClass() {
        return classSet('slds-button__icon').add({
          'slds-button__icon_left': this.normalizedIconPosition === 'left',
          'slds-button__icon_right': this.normalizedIconPosition === 'right'
        }).toString();
      }

      handleButtonFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleButtonBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }
      /**
       * Sets focus on the button.
       */


      focus() {
        this.template.querySelector('button').focus();
      }
      /**
       * {Function} setOrder - Sets the order value of the button when in the context of a button-group or other ordered component
       * @param {String} order -  The order string (first, middle, last)
       */


      setOrder(order) {
        this._order = order;
      }
      /**
       * Once we are connected, we fire a register event so the button-group (or other) component can register
       * the buttons.
       */


      connectedCallback() {
        const privatebuttonregister = new CustomEvent('privatebuttonregister', {
          bubbles: true,
          detail: {
            callbacks: {
              setOrder: this.setOrder.bind(this),
              setDeRegistrationCallback: deRegistrationCallback => {
                this._deRegistrationCallback = deRegistrationCallback;
              }
            }
          }
        });
        this.dispatchEvent(privatebuttonregister);
      }

      disconnectedCallback() {
        if (this._deRegistrationCallback) {
          this._deRegistrationCallback();
        }
      }

    }

    LightningButton.delegatesFocus = true;

    lwc.registerDecorators(LightningButton, {
      publicProps: {
        name: {
          config: 0
        },
        value: {
          config: 0
        },
        label: {
          config: 0
        },
        variant: {
          config: 0
        },
        iconName: {
          config: 0
        },
        iconPosition: {
          config: 0
        },
        type: {
          config: 0
        }
      },
      publicMethods: ["focus"],
      track: {
        title: 1,
        _order: 1
      }
    });

    var _lightningButton = lwc.registerComponent(LightningButton, {
      tmpl: _tmpl$w
    });
    LightningButton.interopMap = {
      exposeNativeEvent: {
        click: true,
        focus: true,
        blur: true
      }
    };

    function tmpl$y($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        gid: api_scoped_id,
        h: api_element,
        c: api_custom_element,
        b: api_bind,
        k: api_key,
        i: api_iterator,
        f: api_flatten
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11
      } = $ctx;
      return [$cmp.renderLabel ? api_element("span", {
        className: $cmp.computedLabelClass,
        attrs: {
          "id": api_scoped_id("label"),
          "data-label": true
        },
        key: 3
      }, [api_dynamic($cmp.computedLabel)]) : null, api_element("div", {
        classMap: {
          "slds-rich-text-editor": true,
          "slds-grid": true,
          "slds-grid_vertical": true,
          "slds-nowrap": true
        },
        key: 4,
        on: {
          "click": _m7 || ($ctx._m7 = api_bind($cmp.activateEditor))
        }
      }, [$cmp.isBottomToolbar ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__textarea": true,
          "slds-grid": true,
          "editor": true
        },
        key: 6
      }, []) : null, $cmp.isBottomToolbar ? $cmp.quillNotReady ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__textarea": true,
          "slds-grid": true
        },
        key: 7
      }, [api_element("div", {
        classMap: {
          "slds-rich-text-area__content": true,
          "slds-grow": true,
          "slds-text-color-weak": true,
          "standin": true
        },
        key: 8
      }, [api_custom_element("lightning-formatted-rich-text", _lightningFormattedRichText, {
        props: {
          "value": $cmp.value,
          "disableLinkify": true
        },
        key: 9
      }, [])])]) : null : null, $cmp.isBottomToolbar ? !$cmp.valid ? api_element("div", {
        classMap: {
          "slds-form-element__help": true,
          "slds-p-around_small": true
        },
        attrs: {
          "id": api_scoped_id("error-message"),
          "data-error-message": true
        },
        key: 11
      }, [api_dynamic($cmp.errorMessage)]) : null : null, api_element("div", {
        classMap: {
          "slds-rich-text-editor__toolbar": true,
          "slds-shrink-none": true
        },
        attrs: {
          "role": "toolbar",
          "aria-label": $cmp.toolbarAriaLabel
        },
        key: 12,
        on: {
          "keydown": _m6 || ($ctx._m6 = api_bind($cmp.navigateToolbar))
        }
      }, api_flatten([$cmp.isFontMenusVisible ? api_element("div", {
        classMap: {
          "slds-grid": true,
          "slds-wrap": true
        },
        attrs: {
          "role": "group",
          "aria-label": $cmp.i18n.formatFont
        },
        key: 14
      }, [$cmp.isDesktop ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__select": true
        },
        key: 16
      }, [api_custom_element("lightning-combobox", _lightningCombobox, {
        props: {
          "value": $cmp.selectedFontValue,
          "variant": "label-hidden",
          "label": $cmp.i18n.font,
          "options": $cmp.fontMenus.fontList,
          "disabled": $cmp.disabled,
          "dropdownAlignment": $cmp.menuDropdownAlignment
        },
        key: 17,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.activateEditor)),
          "change": _m1 || ($ctx._m1 = api_bind($cmp.selectFont))
        }
      }, [])]) : null, $cmp.isDesktop ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__select": true,
          "slds-size_xx-small": true
        },
        key: 18
      }, [api_custom_element("lightning-combobox", _lightningCombobox, {
        props: {
          "value": $cmp.selectedSizeValue,
          "variant": "label-hidden",
          "label": $cmp.i18n.fontSize,
          "options": $cmp.fontMenus.sizeList,
          "disabled": $cmp.disabled,
          "dropdownAlignment": $cmp.menuDropdownAlignment
        },
        key: 19,
        on: {
          "change": _m2 || ($ctx._m2 = api_bind($cmp.selectSize))
        }
      }, [])]) : null, !$cmp.isDesktop ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__select": true,
          "slds-size_x-small": true
        },
        key: 21
      }, [api_custom_element("lightning-primitive-select", _lightningPrimitiveSelect, {
        props: {
          "value": $cmp.selectedFontValue,
          "variant": "label-hidden",
          "label": $cmp.i18n.font,
          "options": $cmp.fontMenus.fontList,
          "disabled": $cmp.disabled
        },
        key: 22,
        on: {
          "change": _m3 || ($ctx._m3 = api_bind($cmp.selectFont))
        }
      }, [])]) : null, !$cmp.isDesktop ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__select": true,
          "slds-size_xx-small": true
        },
        key: 23
      }, [api_custom_element("lightning-primitive-select", _lightningPrimitiveSelect, {
        props: {
          "value": $cmp.selectedSizeValue,
          "variant": "label-hidden",
          "label": $cmp.i18n.fontSize,
          "options": $cmp.fontMenus.sizeList,
          "disabled": $cmp.disabled
        },
        key: 24,
        on: {
          "change": _m4 || ($ctx._m4 = api_bind($cmp.selectSize))
        }
      }, [])]) : null]) : null, $cmp.isColorpickerVisible ? api_custom_element("lightning-primitive-colorpicker-button", _lightningPrimitiveColorpickerButton, {
        props: {
          "disabled": $cmp.disabled,
          "value": $cmp.selectedTextColorValue
        },
        key: 26,
        on: {
          "change": _m5 || ($ctx._m5 = api_bind($cmp.handleColorUpdate))
        }
      }, []) : null, api_iterator($cmp.computedCategories, function (category) {
        return api_element("ul", {
          classMap: {
            "slds-button-group-list": true
          },
          attrs: {
            "aria-label": category.label
          },
          key: api_key(28, category.label)
        }, api_iterator(category.buttons, function (button) {
          return api_element("li", {
            key: api_key(30, button.key)
          }, [api_element("button", {
            className: button.computedClass,
            attrs: {
              "value": button.value,
              "title": button.label,
              "data-format": button.format,
              "aria-pressed": "false"
            },
            key: 31
          }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
            props: {
              "iconName": button.iconName,
              "svgClass": "slds-button__icon",
              "variant": "bare"
            },
            key: 32
          }, []), api_element("span", {
            classMap: {
              "slds-assistive-text": true
            },
            key: 33
          }, [api_dynamic(button.label)])])]);
        }));
      })])), !$cmp.isBottomToolbar ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__textarea": true,
          "slds-grid": true,
          "editor": true
        },
        key: 35
      }, []) : null, !$cmp.isBottomToolbar ? $cmp.quillNotReady ? api_element("div", {
        classMap: {
          "slds-rich-text-editor__textarea": true,
          "slds-grid": true
        },
        key: 36
      }, [api_element("div", {
        classMap: {
          "slds-rich-text-area__content": true,
          "slds-grow": true,
          "slds-text-color-weak": true,
          "standin": true
        },
        key: 37
      }, [api_custom_element("lightning-formatted-rich-text", _lightningFormattedRichText, {
        props: {
          "value": $cmp.value,
          "disableLinkify": true
        },
        key: 38
      }, [])])]) : null : null, !$cmp.isBottomToolbar ? !$cmp.valid ? api_element("div", {
        classMap: {
          "slds-form-element__help": true,
          "slds-p-around_small": true
        },
        attrs: {
          "id": api_scoped_id("error-message-bottom"),
          "data-error-message": true
        },
        key: 40
      }, [api_dynamic($cmp.errorMessage)]) : null : null]), $cmp.linkPanelOpen ? api_element("div", {
        classMap: {
          "slds-popover": true,
          "slds-popover__body": true
        },
        key: 42
      }, [api_custom_element("lightning-input", _lightningInput, {
        classMap: {
          "link-input": true
        },
        props: {
          "name": "link-input",
          "value": $cmp.showLinkValue,
          "label": $cmp.i18n.linkInput
        },
        key: 43,
        on: {
          "change": _m8 || ($ctx._m8 = api_bind($cmp.handleLinkValueChange)),
          "keydown": _m9 || ($ctx._m9 = api_bind($cmp.linkKeyboardPress))
        }
      }, []), api_element("div", {
        classMap: {
          "slds-m-top_small": true
        },
        key: 44
      }, [api_custom_element("lightning-button", _lightningButton, {
        props: {
          "variant": "brand",
          "label": $cmp.i18n.linkSave
        },
        key: 45,
        on: {
          "click": _m10 || ($ctx._m10 = api_bind($cmp.saveLink))
        }
      }, []), api_custom_element("lightning-button", _lightningButton, {
        styleMap: {
          "marginLeft": ".25rem"
        },
        props: {
          "variant": "bare",
          "label": $cmp.i18n.linkCancel
        },
        key: 46,
        on: {
          "click": _m11 || ($ctx._m11 = api_bind($cmp.cancelLink))
        }
      }, [])])]) : null];
    }

    var _tmpl$x = lwc.registerTemplate(tmpl$y);
    tmpl$y.stylesheets = [];

    if (_implicitStylesheets$d) {
      tmpl$y.stylesheets.push.apply(tmpl$y.stylesheets, _implicitStylesheets$d);
    }
    tmpl$y.stylesheetTokens = {
      hostAttribute: "lightning-inputRichText_inputRichText-host",
      shadowAttribute: "lightning-inputRichText_inputRichText"
    };

    var labelAlignText = 'Align text';

    var labelBold = 'Bold';

    var labelBullet = 'Bulleted list';

    var labelCenterAlign = 'Center align text';

    var labelComposeText = 'Compose text';

    var labelFont = 'Font';

    var labelFontSize = 'Font Size';

    var labelFormatBackground = 'Format background and text color';

    var labelFormatBody = 'Format body';

    var labelFormatFont = 'Format font family and size';

    var labelFormatText = 'Format text';

    var labelIndent = 'Indent';

    var labelInsertContent = 'Insert content';

    var labelItalic = 'Italic';

    var labelLeftAlign = 'Left align text';

    var labelLink = 'Link';

    var labelImage = 'Image';

    var labelLinkCancel = 'Cancel';

    var labelLinkInput = 'Link URL';

    var labelLinkSave = 'Save';

    var labelNumber = 'Numbered list';

    var labelOutdent = 'Outdent';

    var labelRemoveFormatting = 'Remove formatting';

    var labelRightAlign = 'Right align text';

    var labelStrike = 'Strikethrough';

    var labelUnderline = 'Underline';

    /*
     * Copyright (C) 2016 salesforce.com, inc.
     *
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     *         http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     */ /*
    Quill

    Copyright (c) 2014, Jason Chen
    Copyright (c) 2013, salesforce.com
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions
    are met:

    1. Redistributions of source code must retain the above copyright
    notice, this list of conditions and the following disclaimer.

    2. Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

    3. Neither the name of the copyright holder nor the names of its
    contributors may be used to endorse or promote products derived from
    this software without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */var commonjsGlobal=typeof window!=='undefined'?window:typeof global!=='undefined'?global:typeof self!=='undefined'?self:{};function unwrapExports(x){return x&&x.__esModule&&Object.prototype.hasOwnProperty.call(x,'default')?x['default']:x;}function createCommonjsModule(fn,module){return module={exports:{}},fn(module,module.exports),module.exports;}var quill=createCommonjsModule(function(module,exports){(function webpackUniversalModuleDefinition(root,factory){module.exports=factory();})(typeof self!=='undefined'?self:commonjsGlobal,function(){return function(modules){var installedModules={};function __webpack_require__(moduleId){if(installedModules[moduleId]){return installedModules[moduleId].exports;}var module=installedModules[moduleId]={i:moduleId,l:false,exports:{}};modules[moduleId].call(module.exports,module,module.exports,__webpack_require__);module.l=true;return module.exports;}__webpack_require__.m=modules;__webpack_require__.c=installedModules;__webpack_require__.d=function(exports,name,getter){if(!__webpack_require__.o(exports,name)){Object.defineProperty(exports,name,{configurable:false,enumerable:true,get:getter});}};__webpack_require__.n=function(module){var getter=module&&module.__esModule?function getDefault(){return module['default'];}:function getModuleExports(){return module;};__webpack_require__.d(getter,'a',getter);return getter;};__webpack_require__.o=function(object,property){return Object.prototype.hasOwnProperty.call(object,property);};__webpack_require__.p="";return __webpack_require__(__webpack_require__.s=109);}([function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var container_1=__webpack_require__(17);var format_1=__webpack_require__(18);var leaf_1=__webpack_require__(19);var scroll_1=__webpack_require__(45);var inline_1=__webpack_require__(46);var block_1=__webpack_require__(47);var embed_1=__webpack_require__(48);var text_1=__webpack_require__(49);var attributor_1=__webpack_require__(12);var class_1=__webpack_require__(32);var style_1=__webpack_require__(33);var store_1=__webpack_require__(31);var Registry=__webpack_require__(1);var Parchment={Scope:Registry.Scope,create:Registry.create,find:Registry.find,query:Registry.query,register:Registry.register,Container:container_1.default,Format:format_1.default,Leaf:leaf_1.default,Embed:embed_1.default,Scroll:scroll_1.default,Block:block_1.default,Inline:inline_1.default,Text:text_1.default,Attributor:{Attribute:attributor_1.default,Class:class_1.default,Style:style_1.default,Store:store_1.default}};exports.default=Parchment;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var ParchmentError=function(_super){__extends(ParchmentError,_super);function ParchmentError(message){var _this=this;message='[Parchment] '+message;_this=_super.call(this,message)||this;_this.message=message;_this.name=_this.constructor.name;return _this;}return ParchmentError;}(Error);exports.ParchmentError=ParchmentError;var attributes={};var classes={};var tags={};var types={};exports.DATA_KEY='__blot';var Scope;(function(Scope){Scope[Scope["TYPE"]=3]="TYPE";Scope[Scope["LEVEL"]=12]="LEVEL";Scope[Scope["ATTRIBUTE"]=13]="ATTRIBUTE";Scope[Scope["BLOT"]=14]="BLOT";Scope[Scope["INLINE"]=7]="INLINE";Scope[Scope["BLOCK"]=11]="BLOCK";Scope[Scope["BLOCK_BLOT"]=10]="BLOCK_BLOT";Scope[Scope["INLINE_BLOT"]=6]="INLINE_BLOT";Scope[Scope["BLOCK_ATTRIBUTE"]=9]="BLOCK_ATTRIBUTE";Scope[Scope["INLINE_ATTRIBUTE"]=5]="INLINE_ATTRIBUTE";Scope[Scope["ANY"]=15]="ANY";})(Scope=exports.Scope||(exports.Scope={}));function create(input,value){var match=query(input);if(match==null){throw new ParchmentError("Unable to create "+input+" blot");}var BlotClass=match;var node=input instanceof Node||input['nodeType']===Node.TEXT_NODE?input:BlotClass.create(value);return new BlotClass(node,value);}exports.create=create;function find(node,bubble){if(bubble===void 0){bubble=false;}if(node==null)return null;if(node[exports.DATA_KEY]!=null)return node[exports.DATA_KEY].blot;if(bubble)return find(node.parentNode,bubble);return null;}exports.find=find;function query(query,scope){if(scope===void 0){scope=Scope.ANY;}var match;if(typeof query==='string'){match=types[query]||attributes[query];}else if(query instanceof Text||query['nodeType']===Node.TEXT_NODE){match=types['text'];}else if(typeof query==='number'){if(query&Scope.LEVEL&Scope.BLOCK){match=types['block'];}else if(query&Scope.LEVEL&Scope.INLINE){match=types['inline'];}}else if(query instanceof HTMLElement){var names=(query.getAttribute('class')||'').split(/\s+/);for(var i in names){match=classes[names[i]];if(match)break;}match=match||tags[query.tagName];}if(match==null)return null;if(scope&Scope.LEVEL&match.scope&&scope&Scope.TYPE&match.scope)return match;return null;}exports.query=query;function register(){var Definitions=[];for(var _i=0;_i<arguments.length;_i++){Definitions[_i]=arguments[_i];}if(Definitions.length>1){return Definitions.map(function(d){return register(d);});}var Definition=Definitions[0];if(typeof Definition.blotName!=='string'&&typeof Definition.attrName!=='string'){throw new ParchmentError('Invalid definition');}else if(Definition.blotName==='abstract'){throw new ParchmentError('Cannot register abstract class');}types[Definition.blotName||Definition.attrName]=Definition;if(typeof Definition.keyName==='string'){attributes[Definition.keyName]=Definition;}else{if(Definition.className!=null){classes[Definition.className]=Definition;}if(Definition.tagName!=null){if(Array.isArray(Definition.tagName)){Definition.tagName=Definition.tagName.map(function(tagName){return tagName.toUpperCase();});}else{Definition.tagName=Definition.tagName.toUpperCase();}var tagNames=Array.isArray(Definition.tagName)?Definition.tagName:[Definition.tagName];tagNames.forEach(function(tag){if(tags[tag]==null||Definition.className==null){tags[tag]=Definition;}});}}return Definition;}exports.register=register;},function(module,exports,__webpack_require__){var diff=__webpack_require__(51);var equal=__webpack_require__(11);var extend=__webpack_require__(3);var op=__webpack_require__(20);var NULL_CHARACTER=String.fromCharCode(0);var Delta=function(ops){if(Array.isArray(ops)){this.ops=ops;}else if(ops!=null&&Array.isArray(ops.ops)){this.ops=ops.ops;}else{this.ops=[];}};Delta.prototype.insert=function(text,attributes){var newOp={};if(text.length===0)return this;newOp.insert=text;if(attributes!=null&&typeof attributes==='object'&&Object.keys(attributes).length>0){newOp.attributes=attributes;}return this.push(newOp);};Delta.prototype['delete']=function(length){if(length<=0)return this;return this.push({'delete':length});};Delta.prototype.retain=function(length,attributes){if(length<=0)return this;var newOp={retain:length};if(attributes!=null&&typeof attributes==='object'&&Object.keys(attributes).length>0){newOp.attributes=attributes;}return this.push(newOp);};Delta.prototype.push=function(newOp){var index=this.ops.length;var lastOp=this.ops[index-1];newOp=extend(true,{},newOp);if(typeof lastOp==='object'){if(typeof newOp['delete']==='number'&&typeof lastOp['delete']==='number'){this.ops[index-1]={'delete':lastOp['delete']+newOp['delete']};return this;}if(typeof lastOp['delete']==='number'&&newOp.insert!=null){index-=1;lastOp=this.ops[index-1];if(typeof lastOp!=='object'){this.ops.unshift(newOp);return this;}}if(equal(newOp.attributes,lastOp.attributes)){if(typeof newOp.insert==='string'&&typeof lastOp.insert==='string'){this.ops[index-1]={insert:lastOp.insert+newOp.insert};if(typeof newOp.attributes==='object')this.ops[index-1].attributes=newOp.attributes;return this;}else if(typeof newOp.retain==='number'&&typeof lastOp.retain==='number'){this.ops[index-1]={retain:lastOp.retain+newOp.retain};if(typeof newOp.attributes==='object')this.ops[index-1].attributes=newOp.attributes;return this;}}}if(index===this.ops.length){this.ops.push(newOp);}else{this.ops.splice(index,0,newOp);}return this;};Delta.prototype.chop=function(){var lastOp=this.ops[this.ops.length-1];if(lastOp&&lastOp.retain&&!lastOp.attributes){this.ops.pop();}return this;};Delta.prototype.filter=function(predicate){return this.ops.filter(predicate);};Delta.prototype.forEach=function(predicate){this.ops.forEach(predicate);};Delta.prototype.map=function(predicate){return this.ops.map(predicate);};Delta.prototype.partition=function(predicate){var passed=[],failed=[];this.forEach(function(op){var target=predicate(op)?passed:failed;target.push(op);});return [passed,failed];};Delta.prototype.reduce=function(predicate,initial){return this.ops.reduce(predicate,initial);};Delta.prototype.changeLength=function(){return this.reduce(function(length,elem){if(elem.insert){return length+op.length(elem);}else if(elem.delete){return length-elem.delete;}return length;},0);};Delta.prototype.length=function(){return this.reduce(function(length,elem){return length+op.length(elem);},0);};Delta.prototype.slice=function(start,end){start=start||0;if(typeof end!=='number')end=Infinity;var ops=[];var iter=op.iterator(this.ops);var index=0;while(index<end&&iter.hasNext()){var nextOp;if(index<start){nextOp=iter.next(start-index);}else{nextOp=iter.next(end-index);ops.push(nextOp);}index+=op.length(nextOp);}return new Delta(ops);};Delta.prototype.compose=function(other){var thisIter=op.iterator(this.ops);var otherIter=op.iterator(other.ops);var delta=new Delta();while(thisIter.hasNext()||otherIter.hasNext()){if(otherIter.peekType()==='insert'){delta.push(otherIter.next());}else if(thisIter.peekType()==='delete'){delta.push(thisIter.next());}else{var length=Math.min(thisIter.peekLength(),otherIter.peekLength());var thisOp=thisIter.next(length);var otherOp=otherIter.next(length);if(typeof otherOp.retain==='number'){var newOp={};if(typeof thisOp.retain==='number'){newOp.retain=length;}else{newOp.insert=thisOp.insert;}var attributes=op.attributes.compose(thisOp.attributes,otherOp.attributes,typeof thisOp.retain==='number');if(attributes)newOp.attributes=attributes;delta.push(newOp);}else if(typeof otherOp['delete']==='number'&&typeof thisOp.retain==='number'){delta.push(otherOp);}}}return delta.chop();};Delta.prototype.concat=function(other){var delta=new Delta(this.ops.slice());if(other.ops.length>0){delta.push(other.ops[0]);delta.ops=delta.ops.concat(other.ops.slice(1));}return delta;};Delta.prototype.diff=function(other,index){if(this.ops===other.ops){return new Delta();}var strings=[this,other].map(function(delta){return delta.map(function(op){if(op.insert!=null){return typeof op.insert==='string'?op.insert:NULL_CHARACTER;}var prep=delta===other?'on':'with';throw new Error('diff() called '+prep+' non-document');}).join('');});var delta=new Delta();var diffResult=diff(strings[0],strings[1],index);var thisIter=op.iterator(this.ops);var otherIter=op.iterator(other.ops);diffResult.forEach(function(component){var length=component[1].length;while(length>0){var opLength=0;switch(component[0]){case diff.INSERT:opLength=Math.min(otherIter.peekLength(),length);delta.push(otherIter.next(opLength));break;case diff.DELETE:opLength=Math.min(length,thisIter.peekLength());thisIter.next(opLength);delta['delete'](opLength);break;case diff.EQUAL:opLength=Math.min(thisIter.peekLength(),otherIter.peekLength(),length);var thisOp=thisIter.next(opLength);var otherOp=otherIter.next(opLength);if(equal(thisOp.insert,otherOp.insert)){delta.retain(opLength,op.attributes.diff(thisOp.attributes,otherOp.attributes));}else{delta.push(otherOp)['delete'](opLength);}break;}length-=opLength;}});return delta.chop();};Delta.prototype.eachLine=function(predicate,newline){newline=newline||'\n';var iter=op.iterator(this.ops);var line=new Delta();var i=0;while(iter.hasNext()){if(iter.peekType()!=='insert')return;var thisOp=iter.peek();var start=op.length(thisOp)-iter.peekLength();var index=typeof thisOp.insert==='string'?thisOp.insert.indexOf(newline,start)-start:-1;if(index<0){line.push(iter.next());}else if(index>0){line.push(iter.next(index));}else{if(predicate(line,iter.next(1).attributes||{},i)===false){return;}i+=1;line=new Delta();}}if(line.length()>0){predicate(line,{},i);}};Delta.prototype.transform=function(other,priority){priority=!!priority;if(typeof other==='number'){return this.transformPosition(other,priority);}var thisIter=op.iterator(this.ops);var otherIter=op.iterator(other.ops);var delta=new Delta();while(thisIter.hasNext()||otherIter.hasNext()){if(thisIter.peekType()==='insert'&&(priority||otherIter.peekType()!=='insert')){delta.retain(op.length(thisIter.next()));}else if(otherIter.peekType()==='insert'){delta.push(otherIter.next());}else{var length=Math.min(thisIter.peekLength(),otherIter.peekLength());var thisOp=thisIter.next(length);var otherOp=otherIter.next(length);if(thisOp['delete']){continue;}else if(otherOp['delete']){delta.push(otherOp);}else{delta.retain(length,op.attributes.transform(thisOp.attributes,otherOp.attributes,priority));}}}return delta.chop();};Delta.prototype.transformPosition=function(index,priority){priority=!!priority;var thisIter=op.iterator(this.ops);var offset=0;while(thisIter.hasNext()&&offset<=index){var length=thisIter.peekLength();var nextType=thisIter.peekType();thisIter.next();if(nextType==='delete'){index-=Math.min(length,index-offset);continue;}else if(nextType==='insert'&&(offset<index||!priority)){index+=length;}offset+=length;}return index;};module.exports=Delta;},function(module,exports){var hasOwn=Object.prototype.hasOwnProperty;var toStr=Object.prototype.toString;var isArray=function isArray(arr){if(typeof Array.isArray==='function'){return Array.isArray(arr);}return toStr.call(arr)==='[object Array]';};var isPlainObject=function isPlainObject(obj){if(!obj||toStr.call(obj)!=='[object Object]'){return false;}var hasOwnConstructor=hasOwn.call(obj,'constructor');var hasIsPrototypeOf=obj.constructor&&obj.constructor.prototype&&hasOwn.call(obj.constructor.prototype,'isPrototypeOf');if(obj.constructor&&!hasOwnConstructor&&!hasIsPrototypeOf){return false;}var key;for(key in obj){}return typeof key==='undefined'||hasOwn.call(obj,key);};module.exports=function extend(){var options,name,src,copy,copyIsArray,clone;var target=arguments[0];var i=1;var length=arguments.length;var deep=false;if(typeof target==='boolean'){deep=target;target=arguments[1]||{};i=2;}if(target==null||typeof target!=='object'&&typeof target!=='function'){target={};}for(;i<length;++i){options=arguments[i];if(options!=null){for(name in options){src=target[name];copy=options[name];if(target!==copy){if(deep&&copy&&(isPlainObject(copy)||(copyIsArray=isArray(copy)))){if(copyIsArray){copyIsArray=false;clone=src&&isArray(src)?src:[];}else{clone=src&&isPlainObject(src)?src:{};}target[name]=extend(deep,clone,copy);}else if(typeof copy!=='undefined'){target[name]=copy;}}}}}return target;};},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.BlockEmbed=exports.bubbleFormats=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _extend=__webpack_require__(3);var _extend2=_interopRequireDefault(_extend);var _quillDelta=__webpack_require__(2);var _quillDelta2=_interopRequireDefault(_quillDelta);var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _break=__webpack_require__(16);var _break2=_interopRequireDefault(_break);var _inline=__webpack_require__(6);var _inline2=_interopRequireDefault(_inline);var _text=__webpack_require__(7);var _text2=_interopRequireDefault(_text);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var NEWLINE_LENGTH=1;var BlockEmbed=function(_Parchment$Embed){_inherits(BlockEmbed,_Parchment$Embed);function BlockEmbed(){_classCallCheck(this,BlockEmbed);return _possibleConstructorReturn(this,(BlockEmbed.__proto__||Object.getPrototypeOf(BlockEmbed)).apply(this,arguments));}_createClass(BlockEmbed,[{key:'attach',value:function attach(){_get(BlockEmbed.prototype.__proto__||Object.getPrototypeOf(BlockEmbed.prototype),'attach',this).call(this);this.attributes=new _parchment2.default.Attributor.Store(this.domNode);}},{key:'delta',value:function delta(){return new _quillDelta2.default().insert(this.value(),_extend2.default(this.formats(),this.attributes.values()));}},{key:'format',value:function format(name,value){var attribute=_parchment2.default.query(name,_parchment2.default.Scope.BLOCK_ATTRIBUTE);if(attribute!=null){this.attributes.attribute(attribute,value);}}},{key:'formatAt',value:function formatAt(index,length,name,value){this.format(name,value);}},{key:'insertAt',value:function insertAt(index,value,def){if(typeof value==='string'&&value.endsWith('\n')){var block=_parchment2.default.create(Block.blotName);this.parent.insertBefore(block,index===0?this:this.next);block.insertAt(0,value.slice(0,-1));}else{_get(BlockEmbed.prototype.__proto__||Object.getPrototypeOf(BlockEmbed.prototype),'insertAt',this).call(this,index,value,def);}}}]);return BlockEmbed;}(_parchment2.default.Embed);BlockEmbed.scope=_parchment2.default.Scope.BLOCK_BLOT;var Block=function(_Parchment$Block){_inherits(Block,_Parchment$Block);function Block(domNode){_classCallCheck(this,Block);var _this2=_possibleConstructorReturn(this,(Block.__proto__||Object.getPrototypeOf(Block)).call(this,domNode));_this2.cache={};return _this2;}_createClass(Block,[{key:'delta',value:function delta(){if(this.cache.delta==null){this.cache.delta=this.descendants(_parchment2.default.Leaf).reduce(function(delta,leaf){if(leaf.length()===0){return delta;}else{return delta.insert(leaf.value(),bubbleFormats(leaf));}},new _quillDelta2.default()).insert('\n',bubbleFormats(this));}return this.cache.delta;}},{key:'deleteAt',value:function deleteAt(index,length){_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'deleteAt',this).call(this,index,length);this.cache={};}},{key:'formatAt',value:function formatAt(index,length,name,value){if(length<=0)return;if(_parchment2.default.query(name,_parchment2.default.Scope.BLOCK)){if(index+length===this.length()){this.format(name,value);}}else{_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'formatAt',this).call(this,index,Math.min(length,this.length()-index-1),name,value);}this.cache={};}},{key:'insertAt',value:function insertAt(index,value,def){if(def!=null)return _get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'insertAt',this).call(this,index,value,def);if(value.length===0)return;var lines=value.split('\n');var text=lines.shift();if(text.length>0){if(index<this.length()-1||this.children.tail==null){_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'insertAt',this).call(this,Math.min(index,this.length()-1),text);}else{this.children.tail.insertAt(this.children.tail.length(),text);}this.cache={};}var block=this;lines.reduce(function(index,line){block=block.split(index,true);block.insertAt(0,line);return line.length;},index+text.length);}},{key:'insertBefore',value:function insertBefore(blot,ref){var head=this.children.head;_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'insertBefore',this).call(this,blot,ref);if(head instanceof _break2.default){head.remove();}this.cache={};}},{key:'length',value:function length(){if(this.cache.length==null){this.cache.length=_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'length',this).call(this)+NEWLINE_LENGTH;}return this.cache.length;}},{key:'moveChildren',value:function moveChildren(target,ref){_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'moveChildren',this).call(this,target,ref);this.cache={};}},{key:'optimize',value:function optimize(context){_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'optimize',this).call(this,context);this.cache={};}},{key:'path',value:function path(index){return _get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'path',this).call(this,index,true);}},{key:'removeChild',value:function removeChild(child){_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'removeChild',this).call(this,child);this.cache={};}},{key:'split',value:function split(index){var force=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(force&&(index===0||index>=this.length()-NEWLINE_LENGTH)){var clone=this.clone();if(index===0){this.parent.insertBefore(clone,this);return this;}else{this.parent.insertBefore(clone,this.next);return clone;}}else{var next=_get(Block.prototype.__proto__||Object.getPrototypeOf(Block.prototype),'split',this).call(this,index,force);this.cache={};return next;}}}]);return Block;}(_parchment2.default.Block);Block.blotName='block';Block.tagName='P';Block.defaultChild='break';Block.allowedChildren=[_inline2.default,_parchment2.default.Embed,_text2.default];function bubbleFormats(blot){var formats=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(blot==null)return formats;if(typeof blot.formats==='function'){formats=_extend2.default(formats,blot.formats());}if(blot.parent==null||blot.parent.blotName=='scroll'||blot.parent.statics.scope!==blot.statics.scope){return formats;}return bubbleFormats(blot.parent,formats);}exports.bubbleFormats=bubbleFormats;exports.BlockEmbed=BlockEmbed;exports.default=Block;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.overload=exports.expandConfig=undefined;var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();__webpack_require__(50);var _quillDelta=__webpack_require__(2);var _quillDelta2=_interopRequireDefault(_quillDelta);var _editor=__webpack_require__(14);var _editor2=_interopRequireDefault(_editor);var _emitter3=__webpack_require__(8);var _emitter4=_interopRequireDefault(_emitter3);var _module=__webpack_require__(9);var _module2=_interopRequireDefault(_module);var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _selection=__webpack_require__(15);var _selection2=_interopRequireDefault(_selection);var _extend=__webpack_require__(3);var _extend2=_interopRequireDefault(_extend);var _logger=__webpack_require__(10);var _logger2=_interopRequireDefault(_logger);var _theme=__webpack_require__(34);var _theme2=_interopRequireDefault(_theme);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var debug=_logger2.default('quill');var Quill=function(){_createClass(Quill,null,[{key:'debug',value:function debug(limit){if(limit===true){limit='log';}_logger2.default.level(limit);}},{key:'find',value:function find(node){return node.__quill||_parchment2.default.find(node);}},{key:'import',value:function _import(name){if(this.imports[name]==null){debug.error('Cannot import '+name+'. Are you sure it was registered?');}return this.imports[name];}},{key:'register',value:function register(path,target){var _this=this;var overwrite=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;if(typeof path!=='string'){var name=path.attrName||path.blotName;if(typeof name==='string'){this.register('formats/'+name,path,target);}else{Object.keys(path).forEach(function(key){_this.register(key,path[key],target);});}}else{if(this.imports[path]!=null&&!overwrite){debug.warn('Overwriting '+path+' with',target);}this.imports[path]=target;if((path.startsWith('blots/')||path.startsWith('formats/'))&&target.blotName!=='abstract'){_parchment2.default.register(target);}else if(path.startsWith('modules')&&typeof target.register==='function'){target.register();}}}}]);function Quill(container){var _this2=this;var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Quill);this.options=expandConfig(container,options);this.container=this.options.container;if(this.container==null){return debug.error('Invalid Quill container',container);}if(this.options.debug){Quill.debug(this.options.debug);}var html=this.container.innerHTML.trim();this.container.classList.add('ql-container');this.container.innerHTML='';this.container.__quill=this;this.root=this.addContainer('ql-editor');this.root.classList.add('ql-blank');this.root.setAttribute('data-gramm',false);this.scrollingContainer=this.options.scrollingContainer||this.root;this.emitter=new _emitter4.default();this.scroll=_parchment2.default.create(this.root,{emitter:this.emitter,whitelist:this.options.formats});this.editor=new _editor2.default(this.scroll);this.selection=new _selection2.default(this.scroll,this.emitter);this.theme=new this.options.theme(this,this.options);this.keyboard=this.theme.addModule('keyboard');this.clipboard=this.theme.addModule('clipboard');this.history=this.theme.addModule('history');this.theme.init();this.emitter.on(_emitter4.default.events.EDITOR_CHANGE,function(type){if(type===_emitter4.default.events.TEXT_CHANGE){_this2.root.classList.toggle('ql-blank',_this2.editor.isBlank());}});this.emitter.on(_emitter4.default.events.SCROLL_UPDATE,function(source,mutations){var range=_this2.selection.lastRange;var index=range&&range.length===0?range.index:undefined;modify.call(_this2,function(){return _this2.editor.update(null,mutations,index);},source);});var contents=this.clipboard.convert('<div class=\'ql-editor\' style="white-space: normal;">'+html+'<p><br></p></div>');this.setContents(contents);this.history.clear();if(this.options.placeholder){this.root.setAttribute('data-placeholder',this.options.placeholder);}if(this.options.readOnly){this.disable();}}_createClass(Quill,[{key:'addContainer',value:function addContainer(container){var refNode=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;if(typeof container==='string'){var className=container;container=document.createElement('div');container.classList.add(className);}this.container.insertBefore(container,refNode);return container;}},{key:'blur',value:function blur(){this.selection.setRange(null);}},{key:'deleteText',value:function deleteText(index,length,source){var _this3=this;var _overload=overload(index,length,source);var _overload2=_slicedToArray(_overload,4);index=_overload2[0];length=_overload2[1];source=_overload2[3];return modify.call(this,function(){return _this3.editor.deleteText(index,length);},source,index,-1*length);}},{key:'disable',value:function disable(){this.enable(false);}},{key:'enable',value:function enable(){var enabled=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;this.scroll.enable(enabled);this.container.classList.toggle('ql-disabled',!enabled);}},{key:'focus',value:function focus(){var scrollTop=this.scrollingContainer.scrollTop;this.selection.focus();this.scrollingContainer.scrollTop=scrollTop;this.scrollIntoView();}},{key:'format',value:function format(name,value){var _this4=this;var source=arguments.length>2&&arguments[2]!==undefined?arguments[2]:_emitter4.default.sources.API;return modify.call(this,function(){var range=_this4.getSelection(true);var change=new _quillDelta2.default();if(range==null){return change;}else if(_parchment2.default.query(name,_parchment2.default.Scope.BLOCK)){change=_this4.editor.formatLine(range.index,range.length,_defineProperty({},name,value));}else if(range.length===0){_this4.selection.format(name,value);return change;}else{change=_this4.editor.formatText(range.index,range.length,_defineProperty({},name,value));}_this4.setSelection(range,_emitter4.default.sources.SILENT);return change;},source);}},{key:'formatLine',value:function formatLine(index,length,name,value,source){var _this5=this;var formats=void 0;var _overload3=overload(index,length,name,value,source);var _overload4=_slicedToArray(_overload3,4);index=_overload4[0];length=_overload4[1];formats=_overload4[2];source=_overload4[3];return modify.call(this,function(){return _this5.editor.formatLine(index,length,formats);},source,index,0);}},{key:'formatText',value:function formatText(index,length,name,value,source){var _this6=this;var formats=void 0;var _overload5=overload(index,length,name,value,source);var _overload6=_slicedToArray(_overload5,4);index=_overload6[0];length=_overload6[1];formats=_overload6[2];source=_overload6[3];return modify.call(this,function(){return _this6.editor.formatText(index,length,formats);},source,index,0);}},{key:'getBounds',value:function getBounds(index){var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var bounds=void 0;if(typeof index==='number'){bounds=this.selection.getBounds(index,length);}else{bounds=this.selection.getBounds(index.index,index.length);}var containerBounds=this.container.getBoundingClientRect();return {bottom:bounds.bottom-containerBounds.top,height:bounds.height,left:bounds.left-containerBounds.left,right:bounds.right-containerBounds.left,top:bounds.top-containerBounds.top,width:bounds.width};}},{key:'getContents',value:function getContents(){var index=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.getLength()-index;var _overload7=overload(index,length);var _overload8=_slicedToArray(_overload7,2);index=_overload8[0];length=_overload8[1];return this.editor.getContents(index,length);}},{key:'getFormat',value:function getFormat(){var index=arguments.length>0&&arguments[0]!==undefined?arguments[0]:this.getSelection(true);var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;if(typeof index==='number'){return this.editor.getFormat(index,length);}else{return this.editor.getFormat(index.index,index.length);}}},{key:'getIndex',value:function getIndex(blot){return blot.offset(this.scroll);}},{key:'getLength',value:function getLength(){return this.scroll.length();}},{key:'getLeaf',value:function getLeaf(index){return this.scroll.leaf(index);}},{key:'getLine',value:function getLine(index){return this.scroll.line(index);}},{key:'getLines',value:function getLines(){var index=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Number.MAX_VALUE;if(typeof index!=='number'){return this.scroll.lines(index.index,index.length);}else{return this.scroll.lines(index,length);}}},{key:'getModule',value:function getModule(name){return this.theme.modules[name];}},{key:'getSelection',value:function getSelection(){var focus=arguments.length>0&&arguments[0]!==undefined?arguments[0]:false;if(focus)this.focus();this.update();return this.selection.getRange()[0];}},{key:'getText',value:function getText(){var index=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:this.getLength()-index;var _overload9=overload(index,length);var _overload10=_slicedToArray(_overload9,2);index=_overload10[0];length=_overload10[1];return this.editor.getText(index,length);}},{key:'hasFocus',value:function hasFocus(){return this.selection.hasFocus();}},{key:'insertEmbed',value:function insertEmbed(index,embed,value){var _this7=this;var source=arguments.length>3&&arguments[3]!==undefined?arguments[3]:Quill.sources.API;return modify.call(this,function(){return _this7.editor.insertEmbed(index,embed,value);},source,index);}},{key:'insertText',value:function insertText(index,text,name,value,source){var _this8=this;var formats=void 0;var _overload11=overload(index,0,name,value,source);var _overload12=_slicedToArray(_overload11,4);index=_overload12[0];formats=_overload12[2];source=_overload12[3];return modify.call(this,function(){return _this8.editor.insertText(index,text,formats);},source,index,text.length);}},{key:'isEnabled',value:function isEnabled(){return !this.container.classList.contains('ql-disabled');}},{key:'off',value:function off(){return this.emitter.off.apply(this.emitter,arguments);}},{key:'on',value:function on(){return this.emitter.on.apply(this.emitter,arguments);}},{key:'once',value:function once(){return this.emitter.once.apply(this.emitter,arguments);}},{key:'pasteHTML',value:function pasteHTML(index,html,source){this.clipboard.dangerouslyPasteHTML(index,html,source);}},{key:'removeFormat',value:function removeFormat(index,length,source){var _this9=this;var _overload13=overload(index,length,source);var _overload14=_slicedToArray(_overload13,4);index=_overload14[0];length=_overload14[1];source=_overload14[3];return modify.call(this,function(){return _this9.editor.removeFormat(index,length);},source,index);}},{key:'scrollIntoView',value:function scrollIntoView(){this.selection.scrollIntoView(this.scrollingContainer);}},{key:'setContents',value:function setContents(delta){var _this10=this;var source=arguments.length>1&&arguments[1]!==undefined?arguments[1]:_emitter4.default.sources.API;return modify.call(this,function(){delta=new _quillDelta2.default(delta);var length=_this10.getLength();var deleted=_this10.editor.deleteText(0,length);var applied=_this10.editor.applyDelta(delta);var lastOp=applied.ops[applied.ops.length-1];if(lastOp!=null&&typeof lastOp.insert==='string'&&lastOp.insert[lastOp.insert.length-1]==='\n'){_this10.editor.deleteText(_this10.getLength()-1,1);applied.delete(1);}var ret=deleted.compose(applied);return ret;},source);}},{key:'setSelection',value:function setSelection(index,length,source){if(index==null){this.selection.setRange(null,length||Quill.sources.API);}else{var _overload15=overload(index,length,source);var _overload16=_slicedToArray(_overload15,4);index=_overload16[0];length=_overload16[1];source=_overload16[3];this.selection.setRange(new _selection.Range(index,length),source);if(source!==_emitter4.default.sources.SILENT){this.selection.scrollIntoView(this.scrollingContainer);}}}},{key:'setText',value:function setText(text){var source=arguments.length>1&&arguments[1]!==undefined?arguments[1]:_emitter4.default.sources.API;var delta=new _quillDelta2.default().insert(text);return this.setContents(delta,source);}},{key:'update',value:function update(){var source=arguments.length>0&&arguments[0]!==undefined?arguments[0]:_emitter4.default.sources.USER;var change=this.scroll.update(source);this.selection.update(source);return change;}},{key:'updateContents',value:function updateContents(delta){var _this11=this;var source=arguments.length>1&&arguments[1]!==undefined?arguments[1]:_emitter4.default.sources.API;return modify.call(this,function(){delta=new _quillDelta2.default(delta);return _this11.editor.applyDelta(delta,source);},source,true);}}]);return Quill;}();Quill.DEFAULTS={bounds:null,formats:null,modules:{},placeholder:'',readOnly:false,scrollingContainer:null,strict:true,theme:'default'};Quill.events=_emitter4.default.events;Quill.sources=_emitter4.default.sources;Quill.version="1.3.4";Quill.imports={'delta':_quillDelta2.default,'parchment':_parchment2.default,'core/module':_module2.default,'core/theme':_theme2.default};function expandConfig(container,userConfig){userConfig=_extend2.default(true,{container:container,modules:{clipboard:true,keyboard:true,history:true}},userConfig);if(!userConfig.theme||userConfig.theme===Quill.DEFAULTS.theme){userConfig.theme=_theme2.default;}else{userConfig.theme=Quill.import('themes/'+userConfig.theme);if(userConfig.theme==null){throw new Error('Invalid theme '+userConfig.theme+'. Did you register it?');}}var themeConfig=_extend2.default(true,{},userConfig.theme.DEFAULTS);[themeConfig,userConfig].forEach(function(config){config.modules=config.modules||{};Object.keys(config.modules).forEach(function(module){if(config.modules[module]===true){config.modules[module]={};}});});var moduleNames=Object.keys(themeConfig.modules).concat(Object.keys(userConfig.modules));var moduleConfig=moduleNames.reduce(function(config,name){var moduleClass=Quill.import('modules/'+name);if(moduleClass==null){debug.error('Cannot load '+name+' module. Are you sure you registered it?');}else{config[name]=moduleClass.DEFAULTS||{};}return config;},{});if(userConfig.modules!=null&&userConfig.modules.toolbar&&userConfig.modules.toolbar.constructor!==Object){userConfig.modules.toolbar={container:userConfig.modules.toolbar};}userConfig=_extend2.default(true,{},Quill.DEFAULTS,{modules:moduleConfig},themeConfig,userConfig);['bounds','container','scrollingContainer'].forEach(function(key){if(typeof userConfig[key]==='string'){userConfig[key]=document.querySelector(userConfig[key]);}});userConfig.modules=Object.keys(userConfig.modules).reduce(function(config,name){if(userConfig.modules[name]){config[name]=userConfig.modules[name];}return config;},{});return userConfig;}function modify(modifier,source,index,shift){if(this.options.strict&&!this.isEnabled()&&source===_emitter4.default.sources.USER){return new _quillDelta2.default();}var range=index==null?null:this.getSelection();var oldDelta=this.editor.delta;var change=modifier();if(range!=null){if(index===true)index=range.index;if(shift==null){range=shiftRange(range,change,source);}else if(shift!==0){range=shiftRange(range,index,shift,source);}this.setSelection(range,_emitter4.default.sources.SILENT);}if(change.length()>0){var _emitter;var args=[_emitter4.default.events.TEXT_CHANGE,change,oldDelta,source];(_emitter=this.emitter).emit.apply(_emitter,[_emitter4.default.events.EDITOR_CHANGE].concat(args));if(source!==_emitter4.default.sources.SILENT){var _emitter2;(_emitter2=this.emitter).emit.apply(_emitter2,args);}}return change;}function overload(index,length,name,value,source){var formats={};if(typeof index.index==='number'&&typeof index.length==='number'){if(typeof length!=='number'){source=value,value=name,name=length,length=index.length,index=index.index;}else{length=index.length,index=index.index;}}else if(typeof length!=='number'){source=value,value=name,name=length,length=0;}if((typeof name==='undefined'?'undefined':_typeof(name))==='object'){formats=name;source=value;}else if(typeof name==='string'){if(value!=null){formats[name]=value;}else{source=name;}}source=source||_emitter4.default.sources.API;return [index,length,formats,source];}function shiftRange(range,index,length,source){if(range==null)return null;var start=void 0,end=void 0;if(index instanceof _quillDelta2.default){var _map=[range.index,range.index+range.length].map(function(pos){return index.transformPosition(pos,source!==_emitter4.default.sources.USER);});var _map2=_slicedToArray(_map,2);start=_map2[0];end=_map2[1];}else{var _map3=[range.index,range.index+range.length].map(function(pos){if(pos<index||pos===index&&source===_emitter4.default.sources.USER)return pos;if(length>=0){return pos+length;}else{return Math.max(index,pos+length);}});var _map4=_slicedToArray(_map3,2);start=_map4[0];end=_map4[1];}return new _selection.Range(start,end-start);}exports.expandConfig=expandConfig;exports.overload=overload;exports.default=Quill;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _text=__webpack_require__(7);var _text2=_interopRequireDefault(_text);var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Inline=function(_Parchment$Inline){_inherits(Inline,_Parchment$Inline);function Inline(){_classCallCheck(this,Inline);return _possibleConstructorReturn(this,(Inline.__proto__||Object.getPrototypeOf(Inline)).apply(this,arguments));}_createClass(Inline,[{key:'formatAt',value:function formatAt(index,length,name,value){if(Inline.compare(this.statics.blotName,name)<0&&_parchment2.default.query(name,_parchment2.default.Scope.BLOT)){var blot=this.isolate(index,length);if(value){blot.wrap(name,value);}}else{_get(Inline.prototype.__proto__||Object.getPrototypeOf(Inline.prototype),'formatAt',this).call(this,index,length,name,value);}}},{key:'optimize',value:function optimize(context){_get(Inline.prototype.__proto__||Object.getPrototypeOf(Inline.prototype),'optimize',this).call(this,context);if(this.parent instanceof Inline&&Inline.compare(this.statics.blotName,this.parent.statics.blotName)>0){var parent=this.parent.isolate(this.offset(),this.length());this.moveChildren(parent);parent.wrap(this);}}}],[{key:'compare',value:function compare(self,other){var selfIndex=Inline.order.indexOf(self);var otherIndex=Inline.order.indexOf(other);if(selfIndex>=0||otherIndex>=0){return selfIndex-otherIndex;}else if(self===other){return 0;}else if(self<other){return -1;}else{return 1;}}}]);return Inline;}(_parchment2.default.Inline);Inline.allowedChildren=[Inline,_parchment2.default.Embed,_text2.default];Inline.order=['cursor','inline','underline','strike','italic','bold','script','link','code'];exports.default=Inline;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var TextBlot=function(_Parchment$Text){_inherits(TextBlot,_Parchment$Text);function TextBlot(){_classCallCheck(this,TextBlot);return _possibleConstructorReturn(this,(TextBlot.__proto__||Object.getPrototypeOf(TextBlot)).apply(this,arguments));}return TextBlot;}(_parchment2.default.Text);exports.default=TextBlot;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _eventemitter=__webpack_require__(54);var _eventemitter2=_interopRequireDefault(_eventemitter);var _logger=__webpack_require__(10);var _logger2=_interopRequireDefault(_logger);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var debug=_logger2.default('quill:events');var EVENTS=['selectionchange','mousedown','mouseup','click'];EVENTS.forEach(function(eventName){document.addEventListener(eventName,function(){for(var _len=arguments.length,args=Array(_len),_key=0;_key<_len;_key++){args[_key]=arguments[_key];}[].slice.call(document.querySelectorAll('.ql-container')).forEach(function(node){if(node.__quill&&node.__quill.emitter){var _node$__quill$emitter;(_node$__quill$emitter=node.__quill.emitter).handleDOM.apply(_node$__quill$emitter,args);}});});});var Emitter=function(_EventEmitter){_inherits(Emitter,_EventEmitter);function Emitter(){_classCallCheck(this,Emitter);var _this=_possibleConstructorReturn(this,(Emitter.__proto__||Object.getPrototypeOf(Emitter)).call(this));_this.listeners={};_this.on('error',debug.error);return _this;}_createClass(Emitter,[{key:'emit',value:function emit(){debug.log.apply(debug,arguments);_get(Emitter.prototype.__proto__||Object.getPrototypeOf(Emitter.prototype),'emit',this).apply(this,arguments);}},{key:'handleDOM',value:function handleDOM(event){for(var _len2=arguments.length,args=Array(_len2>1?_len2-1:0),_key2=1;_key2<_len2;_key2++){args[_key2-1]=arguments[_key2];}(this.listeners[event.type]||[]).forEach(function(_ref){var node=_ref.node,handler=_ref.handler;if(event.target===node||node.contains(event.target)){handler.apply(undefined,[event].concat(args));}});}},{key:'listenDOM',value:function listenDOM(eventName,node,handler){if(!this.listeners[eventName]){this.listeners[eventName]=[];}this.listeners[eventName].push({node:node,handler:handler});}}]);return Emitter;}(_eventemitter2.default);Emitter.events={EDITOR_CHANGE:'editor-change',SCROLL_BEFORE_UPDATE:'scroll-before-update',SCROLL_OPTIMIZE:'scroll-optimize',SCROLL_UPDATE:'scroll-update',SELECTION_CHANGE:'selection-change',TEXT_CHANGE:'text-change'};Emitter.sources={API:'api',SILENT:'silent',USER:'user'};exports.default=Emitter;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Module=function Module(quill){var options=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};_classCallCheck(this,Module);this.quill=quill;this.options=options;};Module.DEFAULTS={};exports.default=Module;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var levels=['error','warn','log','info'];var level='warn';function debug(method){if(levels.indexOf(method)<=levels.indexOf(level)){var _console;for(var _len=arguments.length,args=Array(_len>1?_len-1:0),_key=1;_key<_len;_key++){args[_key-1]=arguments[_key];}(_console=console)[method].apply(_console,args);}}function namespace(ns){return levels.reduce(function(logger,method){logger[method]=debug.bind(console,method,ns);return logger;},{});}debug.level=namespace.level=function(newLevel){level=newLevel;};exports.default=namespace;},function(module,exports,__webpack_require__){var pSlice=Array.prototype.slice;var objectKeys=__webpack_require__(52);var isArguments=__webpack_require__(53);var deepEqual=module.exports=function(actual,expected,opts){if(!opts)opts={};if(actual===expected){return true;}else if(actual instanceof Date&&expected instanceof Date){return actual.getTime()===expected.getTime();}else if(!actual||!expected||typeof actual!='object'&&typeof expected!='object'){return opts.strict?actual===expected:actual==expected;}else{return objEquiv(actual,expected,opts);}};function isUndefinedOrNull(value){return value===null||value===undefined;}function isBuffer(x){if(!x||typeof x!=='object'||typeof x.length!=='number')return false;if(typeof x.copy!=='function'||typeof x.slice!=='function'){return false;}if(x.length>0&&typeof x[0]!=='number')return false;return true;}function objEquiv(a,b,opts){var i,key;if(isUndefinedOrNull(a)||isUndefinedOrNull(b))return false;if(a.prototype!==b.prototype)return false;if(isArguments(a)){if(!isArguments(b)){return false;}a=pSlice.call(a);b=pSlice.call(b);return deepEqual(a,b,opts);}if(isBuffer(a)){if(!isBuffer(b)){return false;}if(a.length!==b.length)return false;for(i=0;i<a.length;i++){if(a[i]!==b[i])return false;}return true;}try{var ka=objectKeys(a),kb=objectKeys(b);}catch(e){return false;}if(ka.length!=kb.length)return false;ka.sort();kb.sort();for(i=ka.length-1;i>=0;i--){if(ka[i]!=kb[i])return false;}for(i=ka.length-1;i>=0;i--){key=ka[i];if(!deepEqual(a[key],b[key],opts))return false;}return typeof a===typeof b;}},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var Registry=__webpack_require__(1);var Attributor=function(){function Attributor(attrName,keyName,options){if(options===void 0){options={};}this.attrName=attrName;this.keyName=keyName;var attributeBit=Registry.Scope.TYPE&Registry.Scope.ATTRIBUTE;if(options.scope!=null){this.scope=options.scope&Registry.Scope.LEVEL|attributeBit;}else{this.scope=Registry.Scope.ATTRIBUTE;}if(options.whitelist!=null)this.whitelist=options.whitelist;}Attributor.keys=function(node){return [].map.call(node.attributes,function(item){return item.name;});};Attributor.prototype.add=function(node,value){if(!this.canAdd(node,value))return false;node.setAttribute(this.keyName,value);return true;};Attributor.prototype.canAdd=function(node,value){var match=Registry.query(node,Registry.Scope.BLOT&(this.scope|Registry.Scope.TYPE));if(match==null)return false;if(this.whitelist==null)return true;if(typeof value==='string'){return this.whitelist.indexOf(value.replace(/["']/g,''))>-1;}else{return this.whitelist.indexOf(value)>-1;}};Attributor.prototype.remove=function(node){node.removeAttribute(this.keyName);};Attributor.prototype.value=function(node){var value=node.getAttribute(this.keyName);return this.canAdd(node,value)?value:'';};return Attributor;}();exports.default=Attributor;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.Code=undefined;var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _quillDelta=__webpack_require__(2);var _quillDelta2=_interopRequireDefault(_quillDelta);var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _block=__webpack_require__(4);var _block2=_interopRequireDefault(_block);var _inline=__webpack_require__(6);var _inline2=_interopRequireDefault(_inline);var _text=__webpack_require__(7);var _text2=_interopRequireDefault(_text);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Code=function(_Inline){_inherits(Code,_Inline);function Code(){_classCallCheck(this,Code);return _possibleConstructorReturn(this,(Code.__proto__||Object.getPrototypeOf(Code)).apply(this,arguments));}return Code;}(_inline2.default);Code.blotName='code';Code.tagName='CODE';var CodeBlock=function(_Block){_inherits(CodeBlock,_Block);function CodeBlock(){_classCallCheck(this,CodeBlock);return _possibleConstructorReturn(this,(CodeBlock.__proto__||Object.getPrototypeOf(CodeBlock)).apply(this,arguments));}_createClass(CodeBlock,[{key:'delta',value:function delta(){var _this3=this;var text=this.domNode.textContent;if(text.endsWith('\n')){text=text.slice(0,-1);}return text.split('\n').reduce(function(delta,frag){return delta.insert(frag).insert('\n',_this3.formats());},new _quillDelta2.default());}},{key:'format',value:function format(name,value){if(name===this.statics.blotName&&value)return;var _descendant=this.descendant(_text2.default,this.length()-1),_descendant2=_slicedToArray(_descendant,1),text=_descendant2[0];if(text!=null){text.deleteAt(text.length()-1,1);}_get(CodeBlock.prototype.__proto__||Object.getPrototypeOf(CodeBlock.prototype),'format',this).call(this,name,value);}},{key:'formatAt',value:function formatAt(index,length,name,value){if(length===0)return;if(_parchment2.default.query(name,_parchment2.default.Scope.BLOCK)==null||name===this.statics.blotName&&value===this.statics.formats(this.domNode)){return;}var nextNewline=this.newlineIndex(index);if(nextNewline<0||nextNewline>=index+length)return;var prevNewline=this.newlineIndex(index,true)+1;var isolateLength=nextNewline-prevNewline+1;var blot=this.isolate(prevNewline,isolateLength);var next=blot.next;blot.format(name,value);if(next instanceof CodeBlock){next.formatAt(0,index-prevNewline+length-isolateLength,name,value);}}},{key:'insertAt',value:function insertAt(index,value,def){if(def!=null)return;var _descendant3=this.descendant(_text2.default,index),_descendant4=_slicedToArray(_descendant3,2),text=_descendant4[0],offset=_descendant4[1];text.insertAt(offset,value);}},{key:'length',value:function length(){var length=this.domNode.textContent.length;if(!this.domNode.textContent.endsWith('\n')){return length+1;}return length;}},{key:'newlineIndex',value:function newlineIndex(searchIndex){var reverse=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;if(!reverse){var offset=this.domNode.textContent.slice(searchIndex).indexOf('\n');return offset>-1?searchIndex+offset:-1;}else{return this.domNode.textContent.slice(0,searchIndex).lastIndexOf('\n');}}},{key:'optimize',value:function optimize(context){if(!this.domNode.textContent.endsWith('\n')){this.appendChild(_parchment2.default.create('text','\n'));}_get(CodeBlock.prototype.__proto__||Object.getPrototypeOf(CodeBlock.prototype),'optimize',this).call(this,context);var next=this.next;if(next!=null&&next.prev===this&&next.statics.blotName===this.statics.blotName&&this.statics.formats(this.domNode)===next.statics.formats(next.domNode)){next.optimize(context);next.moveChildren(this);next.remove();}}},{key:'replace',value:function replace(target){_get(CodeBlock.prototype.__proto__||Object.getPrototypeOf(CodeBlock.prototype),'replace',this).call(this,target);[].slice.call(this.domNode.querySelectorAll('*')).forEach(function(node){var blot=_parchment2.default.find(node);if(blot==null){node.parentNode.removeChild(node);}else if(blot instanceof _parchment2.default.Embed){blot.remove();}else{blot.unwrap();}});}}],[{key:'create',value:function create(value){var domNode=_get(CodeBlock.__proto__||Object.getPrototypeOf(CodeBlock),'create',this).call(this,value);domNode.setAttribute('spellcheck',false);return domNode;}},{key:'formats',value:function formats(){return true;}}]);return CodeBlock;}(_block2.default);CodeBlock.blotName='code-block';CodeBlock.tagName='PRE';CodeBlock.TAB='  ';exports.Code=Code;exports.default=CodeBlock;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _quillDelta=__webpack_require__(2);var _quillDelta2=_interopRequireDefault(_quillDelta);var _op=__webpack_require__(20);var _op2=_interopRequireDefault(_op);var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _code=__webpack_require__(13);var _code2=_interopRequireDefault(_code);var _cursor=__webpack_require__(23);var _cursor2=_interopRequireDefault(_cursor);var _block=__webpack_require__(4);var _block2=_interopRequireDefault(_block);var _break=__webpack_require__(16);var _break2=_interopRequireDefault(_break);var _clone=__webpack_require__(21);var _clone2=_interopRequireDefault(_clone);var _deepEqual=__webpack_require__(11);var _deepEqual2=_interopRequireDefault(_deepEqual);var _extend=__webpack_require__(3);var _extend2=_interopRequireDefault(_extend);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var ASCII=/^[ -~]*$/;var Editor=function(){function Editor(scroll){_classCallCheck(this,Editor);this.scroll=scroll;this.delta=this.getDelta();}_createClass(Editor,[{key:'applyDelta',value:function applyDelta(delta){var _this=this;var consumeNextNewline=false;this.scroll.update();var scrollLength=this.scroll.length();this.scroll.batchStart();delta=normalizeDelta(delta);delta.reduce(function(index,op){var length=op.retain||op.delete||op.insert.length||1;var attributes=op.attributes||{};if(op.insert!=null){if(typeof op.insert==='string'){var text=op.insert;if(text.endsWith('\n')&&consumeNextNewline){consumeNextNewline=false;text=text.slice(0,-1);}if(index>=scrollLength&&!text.endsWith('\n')){consumeNextNewline=true;}_this.scroll.insertAt(index,text);var _scroll$line=_this.scroll.line(index),_scroll$line2=_slicedToArray(_scroll$line,2),line=_scroll$line2[0],offset=_scroll$line2[1];var formats=_extend2.default({},_block.bubbleFormats(line));if(line instanceof _block2.default){var _line$descendant=line.descendant(_parchment2.default.Leaf,offset),_line$descendant2=_slicedToArray(_line$descendant,1),leaf=_line$descendant2[0];formats=_extend2.default(formats,_block.bubbleFormats(leaf));}attributes=_op2.default.attributes.diff(formats,attributes)||{};}else if(_typeof(op.insert)==='object'){var key=Object.keys(op.insert)[0];if(key==null)return index;_this.scroll.insertAt(index,key,op.insert[key]);}scrollLength+=length;}Object.keys(attributes).forEach(function(name){_this.scroll.formatAt(index,length,name,attributes[name]);});return index+length;},0);delta.reduce(function(index,op){if(typeof op.delete==='number'){_this.scroll.deleteAt(index,op.delete);return index;}return index+(op.retain||op.insert.length||1);},0);this.scroll.batchEnd();return this.update(delta);}},{key:'deleteText',value:function deleteText(index,length){this.scroll.deleteAt(index,length);return this.update(new _quillDelta2.default().retain(index).delete(length));}},{key:'formatLine',value:function formatLine(index,length){var _this2=this;var formats=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};this.scroll.update();Object.keys(formats).forEach(function(format){if(_this2.scroll.whitelist!=null&&!_this2.scroll.whitelist[format])return;var lines=_this2.scroll.lines(index,Math.max(length,1));var lengthRemaining=length;lines.forEach(function(line){var lineLength=line.length();if(!(line instanceof _code2.default)){line.format(format,formats[format]);}else{var codeIndex=index-line.offset(_this2.scroll);var codeLength=line.newlineIndex(codeIndex+lengthRemaining)-codeIndex+1;line.formatAt(codeIndex,codeLength,format,formats[format]);}lengthRemaining-=lineLength;});});this.scroll.optimize();return this.update(new _quillDelta2.default().retain(index).retain(length,_clone2.default(formats)));}},{key:'formatText',value:function formatText(index,length){var _this3=this;var formats=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};Object.keys(formats).forEach(function(format){_this3.scroll.formatAt(index,length,format,formats[format]);});return this.update(new _quillDelta2.default().retain(index).retain(length,_clone2.default(formats)));}},{key:'getContents',value:function getContents(index,length){return this.delta.slice(index,index+length);}},{key:'getDelta',value:function getDelta(){return this.scroll.lines().reduce(function(delta,line){return delta.concat(line.delta());},new _quillDelta2.default());}},{key:'getFormat',value:function getFormat(index){var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var lines=[],leaves=[];if(length===0){this.scroll.path(index).forEach(function(path){var _path=_slicedToArray(path,1),blot=_path[0];if(blot instanceof _block2.default){lines.push(blot);}else if(blot instanceof _parchment2.default.Leaf){leaves.push(blot);}});}else{lines=this.scroll.lines(index,length);leaves=this.scroll.descendants(_parchment2.default.Leaf,index,length);}var formatsArr=[lines,leaves].map(function(blots){if(blots.length===0)return {};var formats=_block.bubbleFormats(blots.shift());while(Object.keys(formats).length>0){var blot=blots.shift();if(blot==null)return formats;formats=combineFormats(_block.bubbleFormats(blot),formats);}return formats;});return _extend2.default.apply(_extend2.default,formatsArr);}},{key:'getText',value:function getText(index,length){return this.getContents(index,length).filter(function(op){return typeof op.insert==='string';}).map(function(op){return op.insert;}).join('');}},{key:'insertEmbed',value:function insertEmbed(index,embed,value){this.scroll.insertAt(index,embed,value);return this.update(new _quillDelta2.default().retain(index).insert(_defineProperty({},embed,value)));}},{key:'insertText',value:function insertText(index,text){var _this4=this;var formats=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};text=text.replace(/\r\n/g,'\n').replace(/\r/g,'\n');this.scroll.insertAt(index,text);Object.keys(formats).forEach(function(format){_this4.scroll.formatAt(index,text.length,format,formats[format]);});return this.update(new _quillDelta2.default().retain(index).insert(text,_clone2.default(formats)));}},{key:'isBlank',value:function isBlank(){if(this.scroll.children.length==0)return true;if(this.scroll.children.length>1)return false;var block=this.scroll.children.head;if(block.statics.blotName!==_block2.default.blotName)return false;if(block.children.length>1)return false;return block.children.head instanceof _break2.default;}},{key:'removeFormat',value:function removeFormat(index,length){var text=this.getText(index,length);var _scroll$line3=this.scroll.line(index+length),_scroll$line4=_slicedToArray(_scroll$line3,2),line=_scroll$line4[0],offset=_scroll$line4[1];var suffixLength=0,suffix=new _quillDelta2.default();if(line!=null){if(!(line instanceof _code2.default)){suffixLength=line.length()-offset;}else{suffixLength=line.newlineIndex(offset)-offset+1;}suffix=line.delta().slice(offset,offset+suffixLength-1).insert('\n');}var contents=this.getContents(index,length+suffixLength);var diff=contents.diff(new _quillDelta2.default().insert(text).concat(suffix));var delta=new _quillDelta2.default().retain(index).concat(diff);return this.applyDelta(delta);}},{key:'update',value:function update(change){var mutations=arguments.length>1&&arguments[1]!==undefined?arguments[1]:[];var cursorIndex=arguments.length>2&&arguments[2]!==undefined?arguments[2]:undefined;var oldDelta=this.delta;if(mutations.length===1&&mutations[0].type==='characterData'&&mutations[0].target.data.match(ASCII)&&_parchment2.default.find(mutations[0].target)){var textBlot=_parchment2.default.find(mutations[0].target);var formats=_block.bubbleFormats(textBlot);var index=textBlot.offset(this.scroll);var oldValue=mutations[0].oldValue.replace(_cursor2.default.CONTENTS,'');var oldText=new _quillDelta2.default().insert(oldValue);var newText=new _quillDelta2.default().insert(textBlot.value());var diffDelta=new _quillDelta2.default().retain(index).concat(oldText.diff(newText,cursorIndex));change=diffDelta.reduce(function(delta,op){if(op.insert){return delta.insert(op.insert,formats);}else{return delta.push(op);}},new _quillDelta2.default());this.delta=oldDelta.compose(change);}else{this.delta=this.getDelta();if(!change||!_deepEqual2.default(oldDelta.compose(change),this.delta)){change=oldDelta.diff(this.delta,cursorIndex);}}return change;}}]);return Editor;}();function combineFormats(formats,combined){return Object.keys(combined).reduce(function(merged,name){if(formats[name]==null)return merged;if(combined[name]===formats[name]){merged[name]=combined[name];}else if(Array.isArray(combined[name])){if(combined[name].indexOf(formats[name])<0){merged[name]=combined[name].concat([formats[name]]);}}else{merged[name]=[combined[name],formats[name]];}return merged;},{});}function normalizeDelta(delta){return delta.reduce(function(delta,op){if(op.insert===1){var attributes=_clone2.default(op.attributes);delete attributes['image'];return delta.insert({image:op.attributes.image},attributes);}if(op.attributes!=null&&(op.attributes.list===true||op.attributes.bullet===true)){op=_clone2.default(op);if(op.attributes.list){op.attributes.list='ordered';}else{op.attributes.list='bullet';delete op.attributes.bullet;}}if(typeof op.insert==='string'){var text=op.insert.replace(/\r\n/g,'\n').replace(/\r/g,'\n');return delta.insert(text,op.attributes);}return delta.push(op);},new _quillDelta2.default());}exports.default=Editor;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.Range=undefined;var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _clone=__webpack_require__(21);var _clone2=_interopRequireDefault(_clone);var _deepEqual=__webpack_require__(11);var _deepEqual2=_interopRequireDefault(_deepEqual);var _emitter3=__webpack_require__(8);var _emitter4=_interopRequireDefault(_emitter3);var _logger=__webpack_require__(10);var _logger2=_interopRequireDefault(_logger);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _toConsumableArray(arr){if(Array.isArray(arr)){for(var i=0,arr2=Array(arr.length);i<arr.length;i++){arr2[i]=arr[i];}return arr2;}else{return Array.from(arr);}}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var debug=_logger2.default('quill:selection');var Range=function Range(index){var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;_classCallCheck(this,Range);this.index=index;this.length=length;};var Selection=function(){function Selection(scroll,emitter){var _this=this;_classCallCheck(this,Selection);this.emitter=emitter;this.scroll=scroll;this.composing=false;this.mouseDown=false;this.root=this.scroll.domNode;this.cursor=_parchment2.default.create('cursor',this);this.lastRange=this.savedRange=new Range(0,0);this.handleComposition();this.handleDragging();this.emitter.listenDOM('selectionchange',document,function(){if(!_this.mouseDown){setTimeout(_this.update.bind(_this,_emitter4.default.sources.USER),1);}});this.emitter.on(_emitter4.default.events.EDITOR_CHANGE,function(type,delta){if(type===_emitter4.default.events.TEXT_CHANGE&&delta.length()>0){_this.update(_emitter4.default.sources.SILENT);}});this.emitter.on(_emitter4.default.events.SCROLL_BEFORE_UPDATE,function(){if(!_this.hasFocus())return;var native=_this.getNativeRange();if(native==null)return;if(native.start.node===_this.cursor.textNode)return;_this.emitter.once(_emitter4.default.events.SCROLL_UPDATE,function(){try{_this.setNativeRange(native.start.node,native.start.offset,native.end.node,native.end.offset);}catch(ignored){}});});this.emitter.on(_emitter4.default.events.SCROLL_OPTIMIZE,function(mutations,context){if(context.range){var _context$range=context.range,startNode=_context$range.startNode,startOffset=_context$range.startOffset,endNode=_context$range.endNode,endOffset=_context$range.endOffset;_this.setNativeRange(startNode,startOffset,endNode,endOffset);}});this.update(_emitter4.default.sources.SILENT);}_createClass(Selection,[{key:'handleComposition',value:function handleComposition(){var _this2=this;this.root.addEventListener('compositionstart',function(){_this2.composing=true;});this.root.addEventListener('compositionend',function(){_this2.composing=false;if(_this2.cursor.parent){var range=_this2.cursor.restore();if(!range)return;setTimeout(function(){_this2.setNativeRange(range.startNode,range.startOffset,range.endNode,range.endOffset);},1);}});}},{key:'handleDragging',value:function handleDragging(){var _this3=this;this.emitter.listenDOM('mousedown',document.body,function(){_this3.mouseDown=true;});this.emitter.listenDOM('mouseup',document.body,function(){_this3.mouseDown=false;_this3.update(_emitter4.default.sources.USER);});}},{key:'focus',value:function focus(){if(this.hasFocus())return;this.root.focus();this.setRange(this.savedRange);}},{key:'format',value:function format(_format,value){if(this.scroll.whitelist!=null&&!this.scroll.whitelist[_format])return;this.scroll.update();var nativeRange=this.getNativeRange();if(nativeRange==null||!nativeRange.native.collapsed||_parchment2.default.query(_format,_parchment2.default.Scope.BLOCK))return;if(nativeRange.start.node!==this.cursor.textNode){var blot=_parchment2.default.find(nativeRange.start.node,false);if(blot==null)return;if(blot instanceof _parchment2.default.Leaf){var after=blot.split(nativeRange.start.offset);blot.parent.insertBefore(this.cursor,after);}else{blot.insertBefore(this.cursor,nativeRange.start.node);}this.cursor.attach();}this.cursor.format(_format,value);this.scroll.optimize();this.setNativeRange(this.cursor.textNode,this.cursor.textNode.data.length);this.update();}},{key:'getBounds',value:function getBounds(index){var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:0;var scrollLength=this.scroll.length();index=Math.min(index,scrollLength-1);length=Math.min(index+length,scrollLength-1)-index;var node=void 0,_scroll$leaf=this.scroll.leaf(index),_scroll$leaf2=_slicedToArray(_scroll$leaf,2),leaf=_scroll$leaf2[0],offset=_scroll$leaf2[1];if(leaf==null)return null;var _leaf$position=leaf.position(offset,true);var _leaf$position2=_slicedToArray(_leaf$position,2);node=_leaf$position2[0];offset=_leaf$position2[1];var range=document.createRange();if(length>0){range.setStart(node,offset);var _scroll$leaf3=this.scroll.leaf(index+length);var _scroll$leaf4=_slicedToArray(_scroll$leaf3,2);leaf=_scroll$leaf4[0];offset=_scroll$leaf4[1];if(leaf==null)return null;var _leaf$position3=leaf.position(offset,true);var _leaf$position4=_slicedToArray(_leaf$position3,2);node=_leaf$position4[0];offset=_leaf$position4[1];range.setEnd(node,offset);return range.getBoundingClientRect();}else{var side='left';var rect=void 0;if(node instanceof Text){if(offset<node.data.length){range.setStart(node,offset);range.setEnd(node,offset+1);}else{range.setStart(node,offset-1);range.setEnd(node,offset);side='right';}rect=range.getBoundingClientRect();}else{rect=leaf.domNode.getBoundingClientRect();if(offset>0)side='right';}return {bottom:rect.top+rect.height,height:rect.height,left:rect[side],right:rect[side],top:rect.top,width:0};}}},{key:'getNativeRange',value:function getNativeRange(){var selection=document.getSelection();if(selection==null||selection.rangeCount<=0)return null;var nativeRange=selection.getRangeAt(0);if(nativeRange==null)return null;var range=this.normalizeNative(nativeRange);debug.info('getNativeRange',range);return range;}},{key:'getRange',value:function getRange(){var normalized=this.getNativeRange();if(normalized==null)return [null,null];var range=this.normalizedToRange(normalized);return [range,normalized];}},{key:'hasFocus',value:function hasFocus(){return document.activeElement===this.root;}},{key:'normalizedToRange',value:function normalizedToRange(range){var _this4=this;var positions=[[range.start.node,range.start.offset]];if(!range.native.collapsed){positions.push([range.end.node,range.end.offset]);}var indexes=positions.map(function(position){var _position=_slicedToArray(position,2),node=_position[0],offset=_position[1];var blot=_parchment2.default.find(node,true);var index=blot.offset(_this4.scroll);if(offset===0){return index;}else if(blot instanceof _parchment2.default.Container){return index+blot.length();}else{return index+blot.index(node,offset);}});var end=Math.min(Math.max.apply(Math,_toConsumableArray(indexes)),this.scroll.length()-1);var start=Math.min.apply(Math,[end].concat(_toConsumableArray(indexes)));return new Range(start,end-start);}},{key:'normalizeNative',value:function normalizeNative(nativeRange){if(!contains(this.root,nativeRange.startContainer)||!nativeRange.collapsed&&!contains(this.root,nativeRange.endContainer)){return null;}var range={start:{node:nativeRange.startContainer,offset:nativeRange.startOffset},end:{node:nativeRange.endContainer,offset:nativeRange.endOffset},native:nativeRange};[range.start,range.end].forEach(function(position){var node=position.node,offset=position.offset;while(!(node instanceof Text)&&node.childNodes.length>0){if(node.childNodes.length>offset){node=node.childNodes[offset];offset=0;}else if(node.childNodes.length===offset){node=node.lastChild;offset=node instanceof Text?node.data.length:node.childNodes.length+1;}else{break;}}position.node=node,position.offset=offset;});return range;}},{key:'rangeToNative',value:function rangeToNative(range){var _this5=this;var indexes=range.collapsed?[range.index]:[range.index,range.index+range.length];var args=[];var scrollLength=this.scroll.length();indexes.forEach(function(index,i){index=Math.min(scrollLength-1,index);var node=void 0,_scroll$leaf5=_this5.scroll.leaf(index),_scroll$leaf6=_slicedToArray(_scroll$leaf5,2),leaf=_scroll$leaf6[0],offset=_scroll$leaf6[1];var _leaf$position5=leaf.position(offset,i!==0);var _leaf$position6=_slicedToArray(_leaf$position5,2);node=_leaf$position6[0];offset=_leaf$position6[1];args.push(node,offset);});if(args.length<2){args=args.concat(args);}return args;}},{key:'scrollIntoView',value:function scrollIntoView(scrollingContainer){var range=this.lastRange;if(range==null)return;var bounds=this.getBounds(range.index,range.length);if(bounds==null)return;var limit=this.scroll.length()-1;var _scroll$line=this.scroll.line(Math.min(range.index,limit)),_scroll$line2=_slicedToArray(_scroll$line,1),first=_scroll$line2[0];var last=first;if(range.length>0){var _scroll$line3=this.scroll.line(Math.min(range.index+range.length,limit));var _scroll$line4=_slicedToArray(_scroll$line3,1);last=_scroll$line4[0];}if(first==null||last==null)return;var scrollBounds=scrollingContainer.getBoundingClientRect();if(bounds.top<scrollBounds.top){scrollingContainer.scrollTop-=scrollBounds.top-bounds.top;}else if(bounds.bottom>scrollBounds.bottom){scrollingContainer.scrollTop+=bounds.bottom-scrollBounds.bottom;}}},{key:'setNativeRange',value:function setNativeRange(startNode,startOffset){var endNode=arguments.length>2&&arguments[2]!==undefined?arguments[2]:startNode;var endOffset=arguments.length>3&&arguments[3]!==undefined?arguments[3]:startOffset;var force=arguments.length>4&&arguments[4]!==undefined?arguments[4]:false;debug.info('setNativeRange',startNode,startOffset,endNode,endOffset);if(startNode!=null&&(this.root.parentNode==null||startNode.parentNode==null||endNode.parentNode==null)){return;}var selection=document.getSelection();if(selection==null)return;if(startNode!=null){if(!this.hasFocus())this.root.focus();var native=(this.getNativeRange()||{}).native;if(native==null||force||startNode!==native.startContainer||startOffset!==native.startOffset||endNode!==native.endContainer||endOffset!==native.endOffset){if(startNode.tagName=="BR"){startOffset=[].indexOf.call(startNode.parentNode.childNodes,startNode);startNode=startNode.parentNode;}if(endNode.tagName=="BR"){endOffset=[].indexOf.call(endNode.parentNode.childNodes,endNode);endNode=endNode.parentNode;}var range=document.createRange();range.setStart(startNode,startOffset);range.setEnd(endNode,endOffset);selection.removeAllRanges();selection.addRange(range);}}else{selection.removeAllRanges();this.root.blur();document.body.focus();}}},{key:'setRange',value:function setRange(range){var force=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var source=arguments.length>2&&arguments[2]!==undefined?arguments[2]:_emitter4.default.sources.API;if(typeof force==='string'){source=force;force=false;}debug.info('setRange',range);if(range!=null){var args=this.rangeToNative(range);this.setNativeRange.apply(this,_toConsumableArray(args).concat([force]));}else{this.setNativeRange(null);}this.update(source);}},{key:'update',value:function update(){var source=arguments.length>0&&arguments[0]!==undefined?arguments[0]:_emitter4.default.sources.USER;var oldRange=this.lastRange;var _getRange=this.getRange(),_getRange2=_slicedToArray(_getRange,2),lastRange=_getRange2[0],nativeRange=_getRange2[1];this.lastRange=lastRange;if(this.lastRange!=null){this.savedRange=this.lastRange;}if(!_deepEqual2.default(oldRange,this.lastRange)){var _emitter;if(!this.composing&&nativeRange!=null&&nativeRange.native.collapsed&&nativeRange.start.node!==this.cursor.textNode){this.cursor.restore();}var args=[_emitter4.default.events.SELECTION_CHANGE,_clone2.default(this.lastRange),_clone2.default(oldRange),source];(_emitter=this.emitter).emit.apply(_emitter,[_emitter4.default.events.EDITOR_CHANGE].concat(args));if(source!==_emitter4.default.sources.SILENT){var _emitter2;(_emitter2=this.emitter).emit.apply(_emitter2,args);}}}}]);return Selection;}();function contains(parent,descendant){try{descendant.parentNode;}catch(e){return false;}if(descendant instanceof Text){descendant=descendant.parentNode;}return parent.contains(descendant);}exports.Range=Range;exports.default=Selection;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Break=function(_Parchment$Embed){_inherits(Break,_Parchment$Embed);function Break(){_classCallCheck(this,Break);return _possibleConstructorReturn(this,(Break.__proto__||Object.getPrototypeOf(Break)).apply(this,arguments));}_createClass(Break,[{key:'insertInto',value:function insertInto(parent,ref){if(parent.children.length===0){_get(Break.prototype.__proto__||Object.getPrototypeOf(Break.prototype),'insertInto',this).call(this,parent,ref);}else{this.remove();}}},{key:'length',value:function length(){return 0;}},{key:'value',value:function value(){return '';}}],[{key:'value',value:function value(){return undefined;}}]);return Break;}(_parchment2.default.Embed);Break.blotName='break';Break.tagName='BR';exports.default=Break;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var linked_list_1=__webpack_require__(44);var shadow_1=__webpack_require__(30);var Registry=__webpack_require__(1);var ContainerBlot=function(_super){__extends(ContainerBlot,_super);function ContainerBlot(domNode){var _this=_super.call(this,domNode)||this;_this.build();return _this;}ContainerBlot.prototype.appendChild=function(other){this.insertBefore(other);};ContainerBlot.prototype.attach=function(){_super.prototype.attach.call(this);this.children.forEach(function(child){child.attach();});};ContainerBlot.prototype.build=function(){var _this=this;this.children=new linked_list_1.default();[].slice.call(this.domNode.childNodes).reverse().forEach(function(node){try{var child=makeBlot(node);_this.insertBefore(child,_this.children.head);}catch(err){if(err instanceof Registry.ParchmentError)return;else throw err;}});};ContainerBlot.prototype.deleteAt=function(index,length){if(index===0&&length===this.length()){return this.remove();}this.children.forEachAt(index,length,function(child,offset,length){child.deleteAt(offset,length);});};ContainerBlot.prototype.descendant=function(criteria,index){var _a=this.children.find(index),child=_a[0],offset=_a[1];if(criteria.blotName==null&&criteria(child)||criteria.blotName!=null&&child instanceof criteria){return [child,offset];}else if(child instanceof ContainerBlot){return child.descendant(criteria,offset);}else{return [null,-1];}};ContainerBlot.prototype.descendants=function(criteria,index,length){if(index===void 0){index=0;}if(length===void 0){length=Number.MAX_VALUE;}var descendants=[],lengthLeft=length;this.children.forEachAt(index,length,function(child,index,length){if(criteria.blotName==null&&criteria(child)||criteria.blotName!=null&&child instanceof criteria){descendants.push(child);}if(child instanceof ContainerBlot){descendants=descendants.concat(child.descendants(criteria,index,lengthLeft));}lengthLeft-=length;});return descendants;};ContainerBlot.prototype.detach=function(){this.children.forEach(function(child){child.detach();});_super.prototype.detach.call(this);};ContainerBlot.prototype.formatAt=function(index,length,name,value){this.children.forEachAt(index,length,function(child,offset,length){child.formatAt(offset,length,name,value);});};ContainerBlot.prototype.insertAt=function(index,value,def){var _a=this.children.find(index),child=_a[0],offset=_a[1];if(child){child.insertAt(offset,value,def);}else{var blot=def==null?Registry.create('text',value):Registry.create(value,def);this.appendChild(blot);}};ContainerBlot.prototype.insertBefore=function(childBlot,refBlot){if(this.statics.allowedChildren!=null&&!this.statics.allowedChildren.some(function(child){return childBlot instanceof child;})){throw new Registry.ParchmentError("Cannot insert "+childBlot.statics.blotName+" into "+this.statics.blotName);}childBlot.insertInto(this,refBlot);};ContainerBlot.prototype.length=function(){return this.children.reduce(function(memo,child){return memo+child.length();},0);};ContainerBlot.prototype.moveChildren=function(targetParent,refNode){this.children.forEach(function(child){targetParent.insertBefore(child,refNode);});};ContainerBlot.prototype.optimize=function(context){_super.prototype.optimize.call(this,context);if(this.children.length===0){if(this.statics.defaultChild!=null){var child=Registry.create(this.statics.defaultChild);this.appendChild(child);child.optimize(context);}else{this.remove();}}};ContainerBlot.prototype.path=function(index,inclusive){if(inclusive===void 0){inclusive=false;}var _a=this.children.find(index,inclusive),child=_a[0],offset=_a[1];var position=[[this,index]];if(child instanceof ContainerBlot){return position.concat(child.path(offset,inclusive));}else if(child!=null){position.push([child,offset]);}return position;};ContainerBlot.prototype.removeChild=function(child){this.children.remove(child);};ContainerBlot.prototype.replace=function(target){if(target instanceof ContainerBlot){target.moveChildren(this);}_super.prototype.replace.call(this,target);};ContainerBlot.prototype.split=function(index,force){if(force===void 0){force=false;}if(!force){if(index===0)return this;if(index===this.length())return this.next;}var after=this.clone();this.parent.insertBefore(after,this.next);this.children.forEachAt(index,this.length(),function(child,offset,length){child=child.split(offset,force);after.appendChild(child);});return after;};ContainerBlot.prototype.unwrap=function(){this.moveChildren(this.parent,this.next);this.remove();};ContainerBlot.prototype.update=function(mutations,context){var _this=this;var addedNodes=[],removedNodes=[];mutations.forEach(function(mutation){if(mutation.target===_this.domNode&&mutation.type==='childList'){addedNodes.push.apply(addedNodes,mutation.addedNodes);removedNodes.push.apply(removedNodes,mutation.removedNodes);}});removedNodes.forEach(function(node){if(node.parentNode!=null&&node.tagName!=='IFRAME'&&document.body.compareDocumentPosition(node)&Node.DOCUMENT_POSITION_CONTAINED_BY){return;}var blot=Registry.find(node);if(blot==null)return;if(blot.domNode.parentNode==null||blot.domNode.parentNode===_this.domNode){blot.detach();}});addedNodes.filter(function(node){return node.parentNode==_this.domNode;}).sort(function(a,b){if(a===b)return 0;if(a.compareDocumentPosition(b)&Node.DOCUMENT_POSITION_FOLLOWING){return 1;}return -1;}).forEach(function(node){var refBlot=null;if(node.nextSibling!=null){refBlot=Registry.find(node.nextSibling);}var blot=makeBlot(node);if(blot.next!=refBlot||blot.next==null){if(blot.parent!=null){blot.parent.removeChild(_this);}_this.insertBefore(blot,refBlot);}});};return ContainerBlot;}(shadow_1.default);function makeBlot(node){var blot=Registry.find(node);if(blot==null){try{blot=Registry.create(node);}catch(e){blot=Registry.create(Registry.Scope.INLINE);[].slice.call(node.childNodes).forEach(function(child){blot.domNode.appendChild(child);});node.parentNode.replaceChild(blot.domNode,node);blot.attach();}}return blot;}exports.default=ContainerBlot;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var attributor_1=__webpack_require__(12);var store_1=__webpack_require__(31);var container_1=__webpack_require__(17);var Registry=__webpack_require__(1);var FormatBlot=function(_super){__extends(FormatBlot,_super);function FormatBlot(domNode){var _this=_super.call(this,domNode)||this;_this.attributes=new store_1.default(_this.domNode);return _this;}FormatBlot.formats=function(domNode){if(typeof this.tagName==='string'){return true;}else if(Array.isArray(this.tagName)){return domNode.tagName.toLowerCase();}return undefined;};FormatBlot.prototype.format=function(name,value){var format=Registry.query(name);if(format instanceof attributor_1.default){this.attributes.attribute(format,value);}else if(value){if(format!=null&&(name!==this.statics.blotName||this.formats()[name]!==value)){this.replaceWith(name,value);}}};FormatBlot.prototype.formats=function(){var formats=this.attributes.values();var format=this.statics.formats(this.domNode);if(format!=null){formats[this.statics.blotName]=format;}return formats;};FormatBlot.prototype.replaceWith=function(name,value){var replacement=_super.prototype.replaceWith.call(this,name,value);this.attributes.copy(replacement);return replacement;};FormatBlot.prototype.update=function(mutations,context){var _this=this;_super.prototype.update.call(this,mutations,context);if(mutations.some(function(mutation){return mutation.target===_this.domNode&&mutation.type==='attributes';})){this.attributes.build();}};FormatBlot.prototype.wrap=function(name,value){var wrapper=_super.prototype.wrap.call(this,name,value);if(wrapper instanceof FormatBlot&&wrapper.statics.scope===this.statics.scope){this.attributes.move(wrapper);}return wrapper;};return FormatBlot;}(container_1.default);exports.default=FormatBlot;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var shadow_1=__webpack_require__(30);var Registry=__webpack_require__(1);var LeafBlot=function(_super){__extends(LeafBlot,_super);function LeafBlot(){return _super!==null&&_super.apply(this,arguments)||this;}LeafBlot.value=function(domNode){return true;};LeafBlot.prototype.index=function(node,offset){if(this.domNode===node||this.domNode.compareDocumentPosition(node)&Node.DOCUMENT_POSITION_CONTAINED_BY){return Math.min(offset,1);}return -1;};LeafBlot.prototype.position=function(index,inclusive){var offset=[].indexOf.call(this.parent.domNode.childNodes,this.domNode);if(index>0)offset+=1;return [this.parent.domNode,offset];};LeafBlot.prototype.value=function(){return _a={},_a[this.statics.blotName]=this.statics.value(this.domNode)||true,_a;var _a;};LeafBlot.scope=Registry.Scope.INLINE_BLOT;return LeafBlot;}(shadow_1.default);exports.default=LeafBlot;},function(module,exports,__webpack_require__){var equal=__webpack_require__(11);var extend=__webpack_require__(3);var lib={attributes:{compose:function(a,b,keepNull){if(typeof a!=='object')a={};if(typeof b!=='object')b={};var attributes=extend(true,{},b);if(!keepNull){attributes=Object.keys(attributes).reduce(function(copy,key){if(attributes[key]!=null){copy[key]=attributes[key];}return copy;},{});}for(var key in a){if(a[key]!==undefined&&b[key]===undefined){attributes[key]=a[key];}}return Object.keys(attributes).length>0?attributes:undefined;},diff:function(a,b){if(typeof a!=='object')a={};if(typeof b!=='object')b={};var attributes=Object.keys(a).concat(Object.keys(b)).reduce(function(attributes,key){if(!equal(a[key],b[key])){attributes[key]=b[key]===undefined?null:b[key];}return attributes;},{});return Object.keys(attributes).length>0?attributes:undefined;},transform:function(a,b,priority){if(typeof a!=='object')return b;if(typeof b!=='object')return undefined;if(!priority)return b;var attributes=Object.keys(b).reduce(function(attributes,key){if(a[key]===undefined)attributes[key]=b[key];return attributes;},{});return Object.keys(attributes).length>0?attributes:undefined;}},iterator:function(ops){return new Iterator(ops);},length:function(op){if(typeof op['delete']==='number'){return op['delete'];}else if(typeof op.retain==='number'){return op.retain;}else{return typeof op.insert==='string'?op.insert.length:1;}}};function Iterator(ops){this.ops=ops;this.index=0;this.offset=0;}Iterator.prototype.hasNext=function(){return this.peekLength()<Infinity;};Iterator.prototype.next=function(length){if(!length)length=Infinity;var nextOp=this.ops[this.index];if(nextOp){var offset=this.offset;var opLength=lib.length(nextOp);if(length>=opLength-offset){length=opLength-offset;this.index+=1;this.offset=0;}else{this.offset+=length;}if(typeof nextOp['delete']==='number'){return {'delete':length};}else{var retOp={};if(nextOp.attributes){retOp.attributes=nextOp.attributes;}if(typeof nextOp.retain==='number'){retOp.retain=length;}else if(typeof nextOp.insert==='string'){retOp.insert=nextOp.insert.substr(offset,length);}else{retOp.insert=nextOp.insert;}return retOp;}}else{return {retain:Infinity};}};Iterator.prototype.peek=function(){return this.ops[this.index];};Iterator.prototype.peekLength=function(){if(this.ops[this.index]){return lib.length(this.ops[this.index])-this.offset;}else{return Infinity;}};Iterator.prototype.peekType=function(){if(this.ops[this.index]){if(typeof this.ops[this.index]['delete']==='number'){return 'delete';}else if(typeof this.ops[this.index].retain==='number'){return 'retain';}else{return 'insert';}}return 'retain';};module.exports=lib;},function(module,exports){var clone=function(){function _instanceof(obj,type){return type!=null&&obj instanceof type;}var nativeMap;try{nativeMap=Map;}catch(_){nativeMap=function(){};}var nativeSet;try{nativeSet=Set;}catch(_){nativeSet=function(){};}var nativePromise;try{nativePromise=Promise;}catch(_){nativePromise=function(){};}function clone(parent,circular,depth,prototype,includeNonEnumerable){if(typeof circular==='object'){depth=circular.depth;prototype=circular.prototype;includeNonEnumerable=circular.includeNonEnumerable;circular=circular.circular;}var allParents=[];var allChildren=[];var useBuffer=typeof Buffer!='undefined';if(typeof circular=='undefined')circular=true;if(typeof depth=='undefined')depth=Infinity;function _clone(parent,depth){if(parent===null)return null;if(depth===0)return parent;var child;var proto;if(typeof parent!='object'){return parent;}if(_instanceof(parent,nativeMap)){child=new nativeMap();}else if(_instanceof(parent,nativeSet)){child=new nativeSet();}else if(_instanceof(parent,nativePromise)){child=new nativePromise(function(resolve,reject){parent.then(function(value){resolve(_clone(value,depth-1));},function(err){reject(_clone(err,depth-1));});});}else if(clone.__isArray(parent)){child=[];}else if(clone.__isRegExp(parent)){child=new RegExp(parent.source,__getRegExpFlags(parent));if(parent.lastIndex)child.lastIndex=parent.lastIndex;}else if(clone.__isDate(parent)){child=new Date(parent.getTime());}else if(useBuffer&&Buffer.isBuffer(parent)){child=new Buffer(parent.length);parent.copy(child);return child;}else if(_instanceof(parent,Error)){child=Object.create(parent);}else{if(typeof prototype=='undefined'){proto=Object.getPrototypeOf(parent);child=Object.create(proto);}else{child=Object.create(prototype);proto=prototype;}}if(circular){var index=allParents.indexOf(parent);if(index!=-1){return allChildren[index];}allParents.push(parent);allChildren.push(child);}if(_instanceof(parent,nativeMap)){parent.forEach(function(value,key){var keyChild=_clone(key,depth-1);var valueChild=_clone(value,depth-1);child.set(keyChild,valueChild);});}if(_instanceof(parent,nativeSet)){parent.forEach(function(value){var entryChild=_clone(value,depth-1);child.add(entryChild);});}for(var i in parent){var attrs;if(proto){attrs=Object.getOwnPropertyDescriptor(proto,i);}if(attrs&&attrs.set==null){continue;}child[i]=_clone(parent[i],depth-1);}if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(parent);for(var i=0;i<symbols.length;i++){var symbol=symbols[i];var descriptor=Object.getOwnPropertyDescriptor(parent,symbol);if(descriptor&&!descriptor.enumerable&&!includeNonEnumerable){continue;}child[symbol]=_clone(parent[symbol],depth-1);if(!descriptor.enumerable){Object.defineProperty(child,symbol,{enumerable:false});}}}if(includeNonEnumerable){var allPropertyNames=Object.getOwnPropertyNames(parent);for(var i=0;i<allPropertyNames.length;i++){var propertyName=allPropertyNames[i];var descriptor=Object.getOwnPropertyDescriptor(parent,propertyName);if(descriptor&&descriptor.enumerable){continue;}child[propertyName]=_clone(parent[propertyName],depth-1);Object.defineProperty(child,propertyName,{enumerable:false});}}return child;}return _clone(parent,depth);}clone.clonePrototype=function clonePrototype(parent){if(parent===null)return null;var c=function(){};c.prototype=parent;return new c();};function __objToStr(o){return Object.prototype.toString.call(o);}clone.__objToStr=__objToStr;function __isDate(o){return typeof o==='object'&&__objToStr(o)==='[object Date]';}clone.__isDate=__isDate;function __isArray(o){return typeof o==='object'&&__objToStr(o)==='[object Array]';}clone.__isArray=__isArray;function __isRegExp(o){return typeof o==='object'&&__objToStr(o)==='[object RegExp]';}clone.__isRegExp=__isRegExp;function __getRegExpFlags(re){var flags='';if(re.global)flags+='g';if(re.ignoreCase)flags+='i';if(re.multiline)flags+='m';return flags;}clone.__getRegExpFlags=__getRegExpFlags;return clone;}();if(typeof module==='object'&&module.exports){module.exports=clone;}},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _emitter=__webpack_require__(8);var _emitter2=_interopRequireDefault(_emitter);var _block=__webpack_require__(4);var _block2=_interopRequireDefault(_block);var _break=__webpack_require__(16);var _break2=_interopRequireDefault(_break);var _code=__webpack_require__(13);var _code2=_interopRequireDefault(_code);var _container=__webpack_require__(24);var _container2=_interopRequireDefault(_container);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}function isLine(blot){return blot instanceof _block2.default||blot instanceof _block.BlockEmbed;}var Scroll=function(_Parchment$Scroll){_inherits(Scroll,_Parchment$Scroll);function Scroll(domNode,config){_classCallCheck(this,Scroll);var _this=_possibleConstructorReturn(this,(Scroll.__proto__||Object.getPrototypeOf(Scroll)).call(this,domNode));_this.emitter=config.emitter;_this.IMEMode=false;if(Array.isArray(config.whitelist)){_this.whitelist=config.whitelist.reduce(function(whitelist,format){whitelist[format]=true;return whitelist;},{});}_this.domNode.addEventListener('compositionstart',function(){if(!_this.IMEMode){_this.domNode.addEventListener('DOMNodeInserted',function(){});_this.IMEMode=true;}});_this.optimize();_this.enable();return _this;}_createClass(Scroll,[{key:'batchStart',value:function batchStart(){this.batch=true;}},{key:'batchEnd',value:function batchEnd(){this.batch=false;this.optimize();}},{key:'deleteAt',value:function deleteAt(index,length){var _line=this.line(index),_line2=_slicedToArray(_line,2),first=_line2[0],offset=_line2[1];var _line3=this.line(index+length),_line4=_slicedToArray(_line3,1),last=_line4[0];_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),'deleteAt',this).call(this,index,length);if(last!=null&&first!==last&&offset>0){if(first instanceof _block.BlockEmbed||last instanceof _block.BlockEmbed){this.optimize();return;}if(first instanceof _code2.default){var newlineIndex=first.newlineIndex(first.length(),true);if(newlineIndex>-1){first=first.split(newlineIndex+1);if(first===last){this.optimize();return;}}}else if(last instanceof _code2.default){var _newlineIndex=last.newlineIndex(0);if(_newlineIndex>-1){last.split(_newlineIndex+1);}}var ref=last.children.head instanceof _break2.default?null:last.children.head;first.moveChildren(last,ref);first.remove();}this.optimize();}},{key:'enable',value:function enable(){var enabled=arguments.length>0&&arguments[0]!==undefined?arguments[0]:true;this.domNode.setAttribute('contenteditable',enabled);}},{key:'formatAt',value:function formatAt(index,length,format,value){if(this.whitelist!=null&&!this.whitelist[format])return;_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),'formatAt',this).call(this,index,length,format,value);this.optimize();}},{key:'insertAt',value:function insertAt(index,value,def){if(def!=null&&this.whitelist!=null&&!this.whitelist[value])return;if(index>=this.length()){if(def==null||_parchment2.default.query(value,_parchment2.default.Scope.BLOCK)==null){var blot=_parchment2.default.create(this.statics.defaultChild);this.appendChild(blot);if(def==null&&value.endsWith('\n')){value=value.slice(0,-1);}blot.insertAt(0,value,def);}else{var embed=_parchment2.default.create(value,def);this.appendChild(embed);}}else{_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),'insertAt',this).call(this,index,value,def);}this.optimize();}},{key:'insertBefore',value:function insertBefore(blot,ref){if(blot.statics.scope===_parchment2.default.Scope.INLINE_BLOT){var wrapper=_parchment2.default.create(this.statics.defaultChild);wrapper.appendChild(blot);blot=wrapper;}_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),'insertBefore',this).call(this,blot,ref);}},{key:'leaf',value:function leaf(index){return this.path(index).pop()||[null,-1];}},{key:'line',value:function line(index){if(index===this.length()){return this.line(index-1);}return this.descendant(isLine,index);}},{key:'lines',value:function lines(){var index=arguments.length>0&&arguments[0]!==undefined?arguments[0]:0;var length=arguments.length>1&&arguments[1]!==undefined?arguments[1]:Number.MAX_VALUE;var getLines=function getLines(blot,index,length){var lines=[],lengthLeft=length;blot.children.forEachAt(index,length,function(child,index,length){if(isLine(child)){lines.push(child);}else if(child instanceof _parchment2.default.Container){lines=lines.concat(getLines(child,index,lengthLeft));}lengthLeft-=length;});return lines;};return getLines(this,index,length);}},{key:'optimize',value:function optimize(){var mutations=arguments.length>0&&arguments[0]!==undefined?arguments[0]:[];var context=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};if(this.batch===true)return;_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),'optimize',this).call(this,mutations,context);if(mutations.length>0){this.emitter.emit(_emitter2.default.events.SCROLL_OPTIMIZE,mutations,context);}}},{key:'path',value:function path(index){return _get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),'path',this).call(this,index).slice(1);}},{key:'update',value:function update(mutations){if(this.batch===true)return;var source=_emitter2.default.sources.USER;if(typeof mutations==='string'){source=mutations;}if(!Array.isArray(mutations)){mutations=this.observer.takeRecords();}if(mutations.length>0){this.emitter.emit(_emitter2.default.events.SCROLL_BEFORE_UPDATE,source,mutations);}_get(Scroll.prototype.__proto__||Object.getPrototypeOf(Scroll.prototype),'update',this).call(this,mutations.concat([]));if(mutations.length>0){this.emitter.emit(_emitter2.default.events.SCROLL_UPDATE,source,mutations);}}}]);return Scroll;}(_parchment2.default.Scroll);Scroll.blotName='scroll';Scroll.className='ql-editor';Scroll.tagName='DIV';Scroll.defaultChild='block';Scroll.allowedChildren=[_block2.default,_block.BlockEmbed,_container2.default];exports.default=Scroll;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _text=__webpack_require__(7);var _text2=_interopRequireDefault(_text);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Cursor=function(_Parchment$Embed){_inherits(Cursor,_Parchment$Embed);_createClass(Cursor,null,[{key:'value',value:function value(){return undefined;}}]);function Cursor(domNode,selection){_classCallCheck(this,Cursor);var _this=_possibleConstructorReturn(this,(Cursor.__proto__||Object.getPrototypeOf(Cursor)).call(this,domNode));_this.selection=selection;_this.textNode=document.createTextNode(Cursor.CONTENTS);_this.domNode.appendChild(_this.textNode);_this._length=0;return _this;}_createClass(Cursor,[{key:'detach',value:function detach(){if(this.parent!=null)this.parent.removeChild(this);}},{key:'format',value:function format(name,value){if(this._length!==0){return _get(Cursor.prototype.__proto__||Object.getPrototypeOf(Cursor.prototype),'format',this).call(this,name,value);}var target=this,index=0;while(target!=null&&target.statics.scope!==_parchment2.default.Scope.BLOCK_BLOT){index+=target.offset(target.parent);target=target.parent;}if(target!=null){this._length=Cursor.CONTENTS.length;target.optimize();target.formatAt(index,Cursor.CONTENTS.length,name,value);this._length=0;}}},{key:'index',value:function index(node,offset){if(node===this.textNode)return 0;return _get(Cursor.prototype.__proto__||Object.getPrototypeOf(Cursor.prototype),'index',this).call(this,node,offset);}},{key:'length',value:function length(){return this._length;}},{key:'position',value:function position(){return [this.textNode,this.textNode.data.length];}},{key:'remove',value:function remove(){_get(Cursor.prototype.__proto__||Object.getPrototypeOf(Cursor.prototype),'remove',this).call(this);this.parent=null;}},{key:'restore',value:function restore(){if(this.selection.composing||this.parent==null)return;var textNode=this.textNode;var range=this.selection.getNativeRange();var restoreText=void 0,start=void 0,end=void 0;if(range!=null&&range.start.node===textNode&&range.end.node===textNode){var _ref=[textNode,range.start.offset,range.end.offset];restoreText=_ref[0];start=_ref[1];end=_ref[2];}while(this.domNode.lastChild!=null&&this.domNode.lastChild!==this.textNode){this.domNode.parentNode.insertBefore(this.domNode.lastChild,this.domNode);}if(this.textNode.data!==Cursor.CONTENTS){var text=this.textNode.data.split(Cursor.CONTENTS).join('');if(this.next instanceof _text2.default){restoreText=this.next.domNode;this.next.insertAt(0,text);this.textNode.data=Cursor.CONTENTS;}else{this.textNode.data=text;this.parent.insertBefore(_parchment2.default.create(this.textNode),this);this.textNode=document.createTextNode(Cursor.CONTENTS);this.domNode.appendChild(this.textNode);}}this.remove();if(start!=null){var _map=[start,end].map(function(offset){return Math.max(0,Math.min(restoreText.data.length,offset-1));});var _map2=_slicedToArray(_map,2);start=_map2[0];end=_map2[1];return {startNode:restoreText,startOffset:start,endNode:restoreText,endOffset:end};}}},{key:'update',value:function update(mutations,context){var _this2=this;if(mutations.some(function(mutation){return mutation.type==='characterData'&&mutation.target===_this2.textNode;})){var range=this.restore();if(range)context.range=range;}}},{key:'value',value:function value(){return '';}}]);return Cursor;}(_parchment2.default.Embed);Cursor.blotName='cursor';Cursor.className='ql-cursor';Cursor.tagName='span';Cursor.CONTENTS='\uFEFF';exports.default=Cursor;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _block=__webpack_require__(4);var _block2=_interopRequireDefault(_block);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Container=function(_Parchment$Container){_inherits(Container,_Parchment$Container);function Container(){_classCallCheck(this,Container);return _possibleConstructorReturn(this,(Container.__proto__||Object.getPrototypeOf(Container)).apply(this,arguments));}return Container;}(_parchment2.default.Container);Container.allowedChildren=[_block2.default,_block.BlockEmbed,Container];exports.default=Container;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _text=__webpack_require__(7);var _text2=_interopRequireDefault(_text);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var GUARD_TEXT='\uFEFF';var Embed=function(_Parchment$Embed){_inherits(Embed,_Parchment$Embed);function Embed(node){_classCallCheck(this,Embed);var _this=_possibleConstructorReturn(this,(Embed.__proto__||Object.getPrototypeOf(Embed)).call(this,node));_this.contentNode=document.createElement('span');_this.contentNode.setAttribute('contenteditable',false);[].slice.call(_this.domNode.childNodes).forEach(function(childNode){_this.contentNode.appendChild(childNode);});_this.leftGuard=document.createTextNode(GUARD_TEXT);_this.rightGuard=document.createTextNode(GUARD_TEXT);_this.domNode.appendChild(_this.leftGuard);_this.domNode.appendChild(_this.contentNode);_this.domNode.appendChild(_this.rightGuard);return _this;}_createClass(Embed,[{key:'index',value:function index(node,offset){if(node===this.leftGuard)return 0;if(node===this.rightGuard)return 1;return _get(Embed.prototype.__proto__||Object.getPrototypeOf(Embed.prototype),'index',this).call(this,node,offset);}},{key:'restore',value:function restore(node){var range=void 0,textNode=void 0;var text=node.data.split(GUARD_TEXT).join('');if(node===this.leftGuard){if(this.prev instanceof _text2.default){var prevLength=this.prev.length();this.prev.insertAt(prevLength,text);range={startNode:this.prev.domNode,startOffset:prevLength+text.length};}else{textNode=document.createTextNode(text);this.parent.insertBefore(_parchment2.default.create(textNode),this);range={startNode:textNode,startOffset:text.length};}}else if(node===this.rightGuard){if(this.next instanceof _text2.default){this.next.insertAt(0,text);range={startNode:this.next.domNode,startOffset:text.length};}else{textNode=document.createTextNode(text);this.parent.insertBefore(_parchment2.default.create(textNode),this.next);range={startNode:textNode,startOffset:text.length};}}node.data=GUARD_TEXT;return range;}},{key:'update',value:function update(mutations,context){var _this2=this;mutations.forEach(function(mutation){if(mutation.type==='characterData'&&(mutation.target===_this2.leftGuard||mutation.target===_this2.rightGuard)){var range=_this2.restore(mutation.target);if(range)context.range=range;}});}}]);return Embed;}(_parchment2.default.Embed);exports.default=Embed;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.ColorStyle=exports.ColorClass=exports.ColorAttributor=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var ColorAttributor=function(_Parchment$Attributor){_inherits(ColorAttributor,_Parchment$Attributor);function ColorAttributor(){_classCallCheck(this,ColorAttributor);return _possibleConstructorReturn(this,(ColorAttributor.__proto__||Object.getPrototypeOf(ColorAttributor)).apply(this,arguments));}_createClass(ColorAttributor,[{key:'value',value:function value(domNode){var value=_get(ColorAttributor.prototype.__proto__||Object.getPrototypeOf(ColorAttributor.prototype),'value',this).call(this,domNode);if(!value.startsWith('rgb('))return value;value=value.replace(/^[^\d]+/,'').replace(/[^\d]+$/,'');return '#'+value.split(',').map(function(component){return ('00'+parseInt(component).toString(16)).slice(-2);}).join('');}}]);return ColorAttributor;}(_parchment2.default.Attributor.Style);var ColorClass=new _parchment2.default.Attributor.Class('color','ql-color',{scope:_parchment2.default.Scope.INLINE});var ColorStyle=new ColorAttributor('color','color',{scope:_parchment2.default.Scope.INLINE});exports.ColorAttributor=ColorAttributor;exports.ColorClass=ColorClass;exports.ColorStyle=ColorStyle;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.sanitize=exports.default=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _inline=__webpack_require__(6);var _inline2=_interopRequireDefault(_inline);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Link=function(_Inline){_inherits(Link,_Inline);function Link(){_classCallCheck(this,Link);return _possibleConstructorReturn(this,(Link.__proto__||Object.getPrototypeOf(Link)).apply(this,arguments));}_createClass(Link,[{key:'format',value:function format(name,value){if(name!==this.statics.blotName||!value)return _get(Link.prototype.__proto__||Object.getPrototypeOf(Link.prototype),'format',this).call(this,name,value);value=this.constructor.sanitize(value);this.domNode.setAttribute('href',value);}}],[{key:'create',value:function create(value){var node=_get(Link.__proto__||Object.getPrototypeOf(Link),'create',this).call(this,value);value=this.sanitize(value);node.setAttribute('href',value);node.setAttribute('target','_blank');return node;}},{key:'formats',value:function formats(domNode){return domNode.getAttribute('href');}},{key:'sanitize',value:function sanitize(url){return _sanitize(url,this.PROTOCOL_WHITELIST)?url:this.SANITIZED_URL;}}]);return Link;}(_inline2.default);Link.blotName='link';Link.tagName='A';Link.SANITIZED_URL='about:blank';Link.PROTOCOL_WHITELIST=['http','https','mailto','tel'];function _sanitize(url,protocols){var anchor=document.createElement('a');anchor.href=url;var protocol=anchor.href.slice(0,anchor.href.indexOf(':'));return protocols.indexOf(protocol)>-1;}exports.default=Link;exports.sanitize=_sanitize;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _dropdown=__webpack_require__(107);var _dropdown2=_interopRequireDefault(_dropdown);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Picker=function(){function Picker(select){var _this=this;_classCallCheck(this,Picker);this.select=select;this.container=document.createElement('span');this.buildPicker();this.select.style.display='none';this.select.parentNode.insertBefore(this.container,this.select);this.label.addEventListener('mousedown',function(){_this.container.classList.toggle('ql-expanded');});this.select.addEventListener('change',this.update.bind(this));}_createClass(Picker,[{key:'buildItem',value:function buildItem(option){var _this2=this;var item=document.createElement('span');item.classList.add('ql-picker-item');if(option.hasAttribute('value')){item.setAttribute('data-value',option.getAttribute('value'));}if(option.textContent){item.setAttribute('data-label',option.textContent);}item.addEventListener('click',function(){_this2.selectItem(item,true);});return item;}},{key:'buildLabel',value:function buildLabel(){var label=document.createElement('span');label.classList.add('ql-picker-label');label.innerHTML=_dropdown2.default;this.container.appendChild(label);return label;}},{key:'buildOptions',value:function buildOptions(){var _this3=this;var options=document.createElement('span');options.classList.add('ql-picker-options');[].slice.call(this.select.options).forEach(function(option){var item=_this3.buildItem(option);options.appendChild(item);if(option.selected===true){_this3.selectItem(item);}});this.container.appendChild(options);}},{key:'buildPicker',value:function buildPicker(){var _this4=this;[].slice.call(this.select.attributes).forEach(function(item){_this4.container.setAttribute(item.name,item.value);});this.container.classList.add('ql-picker');this.label=this.buildLabel();this.buildOptions();}},{key:'close',value:function close(){this.container.classList.remove('ql-expanded');}},{key:'selectItem',value:function selectItem(item){var trigger=arguments.length>1&&arguments[1]!==undefined?arguments[1]:false;var selected=this.container.querySelector('.ql-selected');if(item===selected)return;if(selected!=null){selected.classList.remove('ql-selected');}if(item==null)return;item.classList.add('ql-selected');this.select.selectedIndex=[].indexOf.call(item.parentNode.children,item);if(item.hasAttribute('data-value')){this.label.setAttribute('data-value',item.getAttribute('data-value'));}else{this.label.removeAttribute('data-value');}if(item.hasAttribute('data-label')){this.label.setAttribute('data-label',item.getAttribute('data-label'));}else{this.label.removeAttribute('data-label');}if(trigger){if(typeof Event==='function'){this.select.dispatchEvent(new Event('change'));}else if((typeof Event==='undefined'?'undefined':_typeof(Event))==='object'){var event=document.createEvent('Event');event.initEvent('change',true,true);this.select.dispatchEvent(event);}this.close();}}},{key:'update',value:function update(){var option=void 0;if(this.select.selectedIndex>-1){var item=this.container.querySelector('.ql-picker-options').children[this.select.selectedIndex];option=this.select.options[this.select.selectedIndex];this.selectItem(item);}else{this.selectItem(null);}var isActive=option!=null&&option!==this.select.querySelector('option[selected]');this.label.classList.toggle('ql-active',isActive);}}]);return Picker;}();exports.default=Picker;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _quill=__webpack_require__(5);var _quill2=_interopRequireDefault(_quill);var _block=__webpack_require__(4);var _block2=_interopRequireDefault(_block);var _break=__webpack_require__(16);var _break2=_interopRequireDefault(_break);var _container=__webpack_require__(24);var _container2=_interopRequireDefault(_container);var _cursor=__webpack_require__(23);var _cursor2=_interopRequireDefault(_cursor);var _embed=__webpack_require__(25);var _embed2=_interopRequireDefault(_embed);var _inline=__webpack_require__(6);var _inline2=_interopRequireDefault(_inline);var _scroll=__webpack_require__(22);var _scroll2=_interopRequireDefault(_scroll);var _text=__webpack_require__(7);var _text2=_interopRequireDefault(_text);var _clipboard=__webpack_require__(55);var _clipboard2=_interopRequireDefault(_clipboard);var _history=__webpack_require__(42);var _history2=_interopRequireDefault(_history);var _keyboard=__webpack_require__(35);var _keyboard2=_interopRequireDefault(_keyboard);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}_quill2.default.register({'blots/block':_block2.default,'blots/block/embed':_block.BlockEmbed,'blots/break':_break2.default,'blots/container':_container2.default,'blots/cursor':_cursor2.default,'blots/embed':_embed2.default,'blots/inline':_inline2.default,'blots/scroll':_scroll2.default,'blots/text':_text2.default,'modules/clipboard':_clipboard2.default,'modules/history':_history2.default,'modules/keyboard':_keyboard2.default});_parchment2.default.register(_block2.default,_break2.default,_cursor2.default,_inline2.default,_scroll2.default,_text2.default);exports.default=_quill2.default;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var Registry=__webpack_require__(1);var ShadowBlot=function(){function ShadowBlot(domNode){this.domNode=domNode;this.domNode[Registry.DATA_KEY]={blot:this};}Object.defineProperty(ShadowBlot.prototype,"statics",{get:function(){return this.constructor;},enumerable:true,configurable:true});ShadowBlot.create=function(value){if(this.tagName==null){throw new Registry.ParchmentError('Blot definition missing tagName');}var node;if(Array.isArray(this.tagName)){if(typeof value==='string'){value=value.toUpperCase();if(parseInt(value).toString()===value){value=parseInt(value);}}if(typeof value==='number'){node=document.createElement(this.tagName[value-1]);}else if(this.tagName.indexOf(value)>-1){node=document.createElement(value);}else{node=document.createElement(this.tagName[0]);}}else{node=document.createElement(this.tagName);}if(this.className){node.classList.add(this.className);}return node;};ShadowBlot.prototype.attach=function(){if(this.parent!=null){this.scroll=this.parent.scroll;}};ShadowBlot.prototype.clone=function(){var domNode=this.domNode.cloneNode(false);return Registry.create(domNode);};ShadowBlot.prototype.detach=function(){if(this.parent!=null)this.parent.removeChild(this);delete this.domNode[Registry.DATA_KEY];};ShadowBlot.prototype.deleteAt=function(index,length){var blot=this.isolate(index,length);blot.remove();};ShadowBlot.prototype.formatAt=function(index,length,name,value){var blot=this.isolate(index,length);if(Registry.query(name,Registry.Scope.BLOT)!=null&&value){blot.wrap(name,value);}else if(Registry.query(name,Registry.Scope.ATTRIBUTE)!=null){var parent=Registry.create(this.statics.scope);blot.wrap(parent);parent.format(name,value);}};ShadowBlot.prototype.insertAt=function(index,value,def){var blot=def==null?Registry.create('text',value):Registry.create(value,def);var ref=this.split(index);this.parent.insertBefore(blot,ref);};ShadowBlot.prototype.insertInto=function(parentBlot,refBlot){if(this.parent!=null){this.parent.children.remove(this);}parentBlot.children.insertBefore(this,refBlot);if(refBlot!=null){var refDomNode=refBlot.domNode;}if(this.next==null||this.domNode.nextSibling!=refDomNode){parentBlot.domNode.insertBefore(this.domNode,typeof refDomNode!=='undefined'?refDomNode:null);}this.parent=parentBlot;this.attach();};ShadowBlot.prototype.isolate=function(index,length){var target=this.split(index);target.split(length);return target;};ShadowBlot.prototype.length=function(){return 1;};ShadowBlot.prototype.offset=function(root){if(root===void 0){root=this.parent;}if(this.parent==null||this==root)return 0;return this.parent.children.offset(this)+this.parent.offset(root);};ShadowBlot.prototype.optimize=function(context){if(this.domNode[Registry.DATA_KEY]!=null){delete this.domNode[Registry.DATA_KEY].mutations;}};ShadowBlot.prototype.remove=function(){if(this.domNode.parentNode!=null){this.domNode.parentNode.removeChild(this.domNode);}this.detach();};ShadowBlot.prototype.replace=function(target){if(target.parent==null)return;target.parent.insertBefore(this,target.next);target.remove();};ShadowBlot.prototype.replaceWith=function(name,value){var replacement=typeof name==='string'?Registry.create(name,value):name;replacement.replace(this);return replacement;};ShadowBlot.prototype.split=function(index,force){return index===0?this:this.next;};ShadowBlot.prototype.update=function(mutations,context){};ShadowBlot.prototype.wrap=function(name,value){var wrapper=typeof name==='string'?Registry.create(name,value):name;if(this.parent!=null){this.parent.insertBefore(wrapper,this.next);}wrapper.appendChild(this);return wrapper;};ShadowBlot.blotName='abstract';return ShadowBlot;}();exports.default=ShadowBlot;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var attributor_1=__webpack_require__(12);var class_1=__webpack_require__(32);var style_1=__webpack_require__(33);var Registry=__webpack_require__(1);var AttributorStore=function(){function AttributorStore(domNode){this.attributes={};this.domNode=domNode;this.build();}AttributorStore.prototype.attribute=function(attribute,value){if(value){if(attribute.add(this.domNode,value)){if(attribute.value(this.domNode)!=null){this.attributes[attribute.attrName]=attribute;}else{delete this.attributes[attribute.attrName];}}}else{attribute.remove(this.domNode);delete this.attributes[attribute.attrName];}};AttributorStore.prototype.build=function(){var _this=this;this.attributes={};var attributes=attributor_1.default.keys(this.domNode);var classes=class_1.default.keys(this.domNode);var styles=style_1.default.keys(this.domNode);attributes.concat(classes).concat(styles).forEach(function(name){var attr=Registry.query(name,Registry.Scope.ATTRIBUTE);if(attr instanceof attributor_1.default){_this.attributes[attr.attrName]=attr;}});};AttributorStore.prototype.copy=function(target){var _this=this;Object.keys(this.attributes).forEach(function(key){var value=_this.attributes[key].value(_this.domNode);target.format(key,value);});};AttributorStore.prototype.move=function(target){var _this=this;this.copy(target);Object.keys(this.attributes).forEach(function(key){_this.attributes[key].remove(_this.domNode);});this.attributes={};};AttributorStore.prototype.values=function(){var _this=this;return Object.keys(this.attributes).reduce(function(attributes,name){attributes[name]=_this.attributes[name].value(_this.domNode);return attributes;},{});};return AttributorStore;}();exports.default=AttributorStore;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var attributor_1=__webpack_require__(12);function match(node,prefix){var className=node.getAttribute('class')||'';return className.split(/\s+/).filter(function(name){return name.indexOf(prefix+"-")===0;});}var ClassAttributor=function(_super){__extends(ClassAttributor,_super);function ClassAttributor(){return _super!==null&&_super.apply(this,arguments)||this;}ClassAttributor.keys=function(node){return (node.getAttribute('class')||'').split(/\s+/).map(function(name){return name.split('-').slice(0,-1).join('-');});};ClassAttributor.prototype.add=function(node,value){if(!this.canAdd(node,value))return false;this.remove(node);node.classList.add(this.keyName+"-"+value);return true;};ClassAttributor.prototype.remove=function(node){var matches=match(node,this.keyName);matches.forEach(function(name){node.classList.remove(name);});if(node.classList.length===0){node.removeAttribute('class');}};ClassAttributor.prototype.value=function(node){var result=match(node,this.keyName)[0]||'';var value=result.slice(this.keyName.length+1);return this.canAdd(node,value)?value:'';};return ClassAttributor;}(attributor_1.default);exports.default=ClassAttributor;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var attributor_1=__webpack_require__(12);function camelize(name){var parts=name.split('-');var rest=parts.slice(1).map(function(part){return part[0].toUpperCase()+part.slice(1);}).join('');return parts[0]+rest;}var StyleAttributor=function(_super){__extends(StyleAttributor,_super);function StyleAttributor(){return _super!==null&&_super.apply(this,arguments)||this;}StyleAttributor.keys=function(node){return (node.getAttribute('style')||'').split(';').map(function(value){var arr=value.split(':');return arr[0].trim();});};StyleAttributor.prototype.add=function(node,value){if(!this.canAdd(node,value))return false;node.style[camelize(this.keyName)]=value;return true;};StyleAttributor.prototype.remove=function(node){node.style[camelize(this.keyName)]='';if(!node.getAttribute('style')){node.removeAttribute('style');}};StyleAttributor.prototype.value=function(node){var value=node.style[camelize(this.keyName)];return this.canAdd(node,value)?value:'';};return StyleAttributor;}(attributor_1.default);exports.default=StyleAttributor;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Theme=function(){function Theme(quill,options){_classCallCheck(this,Theme);this.quill=quill;this.options=options;this.modules={};}_createClass(Theme,[{key:'init',value:function init(){var _this=this;Object.keys(this.options.modules).forEach(function(name){if(_this.modules[name]==null){_this.addModule(name);}});}},{key:'addModule',value:function addModule(name){var moduleClass=this.quill.constructor.import('modules/'+name);this.modules[name]=new moduleClass(this.quill,this.options.modules[name]||{});return this.modules[name];}}]);return Theme;}();Theme.DEFAULTS={modules:{}};Theme.themes={'default':Theme};exports.default=Theme;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.SHORTKEY=exports.default=undefined;var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _clone=__webpack_require__(21);var _clone2=_interopRequireDefault(_clone);var _deepEqual=__webpack_require__(11);var _deepEqual2=_interopRequireDefault(_deepEqual);var _extend=__webpack_require__(3);var _extend2=_interopRequireDefault(_extend);var _quillDelta=__webpack_require__(2);var _quillDelta2=_interopRequireDefault(_quillDelta);var _op=__webpack_require__(20);var _op2=_interopRequireDefault(_op);var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _embed=__webpack_require__(25);var _embed2=_interopRequireDefault(_embed);var _quill=__webpack_require__(5);var _quill2=_interopRequireDefault(_quill);var _logger=__webpack_require__(10);var _logger2=_interopRequireDefault(_logger);var _module=__webpack_require__(9);var _module2=_interopRequireDefault(_module);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var debug=_logger2.default('quill:keyboard');var SHORTKEY=/Mac/i.test(navigator.platform)?'metaKey':'ctrlKey';var Keyboard=function(_Module){_inherits(Keyboard,_Module);_createClass(Keyboard,null,[{key:'match',value:function match(evt,binding){binding=normalize(binding);if(['altKey','ctrlKey','metaKey','shiftKey'].some(function(key){return !!binding[key]!==evt[key]&&binding[key]!==null;})){return false;}return binding.key===(evt.which||evt.keyCode);}}]);function Keyboard(quill,options){_classCallCheck(this,Keyboard);var _this=_possibleConstructorReturn(this,(Keyboard.__proto__||Object.getPrototypeOf(Keyboard)).call(this,quill,options));_this.bindings={};Object.keys(_this.options.bindings).forEach(function(name){if(name==='list autofill'&&quill.scroll.whitelist!=null&&!quill.scroll.whitelist['list']){return;}if(_this.options.bindings[name]){_this.addBinding(_this.options.bindings[name]);}});_this.addBinding({key:Keyboard.keys.ENTER,shiftKey:null},handleEnter);_this.addBinding({key:Keyboard.keys.ENTER,metaKey:null,ctrlKey:null,altKey:null},function(){});if(/Firefox/i.test(navigator.userAgent)){_this.addBinding({key:Keyboard.keys.BACKSPACE},{collapsed:true},handleBackspace);_this.addBinding({key:Keyboard.keys.DELETE},{collapsed:true},handleDelete);}else{_this.addBinding({key:Keyboard.keys.BACKSPACE},{collapsed:true,prefix:/^.?$/},handleBackspace);_this.addBinding({key:Keyboard.keys.DELETE},{collapsed:true,suffix:/^.?$/},handleDelete);}_this.addBinding({key:Keyboard.keys.BACKSPACE},{collapsed:false},handleDeleteRange);_this.addBinding({key:Keyboard.keys.DELETE},{collapsed:false},handleDeleteRange);_this.addBinding({key:Keyboard.keys.BACKSPACE,altKey:null,ctrlKey:null,metaKey:null,shiftKey:null},{collapsed:true,offset:0},handleBackspace);_this.listen();return _this;}_createClass(Keyboard,[{key:'addBinding',value:function addBinding(key){var context=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var handler=arguments.length>2&&arguments[2]!==undefined?arguments[2]:{};var binding=normalize(key);if(binding==null||binding.key==null){return debug.warn('Attempted to add invalid keyboard binding',binding);}if(typeof context==='function'){context={handler:context};}if(typeof handler==='function'){handler={handler:handler};}binding=_extend2.default(binding,context,handler);this.bindings[binding.key]=this.bindings[binding.key]||[];this.bindings[binding.key].push(binding);}},{key:'listen',value:function listen(){var _this2=this;this.quill.root.addEventListener('keydown',function(evt){if(evt.defaultPrevented)return;var which=evt.which||evt.keyCode;var bindings=(_this2.bindings[which]||[]).filter(function(binding){return Keyboard.match(evt,binding);});if(bindings.length===0)return;var range=_this2.quill.getSelection();if(range==null||!_this2.quill.hasFocus())return;var _quill$getLine=_this2.quill.getLine(range.index),_quill$getLine2=_slicedToArray(_quill$getLine,2),line=_quill$getLine2[0],offset=_quill$getLine2[1];var _quill$getLeaf=_this2.quill.getLeaf(range.index),_quill$getLeaf2=_slicedToArray(_quill$getLeaf,2),leafStart=_quill$getLeaf2[0],offsetStart=_quill$getLeaf2[1];var _ref=range.length===0?[leafStart,offsetStart]:_this2.quill.getLeaf(range.index+range.length),_ref2=_slicedToArray(_ref,2),leafEnd=_ref2[0],offsetEnd=_ref2[1];var prefixText=leafStart instanceof _parchment2.default.Text?leafStart.value().slice(0,offsetStart):'';var suffixText=leafEnd instanceof _parchment2.default.Text?leafEnd.value().slice(offsetEnd):'';var curContext={collapsed:range.length===0,empty:range.length===0&&line.length()<=1,format:_this2.quill.getFormat(range),offset:offset,prefix:prefixText,suffix:suffixText};var prevented=bindings.some(function(binding){if(binding.collapsed!=null&&binding.collapsed!==curContext.collapsed)return false;if(binding.empty!=null&&binding.empty!==curContext.empty)return false;if(binding.offset!=null&&binding.offset!==curContext.offset)return false;if(Array.isArray(binding.format)){if(binding.format.every(function(name){return curContext.format[name]==null;})){return false;}}else if(_typeof(binding.format)==='object'){if(!Object.keys(binding.format).every(function(name){if(binding.format[name]===true)return curContext.format[name]!=null;if(binding.format[name]===false)return curContext.format[name]==null;return _deepEqual2.default(binding.format[name],curContext.format[name]);})){return false;}}if(binding.prefix!=null&&!binding.prefix.test(curContext.prefix))return false;if(binding.suffix!=null&&!binding.suffix.test(curContext.suffix))return false;return binding.handler.call(_this2,range,curContext)!==true;});if(prevented){evt.preventDefault();}});}}]);return Keyboard;}(_module2.default);Keyboard.keys={BACKSPACE:8,TAB:9,ENTER:13,ESCAPE:27,LEFT:37,UP:38,RIGHT:39,DOWN:40,DELETE:46};Keyboard.DEFAULTS={bindings:{'bold':makeFormatHandler('bold'),'italic':makeFormatHandler('italic'),'underline':makeFormatHandler('underline'),'indent':{key:Keyboard.keys.TAB,format:['blockquote','indent','list'],handler:function handler(range,context){if(context.collapsed&&context.offset!==0)return true;this.quill.format('indent','+1',_quill2.default.sources.USER);}},'outdent':{key:Keyboard.keys.TAB,shiftKey:true,format:['blockquote','indent','list'],handler:function handler(range,context){if(context.collapsed&&context.offset!==0)return true;this.quill.format('indent','-1',_quill2.default.sources.USER);}},'outdent backspace':{key:Keyboard.keys.BACKSPACE,collapsed:true,shiftKey:null,metaKey:null,ctrlKey:null,altKey:null,format:['indent','list'],offset:0,handler:function handler(range,context){if(context.format.indent!=null){this.quill.format('indent','-1',_quill2.default.sources.USER);}else if(context.format.list!=null){this.quill.format('list',false,_quill2.default.sources.USER);}}},'indent code-block':makeCodeBlockHandler(true),'outdent code-block':makeCodeBlockHandler(false),'remove tab':{key:Keyboard.keys.TAB,shiftKey:true,collapsed:true,prefix:/\t$/,handler:function handler(range){this.quill.deleteText(range.index-1,1,_quill2.default.sources.USER);}},'tab':{key:Keyboard.keys.TAB,handler:function handler(range){this.quill.history.cutoff();var delta=new _quillDelta2.default().retain(range.index).delete(range.length).insert('\t');this.quill.updateContents(delta,_quill2.default.sources.USER);this.quill.history.cutoff();this.quill.setSelection(range.index+1,_quill2.default.sources.SILENT);}},'list empty enter':{key:Keyboard.keys.ENTER,collapsed:true,format:['list'],empty:true,handler:function handler(range,context){this.quill.format('list',false,_quill2.default.sources.USER);if(context.format.indent){this.quill.format('indent',false,_quill2.default.sources.USER);}}},'checklist enter':{key:Keyboard.keys.ENTER,collapsed:true,format:{list:'checked'},handler:function handler(range){var _quill$getLine3=this.quill.getLine(range.index),_quill$getLine4=_slicedToArray(_quill$getLine3,2),line=_quill$getLine4[0],offset=_quill$getLine4[1];var delta=new _quillDelta2.default().retain(range.index).insert('\n',{list:'checked'}).retain(line.length()-offset-1).retain(1,{list:'unchecked'});this.quill.updateContents(delta,_quill2.default.sources.USER);this.quill.setSelection(range.index+1,_quill2.default.sources.SILENT);this.quill.scrollIntoView();}},'header enter':{key:Keyboard.keys.ENTER,collapsed:true,format:['header'],suffix:/^$/,handler:function handler(range,context){var _quill$getLine5=this.quill.getLine(range.index),_quill$getLine6=_slicedToArray(_quill$getLine5,2),line=_quill$getLine6[0],offset=_quill$getLine6[1];var delta=new _quillDelta2.default().retain(range.index).insert('\n',context.format).retain(line.length()-offset-1).retain(1,{header:null});this.quill.updateContents(delta,_quill2.default.sources.USER);this.quill.setSelection(range.index+1,_quill2.default.sources.SILENT);this.quill.scrollIntoView();}},'list autofill':{key:' ',collapsed:true,format:{list:false},prefix:/^\s*?(\d+\.|-|\*|\[ ?\]|\[x\])$/,handler:function handler(range,context){var length=context.prefix.length;var _quill$getLine7=this.quill.getLine(range.index),_quill$getLine8=_slicedToArray(_quill$getLine7,2),line=_quill$getLine8[0],offset=_quill$getLine8[1];if(offset>length)return true;var value=void 0;switch(context.prefix.trim()){case'[]':case'[ ]':value='unchecked';break;case'[x]':value='checked';break;case'-':case'*':value='bullet';break;default:value='ordered';}this.quill.insertText(range.index,' ',_quill2.default.sources.USER);this.quill.history.cutoff();var delta=new _quillDelta2.default().retain(range.index-offset).delete(length+1).retain(line.length()-2-offset).retain(1,{list:value});this.quill.updateContents(delta,_quill2.default.sources.USER);this.quill.history.cutoff();this.quill.setSelection(range.index-length,_quill2.default.sources.SILENT);}},'code exit':{key:Keyboard.keys.ENTER,collapsed:true,format:['code-block'],prefix:/\n\n$/,suffix:/^\s+$/,handler:function handler(range){var _quill$getLine9=this.quill.getLine(range.index),_quill$getLine10=_slicedToArray(_quill$getLine9,2),line=_quill$getLine10[0],offset=_quill$getLine10[1];var delta=new _quillDelta2.default().retain(range.index+line.length()-offset-2).retain(1,{'code-block':null}).delete(1);this.quill.updateContents(delta,_quill2.default.sources.USER);}},'embed left':makeEmbedArrowHandler(Keyboard.keys.LEFT,false),'embed left shift':makeEmbedArrowHandler(Keyboard.keys.LEFT,true),'embed right':makeEmbedArrowHandler(Keyboard.keys.RIGHT,false),'embed right shift':makeEmbedArrowHandler(Keyboard.keys.RIGHT,true)}};function makeEmbedArrowHandler(key,shiftKey){var _ref3;var where=key===Keyboard.keys.LEFT?'prefix':'suffix';return _ref3={key:key,shiftKey:shiftKey},_defineProperty(_ref3,where,/^$/),_defineProperty(_ref3,'handler',function handler(range){var index=range.index;if(key===Keyboard.keys.RIGHT){index+=range.length+1;}var _quill$getLeaf3=this.quill.getLeaf(index),_quill$getLeaf4=_slicedToArray(_quill$getLeaf3,1),leaf=_quill$getLeaf4[0];if(!(leaf instanceof _embed2.default))return true;if(key===Keyboard.keys.LEFT){if(shiftKey){this.quill.setSelection(range.index-1,range.length+1,_quill2.default.sources.USER);}else{this.quill.setSelection(range.index-1,_quill2.default.sources.USER);}}else{if(shiftKey){this.quill.setSelection(range.index,range.length+1,_quill2.default.sources.USER);}else{this.quill.setSelection(range.index+range.length+1,_quill2.default.sources.USER);}}return false;}),_ref3;}function handleBackspace(range,context){if(range.index===0||this.quill.getLength()<=1)return;var _quill$getLine11=this.quill.getLine(range.index),_quill$getLine12=_slicedToArray(_quill$getLine11,1),line=_quill$getLine12[0];var formats={};if(context.offset===0){var _quill$getLine13=this.quill.getLine(range.index-1),_quill$getLine14=_slicedToArray(_quill$getLine13,1),prev=_quill$getLine14[0];if(prev!=null&&prev.length()>1){var curFormats=line.formats();var prevFormats=this.quill.getFormat(range.index-1,1);formats=_op2.default.attributes.diff(curFormats,prevFormats)||{};}}var length=/[\uD800-\uDBFF][\uDC00-\uDFFF]$/.test(context.prefix)?2:1;this.quill.deleteText(range.index-length,length,_quill2.default.sources.USER);if(Object.keys(formats).length>0){this.quill.formatLine(range.index-length,length,formats,_quill2.default.sources.USER);}this.quill.focus();}function handleDelete(range,context){var length=/^[\uD800-\uDBFF][\uDC00-\uDFFF]/.test(context.suffix)?2:1;if(range.index>=this.quill.getLength()-length)return;var formats={},nextLength=0;var _quill$getLine15=this.quill.getLine(range.index),_quill$getLine16=_slicedToArray(_quill$getLine15,1),line=_quill$getLine16[0];if(context.offset>=line.length()-1){var _quill$getLine17=this.quill.getLine(range.index+1),_quill$getLine18=_slicedToArray(_quill$getLine17,1),next=_quill$getLine18[0];if(next){var curFormats=line.formats();var nextFormats=this.quill.getFormat(range.index,1);formats=_op2.default.attributes.diff(curFormats,nextFormats)||{};nextLength=next.length();}}this.quill.deleteText(range.index,length,_quill2.default.sources.USER);if(Object.keys(formats).length>0){this.quill.formatLine(range.index+nextLength-1,length,formats,_quill2.default.sources.USER);}}function handleDeleteRange(range){var lines=this.quill.getLines(range);var formats={};if(lines.length>1){var firstFormats=lines[0].formats();var lastFormats=lines[lines.length-1].formats();formats=_op2.default.attributes.diff(lastFormats,firstFormats)||{};}this.quill.deleteText(range,_quill2.default.sources.USER);if(Object.keys(formats).length>0){this.quill.formatLine(range.index,1,formats,_quill2.default.sources.USER);}this.quill.setSelection(range.index,_quill2.default.sources.SILENT);this.quill.focus();}function handleEnter(range,context){var _this3=this;if(range.length>0){this.quill.scroll.deleteAt(range.index,range.length);}var lineFormats=Object.keys(context.format).reduce(function(lineFormats,format){if(_parchment2.default.query(format,_parchment2.default.Scope.BLOCK)&&!Array.isArray(context.format[format])){lineFormats[format]=context.format[format];}return lineFormats;},{});this.quill.insertText(range.index,'\n',lineFormats,_quill2.default.sources.USER);this.quill.setSelection(range.index+1,_quill2.default.sources.SILENT);this.quill.focus();Object.keys(context.format).forEach(function(name){if(lineFormats[name]!=null)return;if(Array.isArray(context.format[name]))return;if(name==='link')return;_this3.quill.format(name,context.format[name],_quill2.default.sources.USER);});}function makeCodeBlockHandler(indent){return {key:Keyboard.keys.TAB,shiftKey:!indent,format:{'code-block':true},handler:function handler(range){var CodeBlock=_parchment2.default.query('code-block');var index=range.index,length=range.length;var _quill$scroll$descend=this.quill.scroll.descendant(CodeBlock,index),_quill$scroll$descend2=_slicedToArray(_quill$scroll$descend,2),block=_quill$scroll$descend2[0],offset=_quill$scroll$descend2[1];if(block==null)return;var scrollIndex=this.quill.getIndex(block);var start=block.newlineIndex(offset,true)+1;var end=block.newlineIndex(scrollIndex+offset+length);var lines=block.domNode.textContent.slice(start,end).split('\n');offset=0;lines.forEach(function(line,i){if(indent){block.insertAt(start+offset,CodeBlock.TAB);offset+=CodeBlock.TAB.length;if(i===0){index+=CodeBlock.TAB.length;}else{length+=CodeBlock.TAB.length;}}else if(line.startsWith(CodeBlock.TAB)){block.deleteAt(start+offset,CodeBlock.TAB.length);offset-=CodeBlock.TAB.length;if(i===0){index-=CodeBlock.TAB.length;}else{length-=CodeBlock.TAB.length;}}offset+=line.length+1;});this.quill.update(_quill2.default.sources.USER);this.quill.setSelection(index,length,_quill2.default.sources.SILENT);}};}function makeFormatHandler(format){return {key:format[0].toUpperCase(),shortKey:true,handler:function handler(range,context){this.quill.format(format,!context.format[format],_quill2.default.sources.USER);}};}function normalize(binding){if(typeof binding==='string'||typeof binding==='number'){return normalize({key:binding});}if((typeof binding==='undefined'?'undefined':_typeof(binding))==='object'){binding=_clone2.default(binding,false);}if(typeof binding.key==='string'){if(Keyboard.keys[binding.key.toUpperCase()]!=null){binding.key=Keyboard.keys[binding.key.toUpperCase()];}else if(binding.key.length===1){binding.key=binding.key.toUpperCase().charCodeAt(0);}else{return null;}}if(binding.shortKey){binding[SHORTKEY]=binding.shortKey;delete binding.shortKey;}return binding;}exports.default=Keyboard;exports.SHORTKEY=SHORTKEY;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.AlignStyle=exports.AlignClass=exports.AlignAttribute=undefined;var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var config={scope:_parchment2.default.Scope.BLOCK,whitelist:['right','center','justify']};var AlignAttribute=new _parchment2.default.Attributor.Attribute('align','align',config);var AlignClass=new _parchment2.default.Attributor.Class('align','ql-align',config);var AlignStyle=new _parchment2.default.Attributor.Style('align','text-align',config);exports.AlignAttribute=AlignAttribute;exports.AlignClass=AlignClass;exports.AlignStyle=AlignStyle;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.BackgroundStyle=exports.BackgroundClass=undefined;var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _color=__webpack_require__(26);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var BackgroundClass=new _parchment2.default.Attributor.Class('background','ql-bg',{scope:_parchment2.default.Scope.INLINE});var BackgroundStyle=new _color.ColorAttributor('background','background-color',{scope:_parchment2.default.Scope.INLINE});exports.BackgroundClass=BackgroundClass;exports.BackgroundStyle=BackgroundStyle;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.DirectionStyle=exports.DirectionClass=exports.DirectionAttribute=undefined;var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var config={scope:_parchment2.default.Scope.BLOCK,whitelist:['rtl']};var DirectionAttribute=new _parchment2.default.Attributor.Attribute('direction','dir',config);var DirectionClass=new _parchment2.default.Attributor.Class('direction','ql-direction',config);var DirectionStyle=new _parchment2.default.Attributor.Style('direction','direction',config);exports.DirectionAttribute=DirectionAttribute;exports.DirectionClass=DirectionClass;exports.DirectionStyle=DirectionStyle;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.FontClass=exports.FontStyle=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var config={scope:_parchment2.default.Scope.INLINE,whitelist:['serif','monospace']};var FontClass=new _parchment2.default.Attributor.Class('font','ql-font',config);var FontStyleAttributor=function(_Parchment$Attributor){_inherits(FontStyleAttributor,_Parchment$Attributor);function FontStyleAttributor(){_classCallCheck(this,FontStyleAttributor);return _possibleConstructorReturn(this,(FontStyleAttributor.__proto__||Object.getPrototypeOf(FontStyleAttributor)).apply(this,arguments));}_createClass(FontStyleAttributor,[{key:'value',value:function value(node){return _get(FontStyleAttributor.prototype.__proto__||Object.getPrototypeOf(FontStyleAttributor.prototype),'value',this).call(this,node).replace(/["']/g,'');}}]);return FontStyleAttributor;}(_parchment2.default.Attributor.Style);var FontStyle=new FontStyleAttributor('font','font-family',config);exports.FontStyle=FontStyle;exports.FontClass=FontClass;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.SizeStyle=exports.SizeClass=undefined;var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}var SizeClass=new _parchment2.default.Attributor.Class('size','ql-size',{scope:_parchment2.default.Scope.INLINE,whitelist:['small','large','huge']});var SizeStyle=new _parchment2.default.Attributor.Style('size','font-size',{scope:_parchment2.default.Scope.INLINE,whitelist:['10px','18px','32px']});exports.SizeClass=SizeClass;exports.SizeStyle=SizeStyle;},function(module,exports,__webpack_require__){module.exports={'align':{'':__webpack_require__(76),'center':__webpack_require__(77),'right':__webpack_require__(78),'justify':__webpack_require__(79)},'background':__webpack_require__(80),'blockquote':__webpack_require__(81),'bold':__webpack_require__(82),'clean':__webpack_require__(83),'code':__webpack_require__(58),'code-block':__webpack_require__(58),'color':__webpack_require__(84),'direction':{'':__webpack_require__(85),'rtl':__webpack_require__(86)},'float':{'center':__webpack_require__(87),'full':__webpack_require__(88),'left':__webpack_require__(89),'right':__webpack_require__(90)},'formula':__webpack_require__(91),'header':{'1':__webpack_require__(92),'2':__webpack_require__(93)},'italic':__webpack_require__(94),'image':__webpack_require__(95),'indent':{'+1':__webpack_require__(96),'-1':__webpack_require__(97)},'link':__webpack_require__(98),'list':{'ordered':__webpack_require__(99),'bullet':__webpack_require__(100),'check':__webpack_require__(101)},'script':{'sub':__webpack_require__(102),'super':__webpack_require__(103)},'strike':__webpack_require__(104),'underline':__webpack_require__(105),'video':__webpack_require__(106)};},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.getLastChangeIndex=exports.default=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _quill=__webpack_require__(5);var _quill2=_interopRequireDefault(_quill);var _module=__webpack_require__(9);var _module2=_interopRequireDefault(_module);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var History=function(_Module){_inherits(History,_Module);function History(quill,options){_classCallCheck(this,History);var _this=_possibleConstructorReturn(this,(History.__proto__||Object.getPrototypeOf(History)).call(this,quill,options));_this.lastRecorded=0;_this.ignoreChange=false;_this.clear();_this.quill.on(_quill2.default.events.EDITOR_CHANGE,function(eventName,delta,oldDelta,source){if(eventName!==_quill2.default.events.TEXT_CHANGE||_this.ignoreChange)return;if(!_this.options.userOnly||source===_quill2.default.sources.USER){_this.record(delta,oldDelta);}else{_this.transform(delta);}});_this.quill.keyboard.addBinding({key:'Z',shortKey:true},_this.undo.bind(_this));_this.quill.keyboard.addBinding({key:'Z',shortKey:true,shiftKey:true},_this.redo.bind(_this));if(/Win/i.test(navigator.platform)){_this.quill.keyboard.addBinding({key:'Y',shortKey:true},_this.redo.bind(_this));}return _this;}_createClass(History,[{key:'change',value:function change(source,dest){if(this.stack[source].length===0)return;var delta=this.stack[source].pop();this.lastRecorded=0;this.ignoreChange=true;this.quill.updateContents(delta[source],_quill2.default.sources.USER);this.ignoreChange=false;var index=getLastChangeIndex(delta[source]);this.quill.setSelection(index);this.stack[dest].push(delta);}},{key:'clear',value:function clear(){this.stack={undo:[],redo:[]};}},{key:'cutoff',value:function cutoff(){this.lastRecorded=0;}},{key:'record',value:function record(changeDelta,oldDelta){if(changeDelta.ops.length===0)return;this.stack.redo=[];var undoDelta=this.quill.getContents().diff(oldDelta);var timestamp=Date.now();if(this.lastRecorded+this.options.delay>timestamp&&this.stack.undo.length>0){var delta=this.stack.undo.pop();undoDelta=undoDelta.compose(delta.undo);changeDelta=delta.redo.compose(changeDelta);}else{this.lastRecorded=timestamp;}this.stack.undo.push({redo:changeDelta,undo:undoDelta});if(this.stack.undo.length>this.options.maxStack){this.stack.undo.shift();}}},{key:'redo',value:function redo(){this.change('redo','undo');}},{key:'transform',value:function transform(delta){this.stack.undo.forEach(function(change){change.undo=delta.transform(change.undo,true);change.redo=delta.transform(change.redo,true);});this.stack.redo.forEach(function(change){change.undo=delta.transform(change.undo,true);change.redo=delta.transform(change.redo,true);});}},{key:'undo',value:function undo(){this.change('undo','redo');}}]);return History;}(_module2.default);History.DEFAULTS={delay:1000,maxStack:100,userOnly:false};function endsWithNewlineChange(delta){var lastOp=delta.ops[delta.ops.length-1];if(lastOp==null)return false;if(lastOp.insert!=null){return typeof lastOp.insert==='string'&&lastOp.insert.endsWith('\n');}if(lastOp.attributes!=null){return Object.keys(lastOp.attributes).some(function(attr){return _parchment2.default.query(attr,_parchment2.default.Scope.BLOCK)!=null;});}return false;}function getLastChangeIndex(delta){var deleteLength=delta.reduce(function(length,op){length+=op.delete||0;return length;},0);var changeIndex=delta.length()-deleteLength;if(endsWithNewlineChange(delta)){changeIndex-=1;}return changeIndex;}exports.default=History;exports.getLastChangeIndex=getLastChangeIndex;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.BaseTooltip=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _extend=__webpack_require__(3);var _extend2=_interopRequireDefault(_extend);var _quillDelta=__webpack_require__(2);var _quillDelta2=_interopRequireDefault(_quillDelta);var _emitter=__webpack_require__(8);var _emitter2=_interopRequireDefault(_emitter);var _keyboard=__webpack_require__(35);var _keyboard2=_interopRequireDefault(_keyboard);var _theme=__webpack_require__(34);var _theme2=_interopRequireDefault(_theme);var _colorPicker=__webpack_require__(59);var _colorPicker2=_interopRequireDefault(_colorPicker);var _iconPicker=__webpack_require__(60);var _iconPicker2=_interopRequireDefault(_iconPicker);var _picker=__webpack_require__(28);var _picker2=_interopRequireDefault(_picker);var _tooltip=__webpack_require__(61);var _tooltip2=_interopRequireDefault(_tooltip);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var ALIGNS=[false,'center','right','justify'];var COLORS=["#000000","#e60000","#ff9900","#ffff00","#008a00","#0066cc","#9933ff","#ffffff","#facccc","#ffebcc","#ffffcc","#cce8cc","#cce0f5","#ebd6ff","#bbbbbb","#f06666","#ffc266","#ffff66","#66b966","#66a3e0","#c285ff","#888888","#a10000","#b26b00","#b2b200","#006100","#0047b2","#6b24b2","#444444","#5c0000","#663d00","#666600","#003700","#002966","#3d1466"];var FONTS=[false,'serif','monospace'];var HEADERS=['1','2','3',false];var SIZES=['small',false,'large','huge'];var BaseTheme=function(_Theme){_inherits(BaseTheme,_Theme);function BaseTheme(quill,options){_classCallCheck(this,BaseTheme);var _this=_possibleConstructorReturn(this,(BaseTheme.__proto__||Object.getPrototypeOf(BaseTheme)).call(this,quill,options));var listener=function listener(e){if(!document.body.contains(quill.root)){return document.body.removeEventListener('click',listener);}if(_this.tooltip!=null&&!_this.tooltip.root.contains(e.target)&&document.activeElement!==_this.tooltip.textbox&&!_this.quill.hasFocus()){_this.tooltip.hide();}if(_this.pickers!=null){_this.pickers.forEach(function(picker){if(!picker.container.contains(e.target)){picker.close();}});}};quill.emitter.listenDOM('click',document.body,listener);return _this;}_createClass(BaseTheme,[{key:'addModule',value:function addModule(name){var module=_get(BaseTheme.prototype.__proto__||Object.getPrototypeOf(BaseTheme.prototype),'addModule',this).call(this,name);if(name==='toolbar'){this.extendToolbar(module);}return module;}},{key:'buildButtons',value:function buildButtons(buttons,icons){buttons.forEach(function(button){var className=button.getAttribute('class')||'';className.split(/\s+/).forEach(function(name){if(!name.startsWith('ql-'))return;name=name.slice('ql-'.length);if(icons[name]==null)return;if(name==='direction'){button.innerHTML=icons[name]['']+icons[name]['rtl'];}else if(typeof icons[name]==='string'){button.innerHTML=icons[name];}else{var value=button.value||'';if(value!=null&&icons[name][value]){button.innerHTML=icons[name][value];}}});});}},{key:'buildPickers',value:function buildPickers(selects,icons){var _this2=this;this.pickers=selects.map(function(select){if(select.classList.contains('ql-align')){if(select.querySelector('option')==null){fillSelect(select,ALIGNS);}return new _iconPicker2.default(select,icons.align);}else if(select.classList.contains('ql-background')||select.classList.contains('ql-color')){var format=select.classList.contains('ql-background')?'background':'color';if(select.querySelector('option')==null){fillSelect(select,COLORS,format==='background'?'#ffffff':'#000000');}return new _colorPicker2.default(select,icons[format]);}else{if(select.querySelector('option')==null){if(select.classList.contains('ql-font')){fillSelect(select,FONTS);}else if(select.classList.contains('ql-header')){fillSelect(select,HEADERS);}else if(select.classList.contains('ql-size')){fillSelect(select,SIZES);}}return new _picker2.default(select);}});var update=function update(){_this2.pickers.forEach(function(picker){picker.update();});};this.quill.on(_emitter2.default.events.EDITOR_CHANGE,update);}}]);return BaseTheme;}(_theme2.default);BaseTheme.DEFAULTS=_extend2.default(true,{},_theme2.default.DEFAULTS,{modules:{toolbar:{handlers:{formula:function formula(){this.quill.theme.tooltip.edit('formula');},image:function image(){var _this3=this;var fileInput=this.container.querySelector('input.ql-image[type=file]');if(fileInput==null){fileInput=document.createElement('input');fileInput.setAttribute('type','file');fileInput.setAttribute('accept','image/png, image/gif, image/jpeg, image/bmp, image/x-icon');fileInput.classList.add('ql-image');fileInput.addEventListener('change',function(){if(fileInput.files!=null&&fileInput.files[0]!=null){var reader=new FileReader();reader.onload=function(e){var range=_this3.quill.getSelection(true);_this3.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert({image:e.target.result}),_emitter2.default.sources.USER);_this3.quill.setSelection(range.index+1,_emitter2.default.sources.SILENT);fileInput.value="";};reader.readAsDataURL(fileInput.files[0]);}});this.container.appendChild(fileInput);}fileInput.click();},video:function video(){this.quill.theme.tooltip.edit('video');}}}}});var BaseTooltip=function(_Tooltip){_inherits(BaseTooltip,_Tooltip);function BaseTooltip(quill,boundsContainer){_classCallCheck(this,BaseTooltip);var _this4=_possibleConstructorReturn(this,(BaseTooltip.__proto__||Object.getPrototypeOf(BaseTooltip)).call(this,quill,boundsContainer));_this4.textbox=_this4.root.querySelector('input[type="text"]');_this4.listen();return _this4;}_createClass(BaseTooltip,[{key:'listen',value:function listen(){var _this5=this;this.textbox.addEventListener('keydown',function(event){if(_keyboard2.default.match(event,'enter')){_this5.save();event.preventDefault();}else if(_keyboard2.default.match(event,'escape')){_this5.cancel();event.preventDefault();}});}},{key:'cancel',value:function cancel(){this.hide();}},{key:'edit',value:function edit(){var mode=arguments.length>0&&arguments[0]!==undefined?arguments[0]:'link';var preview=arguments.length>1&&arguments[1]!==undefined?arguments[1]:null;this.root.classList.remove('ql-hidden');this.root.classList.add('ql-editing');if(preview!=null){this.textbox.value=preview;}else if(mode!==this.root.getAttribute('data-mode')){this.textbox.value='';}this.position(this.quill.getBounds(this.quill.selection.savedRange));this.textbox.select();this.textbox.setAttribute('placeholder',this.textbox.getAttribute('data-'+mode)||'');this.root.setAttribute('data-mode',mode);}},{key:'restoreFocus',value:function restoreFocus(){var scrollTop=this.quill.scrollingContainer.scrollTop;this.quill.focus();this.quill.scrollingContainer.scrollTop=scrollTop;}},{key:'save',value:function save(){var value=this.textbox.value;switch(this.root.getAttribute('data-mode')){case'link':{var scrollTop=this.quill.root.scrollTop;if(this.linkRange){this.quill.formatText(this.linkRange,'link',value,_emitter2.default.sources.USER);delete this.linkRange;}else{this.restoreFocus();this.quill.format('link',value,_emitter2.default.sources.USER);}this.quill.root.scrollTop=scrollTop;break;}case'video':{value=extractVideoUrl(value);}case'formula':{if(!value)break;var range=this.quill.getSelection(true);if(range!=null){var index=range.index+range.length;this.quill.insertEmbed(index,this.root.getAttribute('data-mode'),value,_emitter2.default.sources.USER);if(this.root.getAttribute('data-mode')==='formula'){this.quill.insertText(index+1,' ',_emitter2.default.sources.USER);}this.quill.setSelection(index+2,_emitter2.default.sources.USER);}break;}default:}this.textbox.value='';this.hide();}}]);return BaseTooltip;}(_tooltip2.default);function extractVideoUrl(url){var match=url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtube\.com\/watch.*v=([a-zA-Z0-9_-]+)/)||url.match(/^(?:(https?):\/\/)?(?:(?:www|m)\.)?youtu\.be\/([a-zA-Z0-9_-]+)/);if(match){return (match[1]||'https')+'://www.youtube.com/embed/'+match[2]+'?showinfo=0';}if(match=url.match(/^(?:(https?):\/\/)?(?:www\.)?vimeo\.com\/(\d+)/)){return (match[1]||'https')+'://player.vimeo.com/video/'+match[2]+'/';}return url;}function fillSelect(select,values){var defaultValue=arguments.length>2&&arguments[2]!==undefined?arguments[2]:false;values.forEach(function(value){var option=document.createElement('option');if(value===defaultValue){option.setAttribute('selected','selected');}else{option.setAttribute('value',value);}select.appendChild(option);});}exports.BaseTooltip=BaseTooltip;exports.default=BaseTheme;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var LinkedList=function(){function LinkedList(){this.head=this.tail=undefined;this.length=0;}LinkedList.prototype.append=function(){var nodes=[];for(var _i=0;_i<arguments.length;_i++){nodes[_i]=arguments[_i];}this.insertBefore(nodes[0],undefined);if(nodes.length>1){this.append.apply(this,nodes.slice(1));}};LinkedList.prototype.contains=function(node){var cur,next=this.iterator();while(cur=next()){if(cur===node)return true;}return false;};LinkedList.prototype.insertBefore=function(node,refNode){node.next=refNode;if(refNode!=null){node.prev=refNode.prev;if(refNode.prev!=null){refNode.prev.next=node;}refNode.prev=node;if(refNode===this.head){this.head=node;}}else if(this.tail!=null){this.tail.next=node;node.prev=this.tail;this.tail=node;}else{node.prev=undefined;this.head=this.tail=node;}this.length+=1;};LinkedList.prototype.offset=function(target){var index=0,cur=this.head;while(cur!=null){if(cur===target)return index;index+=cur.length();cur=cur.next;}return -1;};LinkedList.prototype.remove=function(node){if(!this.contains(node))return;if(node.prev!=null)node.prev.next=node.next;if(node.next!=null)node.next.prev=node.prev;if(node===this.head)this.head=node.next;if(node===this.tail)this.tail=node.prev;this.length-=1;};LinkedList.prototype.iterator=function(curNode){if(curNode===void 0){curNode=this.head;}return function(){var ret=curNode;if(curNode!=null)curNode=curNode.next;return ret;};};LinkedList.prototype.find=function(index,inclusive){if(inclusive===void 0){inclusive=false;}var cur,next=this.iterator();while(cur=next()){var length=cur.length();if(index<length||inclusive&&index===length&&(cur.next==null||cur.next.length()!==0)){return [cur,index];}index-=length;}return [null,0];};LinkedList.prototype.forEach=function(callback){var cur,next=this.iterator();while(cur=next()){callback(cur);}};LinkedList.prototype.forEachAt=function(index,length,callback){if(length<=0)return;var _a=this.find(index),startNode=_a[0],offset=_a[1];var cur,curIndex=index-offset,next=this.iterator(startNode);while((cur=next())&&curIndex<index+length){var curLength=cur.length();if(index>curIndex){callback(cur,index-curIndex,Math.min(length,curIndex+curLength-index));}else{callback(cur,0,Math.min(curLength,index+length-curIndex));}curIndex+=curLength;}};LinkedList.prototype.map=function(callback){return this.reduce(function(memo,cur){memo.push(callback(cur));return memo;},[]);};LinkedList.prototype.reduce=function(callback,memo){var cur,next=this.iterator();while(cur=next()){memo=callback(memo,cur);}return memo;};return LinkedList;}();exports.default=LinkedList;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var container_1=__webpack_require__(17);var Registry=__webpack_require__(1);var OBSERVER_CONFIG={attributes:true,characterData:true,characterDataOldValue:true,childList:true,subtree:true};var MAX_OPTIMIZE_ITERATIONS=100;var ScrollBlot=function(_super){__extends(ScrollBlot,_super);function ScrollBlot(node){var _this=_super.call(this,node)||this;_this.parent=null;_this.scroll=_this;_this.observer=new MutationObserver(function(mutations){_this.update(mutations);});_this.observer.observe(_this.domNode,OBSERVER_CONFIG);_this.attach();return _this;}ScrollBlot.prototype.detach=function(){_super.prototype.detach.call(this);this.observer.disconnect();};ScrollBlot.prototype.deleteAt=function(index,length){this.update();if(index===0&&length===this.length()){this.children.forEach(function(child){child.remove();});}else{_super.prototype.deleteAt.call(this,index,length);}};ScrollBlot.prototype.formatAt=function(index,length,name,value){this.update();_super.prototype.formatAt.call(this,index,length,name,value);};ScrollBlot.prototype.insertAt=function(index,value,def){this.update();_super.prototype.insertAt.call(this,index,value,def);};ScrollBlot.prototype.optimize=function(mutations,context){var _this=this;if(mutations===void 0){mutations=[];}if(context===void 0){context={};}_super.prototype.optimize.call(this,context);var records=[].slice.call(this.observer.takeRecords());while(records.length>0)mutations.push(records.pop());var mark=function(blot,markParent){if(markParent===void 0){markParent=true;}if(blot==null||blot===_this)return;if(blot.domNode.parentNode==null)return;if(blot.domNode[Registry.DATA_KEY].mutations==null){blot.domNode[Registry.DATA_KEY].mutations=[];}if(markParent)mark(blot.parent);};var optimize=function(blot){if(blot.domNode[Registry.DATA_KEY]==null||blot.domNode[Registry.DATA_KEY].mutations==null){return;}if(blot instanceof container_1.default){blot.children.forEach(optimize);}blot.optimize(context);};var remaining=mutations;for(var i=0;remaining.length>0;i+=1){if(i>=MAX_OPTIMIZE_ITERATIONS){throw new Error('[Parchment] Maximum optimize iterations reached');}remaining.forEach(function(mutation){var blot=Registry.find(mutation.target,true);if(blot==null)return;if(blot.domNode===mutation.target){if(mutation.type==='childList'){mark(Registry.find(mutation.previousSibling,false));[].forEach.call(mutation.addedNodes,function(node){var child=Registry.find(node,false);mark(child,false);if(child instanceof container_1.default){child.children.forEach(function(grandChild){mark(grandChild,false);});}});}else if(mutation.type==='attributes'){mark(blot.prev);}}mark(blot);});this.children.forEach(optimize);remaining=[].slice.call(this.observer.takeRecords());records=remaining.slice();while(records.length>0)mutations.push(records.pop());}};ScrollBlot.prototype.update=function(mutations,context){var _this=this;if(context===void 0){context={};}mutations=mutations||this.observer.takeRecords();mutations.map(function(mutation){var blot=Registry.find(mutation.target,true);if(blot==null)return;if(blot.domNode[Registry.DATA_KEY].mutations==null){blot.domNode[Registry.DATA_KEY].mutations=[mutation];return blot;}else{blot.domNode[Registry.DATA_KEY].mutations.push(mutation);return null;}}).forEach(function(blot){if(blot==null||blot===_this||blot.domNode[Registry.DATA_KEY]==null)return;blot.update(blot.domNode[Registry.DATA_KEY].mutations||[],context);});if(this.domNode[Registry.DATA_KEY].mutations!=null){_super.prototype.update.call(this,this.domNode[Registry.DATA_KEY].mutations,context);}this.optimize(mutations,context);};ScrollBlot.blotName='scroll';ScrollBlot.defaultChild='block';ScrollBlot.scope=Registry.Scope.BLOCK_BLOT;ScrollBlot.tagName='DIV';return ScrollBlot;}(container_1.default);exports.default=ScrollBlot;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var format_1=__webpack_require__(18);var Registry=__webpack_require__(1);function isEqual(obj1,obj2){if(Object.keys(obj1).length!==Object.keys(obj2).length)return false;for(var prop in obj1){if(obj1[prop]!==obj2[prop])return false;}return true;}var InlineBlot=function(_super){__extends(InlineBlot,_super);function InlineBlot(){return _super!==null&&_super.apply(this,arguments)||this;}InlineBlot.formats=function(domNode){if(domNode.tagName===InlineBlot.tagName)return undefined;return _super.formats.call(this,domNode);};InlineBlot.prototype.format=function(name,value){var _this=this;if(name===this.statics.blotName&&!value){this.children.forEach(function(child){if(!(child instanceof format_1.default)){child=child.wrap(InlineBlot.blotName,true);}_this.attributes.copy(child);});this.unwrap();}else{_super.prototype.format.call(this,name,value);}};InlineBlot.prototype.formatAt=function(index,length,name,value){if(this.formats()[name]!=null||Registry.query(name,Registry.Scope.ATTRIBUTE)){var blot=this.isolate(index,length);blot.format(name,value);}else{_super.prototype.formatAt.call(this,index,length,name,value);}};InlineBlot.prototype.optimize=function(context){_super.prototype.optimize.call(this,context);var formats=this.formats();if(Object.keys(formats).length===0){return this.unwrap();}var next=this.next;if(next instanceof InlineBlot&&next.prev===this&&isEqual(formats,next.formats())){next.moveChildren(this);next.remove();}};InlineBlot.blotName='inline';InlineBlot.scope=Registry.Scope.INLINE_BLOT;InlineBlot.tagName='SPAN';return InlineBlot;}(format_1.default);exports.default=InlineBlot;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var format_1=__webpack_require__(18);var Registry=__webpack_require__(1);var BlockBlot=function(_super){__extends(BlockBlot,_super);function BlockBlot(){return _super!==null&&_super.apply(this,arguments)||this;}BlockBlot.formats=function(domNode){var tagName=Registry.query(BlockBlot.blotName).tagName;if(domNode.tagName===tagName)return undefined;return _super.formats.call(this,domNode);};BlockBlot.prototype.format=function(name,value){if(Registry.query(name,Registry.Scope.BLOCK)==null){return;}else if(name===this.statics.blotName&&!value){this.replaceWith(BlockBlot.blotName);}else{_super.prototype.format.call(this,name,value);}};BlockBlot.prototype.formatAt=function(index,length,name,value){if(Registry.query(name,Registry.Scope.BLOCK)!=null){this.format(name,value);}else{_super.prototype.formatAt.call(this,index,length,name,value);}};BlockBlot.prototype.insertAt=function(index,value,def){if(def==null||Registry.query(value,Registry.Scope.INLINE)!=null){_super.prototype.insertAt.call(this,index,value,def);}else{var after=this.split(index);var blot=Registry.create(value,def);after.parent.insertBefore(blot,after);}};BlockBlot.prototype.update=function(mutations,context){if(navigator.userAgent.match(/Trident/)){this.build();}else{_super.prototype.update.call(this,mutations,context);}};BlockBlot.blotName='block';BlockBlot.scope=Registry.Scope.BLOCK_BLOT;BlockBlot.tagName='P';return BlockBlot;}(format_1.default);exports.default=BlockBlot;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var leaf_1=__webpack_require__(19);var EmbedBlot=function(_super){__extends(EmbedBlot,_super);function EmbedBlot(){return _super!==null&&_super.apply(this,arguments)||this;}EmbedBlot.formats=function(domNode){return undefined;};EmbedBlot.prototype.format=function(name,value){_super.prototype.formatAt.call(this,0,this.length(),name,value);};EmbedBlot.prototype.formatAt=function(index,length,name,value){if(index===0&&length===this.length()){this.format(name,value);}else{_super.prototype.formatAt.call(this,index,length,name,value);}};EmbedBlot.prototype.formats=function(){return this.statics.formats(this.domNode);};return EmbedBlot;}(leaf_1.default);exports.default=EmbedBlot;},function(module,exports,__webpack_require__){var __extends=this&&this.__extends||function(){var extendStatics=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(d,b){d.__proto__=b;}||function(d,b){for(var p in b)if(b.hasOwnProperty(p))d[p]=b[p];};return function(d,b){extendStatics(d,b);function __(){this.constructor=d;}d.prototype=b===null?Object.create(b):(__.prototype=b.prototype,new __());};}();Object.defineProperty(exports,"__esModule",{value:true});var leaf_1=__webpack_require__(19);var Registry=__webpack_require__(1);var TextBlot=function(_super){__extends(TextBlot,_super);function TextBlot(node){var _this=_super.call(this,node)||this;_this.text=_this.statics.value(_this.domNode);return _this;}TextBlot.create=function(value){return document.createTextNode(value);};TextBlot.value=function(domNode){var text=domNode.data;if(text['normalize'])text=text['normalize']();return text;};TextBlot.prototype.deleteAt=function(index,length){this.domNode.data=this.text=this.text.slice(0,index)+this.text.slice(index+length);};TextBlot.prototype.index=function(node,offset){if(this.domNode===node){return offset;}return -1;};TextBlot.prototype.insertAt=function(index,value,def){if(def==null){this.text=this.text.slice(0,index)+value+this.text.slice(index);this.domNode.data=this.text;}else{_super.prototype.insertAt.call(this,index,value,def);}};TextBlot.prototype.length=function(){return this.text.length;};TextBlot.prototype.optimize=function(context){_super.prototype.optimize.call(this,context);this.text=this.statics.value(this.domNode);if(this.text.length===0){this.remove();}else if(this.next instanceof TextBlot&&this.next.prev===this){this.insertAt(this.length(),this.next.value());this.next.remove();}};TextBlot.prototype.position=function(index,inclusive){if(inclusive===void 0){inclusive=false;}return [this.domNode,index];};TextBlot.prototype.split=function(index,force){if(force===void 0){force=false;}if(!force){if(index===0)return this;if(index===this.length())return this.next;}var after=Registry.create(this.domNode.splitText(index));this.parent.insertBefore(after,this.next);this.text=this.statics.value(this.domNode);return after;};TextBlot.prototype.update=function(mutations,context){var _this=this;if(mutations.some(function(mutation){return mutation.type==='characterData'&&mutation.target===_this.domNode;})){this.text=this.statics.value(this.domNode);}};TextBlot.prototype.value=function(){return this.text;};TextBlot.blotName='text';TextBlot.scope=Registry.Scope.INLINE_BLOT;return TextBlot;}(leaf_1.default);exports.default=TextBlot;},function(module,exports,__webpack_require__){var elem=document.createElement('div');elem.classList.toggle('test-class',false);if(elem.classList.contains('test-class')){var _toggle=DOMTokenList.prototype.toggle;DOMTokenList.prototype.toggle=function(token,force){if(arguments.length>1&&!this.contains(token)===!force){return force;}else{return _toggle.call(this,token);}};}if(!String.prototype.startsWith){String.prototype.startsWith=function(searchString,position){position=position||0;return this.substr(position,searchString.length)===searchString;};}if(!String.prototype.endsWith){String.prototype.endsWith=function(searchString,position){var subjectString=this.toString();if(typeof position!=='number'||!isFinite(position)||Math.floor(position)!==position||position>subjectString.length){position=subjectString.length;}position-=searchString.length;var lastIndex=subjectString.indexOf(searchString,position);return lastIndex!==-1&&lastIndex===position;};}if(!Array.prototype.find){Object.defineProperty(Array.prototype,"find",{value:function value(predicate){if(this===null){throw new TypeError('Array.prototype.find called on null or undefined');}if(typeof predicate!=='function'){throw new TypeError('predicate must be a function');}var list=Object(this);var length=list.length>>>0;var thisArg=arguments[1];var value;for(var i=0;i<length;i++){value=list[i];if(predicate.call(thisArg,value,i,list)){return value;}}return undefined;}});}document.addEventListener("DOMContentLoaded",function(){document.execCommand("enableObjectResizing",false,false);document.execCommand("autoUrlDetect",false,false);});},function(module,exports){var DIFF_DELETE=-1;var DIFF_INSERT=1;var DIFF_EQUAL=0;function diff_main(text1,text2,cursor_pos){if(text1==text2){if(text1){return [[DIFF_EQUAL,text1]];}return [];}if(cursor_pos<0||text1.length<cursor_pos){cursor_pos=null;}var commonlength=diff_commonPrefix(text1,text2);var commonprefix=text1.substring(0,commonlength);text1=text1.substring(commonlength);text2=text2.substring(commonlength);commonlength=diff_commonSuffix(text1,text2);var commonsuffix=text1.substring(text1.length-commonlength);text1=text1.substring(0,text1.length-commonlength);text2=text2.substring(0,text2.length-commonlength);var diffs=diff_compute_(text1,text2);if(commonprefix){diffs.unshift([DIFF_EQUAL,commonprefix]);}if(commonsuffix){diffs.push([DIFF_EQUAL,commonsuffix]);}diff_cleanupMerge(diffs);if(cursor_pos!=null){diffs=fix_cursor(diffs,cursor_pos);}diffs=fix_emoji(diffs);return diffs;}function diff_compute_(text1,text2){var diffs;if(!text1){return [[DIFF_INSERT,text2]];}if(!text2){return [[DIFF_DELETE,text1]];}var longtext=text1.length>text2.length?text1:text2;var shorttext=text1.length>text2.length?text2:text1;var i=longtext.indexOf(shorttext);if(i!=-1){diffs=[[DIFF_INSERT,longtext.substring(0,i)],[DIFF_EQUAL,shorttext],[DIFF_INSERT,longtext.substring(i+shorttext.length)]];if(text1.length>text2.length){diffs[0][0]=diffs[2][0]=DIFF_DELETE;}return diffs;}if(shorttext.length==1){return [[DIFF_DELETE,text1],[DIFF_INSERT,text2]];}var hm=diff_halfMatch_(text1,text2);if(hm){var text1_a=hm[0];var text1_b=hm[1];var text2_a=hm[2];var text2_b=hm[3];var mid_common=hm[4];var diffs_a=diff_main(text1_a,text2_a);var diffs_b=diff_main(text1_b,text2_b);return diffs_a.concat([[DIFF_EQUAL,mid_common]],diffs_b);}return diff_bisect_(text1,text2);}function diff_bisect_(text1,text2){var text1_length=text1.length;var text2_length=text2.length;var max_d=Math.ceil((text1_length+text2_length)/2);var v_offset=max_d;var v_length=2*max_d;var v1=new Array(v_length);var v2=new Array(v_length);for(var x=0;x<v_length;x++){v1[x]=-1;v2[x]=-1;}v1[v_offset+1]=0;v2[v_offset+1]=0;var delta=text1_length-text2_length;var front=delta%2!=0;var k1start=0;var k1end=0;var k2start=0;var k2end=0;for(var d=0;d<max_d;d++){for(var k1=-d+k1start;k1<=d-k1end;k1+=2){var k1_offset=v_offset+k1;var x1;if(k1==-d||k1!=d&&v1[k1_offset-1]<v1[k1_offset+1]){x1=v1[k1_offset+1];}else{x1=v1[k1_offset-1]+1;}var y1=x1-k1;while(x1<text1_length&&y1<text2_length&&text1.charAt(x1)==text2.charAt(y1)){x1++;y1++;}v1[k1_offset]=x1;if(x1>text1_length){k1end+=2;}else if(y1>text2_length){k1start+=2;}else if(front){var k2_offset=v_offset+delta-k1;if(k2_offset>=0&&k2_offset<v_length&&v2[k2_offset]!=-1){var x2=text1_length-v2[k2_offset];if(x1>=x2){return diff_bisectSplit_(text1,text2,x1,y1);}}}}for(var k2=-d+k2start;k2<=d-k2end;k2+=2){var k2_offset=v_offset+k2;var x2;if(k2==-d||k2!=d&&v2[k2_offset-1]<v2[k2_offset+1]){x2=v2[k2_offset+1];}else{x2=v2[k2_offset-1]+1;}var y2=x2-k2;while(x2<text1_length&&y2<text2_length&&text1.charAt(text1_length-x2-1)==text2.charAt(text2_length-y2-1)){x2++;y2++;}v2[k2_offset]=x2;if(x2>text1_length){k2end+=2;}else if(y2>text2_length){k2start+=2;}else if(!front){var k1_offset=v_offset+delta-k2;if(k1_offset>=0&&k1_offset<v_length&&v1[k1_offset]!=-1){var x1=v1[k1_offset];var y1=v_offset+x1-k1_offset;x2=text1_length-x2;if(x1>=x2){return diff_bisectSplit_(text1,text2,x1,y1);}}}}}return [[DIFF_DELETE,text1],[DIFF_INSERT,text2]];}function diff_bisectSplit_(text1,text2,x,y){var text1a=text1.substring(0,x);var text2a=text2.substring(0,y);var text1b=text1.substring(x);var text2b=text2.substring(y);var diffs=diff_main(text1a,text2a);var diffsb=diff_main(text1b,text2b);return diffs.concat(diffsb);}function diff_commonPrefix(text1,text2){if(!text1||!text2||text1.charAt(0)!=text2.charAt(0)){return 0;}var pointermin=0;var pointermax=Math.min(text1.length,text2.length);var pointermid=pointermax;var pointerstart=0;while(pointermin<pointermid){if(text1.substring(pointerstart,pointermid)==text2.substring(pointerstart,pointermid)){pointermin=pointermid;pointerstart=pointermin;}else{pointermax=pointermid;}pointermid=Math.floor((pointermax-pointermin)/2+pointermin);}return pointermid;}function diff_commonSuffix(text1,text2){if(!text1||!text2||text1.charAt(text1.length-1)!=text2.charAt(text2.length-1)){return 0;}var pointermin=0;var pointermax=Math.min(text1.length,text2.length);var pointermid=pointermax;var pointerend=0;while(pointermin<pointermid){if(text1.substring(text1.length-pointermid,text1.length-pointerend)==text2.substring(text2.length-pointermid,text2.length-pointerend)){pointermin=pointermid;pointerend=pointermin;}else{pointermax=pointermid;}pointermid=Math.floor((pointermax-pointermin)/2+pointermin);}return pointermid;}function diff_halfMatch_(text1,text2){var longtext=text1.length>text2.length?text1:text2;var shorttext=text1.length>text2.length?text2:text1;if(longtext.length<4||shorttext.length*2<longtext.length){return null;}function diff_halfMatchI_(longtext,shorttext,i){var seed=longtext.substring(i,i+Math.floor(longtext.length/4));var j=-1;var best_common='';var best_longtext_a,best_longtext_b,best_shorttext_a,best_shorttext_b;while((j=shorttext.indexOf(seed,j+1))!=-1){var prefixLength=diff_commonPrefix(longtext.substring(i),shorttext.substring(j));var suffixLength=diff_commonSuffix(longtext.substring(0,i),shorttext.substring(0,j));if(best_common.length<suffixLength+prefixLength){best_common=shorttext.substring(j-suffixLength,j)+shorttext.substring(j,j+prefixLength);best_longtext_a=longtext.substring(0,i-suffixLength);best_longtext_b=longtext.substring(i+prefixLength);best_shorttext_a=shorttext.substring(0,j-suffixLength);best_shorttext_b=shorttext.substring(j+prefixLength);}}if(best_common.length*2>=longtext.length){return [best_longtext_a,best_longtext_b,best_shorttext_a,best_shorttext_b,best_common];}else{return null;}}var hm1=diff_halfMatchI_(longtext,shorttext,Math.ceil(longtext.length/4));var hm2=diff_halfMatchI_(longtext,shorttext,Math.ceil(longtext.length/2));var hm;if(!hm1&&!hm2){return null;}else if(!hm2){hm=hm1;}else if(!hm1){hm=hm2;}else{hm=hm1[4].length>hm2[4].length?hm1:hm2;}var text1_a,text1_b,text2_a,text2_b;if(text1.length>text2.length){text1_a=hm[0];text1_b=hm[1];text2_a=hm[2];text2_b=hm[3];}else{text2_a=hm[0];text2_b=hm[1];text1_a=hm[2];text1_b=hm[3];}var mid_common=hm[4];return [text1_a,text1_b,text2_a,text2_b,mid_common];}function diff_cleanupMerge(diffs){diffs.push([DIFF_EQUAL,'']);var pointer=0;var count_delete=0;var count_insert=0;var text_delete='';var text_insert='';var commonlength;while(pointer<diffs.length){switch(diffs[pointer][0]){case DIFF_INSERT:count_insert++;text_insert+=diffs[pointer][1];pointer++;break;case DIFF_DELETE:count_delete++;text_delete+=diffs[pointer][1];pointer++;break;case DIFF_EQUAL:if(count_delete+count_insert>1){if(count_delete!==0&&count_insert!==0){commonlength=diff_commonPrefix(text_insert,text_delete);if(commonlength!==0){if(pointer-count_delete-count_insert>0&&diffs[pointer-count_delete-count_insert-1][0]==DIFF_EQUAL){diffs[pointer-count_delete-count_insert-1][1]+=text_insert.substring(0,commonlength);}else{diffs.splice(0,0,[DIFF_EQUAL,text_insert.substring(0,commonlength)]);pointer++;}text_insert=text_insert.substring(commonlength);text_delete=text_delete.substring(commonlength);}commonlength=diff_commonSuffix(text_insert,text_delete);if(commonlength!==0){diffs[pointer][1]=text_insert.substring(text_insert.length-commonlength)+diffs[pointer][1];text_insert=text_insert.substring(0,text_insert.length-commonlength);text_delete=text_delete.substring(0,text_delete.length-commonlength);}}if(count_delete===0){diffs.splice(pointer-count_insert,count_delete+count_insert,[DIFF_INSERT,text_insert]);}else if(count_insert===0){diffs.splice(pointer-count_delete,count_delete+count_insert,[DIFF_DELETE,text_delete]);}else{diffs.splice(pointer-count_delete-count_insert,count_delete+count_insert,[DIFF_DELETE,text_delete],[DIFF_INSERT,text_insert]);}pointer=pointer-count_delete-count_insert+(count_delete?1:0)+(count_insert?1:0)+1;}else if(pointer!==0&&diffs[pointer-1][0]==DIFF_EQUAL){diffs[pointer-1][1]+=diffs[pointer][1];diffs.splice(pointer,1);}else{pointer++;}count_insert=0;count_delete=0;text_delete='';text_insert='';break;}}if(diffs[diffs.length-1][1]===''){diffs.pop();}var changes=false;pointer=1;while(pointer<diffs.length-1){if(diffs[pointer-1][0]==DIFF_EQUAL&&diffs[pointer+1][0]==DIFF_EQUAL){if(diffs[pointer][1].substring(diffs[pointer][1].length-diffs[pointer-1][1].length)==diffs[pointer-1][1]){diffs[pointer][1]=diffs[pointer-1][1]+diffs[pointer][1].substring(0,diffs[pointer][1].length-diffs[pointer-1][1].length);diffs[pointer+1][1]=diffs[pointer-1][1]+diffs[pointer+1][1];diffs.splice(pointer-1,1);changes=true;}else if(diffs[pointer][1].substring(0,diffs[pointer+1][1].length)==diffs[pointer+1][1]){diffs[pointer-1][1]+=diffs[pointer+1][1];diffs[pointer][1]=diffs[pointer][1].substring(diffs[pointer+1][1].length)+diffs[pointer+1][1];diffs.splice(pointer+1,1);changes=true;}}pointer++;}if(changes){diff_cleanupMerge(diffs);}}var diff=diff_main;diff.INSERT=DIFF_INSERT;diff.DELETE=DIFF_DELETE;diff.EQUAL=DIFF_EQUAL;module.exports=diff;function cursor_normalize_diff(diffs,cursor_pos){if(cursor_pos===0){return [DIFF_EQUAL,diffs];}for(var current_pos=0,i=0;i<diffs.length;i++){var d=diffs[i];if(d[0]===DIFF_DELETE||d[0]===DIFF_EQUAL){var next_pos=current_pos+d[1].length;if(cursor_pos===next_pos){return [i+1,diffs];}else if(cursor_pos<next_pos){diffs=diffs.slice();var split_pos=cursor_pos-current_pos;var d_left=[d[0],d[1].slice(0,split_pos)];var d_right=[d[0],d[1].slice(split_pos)];diffs.splice(i,1,d_left,d_right);return [i+1,diffs];}else{current_pos=next_pos;}}}throw new Error('cursor_pos is out of bounds!');}function fix_cursor(diffs,cursor_pos){var norm=cursor_normalize_diff(diffs,cursor_pos);var ndiffs=norm[1];var cursor_pointer=norm[0];var d=ndiffs[cursor_pointer];var d_next=ndiffs[cursor_pointer+1];if(d==null){return diffs;}else if(d[0]!==DIFF_EQUAL){return diffs;}else{if(d_next!=null&&d[1]+d_next[1]===d_next[1]+d[1]){ndiffs.splice(cursor_pointer,2,d_next,d);return merge_tuples(ndiffs,cursor_pointer,2);}else if(d_next!=null&&d_next[1].indexOf(d[1])===0){ndiffs.splice(cursor_pointer,2,[d_next[0],d[1]],[0,d[1]]);var suffix=d_next[1].slice(d[1].length);if(suffix.length>0){ndiffs.splice(cursor_pointer+2,0,[d_next[0],suffix]);}return merge_tuples(ndiffs,cursor_pointer,3);}else{return diffs;}}}function fix_emoji(diffs){var compact=false;var starts_with_pair_end=function(str){return str.charCodeAt(0)>=0xDC00&&str.charCodeAt(0)<=0xDFFF;};var ends_with_pair_start=function(str){return str.charCodeAt(str.length-1)>=0xD800&&str.charCodeAt(str.length-1)<=0xDBFF;};for(var i=2;i<diffs.length;i+=1){if(diffs[i-2][0]===DIFF_EQUAL&&ends_with_pair_start(diffs[i-2][1])&&diffs[i-1][0]===DIFF_DELETE&&starts_with_pair_end(diffs[i-1][1])&&diffs[i][0]===DIFF_INSERT&&starts_with_pair_end(diffs[i][1])){compact=true;diffs[i-1][1]=diffs[i-2][1].slice(-1)+diffs[i-1][1];diffs[i][1]=diffs[i-2][1].slice(-1)+diffs[i][1];diffs[i-2][1]=diffs[i-2][1].slice(0,-1);}}if(!compact){return diffs;}var fixed_diffs=[];for(var i=0;i<diffs.length;i+=1){if(diffs[i][1].length>0){fixed_diffs.push(diffs[i]);}}return fixed_diffs;}function merge_tuples(diffs,start,length){for(var i=start+length-1;i>=0&&i>=start-1;i--){if(i+1<diffs.length){var left_d=diffs[i];var right_d=diffs[i+1];if(left_d[0]===right_d[1]){diffs.splice(i,2,[left_d[0],left_d[1]+right_d[1]]);}}}return diffs;}},function(module,exports){exports=module.exports=typeof Object.keys==='function'?Object.keys:shim;exports.shim=shim;function shim(obj){var keys=[];for(var key in obj)keys.push(key);return keys;}},function(module,exports){var supportsArgumentsClass=function(){return Object.prototype.toString.call(arguments);}()=='[object Arguments]';exports=module.exports=supportsArgumentsClass?supported:unsupported;exports.supported=supported;function supported(object){return Object.prototype.toString.call(object)=='[object Arguments]';}exports.unsupported=unsupported;function unsupported(object){return object&&typeof object=='object'&&typeof object.length=='number'&&Object.prototype.hasOwnProperty.call(object,'callee')&&!Object.prototype.propertyIsEnumerable.call(object,'callee')||false;}},function(module,exports){var has=Object.prototype.hasOwnProperty,prefix='~';function Events(){}if(Object.create){Events.prototype=Object.create(null);if(!new Events().__proto__)prefix=false;}function EE(fn,context,once){this.fn=fn;this.context=context;this.once=once||false;}function EventEmitter(){this._events=new Events();this._eventsCount=0;}EventEmitter.prototype.eventNames=function eventNames(){var names=[],events,name;if(this._eventsCount===0)return names;for(name in events=this._events){if(has.call(events,name))names.push(prefix?name.slice(1):name);}if(Object.getOwnPropertySymbols){return names.concat(Object.getOwnPropertySymbols(events));}return names;};EventEmitter.prototype.listeners=function listeners(event,exists){var evt=prefix?prefix+event:event,available=this._events[evt];if(exists)return !!available;if(!available)return [];if(available.fn)return [available.fn];for(var i=0,l=available.length,ee=new Array(l);i<l;i++){ee[i]=available[i].fn;}return ee;};EventEmitter.prototype.emit=function emit(event,a1,a2,a3,a4,a5){var evt=prefix?prefix+event:event;if(!this._events[evt])return false;var listeners=this._events[evt],len=arguments.length,args,i;if(listeners.fn){if(listeners.once)this.removeListener(event,listeners.fn,undefined,true);switch(len){case 1:return listeners.fn.call(listeners.context),true;case 2:return listeners.fn.call(listeners.context,a1),true;case 3:return listeners.fn.call(listeners.context,a1,a2),true;case 4:return listeners.fn.call(listeners.context,a1,a2,a3),true;case 5:return listeners.fn.call(listeners.context,a1,a2,a3,a4),true;case 6:return listeners.fn.call(listeners.context,a1,a2,a3,a4,a5),true;}for(i=1,args=new Array(len-1);i<len;i++){args[i-1]=arguments[i];}listeners.fn.apply(listeners.context,args);}else{var length=listeners.length,j;for(i=0;i<length;i++){if(listeners[i].once)this.removeListener(event,listeners[i].fn,undefined,true);switch(len){case 1:listeners[i].fn.call(listeners[i].context);break;case 2:listeners[i].fn.call(listeners[i].context,a1);break;case 3:listeners[i].fn.call(listeners[i].context,a1,a2);break;case 4:listeners[i].fn.call(listeners[i].context,a1,a2,a3);break;default:if(!args)for(j=1,args=new Array(len-1);j<len;j++){args[j-1]=arguments[j];}listeners[i].fn.apply(listeners[i].context,args);}}}return true;};EventEmitter.prototype.on=function on(event,fn,context){var listener=new EE(fn,context||this),evt=prefix?prefix+event:event;if(!this._events[evt])this._events[evt]=listener,this._eventsCount++;else if(!this._events[evt].fn)this._events[evt].push(listener);else this._events[evt]=[this._events[evt],listener];return this;};EventEmitter.prototype.once=function once(event,fn,context){var listener=new EE(fn,context||this,true),evt=prefix?prefix+event:event;if(!this._events[evt])this._events[evt]=listener,this._eventsCount++;else if(!this._events[evt].fn)this._events[evt].push(listener);else this._events[evt]=[this._events[evt],listener];return this;};EventEmitter.prototype.removeListener=function removeListener(event,fn,context,once){var evt=prefix?prefix+event:event;if(!this._events[evt])return this;if(!fn){if(--this._eventsCount===0)this._events=new Events();else delete this._events[evt];return this;}var listeners=this._events[evt];if(listeners.fn){if(listeners.fn===fn&&(!once||listeners.once)&&(!context||listeners.context===context)){if(--this._eventsCount===0)this._events=new Events();else delete this._events[evt];}}else{for(var i=0,events=[],length=listeners.length;i<length;i++){if(listeners[i].fn!==fn||once&&!listeners[i].once||context&&listeners[i].context!==context){events.push(listeners[i]);}}if(events.length)this._events[evt]=events.length===1?events[0]:events;else if(--this._eventsCount===0)this._events=new Events();else delete this._events[evt];}return this;};EventEmitter.prototype.removeAllListeners=function removeAllListeners(event){var evt;if(event){evt=prefix?prefix+event:event;if(this._events[evt]){if(--this._eventsCount===0)this._events=new Events();else delete this._events[evt];}}else{this._events=new Events();this._eventsCount=0;}return this;};EventEmitter.prototype.off=EventEmitter.prototype.removeListener;EventEmitter.prototype.addListener=EventEmitter.prototype.on;EventEmitter.prototype.setMaxListeners=function setMaxListeners(){return this;};EventEmitter.prefixed=prefix;EventEmitter.EventEmitter=EventEmitter;if('undefined'!==typeof module){module.exports=EventEmitter;}},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.matchText=exports.matchSpacing=exports.matchNewline=exports.matchBlot=exports.matchAttributor=exports.default=undefined;var _typeof=typeof Symbol==="function"&&typeof Symbol.iterator==="symbol"?function(obj){return typeof obj;}:function(obj){return obj&&typeof Symbol==="function"&&obj.constructor===Symbol&&obj!==Symbol.prototype?"symbol":typeof obj;};var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _extend2=__webpack_require__(3);var _extend3=_interopRequireDefault(_extend2);var _quillDelta=__webpack_require__(2);var _quillDelta2=_interopRequireDefault(_quillDelta);var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _quill=__webpack_require__(5);var _quill2=_interopRequireDefault(_quill);var _logger=__webpack_require__(10);var _logger2=_interopRequireDefault(_logger);var _module=__webpack_require__(9);var _module2=_interopRequireDefault(_module);var _align=__webpack_require__(36);var _background=__webpack_require__(37);var _code=__webpack_require__(13);var _code2=_interopRequireDefault(_code);var _color=__webpack_require__(26);var _direction=__webpack_require__(38);var _font=__webpack_require__(39);var _size=__webpack_require__(40);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var debug=_logger2.default('quill:clipboard');var DOM_KEY='__ql-matcher';var CLIPBOARD_CONFIG=[[Node.TEXT_NODE,matchText],[Node.TEXT_NODE,matchNewline],['br',matchBreak],[Node.ELEMENT_NODE,matchNewline],[Node.ELEMENT_NODE,matchBlot],[Node.ELEMENT_NODE,matchSpacing],[Node.ELEMENT_NODE,matchAttributor],[Node.ELEMENT_NODE,matchStyles],['li',matchIndent],['b',matchAlias.bind(matchAlias,'bold')],['i',matchAlias.bind(matchAlias,'italic')],['style',matchIgnore]];var ATTRIBUTE_ATTRIBUTORS=[_align.AlignAttribute,_direction.DirectionAttribute].reduce(function(memo,attr){memo[attr.keyName]=attr;return memo;},{});var STYLE_ATTRIBUTORS=[_align.AlignStyle,_background.BackgroundStyle,_color.ColorStyle,_direction.DirectionStyle,_font.FontStyle,_size.SizeStyle].reduce(function(memo,attr){memo[attr.keyName]=attr;return memo;},{});var Clipboard=function(_Module){_inherits(Clipboard,_Module);function Clipboard(quill,options){_classCallCheck(this,Clipboard);var _this=_possibleConstructorReturn(this,(Clipboard.__proto__||Object.getPrototypeOf(Clipboard)).call(this,quill,options));_this.quill.root.addEventListener('paste',_this.onPaste.bind(_this));_this.container=_this.quill.addContainer('ql-clipboard');_this.container.setAttribute('contenteditable',true);_this.container.setAttribute('tabindex',-1);_this.matchers=[];CLIPBOARD_CONFIG.concat(_this.options.matchers).forEach(function(_ref){var _ref2=_slicedToArray(_ref,2),selector=_ref2[0],matcher=_ref2[1];if(!options.matchVisual&&matcher===matchSpacing)return;_this.addMatcher(selector,matcher);});return _this;}_createClass(Clipboard,[{key:'addMatcher',value:function addMatcher(selector,matcher){this.matchers.push([selector,matcher]);}},{key:'convert',value:function convert(html){if(typeof html==='string'){this.container.innerHTML=html.replace(/\>\r?\n +\</g,'><');return this.convert();}var formats=this.quill.getFormat(this.quill.selection.savedRange.index);if(formats[_code2.default.blotName]){var text=this.container.innerText;this.container.innerHTML='';return new _quillDelta2.default().insert(text,_defineProperty({},_code2.default.blotName,formats[_code2.default.blotName]));}var _prepareMatching=this.prepareMatching(),_prepareMatching2=_slicedToArray(_prepareMatching,2),elementMatchers=_prepareMatching2[0],textMatchers=_prepareMatching2[1];var delta=traverse(this.container,elementMatchers,textMatchers);if(deltaEndsWith(delta,'\n')&&delta.ops[delta.ops.length-1].attributes==null){delta=delta.compose(new _quillDelta2.default().retain(delta.length()-1).delete(1));}debug.log('convert',this.container.innerHTML,delta);this.container.innerHTML='';return delta;}},{key:'dangerouslyPasteHTML',value:function dangerouslyPasteHTML(index,html){var source=arguments.length>2&&arguments[2]!==undefined?arguments[2]:_quill2.default.sources.API;if(typeof index==='string'){return this.quill.setContents(this.convert(index),html);}else{var paste=this.convert(html);return this.quill.updateContents(new _quillDelta2.default().retain(index).concat(paste),source);}}},{key:'onPaste',value:function onPaste(e){var _this2=this;if(e.defaultPrevented||!this.quill.isEnabled())return;var range=this.quill.getSelection();var delta=new _quillDelta2.default().retain(range.index);var scrollTop=this.quill.scrollingContainer.scrollTop;this.container.focus();this.quill.selection.update(_quill2.default.sources.SILENT);setTimeout(function(){delta=delta.concat(_this2.convert()).delete(range.length);_this2.quill.updateContents(delta,_quill2.default.sources.USER);_this2.quill.setSelection(delta.length()-range.length,_quill2.default.sources.SILENT);_this2.quill.scrollingContainer.scrollTop=scrollTop;_this2.quill.focus();},1);}},{key:'prepareMatching',value:function prepareMatching(){var _this3=this;var elementMatchers=[],textMatchers=[];this.matchers.forEach(function(pair){var _pair=_slicedToArray(pair,2),selector=_pair[0],matcher=_pair[1];switch(selector){case Node.TEXT_NODE:textMatchers.push(matcher);break;case Node.ELEMENT_NODE:elementMatchers.push(matcher);break;default:[].forEach.call(_this3.container.querySelectorAll(selector),function(node){node[DOM_KEY]=node[DOM_KEY]||[];node[DOM_KEY].push(matcher);});break;}});return [elementMatchers,textMatchers];}}]);return Clipboard;}(_module2.default);Clipboard.DEFAULTS={matchers:[],matchVisual:true};function applyFormat(delta,format,value){if((typeof format==='undefined'?'undefined':_typeof(format))==='object'){return Object.keys(format).reduce(function(delta,key){return applyFormat(delta,key,format[key]);},delta);}else{return delta.reduce(function(delta,op){if(op.attributes&&op.attributes[format]){return delta.push(op);}else{return delta.insert(op.insert,_extend3.default({},_defineProperty({},format,value),op.attributes));}},new _quillDelta2.default());}}function computeStyle(node){if(node.nodeType!==Node.ELEMENT_NODE)return {};var DOM_KEY='__ql-computed-style';return node[DOM_KEY]||(node[DOM_KEY]=window.getComputedStyle(node));}function deltaEndsWith(delta,text){var endText="";for(var i=delta.ops.length-1;i>=0&&endText.length<text.length;--i){var op=delta.ops[i];if(typeof op.insert!=='string')break;endText=op.insert+endText;}return endText.slice(-1*text.length)===text;}function isLine(node){if(node.childNodes.length===0)return false;var style=computeStyle(node);return ['block','list-item'].indexOf(style.display)>-1;}function traverse(node,elementMatchers,textMatchers){if(node.nodeType===node.TEXT_NODE){return textMatchers.reduce(function(delta,matcher){return matcher(node,delta);},new _quillDelta2.default());}else if(node.nodeType===node.ELEMENT_NODE){return [].reduce.call(node.childNodes||[],function(delta,childNode){var childrenDelta=traverse(childNode,elementMatchers,textMatchers);if(childNode.nodeType===node.ELEMENT_NODE){childrenDelta=elementMatchers.reduce(function(childrenDelta,matcher){return matcher(childNode,childrenDelta);},childrenDelta);childrenDelta=(childNode[DOM_KEY]||[]).reduce(function(childrenDelta,matcher){return matcher(childNode,childrenDelta);},childrenDelta);}return delta.concat(childrenDelta);},new _quillDelta2.default());}else{return new _quillDelta2.default();}}function matchAlias(format,node,delta){return applyFormat(delta,format,true);}function matchAttributor(node,delta){var attributes=_parchment2.default.Attributor.Attribute.keys(node);var classes=_parchment2.default.Attributor.Class.keys(node);var styles=_parchment2.default.Attributor.Style.keys(node);var formats={};attributes.concat(classes).concat(styles).forEach(function(name){var attr=_parchment2.default.query(name,_parchment2.default.Scope.ATTRIBUTE);if(attr!=null){formats[attr.attrName]=attr.value(node);if(formats[attr.attrName])return;}attr=ATTRIBUTE_ATTRIBUTORS[name];if(attr!=null&&attr.attrName===name){formats[attr.attrName]=attr.value(node)||undefined;}attr=STYLE_ATTRIBUTORS[name];if(attr!=null&&attr.attrName===name){attr=STYLE_ATTRIBUTORS[name];formats[attr.attrName]=attr.value(node)||undefined;}});if(Object.keys(formats).length>0){delta=applyFormat(delta,formats);}return delta;}function matchBlot(node,delta){var match=_parchment2.default.query(node);if(match==null)return delta;if(match.prototype instanceof _parchment2.default.Embed){var embed={};var value=match.value(node);if(value!=null){embed[match.blotName]=value;delta=new _quillDelta2.default().insert(embed,match.formats(node));}}else if(typeof match.formats==='function'){delta=applyFormat(delta,match.blotName,match.formats(node));}return delta;}function matchBreak(node,delta){if(!deltaEndsWith(delta,'\n')){delta.insert('\n');}return delta;}function matchIgnore(){return new _quillDelta2.default();}function matchIndent(node,delta){var match=_parchment2.default.query(node);if(match==null||match.blotName!=='list-item'||!deltaEndsWith(delta,'\n')){return delta;}var indent=-1,parent=node.parentNode;while(!parent.classList.contains('ql-clipboard')){if((_parchment2.default.query(parent)||{}).blotName==='list'){indent+=1;}parent=parent.parentNode;}if(indent<=0)return delta;return delta.compose(new _quillDelta2.default().retain(delta.length()-1).retain(1,{indent:indent}));}function matchNewline(node,delta){if(!deltaEndsWith(delta,'\n')){if(isLine(node)||delta.length()>0&&node.nextSibling&&isLine(node.nextSibling)){delta.insert('\n');}}return delta;}function matchSpacing(node,delta){if(isLine(node)&&node.nextElementSibling!=null&&!deltaEndsWith(delta,'\n\n')){var nodeHeight=node.offsetHeight+parseFloat(computeStyle(node).marginTop)+parseFloat(computeStyle(node).marginBottom);if(node.nextElementSibling.offsetTop>node.offsetTop+nodeHeight*1.5){delta.insert('\n');}}return delta;}function matchStyles(node,delta){var formats={};var style=node.style||{};if(style.fontStyle&&computeStyle(node).fontStyle==='italic'){formats.italic=true;}if(style.fontWeight&&(computeStyle(node).fontWeight.startsWith('bold')||parseInt(computeStyle(node).fontWeight)>=700)){formats.bold=true;}if(Object.keys(formats).length>0){delta=applyFormat(delta,formats);}if(parseFloat(style.textIndent||0)>0){delta=new _quillDelta2.default().insert('\t').concat(delta);}return delta;}function matchText(node,delta){var text=node.data;if(node.parentNode.tagName==='O:P'){return delta.insert(text.trim());}if(text.trim().length===0&&node.parentNode.classList.contains('ql-clipboard')){return delta;}if(!computeStyle(node.parentNode).whiteSpace.startsWith('pre')){var replacer=function replacer(collapse,match){match=match.replace(/[^\u00a0]/g,'');return match.length<1&&collapse?' ':match;};text=text.replace(/\r\n/g,' ').replace(/\n/g,' ');text=text.replace(/\s\s+/g,replacer.bind(replacer,true));if(node.previousSibling==null&&isLine(node.parentNode)||node.previousSibling!=null&&isLine(node.previousSibling)){text=text.replace(/^\s+/,replacer.bind(replacer,false));}if(node.nextSibling==null&&isLine(node.parentNode)||node.nextSibling!=null&&isLine(node.nextSibling)){text=text.replace(/\s+$/,replacer.bind(replacer,false));}}return delta.insert(text);}exports.default=Clipboard;exports.matchAttributor=matchAttributor;exports.matchBlot=matchBlot;exports.matchNewline=matchNewline;exports.matchSpacing=matchSpacing;exports.matchText=matchText;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _inline=__webpack_require__(6);var _inline2=_interopRequireDefault(_inline);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Bold=function(_Inline){_inherits(Bold,_Inline);function Bold(){_classCallCheck(this,Bold);return _possibleConstructorReturn(this,(Bold.__proto__||Object.getPrototypeOf(Bold)).apply(this,arguments));}_createClass(Bold,[{key:'optimize',value:function optimize(context){_get(Bold.prototype.__proto__||Object.getPrototypeOf(Bold.prototype),'optimize',this).call(this,context);if(this.domNode.tagName!==this.statics.tagName[0]){this.replaceWith(this.statics.blotName);}}}],[{key:'create',value:function create(){return _get(Bold.__proto__||Object.getPrototypeOf(Bold),'create',this).call(this);}},{key:'formats',value:function formats(){return true;}}]);return Bold;}(_inline2.default);Bold.blotName='bold';Bold.tagName=['STRONG','B'];exports.default=Bold;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.addControls=exports.default=undefined;var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _quillDelta=__webpack_require__(2);var _quillDelta2=_interopRequireDefault(_quillDelta);var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _quill=__webpack_require__(5);var _quill2=_interopRequireDefault(_quill);var _logger=__webpack_require__(10);var _logger2=_interopRequireDefault(_logger);var _module=__webpack_require__(9);var _module2=_interopRequireDefault(_module);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var debug=_logger2.default('quill:toolbar');var Toolbar=function(_Module){_inherits(Toolbar,_Module);function Toolbar(quill,options){_classCallCheck(this,Toolbar);var _this=_possibleConstructorReturn(this,(Toolbar.__proto__||Object.getPrototypeOf(Toolbar)).call(this,quill,options));if(Array.isArray(_this.options.container)){var container=document.createElement('div');addControls(container,_this.options.container);quill.container.parentNode.insertBefore(container,quill.container);_this.container=container;}else if(typeof _this.options.container==='string'){_this.container=document.querySelector(_this.options.container);}else{_this.container=_this.options.container;}if(!(_this.container instanceof HTMLElement)){var _ret;return _ret=debug.error('Container required for toolbar',_this.options),_possibleConstructorReturn(_this,_ret);}_this.container.classList.add('ql-toolbar');_this.controls=[];_this.handlers={};Object.keys(_this.options.handlers).forEach(function(format){_this.addHandler(format,_this.options.handlers[format]);});[].forEach.call(_this.container.querySelectorAll('button, select'),function(input){_this.attach(input);});_this.quill.on(_quill2.default.events.EDITOR_CHANGE,function(type,range){if(type===_quill2.default.events.SELECTION_CHANGE){_this.update(range);}});_this.quill.on(_quill2.default.events.SCROLL_OPTIMIZE,function(){var _this$quill$selection=_this.quill.selection.getRange(),_this$quill$selection2=_slicedToArray(_this$quill$selection,1),range=_this$quill$selection2[0];_this.update(range);});return _this;}_createClass(Toolbar,[{key:'addHandler',value:function addHandler(format,handler){this.handlers[format]=handler;}},{key:'attach',value:function attach(input){var _this2=this;var format=[].find.call(input.classList,function(className){return className.indexOf('ql-')===0;});if(!format)return;format=format.slice('ql-'.length);if(input.tagName==='BUTTON'){input.setAttribute('type','button');}if(this.handlers[format]==null){if(this.quill.scroll.whitelist!=null&&this.quill.scroll.whitelist[format]==null){debug.warn('ignoring attaching to disabled format',format,input);return;}if(_parchment2.default.query(format)==null){debug.warn('ignoring attaching to nonexistent format',format,input);return;}}var eventName=input.tagName==='SELECT'?'change':'click';input.addEventListener(eventName,function(e){var value=void 0;if(input.tagName==='SELECT'){if(input.selectedIndex<0)return;var selected=input.options[input.selectedIndex];if(selected.hasAttribute('selected')){value=false;}else{value=selected.value||false;}}else{if(input.classList.contains('ql-active')){value=false;}else{value=input.value||!input.hasAttribute('value');}e.preventDefault();}_this2.quill.focus();var _quill$selection$getR=_this2.quill.selection.getRange(),_quill$selection$getR2=_slicedToArray(_quill$selection$getR,1),range=_quill$selection$getR2[0];if(_this2.handlers[format]!=null){_this2.handlers[format].call(_this2,value);}else if(_parchment2.default.query(format).prototype instanceof _parchment2.default.Embed){value=prompt('Enter '+format);if(!value)return;_this2.quill.updateContents(new _quillDelta2.default().retain(range.index).delete(range.length).insert(_defineProperty({},format,value)),_quill2.default.sources.USER);}else{_this2.quill.format(format,value,_quill2.default.sources.USER);}_this2.update(range);});this.controls.push([format,input]);}},{key:'update',value:function update(range){var formats=range==null?{}:this.quill.getFormat(range);this.controls.forEach(function(pair){var _pair=_slicedToArray(pair,2),format=_pair[0],input=_pair[1];if(input.tagName==='SELECT'){var option=void 0;if(range==null){option=null;}else if(formats[format]==null){option=input.querySelector('option[selected]');}else if(!Array.isArray(formats[format])){var value=formats[format];if(typeof value==='string'){value=value.replace(/\"/g,'\\"');}option=input.querySelector('option[value="'+value+'"]');}if(option==null){input.value='';input.selectedIndex=-1;}else{option.selected=true;}}else{if(range==null){input.classList.remove('ql-active');}else if(input.hasAttribute('value')){var isActive=formats[format]===input.getAttribute('value')||formats[format]!=null&&formats[format].toString()===input.getAttribute('value')||formats[format]==null&&!input.getAttribute('value');input.classList.toggle('ql-active',isActive);}else{input.classList.toggle('ql-active',formats[format]!=null);}}});}}]);return Toolbar;}(_module2.default);Toolbar.DEFAULTS={};function addButton(container,format,value){var input=document.createElement('button');input.setAttribute('type','button');input.classList.add('ql-'+format);if(value!=null){input.value=value;}container.appendChild(input);}function addControls(container,groups){if(!Array.isArray(groups[0])){groups=[groups];}groups.forEach(function(controls){var group=document.createElement('span');group.classList.add('ql-formats');controls.forEach(function(control){if(typeof control==='string'){addButton(group,control);}else{var format=Object.keys(control)[0];var value=control[format];if(Array.isArray(value)){addSelect(group,format,value);}else{addButton(group,format,value);}}});container.appendChild(group);});}function addSelect(container,format,values){var input=document.createElement('select');input.classList.add('ql-'+format);values.forEach(function(value){var option=document.createElement('option');if(value!==false){option.setAttribute('value',value);}else{option.setAttribute('selected','selected');}input.appendChild(option);});container.appendChild(input);}Toolbar.DEFAULTS={container:null,handlers:{clean:function clean(){var _this3=this;var range=this.quill.getSelection();if(range==null)return;if(range.length==0){var formats=this.quill.getFormat();Object.keys(formats).forEach(function(name){if(_parchment2.default.query(name,_parchment2.default.Scope.INLINE)!=null){_this3.quill.format(name,false);}});}else{this.quill.removeFormat(range,_quill2.default.sources.USER);}},direction:function direction(value){var align=this.quill.getFormat()['align'];if(value==='rtl'&&align==null){this.quill.format('align','right',_quill2.default.sources.USER);}else if(!value&&align==='right'){this.quill.format('align',false,_quill2.default.sources.USER);}this.quill.format('direction',value,_quill2.default.sources.USER);},indent:function indent(value){var range=this.quill.getSelection();var formats=this.quill.getFormat(range);var indent=parseInt(formats.indent||0);if(value==='+1'||value==='-1'){var modifier=value==='+1'?1:-1;if(formats.direction==='rtl')modifier*=-1;this.quill.format('indent',indent+modifier,_quill2.default.sources.USER);}},link:function link(value){if(value===true){value=prompt('Enter link URL:');}this.quill.format('link',value,_quill2.default.sources.USER);},list:function list(value){var range=this.quill.getSelection();var formats=this.quill.getFormat(range);if(value==='check'){if(formats['list']==='checked'||formats['list']==='unchecked'){this.quill.format('list',false,_quill2.default.sources.USER);}else{this.quill.format('list','unchecked',_quill2.default.sources.USER);}}else{this.quill.format('list',value,_quill2.default.sources.USER);}}}};exports.default=Toolbar;exports.addControls=addControls;},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <polyline class=\"ql-even ql-stroke\" points=\"5 7 3 9 5 11\"></polyline> <polyline class=\"ql-even ql-stroke\" points=\"13 7 15 9 13 11\"></polyline> <line class=ql-stroke x1=10 x2=8 y1=5 y2=13></line> </svg>";},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _picker=__webpack_require__(28);var _picker2=_interopRequireDefault(_picker);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var ColorPicker=function(_Picker){_inherits(ColorPicker,_Picker);function ColorPicker(select,label){_classCallCheck(this,ColorPicker);var _this=_possibleConstructorReturn(this,(ColorPicker.__proto__||Object.getPrototypeOf(ColorPicker)).call(this,select));_this.label.innerHTML=label;_this.container.classList.add('ql-color-picker');[].slice.call(_this.container.querySelectorAll('.ql-picker-item'),0,7).forEach(function(item){item.classList.add('ql-primary');});return _this;}_createClass(ColorPicker,[{key:'buildItem',value:function buildItem(option){var item=_get(ColorPicker.prototype.__proto__||Object.getPrototypeOf(ColorPicker.prototype),'buildItem',this).call(this,option);item.style.backgroundColor=option.getAttribute('value')||'';return item;}},{key:'selectItem',value:function selectItem(item,trigger){_get(ColorPicker.prototype.__proto__||Object.getPrototypeOf(ColorPicker.prototype),'selectItem',this).call(this,item,trigger);var colorLabel=this.label.querySelector('.ql-color-label');var value=item?item.getAttribute('data-value')||'':'';if(colorLabel){if(colorLabel.tagName==='line'){colorLabel.style.stroke=value;}else{colorLabel.style.fill=value;}}}}]);return ColorPicker;}(_picker2.default);exports.default=ColorPicker;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _picker=__webpack_require__(28);var _picker2=_interopRequireDefault(_picker);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var IconPicker=function(_Picker){_inherits(IconPicker,_Picker);function IconPicker(select,icons){_classCallCheck(this,IconPicker);var _this=_possibleConstructorReturn(this,(IconPicker.__proto__||Object.getPrototypeOf(IconPicker)).call(this,select));_this.container.classList.add('ql-icon-picker');[].forEach.call(_this.container.querySelectorAll('.ql-picker-item'),function(item){item.innerHTML=icons[item.getAttribute('data-value')||''];});_this.defaultItem=_this.container.querySelector('.ql-selected');_this.selectItem(_this.defaultItem);return _this;}_createClass(IconPicker,[{key:'selectItem',value:function selectItem(item,trigger){_get(IconPicker.prototype.__proto__||Object.getPrototypeOf(IconPicker.prototype),'selectItem',this).call(this,item,trigger);item=item||this.defaultItem;this.label.innerHTML=item.innerHTML;}}]);return IconPicker;}(_picker2.default);exports.default=IconPicker;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}var Tooltip=function(){function Tooltip(quill,boundsContainer){var _this=this;_classCallCheck(this,Tooltip);this.quill=quill;this.boundsContainer=boundsContainer||document.body;this.root=quill.addContainer('ql-tooltip');this.root.innerHTML=this.constructor.TEMPLATE;if(this.quill.root===this.quill.scrollingContainer){this.quill.root.addEventListener('scroll',function(){_this.root.style.marginTop=-1*_this.quill.root.scrollTop+'px';});}this.hide();}_createClass(Tooltip,[{key:'hide',value:function hide(){this.root.classList.add('ql-hidden');}},{key:'position',value:function position(reference){var left=reference.left+reference.width/2-this.root.offsetWidth/2;var top=reference.bottom+this.quill.root.scrollTop;this.root.style.left=left+'px';this.root.style.top=top+'px';this.root.classList.remove('ql-flip');var containerBounds=this.boundsContainer.getBoundingClientRect();var rootBounds=this.root.getBoundingClientRect();var shift=0;if(rootBounds.right>containerBounds.right){shift=containerBounds.right-rootBounds.right;this.root.style.left=left+shift+'px';}if(rootBounds.left<containerBounds.left){shift=containerBounds.left-rootBounds.left;this.root.style.left=left+shift+'px';}if(rootBounds.bottom>containerBounds.bottom){var height=rootBounds.bottom-rootBounds.top;var verticalShift=reference.bottom-reference.top+height;this.root.style.top=top-verticalShift+'px';this.root.classList.add('ql-flip');}return shift;}},{key:'show',value:function show(){this.root.classList.remove('ql-editing');this.root.classList.remove('ql-hidden');}}]);return Tooltip;}();exports.default=Tooltip;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _slicedToArray=function(){function sliceIterator(arr,i){var _arr=[];var _n=true;var _d=false;var _e=undefined;try{for(var _i=arr[Symbol.iterator](),_s;!(_n=(_s=_i.next()).done);_n=true){_arr.push(_s.value);if(i&&_arr.length===i)break;}}catch(err){_d=true;_e=err;}finally{try{if(!_n&&_i["return"])_i["return"]();}finally{if(_d)throw _e;}}return _arr;}return function(arr,i){if(Array.isArray(arr)){return arr;}else if(Symbol.iterator in Object(arr)){return sliceIterator(arr,i);}else{throw new TypeError("Invalid attempt to destructure non-iterable instance");}};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _extend=__webpack_require__(3);var _extend2=_interopRequireDefault(_extend);var _emitter=__webpack_require__(8);var _emitter2=_interopRequireDefault(_emitter);var _base=__webpack_require__(43);var _base2=_interopRequireDefault(_base);var _link=__webpack_require__(27);var _link2=_interopRequireDefault(_link);var _selection=__webpack_require__(15);var _icons=__webpack_require__(41);var _icons2=_interopRequireDefault(_icons);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var TOOLBAR_CONFIG=[[{header:['1','2','3',false]}],['bold','italic','underline','link'],[{list:'ordered'},{list:'bullet'}],['clean']];var SnowTheme=function(_BaseTheme){_inherits(SnowTheme,_BaseTheme);function SnowTheme(quill,options){_classCallCheck(this,SnowTheme);if(options.modules.toolbar!=null&&options.modules.toolbar.container==null){options.modules.toolbar.container=TOOLBAR_CONFIG;}var _this=_possibleConstructorReturn(this,(SnowTheme.__proto__||Object.getPrototypeOf(SnowTheme)).call(this,quill,options));_this.quill.container.classList.add('ql-snow');return _this;}_createClass(SnowTheme,[{key:'extendToolbar',value:function extendToolbar(toolbar){toolbar.container.classList.add('ql-snow');this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')),_icons2.default);this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')),_icons2.default);this.tooltip=new SnowTooltip(this.quill,this.options.bounds);if(toolbar.container.querySelector('.ql-link')){this.quill.keyboard.addBinding({key:'K',shortKey:true},function(range,context){toolbar.handlers['link'].call(toolbar,!context.format.link);});}}}]);return SnowTheme;}(_base2.default);SnowTheme.DEFAULTS=_extend2.default(true,{},_base2.default.DEFAULTS,{modules:{toolbar:{handlers:{link:function link(value){if(value){var range=this.quill.getSelection();if(range==null||range.length==0)return;var preview=this.quill.getText(range);if(/^\S+@\S+\.\S+$/.test(preview)&&preview.indexOf('mailto:')!==0){preview='mailto:'+preview;}var tooltip=this.quill.theme.tooltip;tooltip.edit('link',preview);}else{this.quill.format('link',false);}}}}}});var SnowTooltip=function(_BaseTooltip){_inherits(SnowTooltip,_BaseTooltip);function SnowTooltip(quill,bounds){_classCallCheck(this,SnowTooltip);var _this2=_possibleConstructorReturn(this,(SnowTooltip.__proto__||Object.getPrototypeOf(SnowTooltip)).call(this,quill,bounds));_this2.preview=_this2.root.querySelector('a.ql-preview');return _this2;}_createClass(SnowTooltip,[{key:'listen',value:function listen(){var _this3=this;_get(SnowTooltip.prototype.__proto__||Object.getPrototypeOf(SnowTooltip.prototype),'listen',this).call(this);this.root.querySelector('a.ql-action').addEventListener('click',function(event){if(_this3.root.classList.contains('ql-editing')){_this3.save();}else{_this3.edit('link',_this3.preview.textContent);}event.preventDefault();});this.root.querySelector('a.ql-remove').addEventListener('click',function(event){if(_this3.linkRange!=null){var range=_this3.linkRange;_this3.restoreFocus();_this3.quill.formatText(range,'link',false,_emitter2.default.sources.USER);delete _this3.linkRange;}event.preventDefault();_this3.hide();});this.quill.on(_emitter2.default.events.SELECTION_CHANGE,function(range,oldRange,source){if(range==null)return;if(range.length===0&&source===_emitter2.default.sources.USER){var _quill$scroll$descend=_this3.quill.scroll.descendant(_link2.default,range.index),_quill$scroll$descend2=_slicedToArray(_quill$scroll$descend,2),link=_quill$scroll$descend2[0],offset=_quill$scroll$descend2[1];if(link!=null){_this3.linkRange=new _selection.Range(range.index-offset,link.length());var preview=_link2.default.formats(link.domNode);_this3.preview.textContent=preview;_this3.preview.setAttribute('href',preview);_this3.show();_this3.position(_this3.quill.getBounds(_this3.linkRange));return;}}else{delete _this3.linkRange;}_this3.hide();});}},{key:'show',value:function show(){_get(SnowTooltip.prototype.__proto__||Object.getPrototypeOf(SnowTooltip.prototype),'show',this).call(this);this.root.removeAttribute('data-mode');}}]);return SnowTooltip;}(_base.BaseTooltip);SnowTooltip.TEMPLATE=['<a class="ql-preview" target="_blank" href="about:blank"></a>','<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">','<a class="ql-action"></a>','<a class="ql-remove"></a>'].join('');exports.default=SnowTheme;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _core=__webpack_require__(29);var _core2=_interopRequireDefault(_core);var _align=__webpack_require__(36);var _direction=__webpack_require__(38);var _indent=__webpack_require__(64);var _blockquote=__webpack_require__(65);var _blockquote2=_interopRequireDefault(_blockquote);var _header=__webpack_require__(66);var _header2=_interopRequireDefault(_header);var _list=__webpack_require__(67);var _list2=_interopRequireDefault(_list);var _background=__webpack_require__(37);var _color=__webpack_require__(26);var _font=__webpack_require__(39);var _size=__webpack_require__(40);var _bold=__webpack_require__(56);var _bold2=_interopRequireDefault(_bold);var _italic=__webpack_require__(68);var _italic2=_interopRequireDefault(_italic);var _link=__webpack_require__(27);var _link2=_interopRequireDefault(_link);var _script=__webpack_require__(69);var _script2=_interopRequireDefault(_script);var _strike=__webpack_require__(70);var _strike2=_interopRequireDefault(_strike);var _underline=__webpack_require__(71);var _underline2=_interopRequireDefault(_underline);var _image=__webpack_require__(72);var _image2=_interopRequireDefault(_image);var _video=__webpack_require__(73);var _video2=_interopRequireDefault(_video);var _code=__webpack_require__(13);var _code2=_interopRequireDefault(_code);var _formula=__webpack_require__(74);var _formula2=_interopRequireDefault(_formula);var _syntax=__webpack_require__(75);var _syntax2=_interopRequireDefault(_syntax);var _toolbar=__webpack_require__(57);var _toolbar2=_interopRequireDefault(_toolbar);var _icons=__webpack_require__(41);var _icons2=_interopRequireDefault(_icons);var _picker=__webpack_require__(28);var _picker2=_interopRequireDefault(_picker);var _colorPicker=__webpack_require__(59);var _colorPicker2=_interopRequireDefault(_colorPicker);var _iconPicker=__webpack_require__(60);var _iconPicker2=_interopRequireDefault(_iconPicker);var _tooltip=__webpack_require__(61);var _tooltip2=_interopRequireDefault(_tooltip);var _bubble=__webpack_require__(108);var _bubble2=_interopRequireDefault(_bubble);var _snow=__webpack_require__(62);var _snow2=_interopRequireDefault(_snow);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}_core2.default.register({'attributors/attribute/direction':_direction.DirectionAttribute,'attributors/class/align':_align.AlignClass,'attributors/class/background':_background.BackgroundClass,'attributors/class/color':_color.ColorClass,'attributors/class/direction':_direction.DirectionClass,'attributors/class/font':_font.FontClass,'attributors/class/size':_size.SizeClass,'attributors/style/align':_align.AlignStyle,'attributors/style/background':_background.BackgroundStyle,'attributors/style/color':_color.ColorStyle,'attributors/style/direction':_direction.DirectionStyle,'attributors/style/font':_font.FontStyle,'attributors/style/size':_size.SizeStyle},true);_core2.default.register({'formats/align':_align.AlignClass,'formats/direction':_direction.DirectionClass,'formats/indent':_indent.IndentClass,'formats/background':_background.BackgroundStyle,'formats/color':_color.ColorStyle,'formats/font':_font.FontClass,'formats/size':_size.SizeClass,'formats/blockquote':_blockquote2.default,'formats/code-block':_code2.default,'formats/header':_header2.default,'formats/list':_list2.default,'formats/bold':_bold2.default,'formats/code':_code.Code,'formats/italic':_italic2.default,'formats/link':_link2.default,'formats/script':_script2.default,'formats/strike':_strike2.default,'formats/underline':_underline2.default,'formats/image':_image2.default,'formats/video':_video2.default,'formats/list/item':_list.ListItem,'modules/formula':_formula2.default,'modules/syntax':_syntax2.default,'modules/toolbar':_toolbar2.default,'themes/bubble':_bubble2.default,'themes/snow':_snow2.default,'ui/icons':_icons2.default,'ui/picker':_picker2.default,'ui/icon-picker':_iconPicker2.default,'ui/color-picker':_colorPicker2.default,'ui/tooltip':_tooltip2.default},true);exports.default=_core2.default;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.IndentClass=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var IdentAttributor=function(_Parchment$Attributor){_inherits(IdentAttributor,_Parchment$Attributor);function IdentAttributor(){_classCallCheck(this,IdentAttributor);return _possibleConstructorReturn(this,(IdentAttributor.__proto__||Object.getPrototypeOf(IdentAttributor)).apply(this,arguments));}_createClass(IdentAttributor,[{key:'add',value:function add(node,value){if(value==='+1'||value==='-1'){var indent=this.value(node)||0;value=value==='+1'?indent+1:indent-1;}if(value===0){this.remove(node);return true;}else{return _get(IdentAttributor.prototype.__proto__||Object.getPrototypeOf(IdentAttributor.prototype),'add',this).call(this,node,value);}}},{key:'canAdd',value:function canAdd(node,value){return _get(IdentAttributor.prototype.__proto__||Object.getPrototypeOf(IdentAttributor.prototype),'canAdd',this).call(this,node,value)||_get(IdentAttributor.prototype.__proto__||Object.getPrototypeOf(IdentAttributor.prototype),'canAdd',this).call(this,node,parseInt(value));}},{key:'value',value:function value(node){return parseInt(_get(IdentAttributor.prototype.__proto__||Object.getPrototypeOf(IdentAttributor.prototype),'value',this).call(this,node))||undefined;}}]);return IdentAttributor;}(_parchment2.default.Attributor.Class);var IndentClass=new IdentAttributor('indent','ql-indent',{scope:_parchment2.default.Scope.BLOCK,whitelist:[1,2,3,4,5,6,7,8]});exports.IndentClass=IndentClass;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _block=__webpack_require__(4);var _block2=_interopRequireDefault(_block);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Blockquote=function(_Block){_inherits(Blockquote,_Block);function Blockquote(){_classCallCheck(this,Blockquote);return _possibleConstructorReturn(this,(Blockquote.__proto__||Object.getPrototypeOf(Blockquote)).apply(this,arguments));}return Blockquote;}(_block2.default);Blockquote.blotName='blockquote';Blockquote.tagName='blockquote';exports.default=Blockquote;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _block=__webpack_require__(4);var _block2=_interopRequireDefault(_block);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Header=function(_Block){_inherits(Header,_Block);function Header(){_classCallCheck(this,Header);return _possibleConstructorReturn(this,(Header.__proto__||Object.getPrototypeOf(Header)).apply(this,arguments));}_createClass(Header,null,[{key:'formats',value:function formats(domNode){return this.tagName.indexOf(domNode.tagName)+1;}}]);return Header;}(_block2.default);Header.blotName='header';Header.tagName=['H1','H2','H3','H4','H5','H6'];exports.default=Header;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.ListItem=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _block=__webpack_require__(4);var _block2=_interopRequireDefault(_block);var _container=__webpack_require__(24);var _container2=_interopRequireDefault(_container);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _defineProperty(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var ListItem=function(_Block){_inherits(ListItem,_Block);function ListItem(){_classCallCheck(this,ListItem);return _possibleConstructorReturn(this,(ListItem.__proto__||Object.getPrototypeOf(ListItem)).apply(this,arguments));}_createClass(ListItem,[{key:'format',value:function format(name,value){if(name===List.blotName&&!value){this.replaceWith(_parchment2.default.create(this.statics.scope));}else{_get(ListItem.prototype.__proto__||Object.getPrototypeOf(ListItem.prototype),'format',this).call(this,name,value);}}},{key:'remove',value:function remove(){if(this.prev==null&&this.next==null){this.parent.remove();}else{_get(ListItem.prototype.__proto__||Object.getPrototypeOf(ListItem.prototype),'remove',this).call(this);}}},{key:'replaceWith',value:function replaceWith(name,value){this.parent.isolate(this.offset(this.parent),this.length());if(name===this.parent.statics.blotName){this.parent.replaceWith(name,value);return this;}else{this.parent.unwrap();return _get(ListItem.prototype.__proto__||Object.getPrototypeOf(ListItem.prototype),'replaceWith',this).call(this,name,value);}}}],[{key:'formats',value:function formats(domNode){return domNode.tagName===this.tagName?undefined:_get(ListItem.__proto__||Object.getPrototypeOf(ListItem),'formats',this).call(this,domNode);}}]);return ListItem;}(_block2.default);ListItem.blotName='list-item';ListItem.tagName='LI';var List=function(_Container){_inherits(List,_Container);_createClass(List,null,[{key:'create',value:function create(value){var tagName=value==='ordered'?'OL':'UL';var node=_get(List.__proto__||Object.getPrototypeOf(List),'create',this).call(this,tagName);if(value==='checked'||value==='unchecked'){node.setAttribute('data-checked',value==='checked');}return node;}},{key:'formats',value:function formats(domNode){if(domNode.tagName==='OL')return 'ordered';if(domNode.tagName==='UL'){if(domNode.hasAttribute('data-checked')){return domNode.getAttribute('data-checked')==='true'?'checked':'unchecked';}else{return 'bullet';}}return undefined;}}]);function List(domNode){_classCallCheck(this,List);var _this2=_possibleConstructorReturn(this,(List.__proto__||Object.getPrototypeOf(List)).call(this,domNode));var listEventHandler=function listEventHandler(e){if(e.target.parentNode!==domNode)return;var format=_this2.statics.formats(domNode);var blot=_parchment2.default.find(e.target);if(format==='checked'){blot.format('list','unchecked');}else if(format==='unchecked'){blot.format('list','checked');}};domNode.addEventListener('touchstart',listEventHandler);domNode.addEventListener('mousedown',listEventHandler);return _this2;}_createClass(List,[{key:'format',value:function format(name,value){if(this.children.length>0){this.children.tail.format(name,value);}}},{key:'formats',value:function formats(){return _defineProperty({},this.statics.blotName,this.statics.formats(this.domNode));}},{key:'insertBefore',value:function insertBefore(blot,ref){if(blot instanceof ListItem){_get(List.prototype.__proto__||Object.getPrototypeOf(List.prototype),'insertBefore',this).call(this,blot,ref);}else{var index=ref==null?this.length():ref.offset(this);var after=this.split(index);after.parent.insertBefore(blot,after);}}},{key:'optimize',value:function optimize(context){_get(List.prototype.__proto__||Object.getPrototypeOf(List.prototype),'optimize',this).call(this,context);var next=this.next;if(next!=null&&next.prev===this&&next.statics.blotName===this.statics.blotName&&next.domNode.tagName===this.domNode.tagName&&next.domNode.getAttribute('data-checked')===this.domNode.getAttribute('data-checked')){next.moveChildren(this);next.remove();}}},{key:'replace',value:function replace(target){if(target.statics.blotName!==this.statics.blotName){var item=_parchment2.default.create(this.statics.defaultChild);target.moveChildren(item);this.appendChild(item);}_get(List.prototype.__proto__||Object.getPrototypeOf(List.prototype),'replace',this).call(this,target);}}]);return List;}(_container2.default);List.blotName='list';List.scope=_parchment2.default.Scope.BLOCK_BLOT;List.tagName=['OL','UL'];List.defaultChild='list-item';List.allowedChildren=[ListItem];exports.ListItem=ListItem;exports.default=List;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _bold=__webpack_require__(56);var _bold2=_interopRequireDefault(_bold);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Italic=function(_Bold){_inherits(Italic,_Bold);function Italic(){_classCallCheck(this,Italic);return _possibleConstructorReturn(this,(Italic.__proto__||Object.getPrototypeOf(Italic)).apply(this,arguments));}return Italic;}(_bold2.default);Italic.blotName='italic';Italic.tagName=['EM','I'];exports.default=Italic;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _inline=__webpack_require__(6);var _inline2=_interopRequireDefault(_inline);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Script=function(_Inline){_inherits(Script,_Inline);function Script(){_classCallCheck(this,Script);return _possibleConstructorReturn(this,(Script.__proto__||Object.getPrototypeOf(Script)).apply(this,arguments));}_createClass(Script,null,[{key:'create',value:function create(value){if(value==='super'){return document.createElement('sup');}else if(value==='sub'){return document.createElement('sub');}else{return _get(Script.__proto__||Object.getPrototypeOf(Script),'create',this).call(this,value);}}},{key:'formats',value:function formats(domNode){if(domNode.tagName==='SUB')return 'sub';if(domNode.tagName==='SUP')return 'super';return undefined;}}]);return Script;}(_inline2.default);Script.blotName='script';Script.tagName=['SUB','SUP'];exports.default=Script;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _inline=__webpack_require__(6);var _inline2=_interopRequireDefault(_inline);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Strike=function(_Inline){_inherits(Strike,_Inline);function Strike(){_classCallCheck(this,Strike);return _possibleConstructorReturn(this,(Strike.__proto__||Object.getPrototypeOf(Strike)).apply(this,arguments));}return Strike;}(_inline2.default);Strike.blotName='strike';Strike.tagName='S';exports.default=Strike;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _inline=__webpack_require__(6);var _inline2=_interopRequireDefault(_inline);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var Underline=function(_Inline){_inherits(Underline,_Inline);function Underline(){_classCallCheck(this,Underline);return _possibleConstructorReturn(this,(Underline.__proto__||Object.getPrototypeOf(Underline)).apply(this,arguments));}return Underline;}(_inline2.default);Underline.blotName='underline';Underline.tagName='U';exports.default=Underline;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _link=__webpack_require__(27);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var ATTRIBUTES=['alt','height','width'];var Image=function(_Parchment$Embed){_inherits(Image,_Parchment$Embed);function Image(){_classCallCheck(this,Image);return _possibleConstructorReturn(this,(Image.__proto__||Object.getPrototypeOf(Image)).apply(this,arguments));}_createClass(Image,[{key:'format',value:function format(name,value){if(ATTRIBUTES.indexOf(name)>-1){if(value){this.domNode.setAttribute(name,value);}else{this.domNode.removeAttribute(name);}}else{_get(Image.prototype.__proto__||Object.getPrototypeOf(Image.prototype),'format',this).call(this,name,value);}}}],[{key:'create',value:function create(value){var node=_get(Image.__proto__||Object.getPrototypeOf(Image),'create',this).call(this,value);if(typeof value==='string'){node.setAttribute('src',this.sanitize(value));}return node;}},{key:'formats',value:function formats(domNode){return ATTRIBUTES.reduce(function(formats,attribute){if(domNode.hasAttribute(attribute)){formats[attribute]=domNode.getAttribute(attribute);}return formats;},{});}},{key:'match',value:function match(url){return /\.(jpe?g|gif|png)$/.test(url)||/^data:image\/.+;base64/.test(url);}},{key:'sanitize',value:function sanitize(url){return _link.sanitize(url,['http','https','data'])?url:'//:0';}},{key:'value',value:function value(domNode){return domNode.getAttribute('src');}}]);return Image;}(_parchment2.default.Embed);Image.blotName='image';Image.tagName='IMG';exports.default=Image;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _block=__webpack_require__(4);var _link=__webpack_require__(27);var _link2=_interopRequireDefault(_link);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var ATTRIBUTES=['height','width'];var Video=function(_BlockEmbed){_inherits(Video,_BlockEmbed);function Video(){_classCallCheck(this,Video);return _possibleConstructorReturn(this,(Video.__proto__||Object.getPrototypeOf(Video)).apply(this,arguments));}_createClass(Video,[{key:'format',value:function format(name,value){if(ATTRIBUTES.indexOf(name)>-1){if(value){this.domNode.setAttribute(name,value);}else{this.domNode.removeAttribute(name);}}else{_get(Video.prototype.__proto__||Object.getPrototypeOf(Video.prototype),'format',this).call(this,name,value);}}}],[{key:'create',value:function create(value){var node=_get(Video.__proto__||Object.getPrototypeOf(Video),'create',this).call(this,value);node.setAttribute('frameborder','0');node.setAttribute('allowfullscreen',true);node.setAttribute('src',this.sanitize(value));return node;}},{key:'formats',value:function formats(domNode){return ATTRIBUTES.reduce(function(formats,attribute){if(domNode.hasAttribute(attribute)){formats[attribute]=domNode.getAttribute(attribute);}return formats;},{});}},{key:'sanitize',value:function sanitize(url){return _link2.default.sanitize(url);}},{key:'value',value:function value(domNode){return domNode.getAttribute('src');}}]);return Video;}(_block.BlockEmbed);Video.blotName='video';Video.className='ql-video';Video.tagName='IFRAME';exports.default=Video;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.FormulaBlot=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _embed=__webpack_require__(25);var _embed2=_interopRequireDefault(_embed);var _quill=__webpack_require__(5);var _quill2=_interopRequireDefault(_quill);var _module=__webpack_require__(9);var _module2=_interopRequireDefault(_module);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var FormulaBlot=function(_Embed){_inherits(FormulaBlot,_Embed);function FormulaBlot(){_classCallCheck(this,FormulaBlot);return _possibleConstructorReturn(this,(FormulaBlot.__proto__||Object.getPrototypeOf(FormulaBlot)).apply(this,arguments));}_createClass(FormulaBlot,null,[{key:'create',value:function create(value){var node=_get(FormulaBlot.__proto__||Object.getPrototypeOf(FormulaBlot),'create',this).call(this,value);if(typeof value==='string'){window.katex.render(value,node,{throwOnError:false,errorColor:'#f00'});node.setAttribute('data-value',value);}return node;}},{key:'value',value:function value(domNode){return domNode.getAttribute('data-value');}}]);return FormulaBlot;}(_embed2.default);FormulaBlot.blotName='formula';FormulaBlot.className='ql-formula';FormulaBlot.tagName='SPAN';var Formula=function(_Module){_inherits(Formula,_Module);_createClass(Formula,null,[{key:'register',value:function register(){_quill2.default.register(FormulaBlot,true);}}]);function Formula(){_classCallCheck(this,Formula);var _this2=_possibleConstructorReturn(this,(Formula.__proto__||Object.getPrototypeOf(Formula)).call(this));if(window.katex==null){throw new Error('Formula module requires KaTeX.');}return _this2;}return Formula;}(_module2.default);exports.FormulaBlot=FormulaBlot;exports.default=Formula;},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.CodeToken=exports.CodeBlock=undefined;var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _parchment=__webpack_require__(0);var _parchment2=_interopRequireDefault(_parchment);var _quill=__webpack_require__(5);var _quill2=_interopRequireDefault(_quill);var _module=__webpack_require__(9);var _module2=_interopRequireDefault(_module);var _code=__webpack_require__(13);var _code2=_interopRequireDefault(_code);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var SyntaxCodeBlock=function(_CodeBlock){_inherits(SyntaxCodeBlock,_CodeBlock);function SyntaxCodeBlock(){_classCallCheck(this,SyntaxCodeBlock);return _possibleConstructorReturn(this,(SyntaxCodeBlock.__proto__||Object.getPrototypeOf(SyntaxCodeBlock)).apply(this,arguments));}_createClass(SyntaxCodeBlock,[{key:'replaceWith',value:function replaceWith(block){this.domNode.textContent=this.domNode.textContent;this.attach();_get(SyntaxCodeBlock.prototype.__proto__||Object.getPrototypeOf(SyntaxCodeBlock.prototype),'replaceWith',this).call(this,block);}},{key:'highlight',value:function highlight(_highlight){var text=this.domNode.textContent;if(this.cachedText!==text){if(text.trim().length>0||this.cachedText==null){this.domNode.innerHTML=_highlight(text);this.domNode.normalize();this.attach();}this.cachedText=text;}}}]);return SyntaxCodeBlock;}(_code2.default);SyntaxCodeBlock.className='ql-syntax';var CodeToken=new _parchment2.default.Attributor.Class('token','hljs',{scope:_parchment2.default.Scope.INLINE});var Syntax=function(_Module){_inherits(Syntax,_Module);_createClass(Syntax,null,[{key:'register',value:function register(){_quill2.default.register(CodeToken,true);_quill2.default.register(SyntaxCodeBlock,true);}}]);function Syntax(quill,options){_classCallCheck(this,Syntax);var _this2=_possibleConstructorReturn(this,(Syntax.__proto__||Object.getPrototypeOf(Syntax)).call(this,quill,options));if(typeof _this2.options.highlight!=='function'){throw new Error('Syntax module requires highlight.js. Please include the library on the page before Quill.');}var timer=null;_this2.quill.on(_quill2.default.events.SCROLL_OPTIMIZE,function(){clearTimeout(timer);timer=setTimeout(function(){_this2.highlight();timer=null;},_this2.options.interval);});_this2.highlight();return _this2;}_createClass(Syntax,[{key:'highlight',value:function highlight(){var _this3=this;if(this.quill.selection.composing)return;this.quill.update(_quill2.default.sources.USER);var range=this.quill.getSelection();this.quill.scroll.descendants(SyntaxCodeBlock).forEach(function(code){code.highlight(_this3.options.highlight);});this.quill.update(_quill2.default.sources.SILENT);if(range!=null){this.quill.setSelection(range,_quill2.default.sources.SILENT);}}}]);return Syntax;}(_module2.default);Syntax.DEFAULTS={highlight:function(){if(window.hljs==null)return null;return function(text){var result=window.hljs.highlightAuto(text);return result.value;};}(),interval:1000};exports.CodeBlock=SyntaxCodeBlock;exports.CodeToken=CodeToken;exports.default=Syntax;},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=13 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=9 y1=4 y2=4></line> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=14 x2=4 y1=14 y2=14></line> <line class=ql-stroke x1=12 x2=6 y1=4 y2=4></line> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=5 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=9 y1=4 y2=4></line> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=15 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=15 x2=3 y1=14 y2=14></line> <line class=ql-stroke x1=15 x2=3 y1=4 y2=4></line> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <g class=\"ql-fill ql-color-label\"> <polygon points=\"6 6.868 6 6 5 6 5 7 5.942 7 6 6.868\"></polygon> <rect height=1 width=1 x=4 y=4></rect> <polygon points=\"6.817 5 6 5 6 6 6.38 6 6.817 5\"></polygon> <rect height=1 width=1 x=2 y=6></rect> <rect height=1 width=1 x=3 y=5></rect> <rect height=1 width=1 x=4 y=7></rect> <polygon points=\"4 11.439 4 11 3 11 3 12 3.755 12 4 11.439\"></polygon> <rect height=1 width=1 x=2 y=12></rect> <rect height=1 width=1 x=2 y=9></rect> <rect height=1 width=1 x=2 y=15></rect> <polygon points=\"4.63 10 4 10 4 11 4.192 11 4.63 10\"></polygon> <rect height=1 width=1 x=3 y=8></rect> <path d=M10.832,4.2L11,4.582V4H10.708A1.948,1.948,0,0,1,10.832,4.2Z></path> <path d=M7,4.582L7.168,4.2A1.929,1.929,0,0,1,7.292,4H7V4.582Z></path> <path d=M8,13H7.683l-0.351.8a1.933,1.933,0,0,1-.124.2H8V13Z></path> <rect height=1 width=1 x=12 y=2></rect> <rect height=1 width=1 x=11 y=3></rect> <path d=M9,3H8V3.282A1.985,1.985,0,0,1,9,3Z></path> <rect height=1 width=1 x=2 y=3></rect> <rect height=1 width=1 x=6 y=2></rect> <rect height=1 width=1 x=3 y=2></rect> <rect height=1 width=1 x=5 y=3></rect> <rect height=1 width=1 x=9 y=2></rect> <rect height=1 width=1 x=15 y=14></rect> <polygon points=\"13.447 10.174 13.469 10.225 13.472 10.232 13.808 11 14 11 14 10 13.37 10 13.447 10.174\"></polygon> <rect height=1 width=1 x=13 y=7></rect> <rect height=1 width=1 x=15 y=5></rect> <rect height=1 width=1 x=14 y=6></rect> <rect height=1 width=1 x=15 y=8></rect> <rect height=1 width=1 x=14 y=9></rect> <path d=M3.775,14H3v1H4V14.314A1.97,1.97,0,0,1,3.775,14Z></path> <rect height=1 width=1 x=14 y=3></rect> <polygon points=\"12 6.868 12 6 11.62 6 12 6.868\"></polygon> <rect height=1 width=1 x=15 y=2></rect> <rect height=1 width=1 x=12 y=5></rect> <rect height=1 width=1 x=13 y=4></rect> <polygon points=\"12.933 9 13 9 13 8 12.495 8 12.933 9\"></polygon> <rect height=1 width=1 x=9 y=14></rect> <rect height=1 width=1 x=8 y=15></rect> <path d=M6,14.926V15H7V14.316A1.993,1.993,0,0,1,6,14.926Z></path> <rect height=1 width=1 x=5 y=15></rect> <path d=M10.668,13.8L10.317,13H10v1h0.792A1.947,1.947,0,0,1,10.668,13.8Z></path> <rect height=1 width=1 x=11 y=15></rect> <path d=M14.332,12.2a1.99,1.99,0,0,1,.166.8H15V12H14.245Z></path> <rect height=1 width=1 x=14 y=15></rect> <rect height=1 width=1 x=15 y=11></rect> </g> <polyline class=ql-stroke points=\"5.5 13 9 5 12.5 13\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=11 y2=11></line> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=4 y=5></rect> <rect class=\"ql-fill ql-stroke\" height=3 width=3 x=11 y=5></rect> <path class=\"ql-even ql-fill ql-stroke\" d=M7,8c0,4.031-3,5-3,5></path> <path class=\"ql-even ql-fill ql-stroke\" d=M14,8c0,4.031-3,5-3,5></path> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,4H9.5A2.5,2.5,0,0,1,12,6.5v0A2.5,2.5,0,0,1,9.5,9H5A0,0,0,0,1,5,9V4A0,0,0,0,1,5,4Z></path> <path class=ql-stroke d=M5,9h5.5A2.5,2.5,0,0,1,13,11.5v0A2.5,2.5,0,0,1,10.5,14H5a0,0,0,0,1,0,0V9A0,0,0,0,1,5,9Z></path> </svg>";},function(module,exports){module.exports="<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=5 x2=13 y1=3 y2=3></line> <line class=ql-stroke x1=6 x2=9.35 y1=12 y2=3></line> <line class=ql-stroke x1=11 x2=15 y1=11 y2=15></line> <line class=ql-stroke x1=15 x2=11 y1=11 y2=15></line> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=7 x=2 y=14></rect> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=\"ql-color-label ql-stroke ql-transparent\" x1=3 x2=15 y1=15 y2=15></line> <polyline class=ql-stroke points=\"5.5 11 9 3 12.5 11\"></polyline> <line class=ql-stroke x1=11.63 x2=6.38 y1=9 y2=9></line> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"3 11 5 9 3 7 3 11\"></polygon> <line class=\"ql-stroke ql-fill\" x1=15 x2=11 y1=4 y2=4></line> <path class=ql-fill d=M11,3a3,3,0,0,0,0,6h1V3H11Z></path> <rect class=ql-fill height=11 width=1 x=11 y=4></rect> <rect class=ql-fill height=11 width=1 x=13 y=4></rect> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <polygon class=\"ql-stroke ql-fill\" points=\"15 12 13 10 15 8 15 12\"></polygon> <line class=\"ql-stroke ql-fill\" x1=9 x2=5 y1=4 y2=4></line> <path class=ql-fill d=M5,3A3,3,0,0,0,5,9H6V3H5Z></path> <rect class=ql-fill height=11 width=1 x=5 y=4></rect> <rect class=ql-fill height=11 width=1 x=7 y=4></rect> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M14,16H4a1,1,0,0,1,0-2H14A1,1,0,0,1,14,16Z /> <path class=ql-fill d=M14,4H4A1,1,0,0,1,4,2H14A1,1,0,0,1,14,4Z /> <rect class=ql-fill x=3 y=6 width=12 height=6 rx=1 ry=1 /> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M13,16H5a1,1,0,0,1,0-2h8A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H5A1,1,0,0,1,5,2h8A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=2 y=6 width=14 height=6 rx=1 ry=1 /> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15,8H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,8Z /> <path class=ql-fill d=M15,12H13a1,1,0,0,1,0-2h2A1,1,0,0,1,15,12Z /> <path class=ql-fill d=M15,16H5a1,1,0,0,1,0-2H15A1,1,0,0,1,15,16Z /> <path class=ql-fill d=M15,4H5A1,1,0,0,1,5,2H15A1,1,0,0,1,15,4Z /> <rect class=ql-fill x=2 y=6 width=8 height=6 rx=1 ry=1 /> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M5,8H3A1,1,0,0,1,3,6H5A1,1,0,0,1,5,8Z /> <path class=ql-fill d=M5,12H3a1,1,0,0,1,0-2H5A1,1,0,0,1,5,12Z /> <path class=ql-fill d=M13,16H3a1,1,0,0,1,0-2H13A1,1,0,0,1,13,16Z /> <path class=ql-fill d=M13,4H3A1,1,0,0,1,3,2H13A1,1,0,0,1,13,4Z /> <rect class=ql-fill x=8 y=6 width=8 height=6 rx=1 ry=1 transform=\"translate(24 18) rotate(-180)\"/> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M11.759,2.482a2.561,2.561,0,0,0-3.53.607A7.656,7.656,0,0,0,6.8,6.2C6.109,9.188,5.275,14.677,4.15,14.927a1.545,1.545,0,0,0-1.3-.933A0.922,0.922,0,0,0,2,15.036S1.954,16,4.119,16s3.091-2.691,3.7-5.553c0.177-.826.36-1.726,0.554-2.6L8.775,6.2c0.381-1.421.807-2.521,1.306-2.676a1.014,1.014,0,0,0,1.02.56A0.966,0.966,0,0,0,11.759,2.482Z></path> <rect class=ql-fill height=1.6 rx=0.8 ry=0.8 width=5 x=5.15 y=6.2></rect> <path class=ql-fill d=M13.663,12.027a1.662,1.662,0,0,1,.266-0.276q0.193,0.069.456,0.138a2.1,2.1,0,0,0,.535.069,1.075,1.075,0,0,0,.767-0.3,1.044,1.044,0,0,0,.314-0.8,0.84,0.84,0,0,0-.238-0.619,0.8,0.8,0,0,0-.594-0.239,1.154,1.154,0,0,0-.781.3,4.607,4.607,0,0,0-.781,1q-0.091.15-.218,0.346l-0.246.38c-0.068-.288-0.137-0.582-0.212-0.885-0.459-1.847-2.494-.984-2.941-0.8-0.482.2-.353,0.647-0.094,0.529a0.869,0.869,0,0,1,1.281.585c0.217,0.751.377,1.436,0.527,2.038a5.688,5.688,0,0,1-.362.467,2.69,2.69,0,0,1-.264.271q-0.221-.08-0.471-0.147a2.029,2.029,0,0,0-.522-0.066,1.079,1.079,0,0,0-.768.3A1.058,1.058,0,0,0,9,15.131a0.82,0.82,0,0,0,.832.852,1.134,1.134,0,0,0,.787-0.3,5.11,5.11,0,0,0,.776-0.993q0.141-.219.215-0.34c0.046-.076.122-0.194,0.223-0.346a2.786,2.786,0,0,0,.918,1.726,2.582,2.582,0,0,0,2.376-.185c0.317-.181.212-0.565,0-0.494A0.807,0.807,0,0,1,14.176,15a5.159,5.159,0,0,1-.913-2.446l0,0Q13.487,12.24,13.663,12.027Z></path> </svg>";},function(module,exports){module.exports="<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M10,4V14a1,1,0,0,1-2,0V10H3v4a1,1,0,0,1-2,0V4A1,1,0,0,1,3,4V8H8V4a1,1,0,0,1,2,0Zm6.06787,9.209H14.98975V7.59863a.54085.54085,0,0,0-.605-.60547h-.62744a1.01119,1.01119,0,0,0-.748.29688L11.645,8.56641a.5435.5435,0,0,0-.022.8584l.28613.30762a.53861.53861,0,0,0,.84717.0332l.09912-.08789a1.2137,1.2137,0,0,0,.2417-.35254h.02246s-.01123.30859-.01123.60547V13.209H12.041a.54085.54085,0,0,0-.605.60547v.43945a.54085.54085,0,0,0,.605.60547h4.02686a.54085.54085,0,0,0,.605-.60547v-.43945A.54085.54085,0,0,0,16.06787,13.209Z /> </svg>";},function(module,exports){module.exports="<svg viewBox=\"0 0 18 18\"> <path class=ql-fill d=M16.73975,13.81445v.43945a.54085.54085,0,0,1-.605.60547H11.855a.58392.58392,0,0,1-.64893-.60547V14.0127c0-2.90527,3.39941-3.42187,3.39941-4.55469a.77675.77675,0,0,0-.84717-.78125,1.17684,1.17684,0,0,0-.83594.38477c-.2749.26367-.561.374-.85791.13184l-.4292-.34082c-.30811-.24219-.38525-.51758-.1543-.81445a2.97155,2.97155,0,0,1,2.45361-1.17676,2.45393,2.45393,0,0,1,2.68408,2.40918c0,2.45312-3.1792,2.92676-3.27832,3.93848h2.79443A.54085.54085,0,0,1,16.73975,13.81445ZM9,3A.99974.99974,0,0,0,8,4V8H3V4A1,1,0,0,0,1,4V14a1,1,0,0,0,2,0V10H8v4a1,1,0,0,0,2,0V4A.99974.99974,0,0,0,9,3Z /> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=13 y1=4 y2=4></line> <line class=ql-stroke x1=5 x2=11 y1=14 y2=14></line> <line class=ql-stroke x1=8 x2=10 y1=14 y2=4></line> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=10 width=12 x=3 y=4></rect> <circle class=ql-fill cx=6 cy=7 r=1></circle> <polyline class=\"ql-even ql-fill\" points=\"5 12 5 11 7 9 8 10 11 7 13 9 13 12 5 12\"></polyline> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=\"ql-fill ql-stroke\" points=\"3 7 3 11 5 9 3 7\"></polyline> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=3 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"5 7 5 11 3 9 5 7\"></polyline> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=11 y1=7 y2=11></line> <path class=\"ql-even ql-stroke\" d=M8.9,4.577a3.476,3.476,0,0,1,.36,4.679A3.476,3.476,0,0,1,4.577,8.9C3.185,7.5,2.035,6.4,4.217,4.217S7.5,3.185,8.9,4.577Z></path> <path class=\"ql-even ql-stroke\" d=M13.423,9.1a3.476,3.476,0,0,0-4.679-.36,3.476,3.476,0,0,0,.36,4.679c1.392,1.392,2.5,2.542,4.679.36S14.815,10.5,13.423,9.1Z></path> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=7 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=7 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=7 x2=15 y1=14 y2=14></line> <line class=\"ql-stroke ql-thin\" x1=2.5 x2=4.5 y1=5.5 y2=5.5></line> <path class=ql-fill d=M3.5,6A0.5,0.5,0,0,1,3,5.5V3.085l-0.276.138A0.5,0.5,0,0,1,2.053,3c-0.124-.247-0.023-0.324.224-0.447l1-.5A0.5,0.5,0,0,1,4,2.5v3A0.5,0.5,0,0,1,3.5,6Z></path> <path class=\"ql-stroke ql-thin\" d=M4.5,10.5h-2c0-.234,1.85-1.076,1.85-2.234A0.959,0.959,0,0,0,2.5,8.156></path> <path class=\"ql-stroke ql-thin\" d=M2.5,14.846a0.959,0.959,0,0,0,1.85-.109A0.7,0.7,0,0,0,3.75,14a0.688,0.688,0,0,0,.6-0.736,0.959,0.959,0,0,0-1.85-.109></path> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=6 x2=15 y1=4 y2=4></line> <line class=ql-stroke x1=6 x2=15 y1=9 y2=9></line> <line class=ql-stroke x1=6 x2=15 y1=14 y2=14></line> <line class=ql-stroke x1=3 x2=3 y1=4 y2=4></line> <line class=ql-stroke x1=3 x2=3 y1=9 y2=9></line> <line class=ql-stroke x1=3 x2=3 y1=14 y2=14></line> </svg>";},function(module,exports){module.exports="<svg class=\"\" viewbox=\"0 0 18 18\"> <line class=ql-stroke x1=9 x2=15 y1=4 y2=4></line> <polyline class=ql-stroke points=\"3 4 4 5 6 3\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=14 y2=14></line> <polyline class=ql-stroke points=\"3 14 4 15 6 13\"></polyline> <line class=ql-stroke x1=9 x2=15 y1=9 y2=9></line> <polyline class=ql-stroke points=\"3 9 4 10 6 8\"></polyline> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,15H13.861a3.858,3.858,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.921,1.921,0,0,0,12.021,11.7a0.50013,0.50013,0,1,0,.957.291h0a0.914,0.914,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.076-1.16971,1.86982-1.93971,2.43082A1.45639,1.45639,0,0,0,12,15.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,15Z /> <path class=ql-fill d=M9.65,5.241a1,1,0,0,0-1.409.108L6,7.964,3.759,5.349A1,1,0,0,0,2.192,6.59178Q2.21541,6.6213,2.241,6.649L4.684,9.5,2.241,12.35A1,1,0,0,0,3.71,13.70722q0.02557-.02768.049-0.05722L6,11.036,8.241,13.65a1,1,0,1,0,1.567-1.24277Q9.78459,12.3777,9.759,12.35L7.316,9.5,9.759,6.651A1,1,0,0,0,9.65,5.241Z /> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-fill d=M15.5,7H13.861a4.015,4.015,0,0,0,1.914-2.975,1.8,1.8,0,0,0-1.6-1.751A1.922,1.922,0,0,0,12.021,3.7a0.5,0.5,0,1,0,.957.291,0.917,0.917,0,0,1,1.053-.725,0.81,0.81,0,0,1,.744.762c0,1.077-1.164,1.925-1.934,2.486A1.423,1.423,0,0,0,12,7.5a0.5,0.5,0,0,0,.5.5h3A0.5,0.5,0,0,0,15.5,7Z /> <path class=ql-fill d=M9.651,5.241a1,1,0,0,0-1.41.108L6,7.964,3.759,5.349a1,1,0,1,0-1.519,1.3L4.683,9.5,2.241,12.35a1,1,0,1,0,1.519,1.3L6,11.036,8.241,13.65a1,1,0,0,0,1.519-1.3L7.317,9.5,9.759,6.651A1,1,0,0,0,9.651,5.241Z /> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <line class=\"ql-stroke ql-thin\" x1=15.5 x2=2.5 y1=8.5 y2=9.5></line> <path class=ql-fill d=M9.007,8C6.542,7.791,6,7.519,6,6.5,6,5.792,7.283,5,9,5c1.571,0,2.765.679,2.969,1.309a1,1,0,0,0,1.9-.617C13.356,4.106,11.354,3,9,3,6.2,3,4,4.538,4,6.5a3.2,3.2,0,0,0,.5,1.843Z></path> <path class=ql-fill d=M8.984,10C11.457,10.208,12,10.479,12,11.5c0,0.708-1.283,1.5-3,1.5-1.571,0-2.765-.679-2.969-1.309a1,1,0,1,0-1.9.617C4.644,13.894,6.646,15,9,15c2.8,0,5-1.538,5-3.5a3.2,3.2,0,0,0-.5-1.843Z></path> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <path class=ql-stroke d=M5,3V9a4.012,4.012,0,0,0,4,4H9a4.012,4.012,0,0,0,4-4V3></path> <rect class=ql-fill height=1 rx=0.5 ry=0.5 width=12 x=3 y=15></rect> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <rect class=ql-stroke height=12 width=12 x=3 y=3></rect> <rect class=ql-fill height=12 width=1 x=5 y=3></rect> <rect class=ql-fill height=12 width=1 x=12 y=3></rect> <rect class=ql-fill height=2 width=8 x=5 y=8></rect> <rect class=ql-fill height=1 width=3 x=3 y=5></rect> <rect class=ql-fill height=1 width=3 x=3 y=7></rect> <rect class=ql-fill height=1 width=3 x=3 y=10></rect> <rect class=ql-fill height=1 width=3 x=3 y=12></rect> <rect class=ql-fill height=1 width=3 x=12 y=5></rect> <rect class=ql-fill height=1 width=3 x=12 y=7></rect> <rect class=ql-fill height=1 width=3 x=12 y=10></rect> <rect class=ql-fill height=1 width=3 x=12 y=12></rect> </svg>";},function(module,exports){module.exports="<svg viewbox=\"0 0 18 18\"> <polygon class=ql-stroke points=\"7 11 9 13 11 11 7 11\"></polygon> <polygon class=ql-stroke points=\"7 7 9 5 11 7 7 7\"></polygon> </svg>";},function(module,exports,__webpack_require__){Object.defineProperty(exports,"__esModule",{value:true});exports.default=exports.BubbleTooltip=undefined;var _get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var _createClass=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var _extend=__webpack_require__(3);var _extend2=_interopRequireDefault(_extend);var _emitter=__webpack_require__(8);var _emitter2=_interopRequireDefault(_emitter);var _base=__webpack_require__(43);var _base2=_interopRequireDefault(_base);var _selection=__webpack_require__(15);var _icons=__webpack_require__(41);var _icons2=_interopRequireDefault(_icons);function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}function _classCallCheck(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}}function _possibleConstructorReturn(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;}function _inherits(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;}var TOOLBAR_CONFIG=[['bold','italic','link'],[{header:1},{header:2},'blockquote']];var BubbleTheme=function(_BaseTheme){_inherits(BubbleTheme,_BaseTheme);function BubbleTheme(quill,options){_classCallCheck(this,BubbleTheme);if(options.modules.toolbar!=null&&options.modules.toolbar.container==null){options.modules.toolbar.container=TOOLBAR_CONFIG;}var _this=_possibleConstructorReturn(this,(BubbleTheme.__proto__||Object.getPrototypeOf(BubbleTheme)).call(this,quill,options));_this.quill.container.classList.add('ql-bubble');return _this;}_createClass(BubbleTheme,[{key:'extendToolbar',value:function extendToolbar(toolbar){this.tooltip=new BubbleTooltip(this.quill,this.options.bounds);this.tooltip.root.appendChild(toolbar.container);this.buildButtons([].slice.call(toolbar.container.querySelectorAll('button')),_icons2.default);this.buildPickers([].slice.call(toolbar.container.querySelectorAll('select')),_icons2.default);}}]);return BubbleTheme;}(_base2.default);BubbleTheme.DEFAULTS=_extend2.default(true,{},_base2.default.DEFAULTS,{modules:{toolbar:{handlers:{link:function link(value){if(!value){this.quill.format('link',false);}else{this.quill.theme.tooltip.edit();}}}}}});var BubbleTooltip=function(_BaseTooltip){_inherits(BubbleTooltip,_BaseTooltip);function BubbleTooltip(quill,bounds){_classCallCheck(this,BubbleTooltip);var _this2=_possibleConstructorReturn(this,(BubbleTooltip.__proto__||Object.getPrototypeOf(BubbleTooltip)).call(this,quill,bounds));_this2.quill.on(_emitter2.default.events.EDITOR_CHANGE,function(type,range,oldRange,source){if(type!==_emitter2.default.events.SELECTION_CHANGE)return;if(range!=null&&range.length>0&&source===_emitter2.default.sources.USER){_this2.show();_this2.root.style.left='0px';_this2.root.style.width='';_this2.root.style.width=_this2.root.offsetWidth+'px';var lines=_this2.quill.getLines(range.index,range.length);if(lines.length===1){_this2.position(_this2.quill.getBounds(range));}else{var lastLine=lines[lines.length-1];var index=_this2.quill.getIndex(lastLine);var length=Math.min(lastLine.length()-1,range.index+range.length-index);var _bounds=_this2.quill.getBounds(new _selection.Range(index,length));_this2.position(_bounds);}}else if(document.activeElement!==_this2.textbox&&_this2.quill.hasFocus()){_this2.hide();}});return _this2;}_createClass(BubbleTooltip,[{key:'listen',value:function listen(){var _this3=this;_get(BubbleTooltip.prototype.__proto__||Object.getPrototypeOf(BubbleTooltip.prototype),'listen',this).call(this);this.root.querySelector('.ql-close').addEventListener('click',function(){_this3.root.classList.remove('ql-editing');});this.quill.on(_emitter2.default.events.SCROLL_OPTIMIZE,function(){setTimeout(function(){if(_this3.root.classList.contains('ql-hidden'))return;var range=_this3.quill.getSelection();if(range!=null){_this3.position(_this3.quill.getBounds(range));}},1);});}},{key:'cancel',value:function cancel(){this.show();}},{key:'position',value:function position(reference){var shift=_get(BubbleTooltip.prototype.__proto__||Object.getPrototypeOf(BubbleTooltip.prototype),'position',this).call(this,reference);var arrow=this.root.querySelector('.ql-tooltip-arrow');arrow.style.marginLeft='';if(shift===0)return shift;arrow.style.marginLeft=-1*shift-arrow.offsetWidth/2+'px';}}]);return BubbleTooltip;}(_base.BaseTooltip);BubbleTooltip.TEMPLATE=['<span class="ql-tooltip-arrow"></span>','<div class="ql-tooltip-editor">','<input type="text" data-formula="e=mc^2" data-link="https://quilljs.com" data-video="Embed URL">','<a class="ql-close"></a>','</div>'].join('');exports.BubbleTooltip=BubbleTooltip;exports.default=BubbleTheme;},function(module,exports,__webpack_require__){module.exports=__webpack_require__(63);}])["default"];});});var Quill$1=unwrapExports(quill);var classCallCheck$1=function(instance,Constructor){if(!(instance instanceof Constructor)){throw new TypeError("Cannot call a class as a function");}};var createClass$1=function(){function defineProperties(target,props){for(var i=0;i<props.length;i++){var descriptor=props[i];descriptor.enumerable=descriptor.enumerable||false;descriptor.configurable=true;if("value"in descriptor)descriptor.writable=true;Object.defineProperty(target,descriptor.key,descriptor);}}return function(Constructor,protoProps,staticProps){if(protoProps)defineProperties(Constructor.prototype,protoProps);if(staticProps)defineProperties(Constructor,staticProps);return Constructor;};}();var defineProperty=function(obj,key,value){if(key in obj){Object.defineProperty(obj,key,{value:value,enumerable:true,configurable:true,writable:true});}else{obj[key]=value;}return obj;};var get=function get(object,property,receiver){if(object===null)object=Function.prototype;var desc=Object.getOwnPropertyDescriptor(object,property);if(desc===undefined){var parent=Object.getPrototypeOf(object);if(parent===null){return undefined;}else{return get(parent,property,receiver);}}else if("value"in desc){return desc.value;}else{var getter=desc.get;if(getter===undefined){return undefined;}return getter.call(receiver);}};var inherits=function(subClass,superClass){if(typeof superClass!=="function"&&superClass!==null){throw new TypeError("Super expression must either be null or a function, not "+typeof superClass);}subClass.prototype=Object.create(superClass&&superClass.prototype,{constructor:{value:subClass,enumerable:false,writable:true,configurable:true}});if(superClass)Object.setPrototypeOf?Object.setPrototypeOf(subClass,superClass):subClass.__proto__=superClass;};var possibleConstructorReturn=function(self,call){if(!self){throw new ReferenceError("this hasn't been initialised - super() hasn't been called");}return call&&(typeof call==="object"||typeof call==="function")?call:self;};var Inline=Quill$1.import('blots/inline');var BoldBlot=function(_Inline){inherits(BoldBlot,_Inline);function BoldBlot(){classCallCheck$1(this,BoldBlot);return possibleConstructorReturn(this,(BoldBlot.__proto__||Object.getPrototypeOf(BoldBlot)).apply(this,arguments));}return BoldBlot;}(Inline);BoldBlot.blotName='bold';BoldBlot.tagName='b';var Inline$1=Quill$1.import('blots/inline');var ItalicBlot=function(_Inline){inherits(ItalicBlot,_Inline);function ItalicBlot(){classCallCheck$1(this,ItalicBlot);return possibleConstructorReturn(this,(ItalicBlot.__proto__||Object.getPrototypeOf(ItalicBlot)).apply(this,arguments));}return ItalicBlot;}(Inline$1);ItalicBlot.blotName='italic';ItalicBlot.tagName='i';var BlockEmbed=Quill$1.import('blots/block/embed');var Divider=function(_BlockEmbed){inherits(Divider,_BlockEmbed);function Divider(){classCallCheck$1(this,Divider);return possibleConstructorReturn(this,(Divider.__proto__||Object.getPrototypeOf(Divider)).apply(this,arguments));}return Divider;}(BlockEmbed);Divider.blotName='divider';Divider.tagName='hr';var BlockEmbed$1=Quill$1.import('blots/block/embed');var SUPPORTED_ATTRS=["accept","action","align","alt","autocomplete","background","bgcolor","border","cellpadding","cellspacing","checked","cite","class","clear","color","cols","colspan","coords","datetime","default","dir","disabled","download","enctype","face","for","headers","height","hidden","high","href","hreflang","id","ismap","label","lang","list","loop","low","max","maxlength","media","method","min","multiple","name","noshade","novalidate","nowrap","open","optimum","pattern","placeholder","poster","preload","pubdate","radiogroup","readonly","rel","required","rev","reversed","rowspan","spellcheck","scope","selected","shape","size","span","srclang","start","src","step","style","summary","tabindex","target","title","type","usemap","valign","value","width","xmlns"];var Table=function(_BlockEmbed){inherits(Table,_BlockEmbed);function Table(){classCallCheck$1(this,Table);return possibleConstructorReturn(this,(Table.__proto__||Object.getPrototypeOf(Table)).apply(this,arguments));}createClass$1(Table,null,[{key:'create',value:function create(value){var node=get(Table.__proto__||Object.getPrototypeOf(Table),'create',this).call(this,value);node.innerHTML=value.innerHTML;for(var attr in value.attributes){if(value.attributes[attr]!==null){node.setAttribute(attr,value.attributes[attr]);}}return node;}},{key:'value',value:function value(node){var ret={attributes:{}};if(node.tagName==='TABLE'){SUPPORTED_ATTRS.forEach(function(attr){if(node[attr]){ret.attributes[attr]=node.getAttribute(attr);}});ret.innerHTML=node.innerHTML;}return ret;}}]);return Table;}(BlockEmbed$1);Table.blotName='table';Table.tagName='TABLE';Table.className='ql-table-blob';var Inline$2=Quill$1.import('blots/inline');var Abbr=function(_Inline){inherits(Abbr,_Inline);function Abbr(){classCallCheck$1(this,Abbr);return possibleConstructorReturn(this,(Abbr.__proto__||Object.getPrototypeOf(Abbr)).apply(this,arguments));}createClass$1(Abbr,null,[{key:'create',value:function create(value){var node=get(Abbr.__proto__||Object.getPrototypeOf(Abbr),'create',this).call(this);if(typeof value==='string'){node.setAttribute('title',value);}return node;}},{key:'formats',value:function formats(node){var title=node.getAttribute('title');if(title){return title;}else{return true;}}}]);return Abbr;}(Inline$2);Abbr.blotName='abbr';Abbr.tagName='ABBR';var Inline$3=Quill$1.import('blots/inline');var Small=function(_Inline){inherits(Small,_Inline);function Small(){classCallCheck$1(this,Small);return possibleConstructorReturn(this,(Small.__proto__||Object.getPrototypeOf(Small)).apply(this,arguments));}return Small;}(Inline$3);Small.blotName='small';Small.tagName='small';var Inline$4=Quill$1.import('blots/inline');var Big=function(_Inline){inherits(Big,_Inline);function Big(){classCallCheck$1(this,Big);return possibleConstructorReturn(this,(Big.__proto__||Object.getPrototypeOf(Big)).apply(this,arguments));}return Big;}(Inline$4);Big.blotName='big';Big.tagName='big';var Inline$5=Quill$1.import('blots/inline');var Cite=function(_Inline){inherits(Cite,_Inline);function Cite(){classCallCheck$1(this,Cite);return possibleConstructorReturn(this,(Cite.__proto__||Object.getPrototypeOf(Cite)).apply(this,arguments));}return Cite;}(Inline$5);Cite.blotName='cite';Cite.tagName='cite';var Block=Quill$1.import('blots/block');var Address=function(_Block){inherits(Address,_Block);function Address(){classCallCheck$1(this,Address);return possibleConstructorReturn(this,(Address.__proto__||Object.getPrototypeOf(Address)).apply(this,arguments));}return Address;}(Block);Address.blotName='address';Address.tagName='ADDRESS';var Inline$6=Quill$1.import('blots/inline');var Del=function(_Inline){inherits(Del,_Inline);function Del(){classCallCheck$1(this,Del);return possibleConstructorReturn(this,(Del.__proto__||Object.getPrototypeOf(Del)).apply(this,arguments));}return Del;}(Inline$6);Del.blotName='del';Del.tagName='DEL';var Inline$7=Quill$1.import('blots/inline');var Q=function(_Inline){inherits(Q,_Inline);function Q(){classCallCheck$1(this,Q);return possibleConstructorReturn(this,(Q.__proto__||Object.getPrototypeOf(Q)).apply(this,arguments));}return Q;}(Inline$7);Q.blotName='q';Q.tagName='Q';var Inline$8=Quill$1.import('blots/inline');var Samp=function(_Inline){inherits(Samp,_Inline);function Samp(){classCallCheck$1(this,Samp);return possibleConstructorReturn(this,(Samp.__proto__||Object.getPrototypeOf(Samp)).apply(this,arguments));}return Samp;}(Inline$8);Samp.blotName='samp';Samp.tagName='SAMP';var Inline$9=Quill$1.import('blots/inline');var Var=function(_Inline){inherits(Var,_Inline);function Var(){classCallCheck$1(this,Var);return possibleConstructorReturn(this,(Var.__proto__||Object.getPrototypeOf(Var)).apply(this,arguments));}return Var;}(Inline$9);Var.blotName='var';Var.tagName='VAR';var Inline$10=Quill$1.import('blots/inline');var Ins=function(_Inline){inherits(Ins,_Inline);function Ins(){classCallCheck$1(this,Ins);return possibleConstructorReturn(this,(Ins.__proto__||Object.getPrototypeOf(Ins)).apply(this,arguments));}return Ins;}(Inline$10);Ins.blotName='ins';Ins.tagName='INS';var Inline$11=Quill$1.import('blots/inline');var Kbd=function(_Inline){inherits(Kbd,_Inline);function Kbd(){classCallCheck$1(this,Kbd);return possibleConstructorReturn(this,(Kbd.__proto__||Object.getPrototypeOf(Kbd)).apply(this,arguments));}return Kbd;}(Inline$11);Kbd.blotName='kbd';Kbd.tagName='KBD';var Parchment=Quill$1.import('parchment');var config={scope:Parchment.Scope.INLINE};var FontStyleAttributor=function(_Parchment$Attributor){inherits(FontStyleAttributor,_Parchment$Attributor);function FontStyleAttributor(){classCallCheck$1(this,FontStyleAttributor);return possibleConstructorReturn(this,(FontStyleAttributor.__proto__||Object.getPrototypeOf(FontStyleAttributor)).apply(this,arguments));}return FontStyleAttributor;}(Parchment.Attributor.Style);var FontStyle$1=new FontStyleAttributor('font','font-family',config);var Parchment$1=Quill$1.import('parchment');var Block$1=Quill$1.import('blots/block');var Container=Quill$1.import('blots/container');var List=Quill$1.import('formats/list');var ListItem=Quill$1.import('formats/list/item');var Dd=function(_Block){inherits(Dd,_Block);function Dd(){classCallCheck$1(this,Dd);return possibleConstructorReturn(this,(Dd.__proto__||Object.getPrototypeOf(Dd)).apply(this,arguments));}createClass$1(Dd,[{key:'format',value:function format(name,value){if(name===Dl.blotName&&!value){this.replaceWith(Parchment$1.create(this.statics.scope));}else{get(Dd.prototype.__proto__||Object.getPrototypeOf(Dd.prototype),'format',this).call(this,name,value);}}},{key:'remove',value:function remove(){if(this.prev==null&&this.next==null){this.parent.remove();}else{get(Dd.prototype.__proto__||Object.getPrototypeOf(Dd.prototype),'remove',this).call(this);}}}],[{key:'formats',value:function formats(domNode){return domNode.tagName;}},{key:'create',value:function create(value){var node=get(Dd.__proto__||Object.getPrototypeOf(Dd),'create',this).call(this,value);return node;}}]);return Dd;}(Block$1);Dd.blotName='dd';Dd.tagName='DD';var Dt=function(_Dd){inherits(Dt,_Dd);function Dt(){classCallCheck$1(this,Dt);return possibleConstructorReturn(this,(Dt.__proto__||Object.getPrototypeOf(Dt)).apply(this,arguments));}return Dt;}(Dd);Dt.blotName='dt';Dt.tagName='DT';var Dl=function(_Container){inherits(Dl,_Container);createClass$1(Dl,null,[{key:'create',value:function create(value){var node=get(Dl.__proto__||Object.getPrototypeOf(Dl),'create',this).call(this,value);return node;}},{key:'formats',value:function formats(domNode){return domNode.tagName.toLowerCase();}}]);function Dl(domNode){classCallCheck$1(this,Dl);return possibleConstructorReturn(this,(Dl.__proto__||Object.getPrototypeOf(Dl)).call(this,domNode));}createClass$1(Dl,[{key:'format',value:function format(name,value){return defineProperty({},this.statics.blotName,this.statics.formats(this.domNode));}},{key:'formats',value:function formats(domNode){return defineProperty({},this.statics.blotName,this.statics.formats(this.domNode));}},{key:'insertBefore',value:function insertBefore(blot,ref){if(blot instanceof Dd){get(Dl.prototype.__proto__||Object.getPrototypeOf(Dl.prototype),'insertBefore',this).call(this,blot,ref);}else{var index=ref==null?this.length():ref.offset(this);var after=this.split(index);if(after){after.parent.insertBefore(blot,after);}else{this.parent.insertBefore(blot);}}}},{key:'replace',value:function replace(target){var item=void 0;if(target.statics.blotName!==this.statics.blotName){if(target.statics.blotName!==Dd.blotName&&target.statics.blotName!==Dt.blotName){item=Parchment$1.create(this.statics.defaultChild);}else{item=Parchment$1.create(target.statics.blotName);}target.moveChildren(item);this.appendChild(item);}get(Dl.prototype.__proto__||Object.getPrototypeOf(Dl.prototype),'replace',this).call(this,target);}},{key:'remove',value:function remove(){if(this.domNode.parentNode!=null){this.domNode.parentNode.removeChild(this.domNode);}this.detach();}},{key:'optimize',value:function optimize(){get(Dl.prototype.__proto__||Object.getPrototypeOf(Dl.prototype),'optimize',this).call(this);var next=this.next;if(next!=null&&next.prev===this&&next.statics.blotName===this.statics.blotName&&next.domNode.tagName===this.domNode.tagName){next.moveChildren(this);next.remove();}}}]);return Dl;}(Container);Dl.blotName='dl';Dl.tagName='DL';Dl.scope=Parchment$1.Scope.BLOCK_BLOT;Dl.defaultChild='dt';Dl.allowedChildren=[Dt,Dd];var Image=Quill$1.import('formats/image');var ATTRIBUTES=['alt','height','width','data-fileid'];var SfdcImage=function(_Image){inherits(SfdcImage,_Image);function SfdcImage(){classCallCheck$1(this,SfdcImage);return possibleConstructorReturn(this,(SfdcImage.__proto__||Object.getPrototypeOf(SfdcImage)).apply(this,arguments));}createClass$1(SfdcImage,[{key:'format',value:function format(name,value){if(ATTRIBUTES.indexOf(name)>-1){if(value){this.domNode.setAttribute(name,value);}else{this.domNode.removeAttribute(name);}}else{get(SfdcImage.prototype.__proto__||Object.getPrototypeOf(SfdcImage.prototype),'format',this).call(this,name,value);}}}],[{key:'formats',value:function formats(domNode){return ATTRIBUTES.reduce(function(formats,attribute){if(domNode.hasAttribute(attribute)){formats[attribute]=domNode.getAttribute(attribute);}return formats;},{});}}]);return SfdcImage;}(Image);SfdcImage.blotName='image';SfdcImage.tagName='IMG';var Block$2=Quill$1.import('blots/block');var Container$1=Quill$1.import('blots/container');var Parchment$2=Quill$1.import('parchment');var QuoteBlock=function(_Block){inherits(QuoteBlock,_Block);function QuoteBlock(){classCallCheck$1(this,QuoteBlock);return possibleConstructorReturn(this,(QuoteBlock.__proto__||Object.getPrototypeOf(QuoteBlock)).apply(this,arguments));}createClass$1(QuoteBlock,[{key:'format',value:function format(name,value){if(name===Blockquote.blotName&&!value){this.replaceWith(Parchment$2.create(this.statics.scope));}else{get(QuoteBlock.prototype.__proto__||Object.getPrototypeOf(QuoteBlock.prototype),'format',this).call(this,name,value);}}},{key:'remove',value:function remove(){if(this.prev==null&&this.next==null){this.parent.remove();}else{get(QuoteBlock.prototype.__proto__||Object.getPrototypeOf(QuoteBlock.prototype),'remove',this).call(this);}}},{key:'replaceWith',value:function replaceWith(name,value){this.parent.isolate(this.offset(this.parent),this.length());if(name===this.parent.statics.blotName){this.parent.replaceWith(name,value);return this;}else{this.parent.unwrap();return get(QuoteBlock.prototype.__proto__||Object.getPrototypeOf(QuoteBlock.prototype),'replaceWith',this).call(this,name,value);}}}],[{key:'formats',value:function formats(domNode){return domNode.tagName===this.tagName?undefined:get(QuoteBlock.__proto__||Object.getPrototypeOf(QuoteBlock),'formats',this).call(this,domNode);}}]);return QuoteBlock;}(Block$2);QuoteBlock.blotName='quote-block';QuoteBlock.className='ql-quote-block';QuoteBlock.tagName=['P','H1','H2'];var Blockquote=function(_Container){inherits(Blockquote,_Container);createClass$1(Blockquote,null,[{key:'create',value:function create(value){var node=get(Blockquote.__proto__||Object.getPrototypeOf(Blockquote),'create',this).call(this,value);return node;}},{key:'formats',value:function formats(domNode){return domNode.tagName.toLowerCase();}}]);function Blockquote(domNode){classCallCheck$1(this,Blockquote);return possibleConstructorReturn(this,(Blockquote.__proto__||Object.getPrototypeOf(Blockquote)).call(this,domNode));}createClass$1(Blockquote,[{key:'format',value:function format(name,value){return defineProperty({},this.statics.blotName,this.statics.formats(this.domNode));}},{key:'formats',value:function formats(domNode){return defineProperty({},this.statics.blotName,this.statics.formats(this.domNode));}},{key:'insertBefore',value:function insertBefore(blot,ref){if(blot instanceof Block$2){get(Blockquote.prototype.__proto__||Object.getPrototypeOf(Blockquote.prototype),'insertBefore',this).call(this,blot,ref);}else{var index=ref==null?this.length():ref.offset(this);var after=this.split(index);after.parent.insertBefore(blot,after);}}},{key:'replace',value:function replace(target){if(target.statics.blotName!==this.statics.blotName){var item=Parchment$2.create(this.statics.defaultChild);target.moveChildren(item);this.appendChild(item);}get(Blockquote.prototype.__proto__||Object.getPrototypeOf(Blockquote.prototype),'replace',this).call(this,target);}},{key:'remove',value:function remove(){if(this.domNode.parentNode!=null){this.domNode.parentNode.removeChild(this.domNode);}this.detach();}},{key:'optimize',value:function optimize(){get(Blockquote.prototype.__proto__||Object.getPrototypeOf(Blockquote.prototype),'optimize',this).call(this);var next=this.next;if(next!=null&&next.prev===this&&next.statics.blotName===this.statics.blotName&&next.domNode.tagName===this.domNode.tagName){next.moveChildren(this);next.remove();}}}]);return Blockquote;}(Container$1);Blockquote.blotName='blockquote';Blockquote.tagName='blockquote';Blockquote.scope=Parchment$2.Scope.BLOCK_BLOT;Blockquote.defaultChild='quote-block';Blockquote.allowedChildren=[QuoteBlock];var Inline$12=Quill$1.import('blots/inline');var Bdo=function(_Inline){inherits(Bdo,_Inline);function Bdo(){classCallCheck$1(this,Bdo);return possibleConstructorReturn(this,(Bdo.__proto__||Object.getPrototypeOf(Bdo)).apply(this,arguments));}createClass$1(Bdo,null,[{key:'create',value:function create(value){var node=get(Bdo.__proto__||Object.getPrototypeOf(Bdo),'create',this).call(this);node.setAttribute('dir',value);return node;}},{key:'formats',value:function formats(node){return node.getAttribute('dir');}}]);return Bdo;}(Inline$12);Bdo.blotName='bdo';Bdo.tagName='BDO';var Inline$13=Quill$1.import('blots/inline');var Dfn=function(_Inline){inherits(Dfn,_Inline);function Dfn(){classCallCheck$1(this,Dfn);return possibleConstructorReturn(this,(Dfn.__proto__||Object.getPrototypeOf(Dfn)).apply(this,arguments));}createClass$1(Dfn,null,[{key:'create',value:function create(value){var node=get(Dfn.__proto__||Object.getPrototypeOf(Dfn),'create',this).call(this);if(typeof value==='string'){node.setAttribute('title',value);}return node;}},{key:'formats',value:function formats(node){var value=node.getAttribute('title');if(value){return value;}else{return true;}}}]);return Dfn;}(Inline$13);Dfn.blotName='dfn';Dfn.tagName='DFN';var Inline$14=Quill$1.import('blots/inline');var Grammarly=function(_Inline){inherits(Grammarly,_Inline);function Grammarly(){classCallCheck$1(this,Grammarly);return possibleConstructorReturn(this,(Grammarly.__proto__||Object.getPrototypeOf(Grammarly)).apply(this,arguments));}return Grammarly;}(Inline$14);Grammarly.tagName='G';Grammarly.blotName='grammarly-inline';Grammarly.className='gr_';var Inline$15=Quill$1.import('blots/inline');var MentionBlot=function(_Inline){inherits(MentionBlot,_Inline);function MentionBlot(){classCallCheck$1(this,MentionBlot);return possibleConstructorReturn(this,(MentionBlot.__proto__||Object.getPrototypeOf(MentionBlot)).apply(this,arguments));}createClass$1(MentionBlot,[{key:'format',value:function format(name,value){if(name==='data-mention'&&value){this.domNode.setAttribute(name,value);}else{get(MentionBlot.prototype.__proto__||Object.getPrototypeOf(MentionBlot.prototype),'format',this).call(this,name,value);}}}],[{key:'create',value:function create(id){var node=get(MentionBlot.__proto__||Object.getPrototypeOf(MentionBlot),'create',this).call(this);node.classList.add('quill_widget_element');node.setAttribute('contenteditable',false);node.setAttribute('tabindex',"-1");node.setAttribute('data-widget','chatterMention');node.setAttribute('data-mention',id);node.addEventListener('keydown',function(event){if(event.keyCode===8||event.keyCode===46){event.preventDefault();var parent=node.parentNode;if(parent){parent.removeChild(node);parent.dispatchEvent(new CustomEvent('deletemention',{bubbles:true}));}}});node.addEventListener('click',function(event){node.focus();node.dispatchEvent(new CustomEvent('clickmention',{bubbles:true}));});return node;}},{key:'formats',value:function formats(domNode){return domNode.getAttribute('data-mention');}}]);return MentionBlot;}(Inline$15);MentionBlot.blotName='mention';MentionBlot.tagName='span';MentionBlot.className='ql-chatter-mention';var BlockEmbed$2=Quill$1.import('blots/block/embed');var CodeSnippet=function(_BlockEmbed){inherits(CodeSnippet,_BlockEmbed);function CodeSnippet(){classCallCheck$1(this,CodeSnippet);return possibleConstructorReturn(this,(CodeSnippet.__proto__||Object.getPrototypeOf(CodeSnippet)).apply(this,arguments));}createClass$1(CodeSnippet,null,[{key:'create',value:function create(data){var node=get(CodeSnippet.__proto__||Object.getPrototypeOf(CodeSnippet),'create',this).call(this);node.setAttribute('contenteditable',false);node.setAttribute('tabindex',"-1");node.classList.add('quill_widget_wrapper');node.classList.add('quill_widget_block');var pre=document.createElement("pre");pre.setAttribute('spellcheck',false);pre.setAttribute('data-widget','codeSnippet');pre.classList.add('quill_widget_element');node.appendChild(pre);var code=document.createElement("code");code.setAttribute('class','language-javascript');data=data.replace(/</g,"&lt;");data=data.replace(/>/g,"&gt;");node.setAttribute("data-code",data);if(window.Aura&&Aura.Quill&&Aura.Quill.Prettify){var highlightedCode=Aura.Quill.Prettify.PR.prettyPrintOne(data,"",true);highlightedCode=highlightedCode.replace(/<li/gi,"<span");highlightedCode=highlightedCode.replace(/<\/li>/gi,"</span>");highlightedCode=highlightedCode.replace(/<ol/gi,"<span");highlightedCode=highlightedCode.replace(/<\/ol>/gi,"</span>");code.innerHTML=highlightedCode;}else{code.innerHTML=data;}pre.appendChild(code);node.addEventListener('keydown',function(event){if(event.keyCode===8||event.keyCode===46){event.preventDefault();event.stopPropagation();node.parentNode.removeChild(node);}});node.addEventListener('click',function(event){event.stopPropagation();node.focus();});return node;}},{key:'value',value:function value(node){if(node.hasAttribute("data-code")){return node.getAttribute("data-code");}return node.innerText;}}]);return CodeSnippet;}(BlockEmbed$2);CodeSnippet.blotName='code-snippet';CodeSnippet.className='ql-codesnippet';CodeSnippet.tagName='pre';var AlignStyle=Quill$1.import('attributors/style/align');var FontStyle=Quill$1.import('attributors/style/font');var SizeStyle=Quill$1.import('attributors/style/size');var ColorStyle=Quill$1.import('attributors/style/color');var Delta=Quill$1.import('delta');SizeStyle.whitelist=null;Quill$1.register(BoldBlot,true);Quill$1.register(ItalicBlot,true);Quill$1.register(AlignStyle,true);Quill$1.register(FontStyle$1,true);Quill$1.register(SizeStyle,true);Quill$1.register(ColorStyle,true);Quill$1.register(SfdcImage,true);Quill$1.register(Blockquote,true);Quill$1.register(QuoteBlock,true);Quill$1.register(Table,true);Quill$1.register(Abbr,true);Quill$1.register(Small,true);Quill$1.register(Big,true);Quill$1.register(Cite,true);Quill$1.register(Address,true);Quill$1.register(Del,true);Quill$1.register(Samp,true);Quill$1.register(Var,true);Quill$1.register(Q,true);Quill$1.register(Ins,true);Quill$1.register(Kbd,true);Quill$1.register(Dt,true);Quill$1.register(Dl,true);Quill$1.register(Dd,true);Quill$1.register(Divider,true);Quill$1.register(Bdo,true);Quill$1.register(Dfn,true);Quill$1.register(Grammarly,true);Quill$1.register(MentionBlot,true);Quill$1.register(CodeSnippet,true);Quill$1.Delta=Delta;var Quill = lwc.registerComponent(Quill$1,{tmpl:_tmpl$1});

    var labelImageSizeExceeded = 'The image exceeded the maximum size of 1 MB.';

    var labelImageUploadFailed = 'There was a problem uploading the file.';

    const Delta$1 = Quill.Delta;
    const ALLOWED_FORMATS_FOR_API = ['align', 'font', 'size'
    /* the following formats are not enabled for 220,
       leaving them here to simplify enabling them
    'link',
    'indent',
    'list',
    'bold',
    'italic',
    'strike',
    'header',
    'direction',
    'code',
    'code-block',
    'color',
    'script',
    'underline',
    'background',*/
    ];
    const ALLOWED_SIZES = [8, 9, 10, 11, 12, 14, 16, 18, 20, 22, 24, 26, 28, 36, 48, 72];
    const FONT_LIST = [{
      label: 'Salesforce Sans',
      value: 'default'
    }, {
      label: 'Arial',
      class: 'sans-serif',
      value: 'sans-serif'
    }, {
      label: 'Courier',
      class: 'courier',
      value: 'courier'
    }, {
      label: 'Verdana',
      class: 'verdana',
      value: 'verdana'
    }, {
      label: 'Tahoma',
      class: 'tahoma',
      value: 'tahoma'
    }, {
      label: 'Garamond',
      class: 'garamond',
      value: 'garamond'
    }, {
      label: 'Times New Roman',
      class: 'serif',
      value: 'serif'
    }];
    const ALLOWED_FONTS = FONT_LIST.map(item => {
      return item.value;
    });
    const ALLOWED_TAGS = ['a', 'abbr', 'acronym', 'address', 'b', 'br', 'big', 'blockquote', 'caption', 'cite', 'code', 'col', 'colgroup', 'del', 'div', 'dl', 'dd', 'dt', 'em', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'hr', 'i', 'img', 'ins', 'kbd', 'li', 'ol', 'p', 'param', 'pre', 'q', 's', 'samp', 'small', 'span', 'strong', 'sub', 'sup', 'table', 'tbody', 'td', 'tfoot', 'th', 'thead', 'tr', 'tt', 'u', 'ul', 'var', 'strike', 'font'];
    const ALLOWED_ATTRS = ['accept', 'action', 'align', 'alt', 'autocomplete', 'background', 'bgcolor', 'border', 'cellpadding', 'cellspacing', 'checked', 'cite', 'class', 'clear', 'color', 'cols', 'colspan', 'coords', 'datetime', 'default', 'dir', 'disabled', 'download', 'enctype', 'face', 'for', 'headers', 'height', 'hidden', 'high', 'href', 'hreflang', 'id', 'ismap', 'label', 'lang', 'list', 'loop', 'low', 'max', 'maxlength', 'media', 'method', 'min', 'multiple', 'name', 'noshade', 'novalidate', 'nowrap', 'open', 'optimum', 'pattern', 'placeholder', 'poster', 'preload', 'pubdate', 'radiogroup', 'readonly', 'rel', 'required', 'rev', 'reversed', 'rows', 'rowspan', 'spellcheck', 'scope', 'selected', 'shape', 'size', 'span', 'srclang', 'start', 'src', 'step', 'style', 'summary', 'tabindex', 'target', 'title', 'type', 'usemap', 'valign', 'value', 'width', 'xmlns', // for custom blots
    'data-fileid'];
    const IMAGE_MAX_SIZE = 1048576; // Max size of image: 1MB - 1048576 bytes

    function _sanitize(val) {
      return configProvider.sanitizeDOM(val, {
        ALLOWED_TAGS,
        ALLOWED_ATTRS
      });
    }

    function computeIndentLevel(node) {
      const indentMatch = node.className.match(/ql-indent-([0-9]+)/);

      if (indentMatch) {
        return parseInt(indentMatch[1], 10);
      }

      return 0;
    }
    /**
     * Turn a list with ql- classes into a nested list.
     * Recursive!
     *
     * @param  {Array} list         an array of list items
     * @param  {Number} indentLevel the current indent level
     * @param  {String} type        ol or ul
     * @return {HTMLElement}        A DOM element
     */


    function nestList(list, indentLevel, type) {
      let level;
      let thisNode;
      let lastNode;
      const returnNode = document.createElement(type);

      while (list.length > 0) {
        if (thisNode) {
          lastNode = thisNode;
        }

        thisNode = list[0];
        level = computeIndentLevel(thisNode); // should be a sub-list. Recurse!

        if (lastNode && level > indentLevel) {
          lastNode.appendChild(nestList(list, level, type));
        } else if (level < indentLevel) {
          return returnNode;
        } else {
          thisNode.removeAttribute('class');
          returnNode.appendChild(list.shift());
        }
      }

      return returnNode;
    }
    /**
     * Recursivly flatten a nested list
     * an add quill classes
     *
     * No return, this will TRANSFORM the passed list
     * @param  {HTMLElement} list        This list node
     * @param  {Number} indentLevel The indentation level of the list passed
     */


    function unnestList(list, indentLevel) {
      const children = Array.prototype.slice.call(list.childNodes);
      children.forEach(node => {
        if (indentLevel > 0) {
          node.className = 'ql-indent-' + indentLevel;
        }

        Array.prototype.slice.call(node.childNodes).forEach(childNode => {
          const regex = /ol|ul/i;

          if (regex.test(childNode.tagName)) {
            unnestList(childNode, indentLevel + 1);
          }
        });
      });
    }

    function cleanInput(html) {
      const frag = document.createElement('div'); // eslint-disable-next-line lwc/no-inner-html

      frag.innerHTML = _sanitize(html);
      const lists = Array.prototype.slice.call(frag.querySelectorAll('ol,ul'));

      if (lists) {
        lists.forEach(list => {
          unnestList(list, 0);
          const flatList = list.querySelectorAll('li');

          if (flatList.length > 0) {
            for (let i = 0; i < flatList.length; i += 1) {
              list.appendChild(flatList[i]);
            }
          }
        });
      } // eslint-disable-next-line lwc/no-inner-html


      return frag.innerHTML;
    }

    function cleanOutput(html) {
      const frag = document.createElement('div'); // eslint-disable-next-line lwc/no-inner-html

      frag.innerHTML = html;
      const lists = Array.prototype.slice.call(frag.querySelectorAll('ol,ul'));

      if (lists) {
        lists.forEach(list => {
          const myList = nestList(Array.prototype.slice.call(list.querySelectorAll('li')), 0, list.tagName);
          list.parentNode.replaceChild(myList, list);
        });
      } // eslint-disable-next-line lwc/no-inner-html


      return frag.innerHTML;
    }

    function insertEmbed(quillInstance, format, value, attributes) {
      const insert = {};
      const attrs = attributes || {}; // this is important! if the editor
      // is not focused we can't insert.

      quillInstance.focus();
      const range = quillInstance.getSelection(); // TODO: handle alt tags!

      insert[format] = value;
      const delta = new Delta$1().retain(range.index).delete(range.length);
      delta.insert(insert, attrs);
      return quillInstance.updateContents(delta);
    }
    /**
     * 1. Attempt to upload the selected file
     *     a. If the file size exceeds 1MB, the file will not be uploaded
     *     b. If the upload encounters a problem, an error is thrown
     * 2. If the file is uploaded, insert the file/image into the editor
     * @param {Object} quillApi - Quill instance into which the image should be inserted
     * @param {Object} file - The file that needs to be uploaded
     * @param {Object} shareWithEntityId - Entity ID to share the image with
     */


    function uploadAndInsertSelectedFile(quillApi, file, shareWithEntityId) {
      if (file.size > this.IMAGE_MAX_SIZE) {
        throw new Error(this.labelImageSizeExceeded);
      } else {
        aura.createComponent('force:fileUpload', {
          shareWithEntityId,
          onUpload: serverResponse => {
            if (serverResponse.successful) {
              this.insertEmbed(quillApi, 'image', serverResponse.response.downloadUrl, {
                alt: file.name
              });
            } else {
              throw new Error(this.labelImageUploadFailed + 'Response from Server: ' + serverResponse.response);
            }
          }
        }, (uploadFileCmp, status) => {
          if (status === 'SUCCESS') {
            uploadFileCmp.uploadFile(file);
          }
        });
      }
    }

    function filterFormats(formats) {
      const ret = {};
      const keys = Object.keys(formats);
      keys.forEach(key => {
        let value = formats[key]; // remove formats not in the white list

        if (ALLOWED_FORMATS_FOR_API.indexOf(key) === -1) {
          return;
        } // check font values whitelist


        if (key === 'font' && ALLOWED_FONTS.indexOf(value) === -1) {
          return;
        } // cast size to int, check value, cast back to string later when we set it


        if (key === 'size') {
          const size = parseInt(value, 10); // fast short circuit non number values;

          if (isNaN(size)) {
            return;
          }

          if (ALLOWED_SIZES.indexOf(size) === -1) {
            return;
          }

          value = size;
        }

        ret[key] = value;
      });
      return ret;
    }

    function applyFormats(api, formats) {
      const filtered = filterFormats(formats);
      Object.keys(filtered).forEach(key => {
        let value = formats[key];

        if (key === 'size') {
          value = `${value}px`;
        }

        api.format(key, value);
      });
    }

    const inputRichTextLibrary = {
      Delta: Delta$1,
      filterFormats,
      applyFormats,
      computeIndentLevel,
      nestList,
      unnestList,
      cleanInput,
      cleanOutput,
      insertEmbed,
      uploadAndInsertSelectedFile,
      ALLOWED_SIZES,
      FONT_LIST,
      ALLOWED_ATTRS,
      ALLOWED_TAGS,
      IMAGE_MAX_SIZE,
      labelImageSizeExceeded,
      labelImageUploadFailed
    };
    var lightningQuill = {
      Quill,
      inputRichTextLibrary
    };

    const EMPTY_CHARACTER = '\u200B';
    const emptyCharMatcher = new RegExp(EMPTY_CHARACTER, 'g');

    function isNonCharacterKey(keyCode) {
      return keyCode && keyCode < 48;
    }
    /**
     * Issue: the first couple letters are entered directly without being considered
     *   as part of IME. This has to do with quill trying to create the first text
     *   node and breaking the IME. This only happens to Chrome and IE11.
     * Workaround: on compositionstart, insert empty characters at the beginning of
     *   every line. Remove all the empty chars when selection is changed.
     *
     * We use a class here to store the state of the hack instead of creating private
     * attributes in the component.
     *
     * @param {Object} rte - input rich text LWC instantce
     */


    class IMEHandler {
      constructor(inputRichText) {
        this.inputRichText = void 0;
        this.isEmptyCharInserted = false;
        this.inputRichText = inputRichText;
      }

      initializeEmptyCharHack() {
        const quill = this.inputRichText.quill;
        const editorElement = quill.root;
        let shouldInsertEmptyChar = false;

        if (isChrome) {
          const handleInsertEmptyChar = event => {
            if (isNonCharacterKey(event.keyCode)) {
              return;
            } // Find all the paragraphs that have no text or images - make sure
            // they have an empty char


            const children = editorElement.querySelectorAll('p, li');

            for (let i = 0; i < children.length; i += 1) {
              const child = children[i];

              if (child.textContent.length === 0 && child.getElementsByTagName('img').length === 0) {
                child.textContent = EMPTY_CHARACTER;
              }
            }

            this.isEmptyCharInserted = true;
          };

          editorElement.addEventListener('compositionstart', handleInsertEmptyChar);
          shouldInsertEmptyChar = true;
        } else if (isIE11) {
          const handleInsertEmptyChar = () => {
            // Insert empty character into the editor when there is no content
            // This is to make sure it works in accordance to the hack applied
            // for W-3946761.
            // Using the workaround for Chrome here would cause IE11 to freeze.
            // IE11 also doesn't need every empty line to have empty char.
            if (quill.editor.isBlank()) {
              const child = editorElement.querySelector('p');
              child.textContent = EMPTY_CHARACTER;
              this.isEmptyCharInserted = true;
            }
          };

          ['focus', 'keydown'].forEach(eventName => {
            editorElement.addEventListener(eventName, handleInsertEmptyChar);
          });
          shouldInsertEmptyChar = true;
        }

        if (shouldInsertEmptyChar) {
          quill.on('selection-change', () => {
            if (this.isEmptyCharInserted) {
              this.clearEmptyCharIfTrulyEmpty(quill);
            }
          });
        }
      }

      clearEmptyCharIfTrulyEmpty() {
        const quill = this.inputRichText.quill;
        const text = quill.getText().replace(/\n/, ''); // if the text is only the empty char that means the editor
        // should be empty

        if (!quill.hasFocus() && text === EMPTY_CHARACTER) {
          quill.setText('');
          this.isEmptyCharInserted = false;
        }
      }

      clearEmptyChars(html) {
        if (this.isEmptyCharInserted) {
          return html.replace(emptyCharMatcher, '');
        }

        return html;
      }

    }

    var IMEHandler$1 = lwc.registerComponent(IMEHandler, {
      tmpl: _tmpl$1
    });

    const {
      Quill: Quill$2,
      inputRichTextLibrary: inputRichTextLibrary$1
    } = lightningQuill;
    const TOOLBAR_CATEGORIES = {
      FORMAT_TEXT: 'FORMAT_TEXT',
      FORMAT_BACKGROUND: 'FORMAT_BACKGROUND',
      FORMAT_BODY: 'FORMAT_BODY',
      FORMAT_FONT: 'FORMAT_FONT',
      ALIGN_TEXT: 'ALIGN_TEXT',
      INSERT_CONTENT: 'INSERT_CONTENT',
      REMOVE_FORMATTING: 'REMOVE_FORMATTING'
    };
    const ALLOWED_IMAGE_FORMATS = ['image/png', 'image/jpg', 'image/jpeg', 'image/gif'];
    const CREATE_LINK_PANEL_WIDTH = 320,
          DEFAULT_FONT_NAME_VALUE = 'default',
          DEFAULT_FONT_SIZE_VALUE = '12px',
          DEFAULT_TEXT_COLOR_VALUE = '#000000',
          DEFAULT_CATEGORY = 'FORMAT_TEXT',
          SF_DEFAULT_FORMATS = ['table', 'image', 'link', 'header'],
          BUTTON_CLASSNAMES = 'slds-button slds-button_icon-border-filled',
          TOOLBAR_SELECTOR = '.slds-rich-text-editor__toolbar > ul li .slds-button, .overflow-menu > ul > li .slds-button';
    const i18n$h = {
      alignText: labelAlignText,
      bold: labelBold,
      bullet: labelBullet,
      centerAlign: labelCenterAlign,
      composeText: labelComposeText,
      font: labelFont,
      fontSize: labelFontSize,
      formatBackground: labelFormatBackground,
      formatBody: labelFormatBody,
      formatFont: labelFormatFont,
      formatText: labelFormatText,
      indent: labelIndent,
      insertContent: labelInsertContent,
      italic: labelItalic,
      leftAlign: labelLeftAlign,
      link: labelLink,
      image: labelImage,
      linkCancel: labelLinkCancel,
      linkInput: labelLinkInput,
      linkSave: labelLinkSave,
      number: labelNumber,
      outdent: labelOutdent,
      removeFormatting: labelRemoveFormatting,
      rightAlign: labelRightAlign,
      strike: labelStrike,
      underline: labelUnderline
    };

    function defaults() {
      return [{
        category: TOOLBAR_CATEGORIES.FORMAT_TEXT,
        label: i18n$h.formatText,
        buttons: [{
          label: i18n$h.bold,
          iconName: 'utility:bold',
          format: 'bold'
        }, {
          label: i18n$h.italic,
          iconName: 'utility:italic',
          format: 'italic'
        }, {
          label: i18n$h.underline,
          iconName: 'utility:underline',
          format: 'underline'
        }, {
          label: i18n$h.strike,
          iconName: 'utility:strikethrough',
          format: 'strike'
        }]
      }, {
        category: TOOLBAR_CATEGORIES.FORMAT_BACKGROUND,
        label: i18n$h.formatBackground,
        buttons: []
      }, {
        category: TOOLBAR_CATEGORIES.FORMAT_BODY,
        label: i18n$h.formatBody,
        buttons: [{
          label: i18n$h.bullet,
          iconName: 'utility:richtextbulletedlist',
          format: 'list',
          value: 'bullet'
        }, {
          label: i18n$h.number,
          iconName: 'utility:richtextnumberedlist',
          format: 'list',
          value: 'ordered'
        }, {
          label: i18n$h.indent,
          iconName: 'utility:richtextindent',
          format: 'indent',
          value: '+1'
        }, {
          label: i18n$h.outdent,
          iconName: 'utility:richtextoutdent',
          format: 'indent',
          value: '-1'
        }]
      }, {
        category: TOOLBAR_CATEGORIES.ALIGN_TEXT,
        label: i18n$h.alignText,
        buttons: [{
          label: i18n$h.leftAlign,
          iconName: 'utility:left_align_text',
          format: 'align',
          value: ''
        }, {
          label: i18n$h.centerAlign,
          iconName: 'utility:center_align_text',
          format: 'align',
          value: 'center'
        }, {
          label: i18n$h.rightAlign,
          iconName: 'utility:right_align_text',
          format: 'align',
          value: 'right'
        }]
      }, {
        category: TOOLBAR_CATEGORIES.INSERT_CONTENT,
        label: i18n$h.insertContent,
        buttons: [{
          label: i18n$h.link,
          iconName: 'utility:link',
          format: 'link'
        }, {
          label: i18n$h.image,
          iconName: 'utility:image',
          format: 'image'
        }]
      }, {
        category: TOOLBAR_CATEGORIES.REMOVE_FORMATTING,
        label: i18n$h.removeFormatting,
        buttons: [{
          label: i18n$h.removeFormatting,
          iconName: 'utility:remove_formatting',
          format: 'clean'
        }]
      }];
    }

    const FONT_LIST$1 = inputRichTextLibrary$1.FONT_LIST;
    const ALLOWED_SIZES$1 = [];
    inputRichTextLibrary$1.ALLOWED_SIZES.forEach(size => {
      ALLOWED_SIZES$1.push({
        label: `${size}`,
        value: `${size}px`
      });
    });
    const keyCodes$1 = {
      tab: 9,
      enter: 13,
      escape: 27,
      space: 32,
      end: 35,
      home: 36,
      left: 37,
      up: 38,
      right: 39,
      down: 40
    };
    const bindings = {
      // This will overwrite the default binding also named 'tab'
      // which would normally indent
      tab: {
        key: 9,
        shiftKey: false,

        handler() {
          // this will stop quill from preventingDefault
          // and stopping propigation on this event
          // so it will be handled normally
          return true;
        }

      },
      // names are not used, unique to avoid collision
      lightningOutdent: {
        key: 219,
        // [
        shortKey: true,

        handler() {
          this.quill.format('indent', '-1');
        }

      },
      lightningIndent: {
        key: 221,
        // ]
        shortKey: true,

        handler() {
          this.quill.format('indent', '+1');
        }

      }
    }; // Map for converting the size in <font size=x />
    // to an actual pixel value

    const FONT_SIZE_MAP = {
      1: '9px',
      2: '11px',
      3: '14px',
      4: '16px',
      5: '22px',
      6: '28px',
      7: '48px'
    };
    /**
     * Converts a CSS style value to an integer
     * Ex. "100px" -> 100
     * @param {HTMLElement} element - Element from which to retrieve the style
     * @param {String} style - The CSS style to retrieve from the element
     * @return {Integer} - Converted integer value
     */

    function getStyleAsInt(element, style) {
      return parseInt(element.style[style], 10);
    }
    /**
     * A WYSIWYG editor with a customizable toolbar for entering rich text
     */


    class LightningInputRichText extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._pendingFormats = [];
        this._valid = true;
        this._disabled = false;
        this.linkPanelOpen = false;
        this.selectedFontValue = DEFAULT_FONT_NAME_VALUE;
        this.selectedSizeValue = DEFAULT_FONT_SIZE_VALUE;
        this.quillNotReady = true;
        this.selectedTextColorValue = DEFAULT_TEXT_COLOR_VALUE;
        this.label = void 0;
        this.labelVisible = false;
        this.placeholder = void 0;
        this.disabledCategories = '';
        this.formats = '';
        this.variant = void 0;
        this.messageWhenBadInput = void 0;
        this.customButtons = void 0;
        this.shareWithEntityId = void 0;
        this.quill = void 0;
        this.initialRender = true;
        this.internalValue = void 0;
        this.linkValue = 'http://';
        this.fontMenus = {
          fontList: FONT_LIST$1,
          sizeList: ALLOWED_SIZES$1
        };
      }

      /**
       * The HTML content in the rich text editor.
       * @type {string}
       *
       */
      get value() {
        return this.internalValue;
      }

      set value(val) {
        // Change internalValue and paste into editor only if
        // the contents are different from the previously saved value
        if (typeof val === 'string' && this.internalValue !== val) {
          this.internalValue = inputRichTextLibrary$1.cleanInput(val);

          if (!this.internalValue) {
            // eslint-disable-next-line no-console
            console.warn('No html sanitizer found for rich text, make sure to sanitize rich text before using lightning-input-rich-text. Using raw html value');
            this.internalValue = val;
          }

          if (this.quill) {
            this.quill.clipboard.dangerouslyPasteHTML(this.internalValue);
          }
        }
      }
      /**
       * Specifies whether the editor content is valid. If invalid, the slds-has-error class is added. This value defaults to true.
       * @type {boolean}
       * @default true
       */


      get valid() {
        return this._valid;
      }

      set valid(value) {
        this._valid = normalizeBoolean(value);

        if (this.quill) {
          const rteElement = this.template.querySelector('.slds-rich-text-editor');
          const editorElement = this.quill.root;

          if (!this.valid) {
            rteElement.classList.add('slds-has-error');
            editorElement.setAttribute('aria-describedby', this.errorMessageId);
          } else {
            rteElement.classList.remove('slds-has-error');
            editorElement.removeAttribute('aria-describedby');
          }
        }
      }
      /**
       * If present, the editor is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * Sets focus on the rich text editor.
       */


      focus() {
        // Focus on inputRichText should activate editor.
        if (!this.quill) {
          this.activateEditor();
        }

        this.quill.root.focus();
      }
      /**
       * Removes focus from the rich text editor.
       */


      blur() {
        if (this.quill) {
          this.quill.root.blur();
        }
      }
      /**
       *
       * Sets a format in the editor from the cursor point onwards.
       * The format also applies to currently selected content.
       *
       * Valid formats are font, size, and align.
       * @param {Object} formats A key-value pair with format names and values.
       */


      setFormat(formats) {
        if (formats && this.quill) {
          inputRichTextLibrary$1.applyFormats(this.quill, lwc.unwrap(formats));
          const selection = this.quill.getSelection();

          if (selection.length === 0) {
            this.syncFontMenus();
          }
        } else if (formats) {
          this._pendingFormats.push(formats);
        }
      }
      /**
       * Returns an object representing the formats applied to the current selection.
       * Only align, font, and size are supported.
       *
       * @returns {Object} format an object representing the formats applied
       *                   to the selection or editor
       */


      getFormat() {
        if (!this.quill) {
          this.activateEditor();
        }

        return inputRichTextLibrary$1.filterFormats(this.quill.getFormat());
      }

      syncFontMenus() {
        const format = this.quill.getFormat();
        this.updateFontMenu(format);
        this.updateSizeMenu(format);
      }

      get showLinkValue() {
        return this.linkValue;
      }

      get isBottomToolbar() {
        return this.variant === 'bottom-toolbar';
      }

      get isColorpickerVisible() {
        return this.formats.indexOf('color') > -1;
      }

      get isFontMenusVisible() {
        if (this.disabledCategories.indexOf(TOOLBAR_CATEGORIES.FORMAT_FONT) !== -1) {
          return false;
        } // If custom formats are specified,
        // hide the fonts menus if font is not a part
        // of the custom formats


        if (this.formats.length > 0) {
          if (this.formats.indexOf('font') === -1) {
            return false;
          }
        }

        return true;
      }

      get menuDropdownAlignment() {
        if (this.isBottomToolbar) {
          return 'bottom-left';
        }

        return null;
      }

      get errorMessage() {
        return this.messageWhenBadInput;
      }

      get i18n() {
        return i18n$h;
      }

      get labelId() {
        return this.uniqueLabelId;
      }

      get errorMessageId() {
        const msg = this.template.querySelector('[data-error-message]');
        return getRealDOMId(msg);
      }

      get toolbarAriaLabel() {
        return this.disabled ? 'disabled' : '';
      }

      get renderLabel() {
        return this.labelVisible || this.label;
      }

      get computedLabel() {
        return this.label ? this.label : this.i18n.composeText;
      }

      get computedLabelClass() {
        const classnames = classSet('slds-form-element__label');
        return classnames.add({
          'slds-assistive-text': !this.labelVisible
        }).toString();
      }
      /**
       * Compute the complete set of buttons to be displayed and
       * add appropriate class names to each button
       *  - If the formats attribute is specified:
       *      Filter out buttons which do not match the specified formats
       *  - Merge the custom buttons with this filtered button set
       *  - Remove an entire category if:
       *      a. There are no remaining buttons in that category
       *      b. If it is a disabled category
       *  - Add the right class names to each remaining button
       * @returns {Object} Filtered set categories and buttons
       */


      get computedCategories() {
        // If custom formats are specified,
        // filter out the buttons which do not match
        // the specified custom formats, within each category
        const customFormats = !!this.formats.length;
        const formatList = this.formats;
        let categories = defaults();

        if (customFormats) {
          categories.forEach(cat => {
            cat.buttons = cat.buttons.filter(button => formatList.includes(button.format));
          });
        } // Merge custom buttons after filtering out default buttons which
        // do not match custom formats, so that the custom buttons may be
        // included even when the custom formats do not specify them


        categories = this.mergeCustomToolbarButtons(categories); // only keep categories that have buttons and not disabled

        categories = categories.filter(cat => cat.buttons && cat.buttons.length > 0 && !this.disabledCategories.includes(cat.category)); // Add additional attributes to each button

        categories.forEach(cat => {
          cat.buttons.forEach(button => {
            // add classes
            if (button.format) {
              button.computedClass = `${BUTTON_CLASSNAMES} ql-${button.format}`;
            } else {
              button.computedClass = BUTTON_CLASSNAMES;
            } // add key for iterations


            button.key = button.label + button.value;
          });
        });
        return categories;
      }
      /**
       * Merge the provided custom buttons with the existing set
       * If custom buttons are provided:
       *      Check if the custom button's category exists in the existing set
       *          If yes, add the button(s) into that category
       *          If no, add that entire category along with button(s) into the existing set
       *      If custom buttons' categories are not specified, add buttons to the default category
       * @param {Array} buttonSet - Set of filtered buttons;
       * If custom formats are provided, this set consists of default
       * buttons with those buttons removed, which do not match the format
       * Else, it is the default set of buttons
       * @returns {Array} Returns the merged set of buttons
       */


      mergeCustomToolbarButtons(buttonSet) {
        if (this.customButtons) {
          let existingCategory = false;
          this.customButtons.forEach(customButton => {
            existingCategory = false;
            buttonSet.forEach(cat => {
              // If the custom button is of an existing category,
              // add the custom button to the existing button set under that category
              // If a category for the custom button was not given
              // add the custom button into the default (Format Text) category
              if (!existingCategory && (cat.category === customButton.category || !customButton.category && cat.category === DEFAULT_CATEGORY)) {
                existingCategory = true;
                cat.buttons = cat.buttons.concat(lwc.unwrap(customButton.buttons));
              }
            }); // If the user button is not part of an existing category,
            // append the button info along with category information
            // to the complete set of buttons

            if (!existingCategory) {
              buttonSet = buttonSet.concat(lwc.unwrap(customButton));
            }
          });
        }

        return buttonSet;
      }
      /**
       * If it is a bottom-toolbar variant, add the appropriate
       * slds class to the toolbar
       */


      setupToolbar() {
        if (this.isBottomToolbar) {
          const toolbar = this.template.querySelector('.slds-rich-text-editor__toolbar');
          toolbar.classList.add('slds-rich-text-editor__toolbar_bottom');
        }
      }
      /**
       * For initial set up of buttons
       * We set the tabindex of every button to -1,
       * except the first button, which is set to 0
       *
       * This is so that tabbing through buttons is disabled
       * Instead ,users will be able to tab onto one button and use
       * arrow keys to navigate to other buttons
       */


      setupButtons() {
        const buttonList = this.template.querySelectorAll(TOOLBAR_SELECTOR);

        if (buttonList.length > 0) {
          this.setButtonTabindex(buttonList, 0);
        }
      }
      /**
       * Helper function to set tabindexes of all buttons to -1,
       * and to set the tabindex of the specified index to 0
       * @param {Array} buttonList - List of buttons to iterate through
       * @param {Number} index - Index of button whose tabindex to set to 0
       */


      setButtonTabindex(buttonList, index) {
        buttonList.forEach(button => {
          button.setAttribute('tabindex', -1);
        });
        buttonList[index].setAttribute('tabindex', 0);
      }
      /**
       * Attach custom handlers to the custom buttons
       * If custom buttons have been provided:
       *      Compare the custom button's format and the rendered
       *      toolbar button's quill class
       *      If they match, attach the provided custom handler as
       *      an onclick handler for that button
       */


      attachCustomButtonHandlers() {
        if (this.customButtons) {
          const renderedButtons = this.template.querySelectorAll(TOOLBAR_SELECTOR);
          this.customButtons.forEach(cat => {
            cat.buttons.forEach(button => {
              renderedButtons.forEach(renderedButton => {
                if (renderedButton.classList.contains('ql-' + button.format)) {
                  // Pass in the inputRichText component so that the handler
                  // has access to the quill instance
                  renderedButton.addEventListener('click', button.handler);
                }
              });
            });
          });
        }
      }
      /**
       * Add slds classes to the editor generated on initialization of Quill
       * @param {HTMLElement} qlEditor - Editor element generated from the
       * initialization of Quill
       */


      addInitialClassesAndAttributesToEditor(qlEditor) {
        qlEditor.classList.add('slds-rich-text-area__content');
        qlEditor.classList.add('slds-grow');
        qlEditor.classList.add('slds-text-color_weak');
        this.setAriaAttributesOnEditor(qlEditor);
      }
      /**
       * Add appropriate aria attributes based on values of label and labelVisible
       * @param {HTMLElement} qlEditor - Editor element on which to set aria attributes
       */


      setAriaAttributesOnEditor(qlEditor) {
        if (this.labelVisible || this.label) {
          qlEditor.setAttribute('aria-labelledby', this.uniqueLabelId);
        } else {
          qlEditor.setAttribute('aria-label', this.i18n.composeText);
        }
      }
      /**
       * Compute the list of formats to be passed in to the Quill configuration
       * If the formats attributes is specified, use that list
       * If formats are not specified:
       *      a. We set the formats of the buttons as the
       *         list of formats to pass into the Quill config
       *      b. Add font menus to list if it is not a disabled category
       * Add the Salesforce default formats to the filtered list - these are
       * on by default
       * @returns {Array} Final list of formats to pass into the Quill config
       */


      computeFormats() {
        let computedFormats = []; // If custom formats are specified, don't do anything
        // we will use this list in the quill config

        if (this.formats.length > 0) {
          return this.formats;
        } // If custom formats are not specified, we should set the
        // formats of the buttons as the formats list in the quill config
        // Visible buttons have already been calculated by the time
        // this stage is reached


        this.computedCategories.forEach(cat => {
          cat.buttons.forEach(button => {
            if (button.format) {
              // to make sure we don't have duplicates
              if (computedFormats.indexOf(button.format) === -1) {
                computedFormats.push(button.format);
              }
            }
          });
        }); // add font separately

        if (this.isFontMenusVisible) {
          computedFormats.push('font');
          computedFormats.push('size');
        }

        computedFormats = computedFormats.concat(SF_DEFAULT_FORMATS);
        return computedFormats;
      }
      /**
       * This is for conversion from <font size="">
       * to a quill size format. The font tag size is defined as
       * an integer between 1-7 with 3 being "normal" or default
       * there is no specified meaning to these sizes, so this is
       * a fairly arbitrary mapping based on experiments in the inspector
       * with font tags and slds
       * @param {Number} fontSize - Refers to the value of the size attribute
       * in a font tag
       * @returns {Number} - Value that corresponds to the right pixel size
       * in the FONT_SIZE_MAP to be rendered
       */


      getNormalizedFontSize(fontSize) {
        const size = fontSize || 3;
        const relativeSize = /^[+-]\d/.test(size) ? Number(size) + 3 : Number(size);
        let normalizedSize = relativeSize > 7 ? 7 : relativeSize;
        normalizedSize = relativeSize < 1 ? 1 : normalizedSize;
        return normalizedSize;
      }
      /**
       * Add matchers to quill so that particular tags can be converted from
       * one to another
       * Conversions:
       *      <font>    -> <span>
       *      <strike>  -> <s>
       *      <tt>      -> <code>
       *      <acronym> -> <abbr>
       *      <table>   -> {tableBlot}
       *      text-decoration
       *          underline    -> <underline>
       *          line-through -> <strike>
       */


      addTagMatchers() {
        // Convert font tags to spans
        this.quill.clipboard.addMatcher('font', (node, delta) => {
          let size = node.getAttribute('size'); // map <font> integers to px sizes

          if (size) {
            size = FONT_SIZE_MAP[this.getNormalizedFontSize(size)];
          } // size may still be undefined, that means it won't be applied
          // so this is fine


          const nodeFormats = {
            font: node.getAttribute('face'),
            // trust the defined font face
            size,
            color: node.getAttribute('color') // color is css compatible

          };
          return delta.compose(new Quill$2.Delta().retain(delta.length(), nodeFormats));
        }); // convert <strike> to <s>

        this.quill.clipboard.addMatcher('strike', (node, delta) => {
          return delta.compose(new Quill$2.Delta().retain(delta.length(), {
            strike: true
          }));
        }); // convert <tt> to <code>

        this.quill.clipboard.addMatcher('tt', (node, delta) => {
          return delta.compose(new Quill$2.Delta().retain(delta.length(), {
            code: true
          }));
        }); // convert <acronym> to <abbr>

        this.quill.clipboard.addMatcher('acronym', (node, delta) => {
          const title = node.getAttribute('title');
          return delta.compose(new Quill$2.Delta().retain(delta.length(), {
            abbr: title ? title : true
          }));
        });
        this.quill.clipboard.addMatcher('span[style*=text-decoration]', (node, delta) => {
          const computedStyle = getComputedStyle(node) || node.style;
          const underline = computedStyle.textDecoration.match(/underline/);
          const strike = computedStyle.textDecoration.match(/line-through/);
          return delta.compose(new Quill$2.Delta().retain(delta.length(), {
            underline: underline ? true : false,
            strike: strike ? true : false
          }));
        }); // This matcher detects tables, and if tables are disabled, returns a normal
        // delta, otherwise it applies the table format

        this.quill.clipboard.addMatcher('table', node => {
          if (this.formats.indexOf('table') === -1) {
            // convert creates a delta from html, in this case the html
            // *inside* the <table>
            return this.quill.clipboard.convert(node.innerHTML); // eslint-disable-line lwc/no-inner-html
          }

          const tableBlot = Quill$2.import('formats/table');
          return new Quill$2.Delta().insert({
            table: tableBlot.value(node)
          });
        });
      }
      /**
       * Initialize a new Quill instance and attach the required
       * handlers for various events
       *      1. Compute information required for configuring Quill
       *      2. Initialize Quill by passing in the computed configuration
       *      3. Add slds classes to editor element generated on init of Quill
       *      4. Add handlers for various events:
       *          a. on text change - dispatch change event
       *          b. on selection change update font and size menu values
       *          c. on double click, open link insertion panel if target is anchor
       *          d. attach custom handler for clicking on link insert button
       */


      initializeQuill() {
        // Passing in the proxy object causes Quill to error out on
        // initialization - so unwrap the editor and toolbar elements
        const container = lwc.unwrap(this.template.querySelector('.editor'));
        const toolbar = lwc.unwrap(this.template.querySelector('.slds-rich-text-editor__toolbar'));
        const computedFormats = this.computeFormats();
        const placeholder = this.placeholder;
        this._hasBeenFocused = false; // Quill Configuration: https://quilljs.com/docs/configuration/

        const quillConfig = {
          modules: {
            toolbar,
            keyboard: {
              bindings
            }
          },
          formats: computedFormats,
          placeholder
        };
        this.quill = new Quill$2(container, quillConfig);
        const editor = this.quill.root;
        this.addInitialClassesAndAttributesToEditor(this.quill.root);
        const imeHandler = new IMEHandler$1(this);
        imeHandler.initializeEmptyCharHack(); // If the editor is 'blank' it still contains a new
        // line (<p><br></p>); check if it is in fact blank
        // If so, we just use an empty string for the value
        // If not blank, clean the editor's contents
        // Fire a change event with the cleaned content as the value

        this.quill.on('text-change', () => {
          let cleanedContent = '';

          if (!this.quill.editor.isBlank()) {
            const editorContents = this.quill.scroll.domNode.innerHTML; // eslint-disable-line lwc/no-inner-html

            cleanedContent = inputRichTextLibrary$1.cleanOutput(editorContents);
          } // make sure we don't send the hacky empty characters back to the user


          cleanedContent = imeHandler.clearEmptyChars(cleanedContent);
          this.internalValue = cleanedContent;
          this.dispatchChangeEvent();
        }); // Update the font, font size menu display values and button pressed state
        // depending on where the cursor is at the time

        this.quill.on('selection-change', range => {
          if (!this._hasBeenFocused) {
            // Due to a bug in quill setting the link format before focusing the cursor in
            // the editor causes the `ql-blank` to never be removed, this change prevents enabling
            // the link button until the editor has been focused (by the user)
            const qlLink = this.template.querySelector('.ql-link');

            if (qlLink) {
              qlLink.removeAttribute('disabled');
            }

            this._hasBeenFocused = true;
          }

          let format = null;

          if (range) {
            // If no range, nothing is selected
            format = this.quill.getFormat(range);
            this.updateFontMenu(format);
            this.updateSizeMenu(format);
            this.updateTextColorButton(format);
          }

          this.updateButtonPressedState(range);
        }); // Update button pressed state depending on what the user is typing.

        this.quill.on('scroll-optimize', () => {
          requestAnimationFrame(() => {
            const range = this.quill.selection.getRange()[0];
            this.updateButtonPressedState(range);
          });
        }); // If user double clicks on a link node in the editor,
        // open the link insertion panel with the href value
        // populated in the input

        this.quill.scroll.domNode.addEventListener('dblclick', clickEvt => {
          const linkNode = this.getEnclosingLinkNode(clickEvt.target);

          if (linkNode) {
            this.expandSelectionToNode(linkNode);
            this.openLinkPanel(linkNode.getAttribute('href'));
          }
        });
        const toolbarModule = this.quill.getModule('toolbar');
        toolbarModule.addHandler('link', () => {
          this.linkButtonClickHandler();
        });
        toolbarModule.addHandler('image', () => {
          this.imageButtonClickHandler();
        });
        const previousCleanHandler = toolbarModule.handlers.clean;
        toolbarModule.addHandler('clean', () => {
          previousCleanHandler.call(this);
          const range = this.quill.getSelection();

          if (range) {
            const format = this.quill.getFormat(range);
            this.updateFontMenu(format);
            this.updateSizeMenu(format);
            this.updateTextColorButton(format);
          }

          this.updateButtonPressedState(range);
        }); // Add tag matchers

        this.addTagMatchers(); // Set initial value passed in to the editor

        if (this.internalValue) {
          this.quill.clipboard.dangerouslyPasteHTML(this.internalValue);
        } // When the editor is focused, set the slds-has-focus class and
        // dispatch focus event to execute onfocus method thats passed in


        editor.addEventListener('focus', () => {
          const rteElement = this.template.querySelector('.slds-rich-text-editor');
          rteElement.classList.add('slds-has-focus');
          this.dispatchEvent(new CustomEvent('focus'));
        }); // When the editor is blurred, remove the slds-has-focus class and
        // dispatch blur event to execute onblur method thats passed in

        editor.addEventListener('blur', () => {
          const rteElement = this.template.querySelector('.slds-rich-text-editor');
          rteElement.classList.remove('slds-has-focus');
          this.dispatchEvent(new CustomEvent('blur'));
        }); // If a file was pasted and is of the image formats supported,
        // proceed to upload the image and insert into the editor

        editor.addEventListener('paste', pasteEvt => {
          const clipboardData = pasteEvt.clipboardData;

          if (clipboardData && clipboardData.files && clipboardData.files.length && clipboardData.types.indexOf('text/html') === -1) {
            const pastedFile = clipboardData.files[0];

            if (ALLOWED_IMAGE_FORMATS.indexOf(pastedFile.type) > -1) {
              pasteEvt.preventDefault();
              pasteEvt.stopPropagation();
              inputRichTextLibrary$1.uploadAndInsertSelectedFile(this.quill, pastedFile, this.shareWithEntityId);
            }
          }
        });

        if (this._pendingFormats) {
          while (this._pendingFormats.length > 0) {
            const toDo = this._pendingFormats.shift();

            this.setFormat(toDo);
            this.syncFontMenus();
          }
        }
      } // Set Editor state to Disabled:
      // Disable Buttons, Comboboxes and the Editor

      /**
       * Set editor's state depending on the disabled attribute value
       * If disabled is set to true:
       *      a. Disable each button
       *      b. Disable the editor
       * If disabled is false:
       *      a. Ensure buttons are not disabled
       *      b. Enable the editor
       * Note: Font and font size menus are disabled directly
       *       based on the disabled attribute
       */


      setEditorAndButtonState() {
        const buttonList = this.template.querySelectorAll(TOOLBAR_SELECTOR);

        if (this.disabled) {
          buttonList.forEach(button => {
            button.setAttribute('disabled', true);
          });

          if (this.quill) {
            this.quill.disable();
          }
        } else {
          buttonList.forEach(button => {
            // prevent link button from being enabled until editor was focused
            if (!this._hasBeenFocused && button.classList.contains('ql-link')) {
              button.setAttribute('disabled', true);
            } else {
              button.removeAttribute('disabled');
            }
          });

          if (this.quill) {
            this.quill.enable();
          }
        }
      }
      /**
       * Set appropriate error classes based on the valid attribute value
       * If valid attribute is false:
       *      a. Set the slds error class on the editor element
       *      b. Unhide the element containing the error message
       *      c. Set aria-describedby to point to error message element
       */


      setEditorValidityState() {
        // Checking validity to append error class
        if (!this.valid) {
          // Add the error class on the editor
          const rteElement = this.template.querySelector('.slds-rich-text-editor');
          rteElement.classList.add('slds-has-error'); // Set editor's aria-describedby to point to error message element

          const editorElement = this.quill.root;
          editorElement.setAttribute('aria-describedby', this.errorMessageId);
        }
      }
      /**
       * Actions to be taken on rerender if the link insertion panel is open or closed
       * If the create link panel is opened:
       *      1. Correctly position the create link panel and set focus to its input
       *      2. Attach a document click handler to handle close on click out on the
       *         create link panel
       * If the create link panel is closed:
       *      Remove the document click handler
       */


      handleLinkPanelOpen() {
        const that = this; // Position the create link panel

        if (this.linkPanelOpen) {
          const createLinkPanel = this.template.querySelector('.slds-popover__body');
          const buttonList = this.template.querySelectorAll(TOOLBAR_SELECTOR);
          this.calculateLinkPanelPositioning(createLinkPanel, buttonList);
          this.template.querySelector('.link-input').focus(); // Stop propagation of this event or the document click handler
          // will get executed immediately and close the create link panel
          // Attach document click handler for close on click out of the
          // create link panel

          window.event.stopPropagation();

          this._documentClickHandler = function (e) {
            that.documentClickHandler(that, e);
          };

          document.addEventListener('click', this._documentClickHandler);
        } else {
          // Remove the document click handler when the link panel is closed
          document.removeEventListener('click', this._documentClickHandler);
        }
      }
      /**
       * Generate a unique id for the errormessage and label
       */


      connectedCallback() {
        this.classList.add('slds-form-element__control');
      }

      get uniqueLabelId() {
        const label = this.template.querySelector('[data-label]');
        return getRealDOMId(label);
      }

      activateEditor(e) {
        // Initialize the Quill instance on initial render
        if (this.initialRender) {
          this.setupToolbar();
          this.setupButtons();
          this.attachCustomButtonHandlers();
          this.initializeQuill();
          this.setEditorValidityState();
          this.initialRender = false;
          this.setEditorAndButtonState();
          this.handleLinkPanelOpen();
          this.quillNotReady = false;

          if (e) {
            const shouldFocus = e.target.classList.contains('standin') || e.target.tagName === 'lightning-formated-rich-text';

            if (shouldFocus) {
              this.quill.setSelection(this.quill.getLength());
            }
          }
        }
      }
      /**
       * On the first render cycle:
       *      1. Set up button tabindexes to be accessible
       *      2. Attach custom handlers for custom buttons
       *      3. Initialize the Quill instance
       * On every rerender:
       *      1. Set editor's disabled state based on disabled attribute
       *      2. Set editor's valid state based on the valid attribute
       *      3. Handle cases when create link panel is opened or closed
       */


      renderedCallback() {
        this.setEditorAndButtonState();
        this.handleLinkPanelOpen();
      }
      /* *******************************
          Keyboard Button Navigation
      ******************************** */

      /**
       * Move to the next button on the toolbar
       * Wrap around to the first button if currently on last
       * Move to next button by:
       *      1. Setting tabindex to 0 on the new button and -1 on the rest
       *      2. Setting focus on the new button
       * @param {Array} buttonList - Array of toolbar button elements
       * @param {Number} currentIndex - Index on which focus is on currently
       */


      moveToNextButton(buttonList, currentIndex) {
        // Determine next index to move to
        let newIndex = currentIndex + 1;

        if (newIndex === buttonList.length) {
          newIndex = 0;
        } // Set tabindex 0 on new button moved to and -1 on rest


        this.setButtonTabindex(buttonList, newIndex);
        buttonList[newIndex].focus();
      }
      /**
       * Move to the previous button on the toolbar
       * Wrap around to the last button if currently on first
       * Move to previous button by:
       *      1. Setting tabindex to 0 on the new button and -1 on the rest
       *      2. Setting focus on the new button
       * @param {Array} buttonList - Array of toolbar button elements
       * @param {Number} currentIndex - Index on which focus is on currently
       */


      moveToPreviousButton(buttonList, currentIndex) {
        // Determine previous index to move to
        let newIndex = currentIndex - 1;

        if (newIndex === -1) {
          newIndex = buttonList.length - 1;
        } // Set tabindex 0 on new button moved to and -1 on rest


        this.setButtonTabindex(buttonList, newIndex);
        buttonList[newIndex].focus();
      }
      /**
       * Navigate the toolbar buttons based on the keyboard input:
       *      1. Determine the current button by capturing event's target
       *      2. If user pressed the right arrow, move to the next button in toolbar
       *      3. If user pressed the left arrow, move to the previous button in toolbar
       * @param {Event} evt - Keyboard event to retrieve target and keyCode from
       */


      navigateToolbar(evt) {
        this.activateEditor();
        const event = evt || window.event;
        const target = event.target;
        const buttonList = Array.prototype.slice.call(this.template.querySelectorAll(TOOLBAR_SELECTOR));

        if (target && target.classList.contains('slds-button')) {
          const currentIndex = buttonList.indexOf(target);

          if (currentIndex === -1) {
            return; // somehow the button that caught the event is not in the toolbar; ignore
          }

          if (event.keyCode === keyCodes$1.right) {
            this.moveToNextButton(buttonList, currentIndex);
          }

          if (event.keyCode === keyCodes$1.left) {
            this.moveToPreviousButton(buttonList, currentIndex);
          }
        }
      }
      /* ***********************************
           Inline image insertion handling
         *********************************** */

      /**
       * 1. Load the browser's native file selector
       * 2. Upload the selected file
       * 3. Insert the uploaded image into the editor
       */


      imageButtonClickHandler() {
        this.loadNativeFileSelector(fileList => {
          inputRichTextLibrary$1.uploadAndInsertSelectedFile(this.quill, fileList[0], this.shareWithEntityId);
        });
      }
      /**
       * 1. Load the browser's native file selector
       *     a. File selector will only show files of certain file types
       *     b. Supported file types - png, jpg, jpeg, gif
       * 2. Execute callback with the file list as param after a file has been selected
       * @param {Function} callback - Callback to be executed after file selection
       */


      loadNativeFileSelector(callback) {
        const container = document.createDocumentFragment();
        const input = document.createElement('input');
        input.type = 'file';
        input.multiple = false;
        input.accept = ALLOWED_IMAGE_FORMATS;

        input.onchange = function () {
          callback(this.files);
        };

        container.appendChild(input);
        input.click();
      }
      /* ***************************
           Link insertion handling
         *************************** */

      /**
       * Custom handler for onclick of link insertion button
       * 1. Get the text selected by user to insert a link on
       * 2. Get the formatting already present on the selected text
       * 3. If selected text already has a link format on it:
       *     a. If length of selected text is 0
       *         i.  Expand the selection length to the enclosing anchor node
       *         ii. Open create link panel with href value populated in input
       *     b. If length of selected text is more than 0
       *         i. Remove the link formatting from that selection
       * 4. If selected text does not have a link format on it:
       *     a. Open create link panel with 'http://' populated in input
       */


      linkButtonClickHandler() {
        const quillApi = this.quill;
        const selection = quillApi.getSelection();
        const format = quillApi.getFormat();
        quillApi.focus();

        if (format.link) {
          if (selection.length === 0) {
            // when cursor is on a link with no selection, show edit panel
            const nodeOnCursor = quillApi.getLeaf(selection.index)[0].domNode;
            const linkNode = this.getEnclosingLinkNode(nodeOnCursor);
            this.expandSelectionToNode(linkNode);
            this.openLinkPanel(linkNode.getAttribute('href'));
          } else {
            // when a link is selected, unlink it
            quillApi.format('link', false);
          }
        } else {
          this.openLinkPanel();
        }
      }
      /**
       * Update the link value to be saved as user types in create link panel input
       * @param {Event} event - Keyboard event to detect value of input
       */


      handleLinkValueChange(event) {
        event.stopPropagation(); // When pressing ESC after some input, a change evt gets fired too
        // During this case, detail doesn't exist and there is no change in value

        if (event.detail) {
          this.linkValue = event.detail.value;
        }
      }
      /**
       * Open the create link panel with the value of link already set
       * on the selection or the default value if no value is set
       * @param {String} value - Value to populate in create link panel input
       */


      openLinkPanel(value) {
        this.linkValue = value ? value : 'http://';
        this.linkPanelOpen = true;
      }
      /**
       * Setting linkPanelOpen will trigger a rerender cycle,
       * causing the create link panel to close is value is set to false
       */


      closeLinkPanel() {
        this.linkValue = 'http://';
        this.linkPanelOpen = false;
      }
      /**
       * Set the text selection's format to link type,
       * with the href value being the value typed in by
       * the user in the create link panel input box
       */


      saveLink() {
        const quillApi = this.quill;
        const selection = quillApi.getSelection(true);

        if (selection.length === 0) {
          quillApi.insertText(selection.index, this.linkValue, {
            link: this.linkValue
          });
        } else {
          quillApi.format('link', this.linkValue);
        }

        this.closeLinkPanel();
      }
      /**
       * Close create link panel without saving
       */


      cancelLink() {
        this.closeLinkPanel();
      }
      /**
       * Calculate and position the create link panel correctly based on the editor's bounds
       * 1. Attempt to align the panel's center with the insert link button's center
       * 2. If panel's right edge goes past the editor's right edge, align both the right edges
       * 3. If panel's left edge goes past the editor's left edge, align both the left edges
       * 4. Vertically position the panel based on the toolbar's position
       * @param {HTMLElement} createLinkPanel -
       */


      calculateLinkPanelPositioning(createLinkPanel) {
        const linkButton = this.template.querySelector('.ql-link');
        const toolbar = this.template.querySelector('.ql-toolbar');
        createLinkPanel.style.position = 'absolute';
        createLinkPanel.style.width = CREATE_LINK_PANEL_WIDTH + 'px'; // Horizontal Positioning of Create Link Panel:
        // Align the center of the panel with the center of the button

        const linkButtonCenter = linkButton.offsetLeft + linkButton.offsetWidth / 2;
        createLinkPanel.style.left = linkButtonCenter - CREATE_LINK_PANEL_WIDTH / 2 + 'px';
        const createLinkPanelLeft = getStyleAsInt(createLinkPanel, 'left');
        const createLinkPanelWidth = getStyleAsInt(createLinkPanel, 'width'); // If panel is going out of the editor/toolbar on the right, position the right
        // of the panel to the right of the editor/toolbar

        if (createLinkPanelLeft + createLinkPanelWidth > toolbar.offsetWidth) {
          const diff = createLinkPanelLeft + createLinkPanelWidth - toolbar.offsetWidth;
          createLinkPanel.style.left = createLinkPanelLeft - diff + 'px';
        } // If panel is going out of the editor/toolbar on the left, position the left
        // of the panel to the left of the editor/toolbar


        if (getStyleAsInt(createLinkPanel, 'left') < toolbar.offsetLeft) {
          createLinkPanel.style.left = toolbar.offsetLeft + 'px';
        } // Vertical Positioning of Create Link Panel


        if (this.variant === 'bottom-toolbar') {
          createLinkPanel.style.top = toolbar.offsetTop - createLinkPanel.offsetHeight + 'px';
        } else {
          createLinkPanel.style.top = toolbar.offsetTop + toolbar.offsetHeight + 'px';
        }
      }
      /**
       * Get the enclosing link node.
       * Search upward through parentNode.
       *
       * @param {Object} node - node of which to find enclosing node
       * @returns {Object} returns the enclosing link node
       */


      getEnclosingLinkNode(node) {
        const quillApi = this.quill;
        const endNode = quillApi.scroll.domNode;
        let currentNode = node;

        while (currentNode && currentNode !== endNode) {
          if (currentNode.tagName === 'A') {
            return currentNode;
          }

          currentNode = currentNode.parentNode;
        }

        return null;
      }
      /**
       * Expand selection to the whole node
       * when selection only covers the node partially
       *
       * @param {Object} node - node of which to expand selection
       */


      expandSelectionToNode(node) {
        const quillApi = this.quill;
        const blot = quillApi.constructor.find(node);

        if (blot) {
          quillApi.focus();
          quillApi.setSelection(quillApi.getIndex(blot), blot.length());
        }
      }
      /**
       * Handle the ENTER and ESC keys appropriately:
       *  1. Handle ENTER key to save the input value
       *  2. Handle ESC key to close the create link panel
       *
       * @param {Event} evt Keyboard event to detect and handle the key pressed
       */


      linkKeyboardPress(evt) {
        this.activateEditor();
        let handled = false;

        if (evt.keyCode === keyCodes$1.enter) {
          this.saveLink();
          handled = true;
        } else if (evt.keyCode === keyCodes$1.escape) {
          this.closeLinkPanel();
          handled = true;
        } // If the events are handled,
        // let them die here


        if (handled) {
          evt.stopPropagation();
          evt.preventDefault();
        }
      }
      /**
       * Event handler for click - for close on click out
       * @param {Object} self - Reference of the inputRichText component
       * @param {Event} e - Click event
       */


      documentClickHandler(self, e) {
        const createLinkPanel = self.template.querySelector('.slds-popover');
        const event = e || window.event;
        const target = event.target || event.srcElement;
        const clickedInside = createLinkPanel.contains(target);

        if (createLinkPanel && !clickedInside) {
          self.closeLinkPanel();
        }
      }
      /**
       * Set the format of the text to font selected from the font dropdown
       * If user selects the default font, we do not set a font name when
       * formatting the text
       * Set the selected font so the font menu displays the right value
       * @param {Event} fontChangeEvt - Event fired by dropdown combobox
       */


      selectFont(fontChangeEvt) {
        fontChangeEvt.stopPropagation();
        const selectFont = fontChangeEvt.detail.value;
        let formatFont = selectFont;

        if (formatFont === DEFAULT_FONT_NAME_VALUE) {
          // We don't want quill to set the font name to 'default'
          formatFont = '';
        }

        const quillApi = this.quill;
        quillApi.focus();
        quillApi.format('font', formatFont);
        this.selectedFontValue = selectFont;
      }
      /**
       * Set the format of the text to font size selected from the dropdown
       * @param {Event} sizeChangeEvt - Event fired by dropdown combobox
       */


      selectSize(sizeChangeEvt) {
        sizeChangeEvt.stopPropagation();
        const selectSize = sizeChangeEvt.detail.value;
        const quillApi = this.quill;
        quillApi.focus();
        quillApi.format('size', selectSize);
        this.selectedSizeValue = selectSize;
      }
      /**
       * Update the value shown by the font dropdown based on cursor location
       * @param {Object} format - Format of the selected text
       */


      updateFontMenu(format) {
        const newFont = format && format.font ? format.font : DEFAULT_FONT_NAME_VALUE;
        this.selectedFontValue = newFont;
      }
      /**
       * Update the value shown by the font size dropdown based on cursor location
       * @param {Object} format - Format of the selected text
       */


      updateSizeMenu(format) {
        const newSize = format && format.size ? format.size : DEFAULT_FONT_SIZE_VALUE;
        this.selectedSizeValue = newSize;
      }
      /**
       * Update the color shown by the color picker button based on cursor location
       * @param {Object} format - Format of the selected text
       */


      updateTextColorButton(format) {
        const newTextColor = format && format.color ? format.color : DEFAULT_TEXT_COLOR_VALUE;
        this.selectedTextColorValue = newTextColor;
      }
      /**
       * Whenever the color changes, it will trigger quill API color change
       * @param {Object} event - change event with text color from colorpicker.
       */


      handleColorUpdate(event) {
        const quillApi = this.quill;
        this.selectedTextColorValue = event.detail.color;
        quillApi.format('color', this.selectedTextColorValue);
      }
      /**
       * Whenever the quill state changes, update each button's pressed state based on the format of given range.
       * @param {Object} range - text range from quill.
       */


      updateButtonPressedState(range) {
        const buttonList = this.template.querySelectorAll(TOOLBAR_SELECTOR);
        const formats = range ? this.quill.getFormat(range) : {};
        buttonList.forEach(button => {
          if (button) {
            const {
              format
            } = button.dataset;
            const value = button.getAttribute('value');
            let isActive = false;

            if (value === null) {
              isActive = !!formats[format];
            } else if (value === '' && format === 'align') {
              isActive = !formats[format];
            } else {
              isActive = formats[format] === value;
            }

            button.classList.toggle('slds-is-selected', isActive);
            button.setAttribute('aria-pressed', isActive);
          }
        });
      }
      /**
       * Check if the current device is desktop or not.
       * @returns {boolean} true if its desktop, false otherwise.
       */


      get isDesktop() {
        return configProvider.getFormFactor() === 'DESKTOP';
      }
      /**
       * Fire a change event by passing the contents of the
       * editor as the value
       */


      dispatchChangeEvent() {
        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            value: this.internalValue
          }
        }));
      }
      /**
       * Reserved for internal use. Insert text in the rich text editor at cursor position.
       *
       * @param {String} text - text to insert
       */


      insertTextAtCursor(text) {
        if (!this.quill) {
          this.activateEditor();
        }

        const selection = this.quill.getSelection(true);
        const cursorPosition = selection ? selection.index : this.quill.getLength() - 1;

        if (selection && selection.length !== 0) {
          this.quill.deleteText(selection.index, selection.length);
        }

        this.quill.insertText(cursorPosition, text);
      }

    }

    lwc.registerDecorators(LightningInputRichText, {
      publicProps: {
        label: {
          config: 0
        },
        labelVisible: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        disabledCategories: {
          config: 0
        },
        formats: {
          config: 0
        },
        variant: {
          config: 0
        },
        messageWhenBadInput: {
          config: 0
        },
        customButtons: {
          config: 0
        },
        shareWithEntityId: {
          config: 0
        },
        value: {
          config: 3
        },
        valid: {
          config: 3
        },
        disabled: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur", "setFormat", "getFormat", "insertTextAtCursor"],
      track: {
        _valid: 1,
        _disabled: 1,
        linkPanelOpen: 1,
        selectedFontValue: 1,
        selectedSizeValue: 1,
        quillNotReady: 1,
        selectedTextColorValue: 1
      }
    });

    var _lightningInputRichText = lwc.registerComponent(LightningInputRichText, {
      tmpl: _tmpl$x
    });

    function tmpl$z($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2
      } = $ctx;
      return [api_element("span", {
        classMap: {
          "slds-form-element__label": true
        },
        key: 2
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 4
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 5
      }, []) : null, api_custom_element("lightning-input-rich-text", _lightningInputRichText, {
        props: {
          "value": $cmp._displayValue,
          "formats": $cmp.formats,
          "messageWhenBadInput": $cmp._helpMessage,
          "valid": $cmp._noErrors,
          "disabled": $cmp.disabled,
          "disabledCategories": $cmp.disabledCategories,
          "customButtons": $cmp.customButtons
        },
        key: 6,
        on: {
          "change": _m0 || ($ctx._m0 = api_bind($cmp.handleChange)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleBlur))
        }
      }, [])];
    }

    var _tmpl$y = lwc.registerTemplate(tmpl$z);
    tmpl$z.stylesheets = [];

    if (_implicitStylesheets$c) {
      tmpl$z.stylesheets.push.apply(tmpl$z.stylesheets, _implicitStylesheets$c);
    }
    tmpl$z.stylesheetTokens = {
      hostAttribute: "lightning-quill_quill-host",
      shadowAttribute: "lightning-quill_quill"
    };

    const i18n$i = {
      required: labelRequired
    };
    const defaultFormats = ['abbr', 'address', 'align', 'alt', 'background', 'bdo', 'big', 'blockquote', 'bold', 'cite', 'clean', 'code', 'code-block', 'color', 'data-fileid', 'del', 'dfn', 'direction', 'divider', 'dl', 'dd', 'dt', 'font', 'header', 'image', 'indent', 'ins', 'ins', 'italic', 'kbd', 'link', 'list', 'q', 'samp', 'script', 'size', 'small', 'strike', 'sup', 'table', 'tt', 'underline', 'var'];

    class LightningQuill extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._required = false;
        this._helpMessage = '';
        this._noErrors = true;
        this._fieldLevelHelp = void 0;
        this._disabled = false;
        this._displayValue = void 0;
        this.label = void 0;
        this.disabledCategories = '';
        this.messageWhenValueMissing = void 0;
        this.customButtons = void 0;
        this.fieldLevelHelp = void 0;
      }

      connectedCallback() {
        this._connected = true;
        this.uniqueId = generateUniqueId();
        this.interactingState = new InteractingState();
        this.interactingState.onleave(() => this.reportValidity());
        this.classList.add('slds-form-element');
        this.updateClassList();
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this._connected = false;
      }

      get value() {
        return this._value;
      }

      set value(value) {
        this._value = value;
        this._displayValue = value ? value : '';
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }

      get disabled() {
        return this._disabled;
      }

      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant$1(value);
        this.updateClassList();
      }

      focus() {
        this.inputRichTextElement.focus();
        this.handleFocus();
      }

      blur() {
        this.inputRichTextElement.blur();
        this.handleBlur();
      }

      get validity() {
        return this._constraint.validity;
      }

      checkValidity() {
        return this._constraint.checkValidity();
      }

      reportValidity() {
        return this._constraint.reportValidity(message => {
          // The errors are shown via the underlying input-rich-text component,
          // we should change it to be more in-line with the other input components
          this._helpMessage = message;
          this._noErrors = message === '';
        });
      }

      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }

      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      handleFocus() {
        this.interactingState.enter();
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleBlur() {
        this.interactingState.leave();
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleChange(event) {
        this._value = event.detail.value;
      }

      get i18n() {
        return i18n$i;
      }

      get formats() {
        return defaultFormats;
      }

      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => !this.disabled && this.required && isEmptyString(this.value)
          });
        }

        return this._constraintApi;
      }

      get inputRichTextElement() {
        return this.template.querySelector('lightning-input-rich-text');
      }

    }

    lwc.registerDecorators(LightningQuill, {
      publicProps: {
        label: {
          config: 0
        },
        disabledCategories: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        customButtons: {
          config: 0
        },
        fieldLevelHelp: {
          config: 0
        },
        value: {
          config: 3
        },
        disabled: {
          config: 3
        },
        required: {
          config: 3
        },
        variant: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        _required: 1,
        _helpMessage: 1,
        _noErrors: 1,
        _fieldLevelHelp: 1,
        _disabled: 1,
        _displayValue: 1
      }
    });

    var _lightningQuill = lwc.registerComponent(LightningQuill, {
      tmpl: _tmpl$y
    });

    function stylesheet$e(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$e = [stylesheet$e];

    function stylesheet$f(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$f = [stylesheet$f];

    function stylesheet$g(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$g = [stylesheet$g];

    var labelPillDelete = 'Press delete or backspace to remove';

    var labelPillError = 'Error';

    var labelPillRemove = 'Remove';

    var labelPillWarning = 'Warning';

    var labelPillDeleteAndNavigate = 'Press delete or backspace to remove, press enter to navigate';

    function tmpl$A($api, $cmp, $slotset, $ctx) {
      const {
        s: api_slot,
        h: api_element,
        c: api_custom_element,
        d: api_dynamic,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0
      } = $ctx;
      return [!$cmp._hasError ? $cmp._hasMedia ? api_element("span", {
        classMap: {
          "slds-pill__icon_container": true
        },
        key: 4
      }, [api_slot("", {
        key: 5
      }, [], $slotset)]) : null : null, $cmp._hasError ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-pill__icon_container": true,
          "slds-m-left_xx-small": true
        },
        props: {
          "title": $cmp.i18n.pillError,
          "iconName": "utility:warning",
          "variant": "bare",
          "svgClass": "icon-error slds-icon_x-small slds-icon-text-error"
        },
        key: 7
      }, []) : null, $cmp._hasError ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 8
      }, [api_dynamic($cmp.i18n.pillWarning)]) : null, $cmp.hasHref ? api_element("a", {
        classMap: {
          "slds-pill__action": true
        },
        attrs: {
          "href": $cmp.href
        },
        key: 10
      }, [api_element("span", {
        classMap: {
          "slds-pill__label": true
        },
        key: 11
      }, [api_dynamic($cmp.label)])]) : null, !$cmp.hasHref ? api_element("span", {
        classMap: {
          "slds-pill__action": true
        },
        key: 13
      }, [api_element("span", {
        classMap: {
          "slds-pill__label": true
        },
        key: 14
      }, [api_dynamic($cmp.label)])]) : null, api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        classMap: {
          "slds-pill__remove": true
        },
        props: {
          "iconName": "utility:close",
          "variant": "bare",
          "title": $cmp.i18n.pillRemove,
          "tabIndex": api_tab_index($cmp._tabIndex),
          "alternativeText": $cmp.i18n.pillRemove
        },
        key: 15,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleRemove))
        }
      }, [])];
    }

    var link = lwc.registerTemplate(tmpl$A);
    tmpl$A.slots = [""];
    tmpl$A.stylesheets = [];
    tmpl$A.stylesheetTokens = {
      hostAttribute: "lightning-pill_link-host",
      shadowAttribute: "lightning-pill_link"
    };

    function tmpl$B($api, $cmp, $slotset, $ctx) {
      const {
        s: api_slot,
        d: api_dynamic,
        h: api_element,
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [$cmp._hasMedia ? api_slot("", {
        key: 3
      }, [], $slotset) : null, api_element("span", {
        classMap: {
          "slds-pill__label": true
        },
        key: 4
      }, [api_dynamic($cmp.label)]), api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-pill__remove": true
        },
        props: {
          "title": $cmp.i18n.pillRemove,
          "iconName": "utility:close",
          "svgClass": "slds-icon slds-icon_x-small slds-icon-text-default",
          "variant": "bare"
        },
        key: 5,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleRemove))
        }
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 6
      }, [api_dynamic($cmp.assistiveText)])];
    }

    var plain = lwc.registerTemplate(tmpl$B);
    tmpl$B.slots = [""];
    tmpl$B.stylesheets = [];
    tmpl$B.stylesheetTokens = {
      hostAttribute: "lightning-pill_plain-host",
      shadowAttribute: "lightning-pill_plain"
    };

    function tmpl$C($api, $cmp, $slotset, $ctx) {
      const {
        s: api_slot,
        d: api_dynamic,
        h: api_element,
        b: api_bind,
        c: api_custom_element,
        ti: api_tab_index
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("a", {
        attrs: {
          "href": $cmp.href,
          "tabindex": api_tab_index($cmp._tabIndex),
          "aria-selected": $cmp._ariaSelected,
          "role": $cmp._role
        },
        key: 2,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleClick))
        }
      }, [$cmp._hasMedia ? api_slot("", {
        key: 4
      }, [], $slotset) : null, api_element("span", {
        classMap: {
          "slds-pill__label": true
        },
        key: 5
      }, [api_dynamic($cmp.label)]), api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-pill__remove": true
        },
        props: {
          "title": $cmp.i18n.pillRemove,
          "iconName": "utility:close",
          "svgClass": "slds-icon slds-icon_x-small slds-icon-text-default",
          "variant": "bare"
        },
        key: 6,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleRemove))
        }
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 7
      }, [api_dynamic($cmp.assistiveText)])])];
    }

    var plainLink = lwc.registerTemplate(tmpl$C);
    tmpl$C.slots = [""];
    tmpl$C.stylesheets = [];
    tmpl$C.stylesheetTokens = {
      hostAttribute: "lightning-pill_plainLink-host",
      shadowAttribute: "lightning-pill_plainLink"
    };

    const i18n$j = {
      pillDelete: labelPillDelete,
      pillError: labelPillError,
      pillRemove: labelPillRemove,
      pillWarning: labelPillWarning,
      pillDeleteAndNavigate: labelPillDeleteAndNavigate
    };
    const VARIANT$1 = {
      PLAIN: 'plain',
      PLAIN_LINK: 'plainLink',
      LINK: 'link'
    };

    function modifyAttribute(el, name, value) {
      if (!el.isPlainLink) {
        if (value !== null && value !== undefined && value !== '') {
          el.setAttribute(name, value);
        } else {
          el.removeAttribute(name);
        }
      } else {
        el.removeAttribute(name);
      }
    }
    /**
     * A pill displays a label that can contain links and can be removed from view.
     * @slot default Placeholder for an image, such as an icon or avatar.
     */


    class LightningPill extends lwc.LightningElement {
      /**
       * The URL of the page that the link goes to.
       * @type {string}
       */
      get href() {
        return this._href;
      }

      set href(value) {
        this._href = value;

        if (this._connected && (this.isPlainLink || this.isLink)) {
          this.updateLinkInfo(value);
        }
      }

      render() {
        switch (this.variant) {
          case VARIANT$1.PLAIN:
            return plain;

          case VARIANT$1.PLAIN_LINK:
            return plainLink;

          case VARIANT$1.LINK:
          default:
            return link;
        }
      }
      /**
       * If present, the pill is shown with a red border and an error icon on the left of the label.
       * @type {boolean}
       * @default false
       */


      get hasError() {
        return this._hasError || false;
      }

      set hasError(value) {
        this._hasError = normalizeBoolean(value);
      }

      get assistiveText() {
        return this.variant === VARIANT$1.PLAIN_LINK ? this.i18n.pillDeleteAndNavigate : this.i18n.pillDelete;
      }

      constructor() {
        super();
        this._href = void 0;
        this.label = void 0;
        this.name = void 0;
        this.variant = VARIANT$1.LINK;
        this._role = void 0;
        this._ariaSelected = void 0;
        this._hasMedia = true;
        this._hasError = void 0;
        this._tabIndex = void 0;
        this._connected = false;

        this._dispatcher = () => {};

        this.addEventListener('keydown', this.handleKeypress.bind(this));
      }

      get pillClass() {
        const cssClass = ['slds-pill'];

        switch (this.variant) {
          case VARIANT$1.PLAIN:
          case VARIANT$1.PLAIN_LINK:
            break;

          case VARIANT$1.LINK:
          default:
            cssClass.push('slds-pill_link');
        }

        return cssClass;
      }

      checkMediaElement() {
        if (!this._mediaElement) {
          this._mediaElement = this.template.querySelector('slot');
        }

        return this._mediaElement && this._mediaElement.assignedNodes().length > 0;
      }

      renderedCallback() {
        const el = this.isPlainLink ? this.template.querySelector('a') : this;
        this.pillClass.forEach(name => el.classList.add(name)); // check if a component was passed into the slot

        this._hasMedia = this.checkMediaElement();
        classListMutation(this.classList, {
          'slds-has-error': this.hasError
        }); // set attributes to self if variant is plain or link

        modifyAttribute(this, 'tabindex', this.tabIndex);
        modifyAttribute(this, 'role', this.role);
        modifyAttribute(this, 'aria-selected', this.ariaSelected);
      }
      /**
       * Reserved for internal use. Specifies whether the element variant is a plain link.
       * @type {boolean}
       * @return {boolean} true if variant is a plain link.
       */


      get isPlainLink() {
        return this.variant === VARIANT$1.PLAIN_LINK;
      }

      get isLink() {
        return this.variant === VARIANT$1.LINK;
      }
      /**
       * Reserved for internal use. Use tabindex instead to indicate if an element should be focusable.
       * A value of 0 means that the pill is focusable and
       * participates in sequential keyboard navigation. A value of -1 means
       * that the pill is focusable but does not participate in keyboard navigation.
       * @type {number}
       */


      get tabIndex() {
        return this._tabIndex;
      }

      set tabIndex(value) {
        this._tabIndex = value;
        modifyAttribute(this, 'tabindex', this._tabIndex);
      }
      /**
       * Specifies the aria-selected of an element.
       */


      get ariaSelected() {
        return this._ariaSelected;
      }

      set ariaSelected(value) {
        this._ariaSelected = normalizeBoolean(value);
        modifyAttribute(this, 'aria-selected', this._ariaSelected);
      }
      /**
       * Specifies the role of an element.
       */


      get role() {
        return this._role;
      }

      set role(value) {
        this._role = value;
        modifyAttribute(this, 'role', this._role);
      }

      get i18n() {
        return i18n$j;
      }

      get hasHref() {
        return !!this.href;
      }

      get labelElement() {
        if (!this._labelElement) {
          this._labelElement = this.template.querySelector('a.slds-pill__label');
        }

        return this._labelElement;
      }

      get removeIconElement() {
        if (!this._removeIconElement) {
          this._removeIconElement = this.template.querySelector('lightning-primitive-icon');
        }

        return this._removeIconElement;
      }

      connectedCallback() {
        this._connected = true;

        if (this.isPlainLink || this.isLink) {
          this.updateLinkInfo(this.href);
        }
      }

      disconnectedCallback() {
        this._connected = false;
      }

      handleKeypress(event) {
        switch (event.keyCode) {
          case keyCodes.delete:
          case keyCodes.backspace:
            this.handleRemove(event);
            break;

          case keyCodes.enter:
            this.handleEnter(event);
            break;

          default:
        }
      }

      handleEnter() {
        if (this.isPlainLink) {
          if (this.labelElement) {
            this.labelElement.click();
          }
        }
      }

      handleClick(event) {
        if (event.target === this.removeIconElement) {
          // click on the X icon to remove the item
          event.stopPropagation();
          event.preventDefault();
          this.handleRemove(event);
        } else if (this.isPlainLink || this.isLink) {
          this._dispatcher(event);
        }
      }

      handleRemove(event) {
        const removeEvent = new CustomEvent('remove', {
          cancelable: true,
          detail: {
            name: this.name
          }
        });
        this.dispatchEvent(removeEvent);

        if (removeEvent.defaultPrevented) {
          event.stopPropagation();
        }
      }
      /**
       * Reserved for internal use.
       * Sets focus on the anchor element for a plain link.
       */


      focusLink() {
        const el = this.template.querySelector('A');

        if (el) {
          el.focus();
        }
      }

      updateLinkInfo(url) {
        updateRawLinkInfo(this, {
          url: this.makeAbsoluteUrl(url)
        }).then(linkInfo => {
          this._url = linkInfo.url;
          this._dispatcher = linkInfo.dispatcher;
        });
      }

      makeAbsoluteUrl(url) {
        return isAbsoluteUrl(url) ? url : `http://${url}`;
      }

    }

    lwc.registerDecorators(LightningPill, {
      publicProps: {
        href: {
          config: 3
        },
        label: {
          config: 0
        },
        name: {
          config: 0
        },
        variant: {
          config: 0
        },
        hasError: {
          config: 3
        },
        isPlainLink: {
          config: 1
        },
        tabIndex: {
          config: 3
        },
        ariaSelected: {
          config: 3
        },
        role: {
          config: 3
        }
      },
      publicMethods: ["focusLink"],
      track: {
        _href: 1,
        _role: 1,
        _ariaSelected: 1,
        _hasMedia: 1,
        _hasError: 1,
        _tabIndex: 1
      }
    });

    var _lightningPill = lwc.registerComponent(LightningPill, {
      tmpl: _tmpl$1
    });

    function tmpl$D($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [$cmp._src ? api_element("img", {
        attrs: {
          "src": $cmp._src,
          "alt": $cmp.alternativeText,
          "title": $cmp.alternativeText
        },
        key: 2,
        on: {
          "error": _m0 || ($ctx._m0 = api_bind($cmp.handleImageError))
        }
      }, []) : null, $cmp.showInitials ? api_element("abbr", {
        className: $cmp.computedInitialsClass,
        attrs: {
          "title": $cmp.alternativeText
        },
        key: 3
      }, [api_dynamic($cmp.initials)]) : null, $cmp.showIcon ? api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "iconName": $cmp.fallbackIconName,
          "alternativeText": $cmp.alternativeText,
          "title": $cmp.alternativeText
        },
        key: 4
      }, []) : null];
    }

    var _tmpl$z = lwc.registerTemplate(tmpl$D);
    tmpl$D.stylesheets = [];
    tmpl$D.stylesheetTokens = {
      hostAttribute: "lightning-avatar_avatar-host",
      shadowAttribute: "lightning-avatar_avatar"
    };

    const DEFAULT_SIZE$1 = 'medium';
    const DEFAULT_VARIANT$1 = 'square';
    /**
     * A visual representation of an object.
     */

    class LightningAvatar extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.alternativeText = '';
        this.fallbackIconName = void 0;
        this.initials = void 0;
        this._size = DEFAULT_SIZE$1;
        this._src = '';
        this._variant = DEFAULT_VARIANT$1;
      }

      /**
       * The size of the avatar. Valid values are x-small, small, medium, and large. This value defaults to medium.
       *
       * @type {string}
       * @default medium
       */
      get size() {
        return this._size;
      }

      set size(value) {
        this._size = normalizeString(value, {
          fallbackValue: DEFAULT_SIZE$1,
          validValues: ['x-small', 'small', 'medium', 'large']
        });
        this.updateClassList();
      }
      /**
       * The URL for the image.
       *
       * @type {string}
       * @required
       */


      get src() {
        return this._src;
      }

      set src(value) {
        this._src = typeof value === 'string' && value.trim() || '';
      }
      /**
       * The variant changes the shape of the avatar. Valid values are empty,
       * circle, and square. This value defaults to square.
       *
       * @type {string}
       * @default square
       */


      get variant() {
        return this._variant;
      }

      set variant(value) {
        this._variant = normalizeString(value, {
          fallbackValue: DEFAULT_VARIANT$1,
          validValues: ['circle', 'square']
        });
        this.updateClassList();
      }

      connectedCallback() {
        this.updateClassList();
      } // update custom element's classList


      updateClassList() {
        const size = this._size;
        const variant = this._variant;
        const classes = classSet('slds-avatar').add({
          'slds-avatar_x-small': size === 'x-small',
          'slds-avatar_small': size === 'small',
          'slds-avatar_medium': size === 'medium',
          'slds-avatar_large': size === 'large'
        }).add({
          'slds-avatar_circle': variant === 'circle'
        });
        classListMutation(this.classList, classes);
      }

      get computedInitialsClass() {
        return classSet('slds-avatar__initials').add(computeSldsClass(this.fallbackIconName)).toString();
      }

      get showInitials() {
        return !this._src && this.initials;
      }

      get showIcon() {
        return !this._src && !this.initials;
      }

      handleImageError(event) {
        // eslint-disable-next-line no-console
        console.warn(`<lightning-avatar> Image with src="${event.target.src}" failed to load.`);
        this._src = '';
      }

    }

    lwc.registerDecorators(LightningAvatar, {
      publicProps: {
        alternativeText: {
          config: 0
        },
        fallbackIconName: {
          config: 0
        },
        initials: {
          config: 0
        },
        size: {
          config: 3
        },
        src: {
          config: 3
        },
        variant: {
          config: 3
        }
      },
      track: {
        _size: 1,
        _src: 1,
        _variant: 1
      }
    });

    var _lightningAvatar = lwc.registerComponent(LightningAvatar, {
      tmpl: _tmpl$z
    });

    function tmpl$E($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        b: api_bind,
        h: api_element,
        c: api_custom_element,
        ti: api_tab_index,
        k: api_key,
        i: api_iterator
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6
      } = $ctx;
      return [$cmp._showMore ? api_element("span", {
        classMap: {
          "slds-listbox-toggle": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 3
      }, [api_element("button", {
        classMap: {
          "slds-button": true
        },
        attrs: {
          "tabindex": "-1"
        },
        key: 4,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleMoreClick))
        }
      }, [api_dynamic($cmp.computedPillCountMoreLabel)])]) : null, api_element("ul", {
        className: $cmp.computedListboxClass,
        attrs: {
          "role": "listbox",
          "aria-label": $cmp.label,
          "aria-orientation": "horizontal"
        },
        key: 5,
        on: {
          "click": _m5 || ($ctx._m5 = api_bind($cmp.handleClick)),
          "keydown": _m6 || ($ctx._m6 = api_bind($cmp.handleKeyDown))
        }
      }, api_iterator($cmp.pillViewModels, function (pillViewModel, index) {
        return api_element("li", {
          classMap: {
            "slds-listbox-item": true
          },
          attrs: {
            "role": "presentation"
          },
          key: api_key(7, pillViewModel.pill.item.label)
        }, [api_custom_element("lightning-pill", _lightningPill, {
          props: {
            "label": pillViewModel.pill.item.label,
            "name": index,
            "href": pillViewModel.pill.item.href,
            "tabIndex": api_tab_index(pillViewModel.tabIndex),
            "role": "option",
            "variant": pillViewModel.pill.variant,
            "ariaSelected": "true"
          },
          key: 8,
          on: {
            "click": _m1 || ($ctx._m1 = api_bind($cmp.handlePillClick)),
            "remove": _m2 || ($ctx._m2 = api_bind($cmp.handleRemove)),
            "blur": _m3 || ($ctx._m3 = api_bind($cmp.handlePillBlur)),
            "focus": _m4 || ($ctx._m4 = api_bind($cmp.handlePillFocus))
          }
        }, [pillViewModel.pill.isIcon ? api_custom_element("lightning-icon", _lightningIcon, {
          classMap: {
            "slds-pill__icon_container": true
          },
          props: {
            "iconName": pillViewModel.pill.item.iconName,
            "alternativeText": pillViewModel.pill.item.alternativeText
          },
          key: 10
        }, []) : null, pillViewModel.pill.isAvatar ? api_custom_element("lightning-avatar", _lightningAvatar, {
          classMap: {
            "slds-pill__icon_container": true
          },
          props: {
            "src": pillViewModel.pill.item.src,
            "fallbackIconName": pillViewModel.pill.item.fallbackIconName,
            "variant": pillViewModel.pill.item.variant,
            "size": "x-small",
            "alternativeText": pillViewModel.pill.item.alternativeText
          },
          key: 12
        }, []) : null])]);
      }))];
    }

    var _tmpl$A = lwc.registerTemplate(tmpl$E);
    tmpl$E.stylesheets = [];
    tmpl$E.stylesheetTokens = {
      hostAttribute: "lightning-pillContainer_pillContainer-host",
      shadowAttribute: "lightning-pillContainer_pillContainer"
    };

    var labelContainerLabel = 'Selected Options:';

    var pillContainerMoreLabel = '+{0} more';

    class LightningPillItem {
      constructor(item) {
        this._item = item;
      }

      get item() {
        return this._item;
      }

      get isAvatar() {
        return this._item.type === 'avatar';
      }

      get isIcon() {
        return this._item.type === 'icon';
      }

      get variant() {
        return this._item.href && this._item.href !== '' ? 'plainLink' : 'plain';
      }

    }

    var LightningPillItem$1 = lwc.registerComponent(LightningPillItem, {
      tmpl: _tmpl$1
    });

    const PILL_SELECTOR = 'lightning-pill';
    const i18n$k = {
      containerLabel: labelContainerLabel
    };
    /**
     * A list of pills grouped in a container. This component requires API version 42.0 and later.
     */

    class LightningPillContainer extends lwc.LightningElement {
      /**
       * Aria label for the pill container.
       * @type {string}
       */
      constructor() {
        super();
        this.label = i18n$k.containerLabel;
        this._variant = void 0;
        this._pills = [];
        this._singleLine = false;
        this._isExpanded = false;
        this._isCollapsible = false;
        this._focusedIndex = 0;
        this._focusedTabIndex = 0;
        this._pillsNotFittingCount = void 0;
        this._pillContainerElementId = void 0;
        this._pills = [];
      }

      connectedCallback() {
        this._connected = true;

        if (this.variant !== 'bare') {
          this.classList.add('slds-pill_container');
        }
      }

      disconnectedCallback() {
        this._connected = false;

        if (this._resizeObserver) {
          this._resizeObserver.disconnect();
        }
      }

      renderedCallback() {
        if (this._resizeObserver) {
          // If we have a resize observer and the pill container is not collapsible it means it was changed
          // to not collapsible, we should disconnect the resize observer.
          if (!this.isCollapsible) {
            this._resizeObserver.disconnect();

            this._resizeObserver = undefined;
          }
        } else if (this.isCollapsible) {
          // No resize observer and is collapsible, we should setup the resize observer
          this._resizeObserver = this._setupResizeObserver();
        }

        const ul = this.template.querySelector('ul');

        if (this._pills.length === 0) {
          // If no option is present, set ul has the focus (SLDS require UL has focus).
          ul.tabIndex = 0;
        } else {
          ul.tabIndex = -1;
          this.setFocusedItemTabIndex(0); // Consider adding pills programmatically to empty pill container.
          // UL has focus, so should shift focus to pill.

          if (this.template.querySelector('ul:focus')) {
            this.focus();
          }
        }
      }
      /**
       * The variant changes the appearance of the pill container. Accepted variants
       * include standard and bare. This value defaults to standard.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || 'standard';
      }

      set variant(value) {
        this._variant = normalizeString(value, {
          fallbackValue: 'standard',
          validValues: ['standard', 'bare']
        });
      }
      /**
       * Specifies whether to keep the pills in a single line.
       * @type {boolean}
       *
       */


      get singleLine() {
        return this._singleLine;
      }

      set singleLine(value) {
        this._singleLine = normalizeBoolean(value);
      }
      /**
       * Specifies whether the pill container can be collapsed.
       * @type {boolean}
       */


      get isCollapsible() {
        return this._isCollapsible;
      }

      set isCollapsible(value) {
        this._isCollapsible = normalizeBoolean(value);
      }
      /**
       * Specifies whether the pill container is expanded.
       * @type {boolean}
       */


      get isExpanded() {
        return this._isExpanded;
      }

      set isExpanded(value) {
        this._isExpanded = normalizeBoolean(value);
        this.classList.toggle('slds-is-expanded', this._isExpanded);
      }
      /**
       * An array of items to be rendered as pills in a container.
       * @type {list}
       */


      get items() {
        return this._pills;
      }

      set items(value) {
        this._pillsChanged = true;
        value = Array.isArray(value) ? value : [];
        this._pills = value.map(item => new LightningPillItem$1(item));
      }

      get pillViewModels() {
        return this._pills.map((pill, index) => {
          return {
            pill,
            tabIndex: this._focusedIndex === index ? this._focusedTabIndex : -1
          };
        });
      }

      get computedListboxClass() {
        const singleLineClass = this.singleLine ? 'slds-listbox_inline' : '';
        return `slds-listbox slds-listbox_horizontal ${singleLineClass}`;
      }

      get focusedIndex() {
        // NOTE: this._pills is manged by getter, setter. So it won't be null or undefined.
        // So call this._pill.length is safe.
        if (this._focusedIndex >= this._pills.length) {
          // Change is due to itemremove event, should move focus to the last one.
          this._focusedIndex = this._deleteLast ? this._pills.length - 1 : 0;
          this._deleteLast = false;
        } else if (this._focusedIndex < 0) {
          this._focusedIndex = this._pills.length - 1;
        }

        return this._focusedIndex;
      }

      set focusedIndex(value) {
        // Host may asynchronous update items. For example, move focus to latest item with right/left key, then host change items.
        // Then at renderedCallback call, need to update which item should has focus, but index > items.length.
        // When set it, the index is valid, but when rendered, index is not valid, so the validation check is happened at getter.
        this._focusedIndex = value;
      }

      get pillNodes() {
        if (!this._pillNodes || this._pillsChanged) {
          this._pillsChanged = false;
          this._pillNodes = this.template.querySelectorAll(PILL_SELECTOR) || [];
        }

        return this._pillNodes;
      }

      get focusedNode() {
        const pills = this.pillNodes;
        return pills.length <= 0 ? null : pills[this.focusedIndex];
      }
      /**
       * Sets focus on the pill list.
       */


      focus() {
        const focusedNode = this.focusedNode;

        if (focusedNode) {
          if (focusedNode.isPlainLink) {
            focusedNode.focusLink();
          } else {
            focusedNode.focus();
          }
        } else {
          const ul = this.template.querySelector('ul');

          if (ul) {
            ul.focus();
          }
        }
      }

      handleRemove(removeEvent) {
        const index = parseInt(removeEvent.detail.name, 10);

        if (typeof index !== 'number' || index < 0) {
          return;
        }

        this.fireEvent(index);
      }

      fireEvent(index) {
        // Mouse click on non-focused pill, switch focus to it.
        if (this.focusedIndex !== index) {
          this.switchFocus(index);
        } // Request to remove the last one, if removed, should move focus to last.


        this._deleteLast = index >= this._pills.length - 1;
        this.dispatchEvent(new CustomEvent('itemremove', {
          detail: {
            item: this.items[index].item,
            index
          }
        }));
      }

      setFocusedItemTabIndex(value) {
        const focusedNode = this.focusedNode;

        if (focusedNode) {
          this._focusedTabIndex = value;
        }
      }

      switchFocus(newValue) {
        // remove focus from current pill
        this.setFocusedItemTabIndex(-1); // move to next

        this.focusedIndex = newValue; // set focus

        this.setFocusedItemTabIndex(0);
        this.focus();
      }

      handleKeyDown(event) {
        if (this._pills.length <= 0) {
          return;
        }

        const index = this.focusedIndex;

        switch (event.keyCode) {
          case keyCodes.left:
          case keyCodes.up:
            this.switchFocus(index - 1);
            break;

          case keyCodes.right:
          case keyCodes.down:
            this.switchFocus(index + 1);
            break;

          default:
            this.focus();
        }
      }

      handlePillFocus() {
        if (!this._hasFocus) {
          this._hasFocus = true;
          this.dispatchEvent(new CustomEvent('focus'));
        }
      }

      handlePillBlur(event) {
        // Replace the below with !this.template.contains(event.relatedTarget) once 0.24 is out
        if (!event.relatedTarget || !this.template.contains(event.relatedTarget)) {
          this._hasFocus = false;
          this.dispatchEvent(new CustomEvent('blur'));
        }
      }

      handleClick() {
        this.focus();
      }

      handlePillClick(clickEvent) {
        const index = parseInt(clickEvent.currentTarget.name, 10);

        if (index >= 0 && this.focusedIndex !== index) {
          this.switchFocus(index);
        } else {
          this.focus();
        }

        clickEvent.stopPropagation();
      }

      handleMoreClick() {
        this.focus();
      }

      get _showMore() {
        return this.isCollapsible && !this.isExpanded;
      }

      get computedPillCountMoreLabel() {
        if (this._isExpanded || isNaN(this._pillsNotFittingCount) || this._pillsNotFittingCount <= 0) {
          return undefined;
        } // TODO: We should have a standard utility for that


        return pillContainerMoreLabel.replace('{0}', this._pillsNotFittingCount);
      }

      _setupResizeObserver() {
        const resizeObserver = new LightningResizeObserver(() => {
          const visibleHeight = this.getBoundingClientRect().height;
          let notFittingCount = 0;

          for (let i = 0; i < this.pillNodes.length; i++) {
            const node = this.pillNodes[i];

            if (node.offsetTop > visibleHeight) {
              notFittingCount += 1;
            }
          }

          this._pillsNotFittingCount = notFittingCount;
        });
        resizeObserver.observe(this.template.querySelector('[role="listbox"]'));
        return resizeObserver;
      }

    }

    lwc.registerDecorators(LightningPillContainer, {
      publicProps: {
        label: {
          config: 0
        },
        variant: {
          config: 3
        },
        singleLine: {
          config: 3
        },
        isCollapsible: {
          config: 3
        },
        isExpanded: {
          config: 3
        },
        items: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        _variant: 1,
        _pills: 1,
        _singleLine: 1,
        _isExpanded: 1,
        _isCollapsible: 1,
        _focusedIndex: 1,
        _focusedTabIndex: 1,
        _pillsNotFittingCount: 1,
        _pillContainerElementId: 1
      }
    });

    var _lightningPillContainer = lwc.registerComponent(LightningPillContainer, {
      tmpl: _tmpl$A
    });

    function tmpl$F($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        gid: api_scoped_id
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14,
        _m15
      } = $ctx;
      return [api_element("label", {
        className: $cmp.computedLabelClass,
        attrs: {
          "data-main-label": true
        },
        key: 2
      }, [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true
        },
        attrs: {
          "title": $cmp.i18n.required
        },
        key: 4
      }, [api_text("*")]) : null, api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 5
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 6
      }, [api_element("div", {
        className: $cmp.computedComboboxGroupClass,
        key: 7
      }, [$cmp.computedHasFilter ? api_element("label", {
        classMap: {
          "slds-form-element__label": true,
          "slds-assistive-text": true
        },
        attrs: {
          "data-filter-label": true
        },
        key: 9
      }, [api_dynamic($cmp.filterLabel)]) : null, $cmp.computedHasFilter ? api_element("div", {
        classMap: {
          "slds-form-element": true
        },
        key: 10
      }, [api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 11
      }, [api_element("div", {
        classMap: {
          "slds-combobox_object-switcher": true,
          "slds-combobox-addon_start": true
        },
        key: 12
      }, [api_custom_element("lightning-base-combobox", _lightningBaseCombobox, {
        attrs: {
          "data-filter": true
        },
        props: {
          "disabled": $cmp.disabled,
          "items": $cmp.filterItems,
          "inputText": $cmp.filterInputText,
          "inputIconName": "utility:down",
          "inputIconSize": "xx-small",
          "dropdownAlignment": "auto"
        },
        key: 13,
        on: {
          "ready": _m0 || ($ctx._m0 = api_bind($cmp.handleFilterReady)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleBlur)),
          "select": _m3 || ($ctx._m3 = api_bind($cmp.handleSelectFilter))
        }
      }, [])])])]) : null, api_custom_element("lightning-base-combobox", _lightningBaseCombobox, {
        className: $cmp.computedLookupComboboxClass,
        attrs: {
          "data-lookup": true
        },
        props: {
          "variant": "lookup",
          "items": $cmp._items,
          "name": $cmp.name,
          "disabled": $cmp.disabled,
          "dropdownAlignment": "auto",
          "placeholder": $cmp.placeholder,
          "inputText": $cmp.inputText,
          "inputPill": $cmp.inputPill,
          "inputMaxlength": $cmp.inputMaxlength,
          "inputIconName": $cmp.inputIconName,
          "inputIconSize": $cmp.inputIconSize,
          "inputIconAlternativeText": $cmp.inputIconAlternativeText,
          "showInputActivityIndicator": $cmp.showActivityIndicator,
          "showDropdownActivityIndicator": $cmp.showDropdownActivityIndicator
        },
        key: 14,
        on: {
          "ready": _m4 || ($ctx._m4 = api_bind($cmp.handleLookupReady)),
          "textchange": _m5 || ($ctx._m5 = api_bind($cmp.handleTextChange)),
          "textinput": _m6 || ($ctx._m6 = api_bind($cmp.handleTextInput)),
          "focus": _m7 || ($ctx._m7 = api_bind($cmp.handleFocus)),
          "blur": _m8 || ($ctx._m8 = api_bind($cmp.handleBlur)),
          "pillremove": _m9 || ($ctx._m9 = api_bind($cmp.handlePillRemove)),
          "endreached": _m10 || ($ctx._m10 = api_bind($cmp.handleEndReached)),
          "dropdownopenrequest": _m11 || ($ctx._m11 = api_bind($cmp.handleDropdownOpenRequest)),
          "select": _m12 || ($ctx._m12 = api_bind($cmp.handleSelect))
        }
      }, [])]), $cmp._hasPills ? api_custom_element("lightning-pill-container", _lightningPillContainer, {
        classMap: {
          "slds-listbox_selection-group": true
        },
        props: {
          "variant": "bare",
          "items": $cmp.pills,
          "isCollapsible": true,
          "isExpanded": $cmp._expandPillContainer
        },
        key: 16,
        on: {
          "blur": _m13 || ($ctx._m13 = api_bind($cmp.handlePillsBlur)),
          "focus": _m14 || ($ctx._m14 = api_bind($cmp.handlePillsFocus)),
          "itemremove": _m15 || ($ctx._m15 = api_bind($cmp.handlePillRemove))
        }
      }, []) : null]), $cmp._helpMessage ? api_element("div", {
        classMap: {
          "slds-form-element__help": true
        },
        attrs: {
          "data-help-message": true,
          "id": api_scoped_id("help-message"),
          "aria-live": "assertive"
        },
        key: 18
      }, [api_dynamic($cmp._helpMessage)]) : null];
    }

    var _tmpl$B = lwc.registerTemplate(tmpl$F);
    tmpl$F.stylesheets = [];

    if (_implicitStylesheets$g) {
      tmpl$F.stylesheets.push.apply(tmpl$F.stylesheets, _implicitStylesheets$g);
    }
    tmpl$F.stylesheetTokens = {
      hostAttribute: "lightning-groupedCombobox_groupedCombobox-host",
      shadowAttribute: "lightning-groupedCombobox_groupedCombobox"
    };

    const i18n$l = {
      required: labelRequired
    };

    class LightningGroupedCombobox extends lwc.LightningElement {
      // TODO: Rename to 'showInputActivityIndicator'
      // Validity related message
      // TODO: Need to remove as if a readonly combobox is needed,
      // the regular lightning-combobox should be used
      constructor() {
        super();
        this.label = void 0;
        this.inputText = '';
        this.inputIconName = 'utility:search';
        this.inputIconSize = 'x-small';
        this.inputIconAlternativeText = void 0;
        this.inputMaxlength = void 0;
        this.showActivityIndicator = false;
        this.showDropdownActivityIndicator = false;
        this.dropdownAlignment = 'left';
        this.placeholder = 'Select an Item';
        this.messageWhenValueMissing = i18n$l.required;
        this.name = void 0;
        this.value = void 0;
        this.required = false;
        this.disabled = false;
        this.readOnly = false;
        this.inputPill = void 0;
        this.filterLabel = void 0;
        this.filterItems = void 0;
        this.filterInputText = void 0;
        this._pills = void 0;
        this._variant = void 0;
        this._items = [];
        this._expandPillContainer = false;
        this._highlightedOptionElementId = '';
        this._helpMessage = void 0;
        this._fieldLevelHelp = void 0;
        this._filterInputId = void 0;
        this._mainInputId = void 0;
        this._mainInputId = generateUniqueId();
        this._filterInputId = generateUniqueId();
      }

      connectedCallback() {
        this._connected = true;
        this.classList.add('slds-form-element');
        this.interactingState = new InteractingState({
          // keeps interacting state when switching between two comboboxes and the pill container
          debounceInteraction: true
        });
        this.interactingState.onleave(() => {
          this.reportValidity();
        });
      }

      synchronizeA11y() {
        const label = this.template.querySelector('[data-main-label]');
        const filterLabel = this.template.querySelector('[data-filter-label]');
        const helpMessage = this.template.querySelector('[data-help-message]'); // const filter = this.template.querySelector('[data-filter]');

        const lookup = this.template.querySelector('[data-lookup]');

        if (helpMessage) {
          lookup.inputDescribedByElements = helpMessage.id;
        }

        synchronizeAttrs(label, {
          for: this._mainInputId
        });
        synchronizeAttrs(filterLabel, {
          for: this._filterInputId
        });
      }

      renderedCallback() {
        this.synchronizeA11y();
      }

      disconnectedCallback() {
        this._connected = false;
      }

      get pills() {
        return this._pills;
      }

      set pills(newPills) {
        assert(Array.isArray(newPills), '"pills" must be an array.');

        if (this._connected && (!newPills || newPills.length === 0)) {
          if (this._focusOnPills) {
            // check why requestAnimationFrame is needed, something is stealing focus otherwise
            requestAnimationFrame(() => {
              this.lookupCombobox.focus();
            });
          }
        }

        this._pills = newPills;
      }

      get fieldLevelHelp() {
        return this._fieldLevelHelp;
      }

      set fieldLevelHelp(value) {
        this._fieldLevelHelp = value;
      }

      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant$1(value);
      }

      set items(items = []) {
        items = lwc.unwrap(items);
        this._items = items;

        if (items) {
          assert(Array.isArray(items), '"items" must be an array.');
        }
      }

      get items() {
        return this._items;
      }

      highlightInputText() {
        if (this._connected) {
          this.lookupCombobox.highlightInputText();
        }
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (this._connected) {
          this.lookupCombobox.focus();
        }
      }

      focusAndOpenDropdownIfNotEmpty() {
        if (this._connected) {
          this.lookupCombobox.focusAndOpenDropdownIfNotEmpty();
        }
      }
      /**
       * Removes focus from the input element.
       */


      blur() {
        if (this._connected) {
          this.lookupCombobox.blur();
        }
      }

      get validity() {
        return this._constraint.validity;
      }

      checkValidity() {
        return this._constraint.checkValidity();
      }

      reportValidity() {
        return this._constraint.reportValidity(message => {
          this._helpMessage = message;
        });
      }

      setCustomValidity(message) {
        this._constraint.setCustomValidity(message);
      }

      showHelpMessageIfInvalid() {
        this.reportValidity();
      }

      handleLookupReady(e) {
        this._mainInputId = e.detail.id;
      }

      handleFilterReady(e) {
        this._filterInputId = e.detail.id;
      }

      get computedUniqueHelpElementId() {
        return this._helpMessage ? this._mainInputId + '-error' : null;
      }

      get lookupCombobox() {
        return this.template.querySelector('[data-lookup]');
      }

      handleDropdownOpenRequest() {
        this.dispatchEvent(new CustomEvent('dropdownopenrequest'));
      }

      handlePillRemove(event) {
        if (!this.disabled) {
          this.dispatchEvent(new CustomEvent('pillremove', {
            detail: event.detail
          }));
        }
      }

      handleTextChange(event) {
        this.dispatchEvent(new CustomEvent('textchange', {
          detail: {
            text: event.detail.text
          }
        }));
      }

      handleTextInput(event) {
        this.dispatchEvent(new CustomEvent('textinput', {
          detail: {
            text: event.detail.text
          }
        }));
      }

      handleSelect(event) {
        this.dispatchEvent(new CustomEvent('select', {
          detail: {
            value: event.detail.value
          }
        }));
      }

      handleSelectFilter(event) {
        const selectedFilterValue = event.detail.value;
        this.dispatchEvent(new CustomEvent('selectfilter', {
          detail: {
            value: selectedFilterValue
          }
        }));
      }

      handleEndReached() {
        this.dispatchEvent(new CustomEvent('endreached'));
      }

      handleFocus() {
        this.interactingState.enter();
        this._expandPillContainer = true;

        if (!this._hasFocus) {
          this._hasFocus = true;
          this.dispatchEvent(new CustomEvent('focus'));
        }
      }

      handlePillsFocus() {
        this.handleFocus();
        this._focusOnPills = true;
      }

      handlePillsBlur() {
        this.handleBlur();
        this._focusOnPills = false;
      }

      handleBlur() {
        this._hasFocus = false; // Once https://github.com/salesforce/lwc/issues/444 is fixed, consider switching to
        // `onfocusout` and `event.relatedTarget` to determine whether the focus stayed in the component,
        // this way the use of async blur can be avoided.

        requestAnimationFrame(() => {
          if (!this._hasFocus) {
            this.interactingState.leave();
            this.dispatchEvent(new CustomEvent('blur'));
            this._expandPillContainer = false;

            if (this.pills && this.pills.length > 0) {
              // Sometimes (involves focusing on lower pills) the pill container scrolls and the top
              // line with the "+ n more" button does not show so we have to manually scroll to the top.
              // We need to figure a better solution for this.
              requestAnimationFrame(() => {
                if (this._connected) {
                  this.template.querySelector('lightning-pill-container').scrollTop = 0;
                }
              });
            }
          }
        });
      }

      get i18n() {
        return i18n$l;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLabelClass() {
        return classSet('slds-form-element__label').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      get computedComboboxGroupClass() {
        return classSet().add({
          'slds-has-selection': Array.isArray(this._pills) && this._pills.length > 0,
          'slds-combobox-group': this.computedHasFilter
        });
      }

      get computedHasFilter() {
        return Array.isArray(this.filterItems);
      }

      get computedLookupComboboxClass() {
        return this.computedHasFilter ? 'slds-combobox-addon_end' : '';
      }

      get _hasPills() {
        return this.pills && this.pills.length > 0;
      }

      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => !this.disabled && this.required && isEmptyString(this.value)
          });
        }

        return this._constraintApi;
      }

    }

    lwc.registerDecorators(LightningGroupedCombobox, {
      publicProps: {
        label: {
          config: 0
        },
        inputText: {
          config: 0
        },
        inputIconName: {
          config: 0
        },
        inputIconSize: {
          config: 0
        },
        inputIconAlternativeText: {
          config: 0
        },
        inputMaxlength: {
          config: 0
        },
        showActivityIndicator: {
          config: 0
        },
        showDropdownActivityIndicator: {
          config: 0
        },
        dropdownAlignment: {
          config: 0
        },
        placeholder: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        name: {
          config: 0
        },
        value: {
          config: 0
        },
        required: {
          config: 0
        },
        disabled: {
          config: 0
        },
        readOnly: {
          config: 0
        },
        inputPill: {
          config: 0
        },
        filterLabel: {
          config: 0
        },
        filterItems: {
          config: 0
        },
        filterInputText: {
          config: 0
        },
        pills: {
          config: 3
        },
        fieldLevelHelp: {
          config: 3
        },
        variant: {
          config: 3
        },
        items: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["highlightInputText", "focus", "focusAndOpenDropdownIfNotEmpty", "blur", "checkValidity", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        _pills: 1,
        _variant: 1,
        _items: 1,
        _expandPillContainer: 1,
        _highlightedOptionElementId: 1,
        _helpMessage: 1,
        _fieldLevelHelp: 1
      }
    });

    var _lightningGroupedCombobox = lwc.registerComponent(LightningGroupedCombobox, {
      tmpl: _tmpl$B
    });

    function tmpl$G($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_custom_element("lightning-grouped-combobox", _lightningGroupedCombobox, {
        props: {
          "disabled": $cmp.disabled,
          "filterInputText": $cmp.filterInputText,
          "filterItems": $cmp.filterItems,
          "filterLabel": $cmp.filterLabel,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "inputIconName": $cmp.inputIconName,
          "inputMaxlength": $cmp.inputMaxlength,
          "inputPill": $cmp.inputPill,
          "inputText": $cmp.inputText,
          "items": $cmp.items,
          "label": $cmp.label,
          "pills": $cmp.pills,
          "placeholder": $cmp.placeholder,
          "required": $cmp.isRequired,
          "showActivityIndicator": $cmp.showActivityIndicator,
          "value": $cmp.value,
          "variant": $cmp.variant
        },
        key: 2,
        on: {
          "blur": _m0 || ($ctx._m0 = api_bind($cmp.handleBlur)),
          "dropdownopenrequest": _m1 || ($ctx._m1 = api_bind($cmp.handleDropdownOpenRequest)),
          "pillremove": _m2 || ($ctx._m2 = api_bind($cmp.handlePillRemove)),
          "select": _m3 || ($ctx._m3 = api_bind($cmp.handleSelect)),
          "selectfilter": _m4 || ($ctx._m4 = api_bind($cmp.handleSelectFilter)),
          "textinput": _m5 || ($ctx._m5 = api_bind($cmp.handleInputTextChange))
        }
      }, [])];
    }

    var _tmpl$C = lwc.registerTemplate(tmpl$G);
    tmpl$G.stylesheets = [];

    if (_implicitStylesheets$f) {
      tmpl$G.stylesheets.push.apply(tmpl$G.stylesheets, _implicitStylesheets$f);
    }
    tmpl$G.stylesheetTokens = {
      hostAttribute: "lightning-lookupDesktop_lookupDesktop-host",
      shadowAttribute: "lightning-lookupDesktop_lookupDesktop"
    };

    const MODAL_TYPE = 'modal';
    const POPOVER_TYPE = 'panel';

    function normalizeInt(x) {
      const parsed = parseInt(x, 10);
      return isNaN(parsed) ? 0 : parsed;
    }

    class OverlayOptions {
      constructor() {
        this._options = {
          panelType: MODAL_TYPE,
          visible: true,
          panelConfig: {}
        };
      }

      get options() {
        if (this._options.panelType === POPOVER_TYPE) {
          if (this._options.panelConfig.showCloseButton == null) {
            this._options.panelConfig.showCloseButton = false;
          }

          if (this._options.panelConfig.showPointer == null) {
            this._options.panelConfig.showPointer = true;
          }
        } // Set isCustomPanel to true, make sure AVP always is ui:modal or ui:panel.


        this._options.panelConfig.isCustomPanel = true;
        return this._options;
      }

      id(value) {
        this._options.panelConfig.devNameOrId = value;
      }

      panelType(value) {
        this._options.panelType = value;
      }

      modal() {
        this._options.panelType = MODAL_TYPE;
      }

      popover() {
        this._options.panelType = POPOVER_TYPE;
      }

      bodyClass(value) {
        this._options.panelConfig.bodyClass = value || '';
      }

      body(value) {
        this._options.panelConfig.body = value || null;
      } // modal specific


      modalClass(value) {
        this._options.panelConfig.modalClass = value || '';
        return this;
      }

      headerClass(value) {
        this._options.panelConfig.headerClass = value || '';
      }

      footerClass(value) {
        this._options.panelConfig.footerClass = value || '';
      }

      classNames(value) {
        this._options.panelConfig.classNames = value || '';
      }

      flavor(value) {
        this._options.panelConfig.flavor = value || '';
      }

      title(value) {
        if (value != null && value !== '') {
          this._options.panelConfig.header = null;
          this._options.panelConfig.title = value;
        }
      }

      header(value) {
        if (value != null) {
          if (typeof value === 'string') {
            this._options.panelConfig.header = null;
            this._options.panelConfig.title = value;
          } else {
            this._options.panelConfig.header = value;
            this._options.panelConfig.title = null;
          }
        }
      }

      footer(value) {
        this._options.panelConfig.footer = value;
      }

      showCloseButton(value) {
        this._options.panelConfig.showCloseButton = !!value;
      }

      closeCallback(value) {
        if (typeof value === 'function') {
          this._options.onDestroy = value;
        }
      } // Popover specific


      referenceSelector(value) {
        this._options.panelConfig.referenceElementSelector = value || '';
      }

      reference(value) {
        this._options.panelConfig.referenceElement = value;
      } // positioning


      showPointer(value) {
        this._options.panelConfig.showPointer = !!value;
      }

      direction(value) {
        this._options.panelConfig.direction = value;
      }

      padding(value) {
        this._options.panelConfig.pad = normalizeInt(value);
      }

      advancedConfig(value) {
        if (typeof value === 'object') {
          this._options.panelConfig.advancedConfig = value;
        }
      }

      boundingElement(value) {
        this._options.panelConfig.boundingElement = value;
      }

      pointerPadding(value) {
        this._options.panelConfig.pointerPad = normalizeInt(value);
      }

      boundingBoxPadding(value) {
        this._options.panelConfig.boundingBoxPad = normalizeInt(value);
      }

      boxDirectionPadding(value) {
        this._options.panelConfig.boxDirectionPad = normalizeInt(value);
      }

      align(value) {
        this._advancedConfig.align = normalizeInt(value);
      }

      targetAlign(value) {
        this._advancedConfig.targetAlign = normalizeInt(value);
      }

      verticalPadding(value) {
        this._advancedConfig.vertPad = normalizeInt(value);
      } // More attributes support W-5455858


      autoFocus(value) {
        this._options.panelConfig.autoFocus = !!value;
      }

      trapFocus(value) {
        this._options.panelConfig.trapFocus = !!value;
      }

      closeOnClickOut(value) {
        this._options.panelConfig.closeOnClickOut = !!value;
      }

      useTransition(value) {
        this._options.panelConfig.useTransition = !!value;
      }

      scopeScrollables(value) {
        this._options.panelConfig.scopeScrollables = !!value;
      }

      closeAction(value) {
        if (typeof value === 'function') {
          this._options.panelConfig.closeAction = value;
        }
      } // Extra attribte pass to custome panel


      customAttributes(value) {
        value = value || {};
        const keys = Object.keys(value);

        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          assert(!this[key], `${key} is a predefined option, can not be overridden by customAttributes`);

          if (!this[key]) {
            this._options.panelConfig[key] = value[key];
          }
        }
      }

      get _advancedConfig() {
        this._options.panelConfig.advancedConfig = this._options.panelConfig.advancedConfig || {};
        return this._options.panelConfig.advancedConfig;
      }

    }

    function parseOptions(options = {}) {
      const config = new OverlayOptions();
      const keys = Object.keys(options);

      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];

        if (typeof config[key] === 'function' && options[key] != null) {
          config[key].apply(config, [options[key]]);
        }
      }

      return config.options;
    }

    const PANEL_ANIMATION_TIME = 220; // panel animation is 0.2s, consider ~17ms frame render, refer to panel.css in aura repo.

    class OverlayPanel {
      constructor(instance) {
        this._panelInstance = instance;
        this._visible = true;
      }

      get isVisible() {
        return this._visible;
      }

      get instance() {
        return this._panelInstance;
      }

      _createPromise(isShow, previousPromise) {
        let promise = new Promise(resolve => {
          const panelCall = isShow ? this._panelInstance.show : this._panelInstance.hide;
          let isDone = false;

          const resolveCall = () => {
            if (!isDone) {
              resolve();
              isDone = true;
            }
          };

          panelCall(resolveCall); // force the promise to resolve if animationend event didn't callback.
          // eslint-disable-next-line lwc/no-set-timeout

          setTimeout(resolveCall, PANEL_ANIMATION_TIME);
        });

        if (previousPromise) {
          promise = this.previousPromise.then(() => promise);
        }

        return promise;
      }

      show() {
        if (!this._visible) {
          this._showPromise = this._createPromise(true, this._hidePromise).then(() => {
            this._showPromise = null;
            this._visible = true;
          });
        }

        return this._showPromise || Promise.resolve();
      }

      hide() {
        if (this._visible) {
          this._hidePromise = this._createPromise(false, this._showPromise).then(() => {
            this._hidePromise = null;
            this._visible = false;
          });
        }

        return this._hidePromise || Promise.resolve();
      }

      close(shouldReturnFocus) {
        return new Promise(resolve => {
          this._panelInstance.close(() => {
            resolve();
          }, shouldReturnFocus);
        });
      }

    }

    function showCustomOverlay(configuration, eventDispatcher) {
      const parameters = parseOptions(configuration);
      return new Promise(resolve => {
        parameters.onCreate = panelInstance => {
          resolve(new OverlayPanel(panelInstance));
        };

        eventDispatcher(parameters);
      });
    }

    function wrapComponent(cmp) {
      return new Promise((resolve, reject) => {
        if (cmp instanceof HTMLElement) {
          aura.createComponent('lightning:overlayInteropWrapper', {
            domElement: cmp
          }, (newComponent, status, errorMessage) => {
            if (status === 'SUCCESS') {
              resolve(newComponent);
            } else {
              const rejectMessage = status === 'INCOMPLETE' ? 'No response from server or client is offline.' : errorMessage;
              reject(rejectMessage);
            }
          });
        } else {
          resolve(cmp);
        }
      });
    }

    function showCustomOverlay$1(configuration) {
      return Promise.all([wrapComponent(configuration.header), wrapComponent(configuration.body), wrapComponent(configuration.footer)]).then(components => {
        const options = Object.assign({}, configuration);
        options.header = components[0];
        options.body = components[1];
        options.footer = components[2];
        return showCustomOverlay(options, eventAttributes => {
          aura.dispatchGlobalEvent('markup://ui:createPanel', eventAttributes);
        });
      });
    }

    // eslint-disable-next-line lwc/no-compat-create
    /**
     * Shows advanced search panel having scoped search results.
     * @param {Object} attrs - Attributes for lookupAdvanced component.
     * Schema -
     * {
     *      additionalFields: {Array},
     *      contextId: {String},
     *      dependentFieldBindings: {Map},
     *      entities: {Array},
     *      field: {String},
     *      groupId: {String},
     *      label: {String},
     *      maxValues: {Integer},
     *      placeholder: {String},
     *      recordId: {String},
     *      saveCallback: {Function},
     *      scopeMap: {Object},
     *      scopeSets: {Object},
     *      source: {String},
     *      term: {String},
     * }
     */

    function showAdvancedSearch(attrs) {
      showCustomOverlay$1({
        isTransient: true,
        isScrollable: false,
        isFullScreen: true,
        flavor: 'large',
        autoFocus: false,
        title: attrs.label
      }).then(panel => {
        updatePanel(panel._panelInstance, attrs);
      });
    }
    /**
     * Updates panel by setting it's body and footer.
     * @param {Object} panel - Instance of panel created, an Aura Component.
     * @param {Object} attrs - Attributes for lookupAdvanced component.
     */

    function updatePanel(panel, attrs) {
      if (!panel || !attrs) {
        return;
      }

      setPanelFooter(panel).then(setPanelBody(panel, attrs)).catch(error => {
        throw new Error(error);
      });
    }
    /**
     * Sets an instance of lookupAdvanced to panel's body.
     * @param {Object} panel - Instance of panel, an Aura Component.
     * @param {Object} attrs - Attributes for lookupAdvanced component.
     * @returns {Promise} a promise used to resolve the creation of lookupAdvanced.
     */


    function setPanelBody(panel, attrs) {
      attrs.panel = panel;
      const promise = new Promise((resolve, reject) => {
        aura.createComponent('forceSearch:lookupAdvanced', attrs, (cmp, status, error) => {
          if (status === 'SUCCESS') {
            panel.update({
              body: cmp
            });
            resolve();
          } else {
            reject(error);
          }
        });
      });
      return promise;
    }
    /**
     * Sets an instance of lookupAdvancedFooter to panel's footer.
     * @param {Object} panel - Instance of panel, an Aura Component.
     * @return {Promise} a promise used to resolve the creation of
     * lookupAdvancedFooter.
     */


    function setPanelFooter(panel) {
      const promise = new Promise((resolve, reject) => {
        aura.createComponent('forceSearch:lookupAdvancedFooter', {
          'aura:id': 'lookupAdvancedFooter'
        }, (cmp, status, error) => {
          if (status === 'SUCCESS') {
            panel.set('v.footer', cmp);
            resolve();
          } else {
            reject(error);
          }
        });
      });
      return promise;
    }

    /*
     * The name of the type of the item that represents the advanced search option.
     * @type {String}
     */
    const ACTION_ADVANCED_SEARCH = 'actionAdvancedSearch';
    /*
    * The name of the type of the item that represents the create new action.
    * @type {String}
    */

    const ACTION_CREATE_NEW = 'actionCreateNew';
    /*
     * GroupId used during advanced search.
     * The groupId indicates the group to which advancedSearch component belongs.
     * Typically only components with identical groupId values will interact.
     * @type {String}
     */

    const ADVANCED_SEARCH_GROUP_ID = 'LOOKUP';
    /*
     * The max number of values a user can select in advanced search.
     * @type {Number}
     */

    const ADVANCED_SEARCH_MAX_VALUES = 1;
    /**
     * The UI API default page value.
     * @type {Number}
     */

    const DEFAULT_PAGE = 1;
    /**
     * The UI API default pageSize value.
     * @type {Number}
     */

    const DEFAULT_PAGE_SIZE = 25;
    /**
     * The default count of items to display in combobox.
     * @type {Number}
     */

    const DEFAULT_LIST_SIZE = 5;
    /**
     * An event indicating a change in lookup value.
     * @type {String}
     */

    const EVENT_CHANGE = 'change';
    /**
     * An event indicating a create new option was selected.
     * @type {String}
     */

    const EVENT_CREATE_NEW = 'createnew';
    /**
     * An event indicating an error.
     * @type {String}
     */

    const EVENT_ERROR = 'error';
    /**
     * An event indicating an error from lds wire adapter.
     * @type {String}
     */

    const EVENT_LDS_ERROR = 'ldserror';
    /**
     * The default entity icon.
     * @type {String}
     */

    const ICON_DEFAULT = 'standard:default';
    /**
     * The add utility icon name.
     * @type {String}
     */

    const ICON_ADD = 'utility:add';
    /**
     * The check utility icon name.
     * @type {String}
     */

    const ICON_CHECK = 'utility:check';
    /**
     * The search utility icon name.
     * @type {String}
     */

    const ICON_SEARCH = 'utility:search';
    /**
     * The utility icon with small size.
     * @type {String}
     */

    const ICON_SIZE_SMALL = 'small';
    /**
     * The utility icon with extra small size.
     * Typically used with search, and add icons.
     * @type {String}
     */

    const ICON_SIZE_X_SMALL = 'x-small';
    /**
     * The max length for combobox input.
     * @type {Number}
     */

    const INPUT_MAX_LENGTH = 255;
    /**
     * The layout type for record-ui wire request.
     * @type {String}
     */

    const LAYOUT_TYPE_FULL = 'Full';
    /**
     * The lightning combobox component name.
     * @type {String}
     */

    const LIGHTNING_COMBOBOX = 'lightning-grouped-combobox';
    /**
     * The ailtn transaction MRU action type for create new.
     * @type {String}
     */

    const LOG_ACTION_CREATE_NEW_OPTION = 'CREATE_OPTION';
    /**
     * The ailtn transaction MRU action type for advanced search.
     * @type {String}
     */

    const LOG_ACTION_SEARCH_OPTION = 'SEARCH_OPTION';
    /**
     * The ailtn transaction context query type for MRU.
     * @type {String}
     */

    const LOG_CONTEXT_Q_TYPE_MRU = 'MRU';
    /**
     * The ailtn transaction context query type for TypeAhead.
     * @type {String}
     */

    const LOG_CONTEXT_Q_TYPE_TYPEAHEAD = 'Typeahead';
    /**
     * The ailtn transaction event source for click interaction.
     * @type {String}
     */

    const LOG_EVENT_CLICK = 'click';
    /**
     * The ailtn transaction event source for pill removal.
     * @type {String}
     */

    const LOG_EVENT_PILL_REMOVE = 'synthetic-pill-remove';
    /**
     * The ailtn transaction scope for lookup desktop.
     * @type {String}
     */

    const LOG_SCOPE_INPUT_LOOKUP_DESKTOP = 'search-input-lookup-desktop';
    /**
     * The ailtn transaction scope for the entiy selector for the lookup desktop.
     * @type {String}
     */

    const LOG_SCOPE_ENTITY_SELECTOR = 'search-entity-selector';
    /**
     * The ailtn transaction target for lookup input.
     * @type {String}
     */

    const LOG_TARGET_INPUT = 'search-input';
    /**
     * The ailtn transaction target for action items like advanced search.
     * @type {String}
     */

    const LOG_TARGET_MRU_ACTION_ITEM = 'search-mru-action-item';
    /**
     * The ailtn transaction target for MRU record items.
     * @type {String}
     */

    const LOG_TARGET_MRU_ITEM = 'search-mru-item';
    /**
     * The ailtn transaction target for the record pill.
     * @type {String}
     */

    const LOG_TARGET_RECORD_PILL_ITEM = 'search-record-pill-item';
    /**
     * The ailtn transaction target for the entity filter item..
     * @type {String}
     */

    const LOG_TARGET_FILTER_ITEM = 'search-filter-item';
    /**
     * The mode view for record-ui wire request.
     * @type {String}
     */

    const MODE_VIEW = 'View';
    /**
     * The combo-box action type to show record.
     * @type {String}
     */

    const OPTION_TYPE_CARD = 'option-card';
    /**
     * The combo-box option type to show an action.
     * @type {String}
     */

    const OPTION_TYPE_INLINE = 'option-inline';
    /**
     * The combo-box pill item type to show icons.
     * @type {String}
     */

    const PILL_TYPE_ICON = 'icon';
    /**
     * UI API query parameter for the dependent field bindings.
     * @type {String}
     */

    const QUERY_PARAMS_DEPENDENT_FIELD_BINDINGS = 'dependentFieldBindings';
    /**
     * UI API query parameter for the page.
     * @type {String}
     */

    const QUERY_PARAMS_PAGE = 'page';
    /**
     * UI API query parameter for the page size.
     * @type {String}
     */

    const QUERY_PARAMS_PAGE_SIZE = 'pageSize';
    /**
     * UI API query parameter for the search term.
     * @type {String}
     */

    const QUERY_PARAMS_Q = 'q';
    /**
     * UI API query parameter for the search type like Recent or TypeAhead.
     * @type {String}
     */

    const QUERY_PARAMS_SEARCH_TYPE = 'searchType';
    /**
     * The UI API searchType value for Recent records.
     * @type {String}
     */

    const SEARCH_TYPE_RECENT = 'Recent';
    /**
     * The UI API searchType value for TypeAhead records.
     * @type {String}
     */

    const SEARCH_TYPE_TYPEAHEAD = 'TypeAhead';

    /**
     * Requests a log entry for tracking user interactions.
     * @param {String} ailtnEventSource - The synthetic event source for the interaction.
     * @param {String} ailtnScope - The component that handles the action. Effectively it's an ancestor of the target component.
     * @param {String} ailtnTarget - The component that handles the event.
     * @param {Object} ailtnContext - The composite of the context from the target and scope. This needs to be a flat map.
     */

    function log(ailtnEventSource, ailtnScope, ailtnTarget, ailtnContext) {
      if (!ailtnEventSource || !ailtnScope || !ailtnTarget) {
        return;
      }

      const _ailtnContext = ailtnContext || {};

      _ailtnContext.sourceCmp = 'lightning:lookup-desktop';
      _ailtnContext.time = Date.now();
      auraInstrumentation.interaction(ailtnTarget, ailtnScope, _ailtnContext, ailtnEventSource);
    }

    var labelAdd = 'Add';

    var labelAdvancedSearch = '"{0}" in {1}';

    var labelCreateNew = 'New {0}';

    var labelCurrentSelection = 'Current Selection';

    var labelMessageWhenBadInputDefault = 'Select an option or remove the search term.';

    var labelMruHeader = 'Recent {0}';

    var labelSearch = 'Search';

    var labelSearchObjectsPlaceholder = 'Search {0}...';

    var labelSearchPlaceholder = 'Search...';

    var labelSelectObject = 'Choose an object';

    const i18n$m = {
      add: labelAdd,
      advancedSearch: labelAdvancedSearch,
      createNew: labelCreateNew,
      currentSelection: labelCurrentSelection,
      messageWhenBadInputDefault: labelMessageWhenBadInputDefault,
      mruHeader: labelMruHeader,
      search: labelSearch,
      searchObjectsPlaceholder: labelSearchObjectsPlaceholder,
      searchPlaceholder: labelSearchPlaceholder,
      selectEntity: labelSelectObject
    };
    /**
     * Compares given array to check if they have identical (string) elements
     * irrespective of their positions.
     * Note - Does not perform deep comparison.
     * @param {Array} array1 - Source array.
     * @param {Array} array2 - Desination array for comparison.
     * @returns {Boolean} true if array1 and array2 have same elements.
     */

    function arraysIdentical(array1 = [], array2 = []) {
      if (!Array.isArray(array1) || !Array.isArray(array2)) {
        return false;
      }

      if (array1.length !== array2.length) {
        return false;
      }

      const sortedArray1 = Object.assign([], array1).sort();
      const sortedArray2 = Object.assign([], array2).sort();
      return sortedArray1.toString() === sortedArray2.toString();
    }
    /**
     * Get advanced search action item for display.
     * @param {String} term - A search term.
     * @param {String} label - Plural name of target api.
     * @returns {Object} - An advanced search action item.
     */


    function computeAdvancedSearchOption(term, label) {
      if (term === null || term === undefined) {
        term = '';
      }

      if (label === null || label === undefined) {
        label = '';
      }

      return {
        highlight: true,
        iconAlternativeText: `${i18n$m.search}`,
        iconName: ICON_SEARCH,
        iconSize: ICON_SIZE_X_SMALL,
        text: `${i18n$m.advancedSearch}`.replace('{0}', term).replace('{1}', label),
        type: OPTION_TYPE_CARD,
        value: ACTION_ADVANCED_SEARCH
      };
    }
    /**
     * Returns a CSV string of dependent field bindings given a Record
     * representaiton and a list of dependent fields.
     * @param  {Object} record - A record representation.
     * @param  {Array} dependentFields - An array of depedent field api names.
     * @return {Object} - A CSV string of dependent field bindings.
     */


    function computeBindingsString(record, dependentFields) {
      if (!record || !dependentFields || !dependentFields.length) {
        return null;
      }

      return dependentFields.map(field => {
        const value = record.fields && record.fields[field] ? record.fields[field].value : null;
        return `${field}=${value}`;
      }).join(',');
    }
    /**
     * Returns a map of dependent field bindings given a Record representaiton and
     * a list of dependent fields.
     * @param  {Object} record - A record representation.
     * @param  {Array} dependentFields - An array of depedent field api names.
     * @return {Object} - A map of dependent field bindings.
     */


    function computeBindingsMap(record, dependentFields) {
      if (!record || !dependentFields || !dependentFields.length) {
        return null;
      }

      const dependentFieldBindings = {};
      dependentFields.forEach(field => {
        const value = record.fields && record.fields[field] ? record.fields[field].value : null;
        dependentFieldBindings[field] = value;
      });
      return dependentFieldBindings;
    }
    /**
     * Get create new action item for display.
     * @param {String} label - Plural name of target api.
     * @returns {Object} - A create new action item.
     */


    function computeCreateNewOption(label = '') {
      if (label === null) {
        label = '';
      }

      return {
        iconAlternativeText: `${i18n$m.add}`,
        iconName: ICON_ADD,
        iconSize: ICON_SIZE_X_SMALL,
        text: `${i18n$m.createNew}`.replace('{0}', label),
        type: OPTION_TYPE_CARD,
        value: ACTION_CREATE_NEW
      };
    }
    /**
     * Gets deduped, and trimmed items.
     * @param {Array} items - The original list of items to be deduped.
     * @param {Array} valuesToIgnore - The list of values to ignore.
     * @param {Number} count - The count of number of items to return.
     * @returns {Array} - The the deduped and trimmed items list.
     */


    function computeDedupedItems(items = [], valuesToIgnore = [], count) {
      if (items === null) {
        items = [];
      }

      if (valuesToIgnore === null) {
        valuesToIgnore = [];
      }

      const dedupedItems = items.filter(item => {
        return valuesToIgnore.indexOf(item.value) < 0;
      });

      if (Number.isInteger(count) && count > 0 && dedupedItems.length > count) {
        dedupedItems.length = count;
      }

      return dedupedItems;
    }
    /**
     * Computes custom event to notify change, error, createnew etc.
     * @param {String} type - The type of event being dispatched.
     * @param {Object} detail - The event data.
     * @param {Boolean} bubbles - Whether or not the event bubbles.
     * @returns {Object} - A custom event.
     */


    function computeEvent(type, detail, bubbles = true) {
      if (!type) {
        return {};
      }

      if (bubbles === null) {
        bubbles = true;
      } // eslint-disable-next-line lightning-global/no-custom-event-identifier-arguments


      return new CustomEvent(type, {
        composed: bubbles,
        bubbles,
        detail
      });
    }
    /**
     * Computes the field API name, qualified with an object name if possible.
     * @param {String|FieldId} fieldName - The value from which to get the field API name.
     * @param {String} sourceApiName - The source record's api name.
     * @return {String} - The field API name.
     */


    function computeFieldApiName(fieldName = '', sourceApiName = '') {
      if (fieldName === null) {
        fieldName = '';
      }

      if (sourceApiName === null) {
        sourceApiName = '';
      }

      let apiName = '';

      if (typeof fieldName === 'string' && fieldName.length) {
        const idx = fieldName.indexOf('.');

        if (idx >= 1) {
          apiName = fieldName;
        }
      } else if (typeof fieldName === 'object' && typeof fieldName.objectApiName === 'string' && typeof fieldName.fieldApiName === 'string') {
        apiName = fieldName.objectApiName + '.' + fieldName.fieldApiName;
      }

      if (!apiName.length && fieldName.length && sourceApiName.length) {
        apiName = sourceApiName + '.' + fieldName;
      }

      return apiName;
    }
    /**
     * Computes a map of field info like isRequired, dependentFields, etc.
     * @param {Object} objectInfos - Source record's objectInfos.
     * @param {String} apiName - An api name.
     * @param {String} fieldApiName - The qualified field name.
     * @returns {Object} - A map of field infos.
     */


    function computeFieldInfo(objectInfos, apiName, fieldApiName) {
      let computedFieldInfo = {};

      if (!objectInfos || !apiName || !fieldApiName) {
        return computedFieldInfo;
      }

      const fieldName = computeUnqualifiedFieldApiName(fieldApiName);
      const objectInfo = objectInfos[apiName] || {};
      const fieldInfo = objectInfo.fields ? objectInfo.fields[fieldName] : null;

      if (fieldInfo) {
        computedFieldInfo = {
          // See https://sfdc.co/dependent-lookups for more information.
          dependentFields: fieldInfo.filteredLookupInfo ? fieldInfo.filteredLookupInfo.controllingFields : undefined,
          fieldName,
          inlineHelpText: fieldInfo.inlineHelpText,
          isRequired: fieldInfo.required,
          references: fieldInfo.referenceToInfos,
          relationshipName: fieldInfo.relationshipName
        };
      }

      return computedFieldInfo;
    }
    /**
     * Gets entity items for multi-entity filter.
     * @param {Object} references - A map of reference apis having name fields and action details.
     * @param {String} chosenApi - Selected api that gets check icon.
     * @returns {List} - An array of filter items that can be consumed by the combobox.
     */


    function computeFilterItems(references = {}, chosenApi) {
      if (references === null) {
        references = {};
      }

      const referenceApiNames = Object.keys(references);
      let items = null;

      if (referenceApiNames.length > 1) {
        // Alphabetically sort api names.
        referenceApiNames.sort();
        items = [];
        referenceApiNames.forEach(apiName => {
          const item = {
            text: references[apiName].label,
            type: OPTION_TYPE_INLINE,
            value: apiName
          };

          if (chosenApi && apiName === chosenApi) {
            item.highlight = true;
            item.iconAlternativeText = `${i18n$m.currentSelection}`;
            item.iconName = ICON_CHECK;
            item.iconSize = ICON_SIZE_X_SMALL;
          }

          items.push(item);
        });
      }

      return items;
    }
    /**
     * Gets filter label for the multi-entity lookup.
     * @returns {String} - Filter dropdown label for the multi-entity.
     */


    function computeFilterLabel() {
      return `${i18n$m.selectEntity}`;
    }
    /**
     * Determines the SLDS icon string given an objectInfo. If the icon cannot be
     * resolved from the given objectInfo, 'standard:default' is returned.
     * TODO: This needs to be done through an API.
     * @param  {Object} objectInfo - An objectInfo.
     * @return {String} - A slds icon string.
     */


    function computeIconName(objectInfo) {
      if (!objectInfo || !objectInfo.themeInfo || !objectInfo.themeInfo.iconUrl) {
        return ICON_DEFAULT;
      }

      const iconUrl = objectInfo.themeInfo.iconUrl;
      const parts = iconUrl.split('/');
      const icon = parts.pop().replace(/(_\d+)(\.\w*)/gi, '');
      const category = parts.pop();
      return `${category}:${icon}`;
    }
    /**
     * Computes heading for the display items.
     * @param {String} label - Plural name of target api.
     * @returns {List} - The new items with heading set.
     */


    function computeHeading(label = '') {
      return `${i18n$m.mruHeader}`.replace('{0}', label);
    }
    /**
     * Returns items with text slices for highlighting.
     *
     * For example -
     * items = [{ text: "salesforce", subText: "(213)111-4444",...}]
     * term = "sal force"
     * returns -
     * [
     *    {
     *      "text": [
     *        {
     *          "text": "sal",
     *          "highlight": true
     *        },
     *        {
     *          "text": "es"
     *        },
     *        {
     *            "text": "force",
     *            "highlight": true
     *        }
     *      ],
     *      "subText": [
     *        {
     *          "text": "(213)111-4444"
     *        }
     *      ],
     *      ...
     *    }
     *  ]
     *
     * Important caveats -
     *
     * Handling term with substrings:
     * --------------------------------
     * Term is broken up into parts for matching by splitting it using whitespaces.
     * Matching for each part starts from the begining till the end of the original text.
     * Parts that are subtrings of each other may get merged while highlighting.
     * For example -
     * text = "salesforce.com account"
     * term = "salesforce.com a"
     * "salesforce.com" would be highlighted but not "a" because it's a substring of "salesforce.com"
     * however for the term "salesforce.com acc" both "salesforce.com" and "acc" would be highlighted.
     *
     * Handling term with wildcards:
     * --------------------------------
     * Wildcards are not dropped while matching.
     * For example -
     * text = "salesforce.com"
     * term = "sales*"
     * would NOT result in highlighting of "sales". However if text was "sales*foo"
     * then the subtring "sales*" would be highlighted.
     *
     * @param {Array} items - Items representing records.
     * @param {String} term - A search term for matching.
     * @return {Array} - An array of items with text split for highlighting.
     */


    function computeHighlightedItems(items, term) {
      const output = []; // No-op if items or term is empty.

      if (!items || items.length === 0 || !term) {
        return output;
      } // Get unique parts of the term.
      // For example -
      // term = "sal sal sales"
      // words = ["sal","sales"]


      const words = term.trim().split(' ').filter((w, i, ar) => {
        return ar.indexOf(w) === i;
      });
      items.forEach(item => {
        const outputItem = Object.assign({}, item); // Creating text list to process text and subText.

        const textList = []; // Process text only if it's not empty

        if (item.text) {
          textList.push({
            type: 'text',
            text: item.text
          });
        } else {
          outputItem.text = null;
        } // Process subText only if it's not empty


        if (item.subText) {
          textList.push({
            type: 'subText',
            text: item.subText
          });
        } else {
          outputItem.subText = null;
        }

        textList.forEach(textItem => {
          // Get matching indexes for the search term.
          const intervals = getMatchingIndexes(textItem.text, words); // If match not found, then return the original text.

          if (intervals.length === 0) {
            outputItem[textItem.type] = [{
              text: textItem.text
            }];
          } else {
            // Get slices of matching text with highlight markers.
            outputItem[textItem.type] = splitTextFromMatchingIndexes(textItem.text, intervals);
          }
        });
        output.push(outputItem);
      });
      return output;
    }
    /**
     * Computes default error message for the bad input
     * @returns {String} The default error message for the bad input
     */


    function computeMessageWhenBadInputDefault() {
      return `${i18n$m.messageWhenBadInputDefault}`;
    }
    /**
     * Computes a map of object info for a given api.
     * @param {Object} objectInfos - Source record's objectInfos.
     * @param {String} apiName - An api name.
     * @returns {Object} - A map of object infos for the given api.
     */


    function computeObjectInfo(objectInfos, apiName) {
      if (!objectInfos || !apiName) {
        return {};
      }

      const objectInfo = objectInfos[apiName] || {};
      const themeInfo = objectInfo.themeInfo || {};
      return {
        apiName,
        color: themeInfo.color || '',
        iconAlternativeText: apiName,
        iconName: computeIconName(objectInfo),
        iconUrl: themeInfo.iconUrl || '',
        keyPrefix: objectInfo.keyPrefix,
        label: objectInfo.label,
        labelPlural: objectInfo.labelPlural
      };
    }
    /**
     * Computes an array of optional name fields required for @wire(getRecordUi)
     * For example - ['Opportunity.Name', 'User.Name'...]
     * @param {Object} references - A map of reference apis having name fields and action details.
     * @returns {Array} - An array of name fields.
     */


    function computeOptionalNameFields(references = {}) {
      if (references === null) {
        references = {};
      }

      const optionalNameFields = [];

      for (const reference in references) {
        if (references.hasOwnProperty(reference) && references[reference].hasOwnProperty('optionalNameField')) {
          optionalNameFields.push(references[reference].optionalNameField);
        }
      }

      return optionalNameFields;
    }
    /**
     * Gets placeholder text for lookup input.
     * @param {String} label - Plural name of target api.
     * @returns {String} - Placeholder text for lookup input.
     */


    function computePlaceholder(label) {
      let placeholder;

      if (label) {
        // Returns "Search <label>", for example - "Search Accounts".
        placeholder = `${i18n$m.searchObjectsPlaceholder}`.replace('{0}', label);
      } else {
        // Returns "Search..."
        placeholder = `${i18n$m.searchPlaceholder}`;
      }

      return placeholder;
    }
    /**
     * Computes a list of pills for the record values.
     * @param  {Object} record - A record representation.
     * @param {Object} fieldInfo - The record's field info.
     * @param {Object} referenceInfos - The reference api infos.
     * @returns {Array} - An array of pills for the record field values.
     */


    function computeRecordPills(record, fieldInfo, referenceInfos) {
      let pills = [];

      if (!record || !fieldInfo || !referenceInfos) {
        return pills;
      }

      const relationshipFieldValue = record.fields[fieldInfo.relationshipName].value; // No-op if relationship field value is empty.

      if (!relationshipFieldValue) {
        return pills;
      } // No-op if field value and relationship field value are inconsistent.


      if (relationshipFieldValue.fields.Id.value !== record.fields[fieldInfo.fieldName].value) {
        return pills;
      }

      const apiName = relationshipFieldValue.apiName;

      if (apiName in referenceInfos) {
        const referenceInfo = referenceInfos[apiName];
        const pill = {
          iconAlternativeText: referenceInfo.iconAlternativeText,
          iconName: referenceInfo.iconName,
          iconSize: ICON_SIZE_SMALL,
          label: relationshipFieldValue.fields[referenceInfo.nameField].value,
          type: PILL_TYPE_ICON,
          value: relationshipFieldValue.fields.Id.value
        };
        pills = [pill];
      }

      return pills;
    }
    /**
     * Computes a list of values from record for the given field.
     * @param  {Object} record - A record representation.
     * @param {String} fieldApiName - The qualified field name.
     * @returns {Array} - An array of the record field values.
     */


    function computeRecordValues(record, fieldApiName) {
      if (!record || !fieldApiName) {
        return [];
      }

      const fieldName = computeUnqualifiedFieldApiName(fieldApiName);
      const recordField = record.fields[fieldName];
      return recordField.value && recordField.value.length ? [recordField.value] : [];
    }
    /**
     * Computes a map of supported references apis with their infos like nameField, label, iconName etc.
     * @param {Object} objectInfos - Source record's objectInfos.
     * @param {Object} referenceToInfos - References for the field.
     * @returns {Object} - A map of reference infos.
     */


    function computeReferenceInfos(objectInfos = {}, referenceToInfos = []) {
      if (objectInfos === null) {
        objectInfos = {};
      }

      if (referenceToInfos === null) {
        referenceToInfos = [];
      }

      const references = {};

      for (const reference of referenceToInfos) {
        const apiName = reference.apiName;
        const nameFields = reference.nameFields;
        let nameField;

        if (Array.isArray(nameFields) && nameFields.length > 0) {
          if (nameFields.length > 1) {
            nameField = 'Name';
          } else {
            nameField = nameFields[0];
          }

          const objectInfo = computeObjectInfo(objectInfos, apiName);
          objectInfo.createNewEnabled = undefined;
          objectInfo.nameField = nameField;
          objectInfo.optionalNameField = apiName + '.' + nameField;
          references[apiName] = objectInfo;
        }
      }

      return references;
    }
    /**
     * Computes map of attributes for given object.
     * Common keys include name, label, labelPlural and iconUrl.
     * @param {Object} objectInfo - An objectInfo.
     * @returns {Object} - A map of attributes.
     */


    function computeScopeMap(objectInfo = {}) {
      if (objectInfo === null) {
        objectInfo = {};
      }

      return {
        iconUrl: objectInfo.iconUrl,
        label: objectInfo.label,
        labelPlural: objectInfo.labelPlural,
        name: objectInfo.apiName
      };
    }
    /**
     * Computes the field API name from a qualified field name.
     * For example - Opportunity.AccountId returns 'AccountId'
     * @param {String} fieldApiName - The qualified field name.
     * @return {String} - The unqualified field name.
     */


    function computeUnqualifiedFieldApiName(fieldApiName = '') {
      if (fieldApiName === null) {
        fieldApiName = '';
      }

      const idx = fieldApiName.indexOf('.'); // The object api name must non-empty.

      if (idx < 1) {
        return '';
      }

      return fieldApiName.substring(idx + 1);
    }
    /**
     * Checks if the given term is contains any CJK characters.
     * @param {String} term - A search term.
     * @return {Boolean} - True if the term contains any CJK characters.
     */


    function hasCJK(term = '') {
      if (term === null) {
        return false;
      }

      if (typeof term !== 'string') {
        return false;
      }

      const chars = term.trim().split('');

      for (let i = 0; i < chars.length; i++) {
        if (/^[\u1100-\u1200\u3040-\uFB00\uFE30-\uFE50\uFF00-\uFFF0]+$/.test(chars[i])) {
          return true;
        }
      }

      return false;
    }
    /**
     * Checks if at least one action supports "CreateFromLookup".
     * @param {Array} actions - An array of lookup actions received from @wire(getLookupActions)
     * @returns {Boolean} - True if "CreateFromLookup" action was found.
     */


    function hasCreateFromLookup(actions = []) {
      if (actions === null) {
        actions = [];
      }

      let hasCreateNew = false;

      if (!Array.isArray(actions) || actions.length === 0) {
        return hasCreateNew;
      }

      for (let i = 0; i < actions.length; i++) {
        const action = actions[i];
        const actionListContext = action.hasOwnProperty('actionListContext') ? action.actionListContext : null;
        const actionApiName = action.hasOwnProperty('apiName') ? action.apiName : null;
        hasCreateNew = actionListContext === 'Lookup' && actionApiName === 'CreateFromLookup';

        if (hasCreateNew) {
          return hasCreateNew;
        }
      }

      return hasCreateNew;
    }
    /**
     * Checks if object has no keys.
     * @param {String} obj - An object to be validated.
     * @returns {Boolean} - True if object has no keys.
     */


    function isEmptyObject(obj) {
      if (obj === undefined || obj === null) {
        return false;
      } // eslint-disable-next-line guard-for-in


      for (const name in obj) {
        return false;
      }

      return true;
    }
    /**
     * Checks if the given term is a valid search term.
     * @param {String} term - A search term.
     * @return {Boolean} - True if the term is a valid search string.
     */


    function isValidSearchTerm(term) {
      if (!term) {
        return false;
      }

      const normalizedTerm = term.replace(/[()"?*]+/g, '').trim();
      return normalizedTerm.length >= 2 || hasCJK(normalizedTerm);
    }
    /**
     * Checks if the given term is a valid typeahead search term.
     * @param {String} term - A search term.
     * @return {Boolean} - True if the term is a valid typeahead string.
     */


    function isValidTypeAheadTerm(term) {
      if (!term) {
        return false;
      }

      const normalizedTerm = term.replace(/[()"?*]+/g, '').trim();
      return normalizedTerm.length < 255 && (normalizedTerm.length > 2 || hasCJK(normalizedTerm));
    }
    /**
     * Returns matching indexes for the terms found in the given text.
     *
     * For example -
     * text = "salesforce"
     * words = ["sal","force"]
     * returns - [[0,3],[5,10]]
     *
     * @param {String} text - Original text for matchin search term.
     * @param {String} words - Distinct words or term parts.
     * @return {Array} - An array of intervals.
     */


    function getMatchingIndexes(text, words) {
      let output = []; // No-op if text to match or term is missing.

      if (!text || !words) {
        return output;
      }

      const matchIndexes = {}; // Convert text to lower case for matching.

      const lowerCasedText = text.toLowerCase();

      for (let t = 0; t < words.length; t++) {
        const word = words[t]; // Convert word to lower case for matching.

        const lowerCasedWord = word.toLowerCase();
        let index = 0,
            start = 0,
            numMatches = 0;

        while (start < text.length && index !== -1 && numMatches < 1) {
          index = lowerCasedText.indexOf(lowerCasedWord, start); // Match found.

          if (index > -1) {
            // Get end index for the current term.
            const endIndex = index + lowerCasedWord.length; // If some term part was found previously with the same start
            // index then update the endIndex having longest part.
            // For example -
            // text = "salesforce"
            // words = ["sal", "salesf"]
            //
            // For "sal", matchIndexes would be {0:3}
            // For "salesf", matchIndexes would be updated to {0:6}

            if (matchIndexes[index]) {
              if (matchIndexes[index] < endIndex) {
                matchIndexes[index] = endIndex;
              }
            } else {
              // No matching term part found for the index, make a new entry.
              matchIndexes[index] = endIndex;
            }

            numMatches++; // Increment the start pointer.

            start = endIndex;
          }
        }
      } // Convert indexes map into an array of indexes.


      output = Object.keys(matchIndexes).map(interval => {
        return [parseInt(interval, 10), matchIndexes[interval]];
      });
      return output;
    }
    /**
     * Merges overlapping intervals.
     *
     * For example -
     * intervals = [[0,3],[1,4],[5,7]]
     * returns - [[0,4],[5,7]]
     *
     * @param {Array} intervals - An array of intervals to merge.
     * @return {Array} - An array of merged intervals.
     */


    function mergeIntervals(intervals) {
      if (!intervals || !intervals.length) {
        return [];
      }

      intervals.sort((a, b) => {
        return a[0] !== b[0] ? a[0] - b[0] : a[1] - b[1];
      });
      let prev = intervals[0];
      const output = [prev];

      for (const curr of intervals) {
        if (curr[0] <= prev[1]) {
          prev[1] = Math.max(prev[1], curr[1]);
        } else {
          output.push(curr);
          prev = curr;
        }
      }

      return output;
    }
    /**
     * Splits text using indexes and adds highlight marker.
     *
     * For example -
     * text = "salesforce"
     * intervals = [[0,3]]
     * returns -
     * [
     *  {
     *    "text": "sal",
     *    "highlight": true
     *  },
     *  {
     *    "text": "esforce"
     *  }
     * ]
     *
     * @param {String} text - Original text for matching indexes.
     * @param {Array} intervals - An array of intervals to highlight.
     * @return {Array} - An array of text items with highlighting.
     */


    function splitTextFromMatchingIndexes(text, intervals) {
      const output = []; // No-op if text or intervals is missing.

      if (!text || !intervals || intervals.length === 0) {
        return output;
      } // Merge intervals to avoid incorrect slicing.


      const _intervals = mergeIntervals(intervals); // Sort array based on first value.


      _intervals.sort((prev, next) => {
        return prev[0] > next[0];
      });

      let prevMatchEndIdx = 0;

      for (let i = 0; i < _intervals.length; i++) {
        const startIdx = _intervals[i][0];
        const endIdx = _intervals[i][1]; // Push part before start index.

        const prevText = text.substring(prevMatchEndIdx, startIdx);

        if (prevText) {
          output.push({
            text: prevText
          });
        } // Push part having match.


        output.push({
          text: text.substring(startIdx, endIdx),
          highlight: true
        }); // Update previous match index with current end index.

        prevMatchEndIdx = endIdx;
      } // Push remaining text.


      const remainingText = text.substring(prevMatchEndIdx);

      if (remainingText) {
        output.push({
          text: remainingText
        });
      }

      return output;
    }

    /**
     * Displays an input lookup for the Desktop.
     */

    class LightningLookupDesktop extends lwc.LightningElement {
      // ================================================================================
      // PUBLIC PROPERTIES
      // ================================================================================

      /**
       * Checks the lookup validity, and fires an 'invalid' event if it's in invalid state.
       * @return {Boolean} - The validity status of the lookup.
       */
      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Indicates whether the field is disabled.
       * @type {Boolean}
       */


      /**
       * @return {String} - The lookup field name.
       */
      get fieldName() {
        return this._fieldName;
      }
      /**
       * Sets the field name for the lookup.
       * @param {String|FieldId} value - The lookup field name.
       */


      set fieldName(value) {
        this._fieldName = value;
        this.updateState();
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (!this._connected) {
          return;
        }

        const combobox = this.template.querySelector(LIGHTNING_COMBOBOX);

        if (combobox) {
          combobox.focus();
        }
      }
      /**
       * The text label for the field.
       * @type {String}
       */


      /**
       * @return {Number} - The maximum number of values supported by the lookup.
       */
      get maxValues() {
        return this._maxValues;
      }
      /**
       * Sets the maximum number of values that can be inserted into the lookup.
       * @param {Number} value - The maximum number of values for the lookup.
       */


      set maxValues(value) {
        this.updateMaxValues(value);
      }
      /**
       * The error message to be displayed when the user enters the text in the input
       * but does not select a valid option.
       * @type {String}
       *
       */


      /**
       * @return {Object} - The source record's objectInfos.
       */
      get objectInfos() {
        return this._objectInfos;
      }
      /**
       * Sets the source record's objectInfos.
       * @param {Object} value - The source record's objectInfos.
       */


      set objectInfos(value) {
        this._objectInfos = value;
        this.updateState();
      }
      /**
       * @return {Object} - The source record representation.
       */


      get record() {
        return this._record;
      }
      /**
       * Sets the source record representation.
       * @param {Object} value - The source record.
       */


      set record(value) {
        this._record = value;
        this.updateState();
      }
      /**
       * The field info in the object info is not updated based on the layout metadata.
       * It allows field to be marked as required for the given layout.
       * @return {Boolean} - Indicates whether or not the field is required.
       */


      get required() {
        return this._required;
      }
      /**
       * Sets the flag to mark the field as required.
       * @param {Boolean} value - A flag to mark the field as required.
       */


      set required(value) {
        this._required = normalizeBoolean(value);
        this.updateState();
      }
      /**
       * Shows validation message based on the validity status.
       * @return {Boolean} - The validity status of the lookup.
       */


      reportValidity() {
        const combobox = this.template.querySelector(LIGHTNING_COMBOBOX);

        if (combobox) {
          return this._constraint.reportValidity(message => {
            combobox.setCustomValidity(message);
            combobox.reportValidity();
          });
        }

        return false;
      }
      /**
       * Sets a custom validity message.
       * @param {String} message - The validation message to be shown in an error state.
       */


      setCustomValidity(message) {
        const combobox = this.template.querySelector(LIGHTNING_COMBOBOX);

        if (combobox) {
          this._constraint.setCustomValidity(message);

          combobox.setCustomValidity(message);
        }
      }
      /**
       * TODO - Remove when @wire(getLookupActions) response is invocable.
       * @return {Boolean} Indicates whether or not to show the create new option.
       */


      get showCreateNew() {
        return this._showCreateNew;
      }
      /**
       * TODO - Remove when @wire(getLookupActions) response is invocable.
       * Sets the flag to enable or disable create new option.
       * If set to true, a backend validation is made using @wire(getLookupActions) to check if
       * create action from lookup is supported for the given target api, and option is added accordingly.
       * @param {Boolean} value - A flag to enable or disable create new option.
       */


      set showCreateNew(value) {
        this._showCreateNew = normalizeBoolean(value);
        this.updateState();
      }
      /**
       * Displays a validation message if the lookup is in invalid state.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }
      /**
       * Gets the validity constraint of the lookup.
       * @return {Object} - The current validity constraint.
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * @return {Array} An array of selected lookup values.
       */


      get value() {
        return this._value;
      }
      /**
       * Sets the values for the lookup.
       * @param {Array} value - An array of record ids.
       */


      set value(value) {
        // Update values, and pills.
        this.updateValue(value, [], false);
      }
      /**
       * Sets the variant type for the lookup.
       * @type {String}
       */


      // ================================================================================
      // ACCESSOR METHODS
      // ================================================================================

      /**
       * Gets the validity constaint.
       */
      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => this.isRequired && (!Array.isArray(this._value) || !this._value.length),
            badInput: () => this.inputText.trim().length
          });
        }

        return this._constraintApi;
      }
      /**
       * Returns an input text for the entity filter.
       * @returns {String} See desc.
       */


      get filterInputText() {
        return this._targetObjectInfo.label;
      } // ================================================================================
      // LIFECYCLE METHODS
      // ================================================================================


      constructor() {
        super();
        this.disabled = false;
        this.label = void 0;
        this.messageWhenBadInput = computeMessageWhenBadInputDefault();
        this.messageWhenValueMissing = void 0;
        this.variant = void 0;
        this.fieldLevelHelp = void 0;
        this.filterItems = void 0;
        this.filterLabel = void 0;
        this.inputIconName = void 0;
        this.inputMaxlength = void 0;
        this.inputPill = null;
        this.inputText = '';
        this.items = [];
        this.isRequired = void 0;
        this.pills = [];
        this.placeholder = '';
        this.showActivityIndicator = void 0;
        this._abortWireItems = false;
        this._actionObjectApiNames = void 0;
        this._actionRequestParams = void 0;
        this._connected = false;
        this._fieldApiName = void 0;
        this._fieldInfo = void 0;
        this._fieldName = void 0;
        this._getLookupActionsInProgress = void 0;
        this._getLookupRecordsInProgress = void 0;
        this._getRecordUiInProgress = void 0;
        this._hasDropdownOpened = void 0;
        this._maxValues = 1;
        this._objectInfos = void 0;
        this._optionalFields = void 0;
        this._pills = [];
        this._record = void 0;
        this._recordIds = void 0;
        this._referenceInfos = {};
        this._requestParams = {
          [QUERY_PARAMS_Q]: '',
          [QUERY_PARAMS_SEARCH_TYPE]: SEARCH_TYPE_RECENT,
          [QUERY_PARAMS_PAGE]: DEFAULT_PAGE,
          [QUERY_PARAMS_PAGE_SIZE]: DEFAULT_PAGE_SIZE,
          [QUERY_PARAMS_DEPENDENT_FIELD_BINDINGS]: null
        };
        this._required = false;
        this._showCreateNew = false;
        this._sourceObjectInfo = {};
        this._targetApiName = void 0;
        this._targetObjectInfo = {};
        this._value = void 0;
        this._wireItems = [];
        this.inputIconName = ICON_SEARCH;
        this.inputMaxlength = INPUT_MAX_LENGTH;
        this.filterLabel = computeFilterLabel();
      }

      connectedCallback() {
        this._connected = true;
      }

      disconnectedCallback() {
        this._connected = false;
      } // ================================================================================
      // WIRE METHODS
      // ================================================================================


      wiredLookupActions({
        error,
        data
      }) {
        // Update wire status.
        this.updateWireStatus('getLookupActions', false);

        if (error) {
          this.fireEvent(EVENT_LDS_ERROR, error);
          return;
        } else if (!data) {
          return;
        }

        try {
          for (const apiName in data.actions) {
            if (data.actions.hasOwnProperty(apiName) && this._referenceInfos.hasOwnProperty(apiName)) {
              this._referenceInfos[apiName].createNewEnabled = hasCreateFromLookup(data.actions[apiName].actions);
            }
          }
        } catch (e) {
          this.fireEvent(EVENT_ERROR, {
            error: e
          });
        }
      }

      wiredLookupRecords({
        error,
        data
      }) {
        // Update wire status.
        this.updateWireStatus('getLookupRecords', false);

        if (error) {
          this.resetCombobox();
          this.fireEvent(EVENT_LDS_ERROR, error);
          return;
        } else if (!data || this._abortWireItems) {
          return;
        }

        try {
          const records = data ? data.records : [];
          this._wireItems = records.map(record => {
            const fields = record.fields;
            return {
              iconAlternativeText: this._targetObjectInfo.iconAlternativeText,
              iconName: this._targetObjectInfo.iconName,
              iconSize: ICON_SIZE_SMALL,
              subText: fields.hasOwnProperty('DisambiguationField') ? fields.DisambiguationField.value : null,
              text: fields[this._referenceInfos[this._targetObjectInfo.apiName].nameField].value,
              type: OPTION_TYPE_CARD,
              value: fields.Id.value
            };
          });
          /*
           * During init both getLookupActions and getLookupRecords wire actions are in progress simultaneously.
           * Delaying updating record items until both actions are received.
           * TODO - W-5313904 - Handle this with Promises
           */

          if (this._getLookupActionsInProgress) {
            let counter = 0;

            const delayedUpdateItems = () => {
              if (this._getLookupActionsInProgress && counter < 100) {
                counter++; // eslint-disable-next-line lwc/no-set-timeout

                setTimeout(delayedUpdateItems, 100);
              } else {
                this.updateItems();
              }
            }; // eslint-disable-next-line lwc/no-set-timeout


            setTimeout(delayedUpdateItems, 100);
          } else {
            // Update display items.
            this.updateItems();
          }
        } catch (e) {
          this.fireEvent(EVENT_ERROR, {
            error: e
          });
        }
      }

      wiredRecordUi({
        error,
        data
      }) {
        // Update wire status.
        this.updateWireStatus('getRecordUi', false);

        if (error) {
          this.fireEvent(EVENT_LDS_ERROR, error);
          return;
        } else if (!data) {
          return;
        }

        try {
          const pills = [];
          const invalidValues = [];

          for (const r in data.records) {
            if (data.records.hasOwnProperty(r)) {
              const record = data.records[r];
              const apiName = record.apiName; // Process records of supported target apis.

              if (this._referenceInfos.hasOwnProperty(apiName)) {
                const iconName = computeIconName(this._objectInfos[apiName]);
                const pill = {
                  iconAlternativeText: apiName,
                  iconName,
                  label: record.fields[this._referenceInfos[apiName].nameField].value,
                  type: PILL_TYPE_ICON,
                  value: record.id
                };
                pills.push(pill);
              } else {
                // Collect values with invalid reference apis.
                invalidValues.push(record.id);
              }
            }
          }

          if (invalidValues.length > 0 && this._value) {
            // Remove invalid values from this._values
            const values = this._value.filter(value => !invalidValues.includes(value)); // Update values, and pills.


            this.updateValue(values, pills, false);
          } else {
            // Update pills only as no invalid values found.
            this.updatePills(pills);
          }
        } catch (e) {
          this.fireEvent(EVENT_ERROR, {
            error: e
          });
        }
      } // ================================================================================
      // PRIVATE METHODS
      // ================================================================================

      /**
       * Aborts processing data from the wire action in flight.
       */


      abortWireAction() {
        this._abortWireItems = true;
        this._wireItems = [];
        this.updateWireStatus('getLookupRecords', false);
      }
      /**
       * Callback method executed by the parent component to update values after handling "createnew" event.
       * @param {Array} values - An array of newly created record ids.
       */


      createNewCallback(values = []) {
        if (!Array.isArray(values) || !values.length) {
          return;
        } // Append new values to exisitng values.


        const newValues = Object.assign([], this._value).concat(values); // Update values, pills, and fire change event.

        this.updateValue(newValues);
      }
      /**
       * Fires an event with details for parent component to handle.
       * @param {String} type - The type of event being dispatched.
       * @param {Object} detail - The event data.
       * @param {Boolean} bubbles - Whether or not the event bubbles.
       */


      fireEvent(type, detail, bubbles = true) {
        let event;

        switch (type) {
          case EVENT_ERROR:
            // eslint-disable-next-line no-console
            console.error(detail.error.message);
            event = computeEvent(type, detail, bubbles);
            break;

          case EVENT_LDS_ERROR:
            // eslint-disable-next-line no-console
            console.error(detail.message);
            event = createErrorEvent(detail);
            break;

          default:
            event = computeEvent(type, detail, bubbles);
            break;
        } // Trigger event.


        if (event) {
          this.dispatchEvent(event);
        }
      }
      /**
       * Handles advanced search by showing scoped results in a panel.
       */


      handleAdvancedSearchAction() {
        // Log click on advanced search option interaction.
        log(LOG_EVENT_CLICK, LOG_SCOPE_INPUT_LOOKUP_DESKTOP, LOG_TARGET_MRU_ACTION_ITEM, {
          scopeName: this._targetObjectInfo.apiName,
          type: LOG_ACTION_SEARCH_OPTION
        });
        const scopeMap = computeScopeMap(this._targetObjectInfo);

        const saveCallback = values => {
          // Advanced search returns an array of selected values.
          if (values && values.length > 0) {
            // Select first value as selected value.
            const selectedValue = values[0];
            const recordId = selectedValue.id;

            if (!Array.isArray(this._value) || !this._value.includes(recordId)) {
              const vals = Object.assign([], this._value);
              vals.push(recordId); // Compute pill if label is available.
              // This avoids unnecessary triggering of wire.

              if (selectedValue.Name) {
                const pill = {
                  iconAlternativeText: this._targetObjectInfo.iconAlternativeText,
                  iconName: this._targetObjectInfo.iconName,
                  label: selectedValue.Name,
                  type: PILL_TYPE_ICON,
                  value: recordId
                };
                const pills = Object.assign([], this._pills);
                pills.push(pill); // Update values with pills.

                this.updateValue(vals, pills);
              } else {
                // Update values, and resolve pills later.
                this.updateValue(vals);
              } // Reset combobox.


              this.resetCombobox();
              this.focus();
            }
          }
        };

        const fieldName = computeUnqualifiedFieldApiName(this._fieldApiName);
        const lookupAdvancedAttributes = {
          additionalFields: [],
          contextId: '',
          dependentFieldBindings: computeBindingsMap(this._record, this._fieldInfo.dependentFields),
          entities: [scopeMap],
          field: fieldName,
          groupId: ADVANCED_SEARCH_GROUP_ID,
          label: this.label,
          maxValues: ADVANCED_SEARCH_MAX_VALUES,
          placeholder: this.placeholder,
          recordId: Array.isArray(this._value) && this._value.length ? this._value[0] : '',
          saveCallback,
          scopeMap,
          scopeSets: {
            DEFAULT: [scopeMap]
          },
          source: this._sourceObjectInfo.apiName,
          term: this.inputText
        };

        try {
          // Show advanced search modal.
          showAdvancedSearch(lookupAdvancedAttributes);
        } catch (error) {
          this.fireEvent(EVENT_ERROR, {
            error
          });
        }
      }
      /**
       * Shows validation message based on the validity status on blur of the input.
       */


      handleBlur() {
        this.reportValidity();
      }
      /**
       * Handles create new option selection.
       */


      handleCreateNewAction() {
        // Log click on create new option interaction.
        log(LOG_EVENT_CLICK, LOG_SCOPE_INPUT_LOOKUP_DESKTOP, LOG_TARGET_MRU_ACTION_ITEM, {
          scopeName: this._targetObjectInfo.apiName,
          sourceName: this._sourceObjectInfo.apiName,
          type: LOG_ACTION_CREATE_NEW_OPTION
        }); // Fire an event to notify parent to handle create new action.

        this.fireEvent(EVENT_CREATE_NEW, {
          value: this._targetObjectInfo.apiName,
          callback: this.createNewCallback.bind(this)
        }); // Reset combobox.

        this.resetCombobox();
      }
      /**
       * Handles the input's focus event.
       */


      handleDropdownOpenRequest() {
        // Log lookup activation.
        log(LOG_EVENT_CLICK, LOG_SCOPE_INPUT_LOOKUP_DESKTOP, LOG_TARGET_INPUT, {
          scopeName: this._targetObjectInfo.apiName
        }); // On the first focus update the internal state that triggers wire..

        if (!this._hasDropdownOpened) {
          this._hasDropdownOpened = true; // Executes wire actions deferred until user's first interaction.

          this.updateState();
        } // Show MRU items only if -
        // 1) There is no wire action in flight AND
        // 2) User has not typed any inputText.


        if (!this._getLookupRecordsInProgress && !this.inputText.length) {
          this.updateTerm('');
        }
      }
      /**
       * Handles the oninput and onchange events from the combobox input, triggering an update to @wire parameters.
       * @param {Object} event - The input's oninput/onchange event.
       */


      handleInputTextChange(event) {
        // Stop combobox event propagation.
        event.stopPropagation(); // No-op if event detail is empty.

        if (!event.detail) {
          return;
        }

        const term = event.detail.text || ''; // Update term.

        this.updateTerm(term);
      }
      /**
       * Handles the pillremove event fired from combo-box when a selected option is removed.
       * @param {Object} event - Contains details of the event being handled.
       */


      handlePillRemove(event) {
        // Log input pill removal interaction.
        log(LOG_EVENT_PILL_REMOVE, LOG_SCOPE_INPUT_LOOKUP_DESKTOP, LOG_TARGET_RECORD_PILL_ITEM, {
          scopeName: this._targetObjectInfo.apiName
        });

        if (this._maxValues === 1) {
          // Update values, and pills.
          this.updateValue([]);
        } else if (this._maxValues > 1) {
          // No-op if event detail is empty.
          if (!event.detail) {
            return;
          }

          const removedValue = event.detail.item.value;

          if (removedValue && this._value && this._pills) {
            // Remove deleted value.
            const values = this._value.filter(v => {
              return v !== removedValue;
            }); // Remove pill for the removed value.


            const pills = this._pills.filter(p => {
              return p.value !== removedValue;
            }); // Update values, and pills.


            this.updateValue(values, pills);
          }
        } // Reset combobox.


        this.resetCombobox();
      }
      /**
       * Handles record option selection
       * @param {String} recordId - The record id of the option.
       */


      handleRecordOptionSelect(recordId) {
        // No-op if record id is empty.
        if (!recordId) {
          return;
        } // No-op if maxValues count is reached.


        if (Array.isArray(this._value) && this._value.length === this._maxValues) {
          return;
        }

        const isMRU = this._requestParams[QUERY_PARAMS_SEARCH_TYPE] === SEARCH_TYPE_RECENT;
        const itemCount = this.items.length;
        const position = this.items.findIndex(item => {
          return item.value === recordId;
        }); // Log click on record option interaction.

        log(LOG_EVENT_CLICK, LOG_SCOPE_INPUT_LOOKUP_DESKTOP, LOG_TARGET_MRU_ITEM, {
          recordId,
          position,
          qType: isMRU ? LOG_CONTEXT_Q_TYPE_MRU : LOG_CONTEXT_Q_TYPE_TYPEAHEAD,
          mruVisibleCount: isMRU ? itemCount : 0,
          typeAheadVisibleCount: isMRU ? 0 : itemCount,
          scopeName: this._targetObjectInfo.apiName
        });

        if (!Array.isArray(this._value) || !this._value.includes(recordId)) {
          // Append new value to the existing list.
          const values = Object.assign([], this._value);
          values.push(recordId); // Selected recordId is always expected to be present in the wireItems.
          // Use it to populate pill info so as to avoid triggering wire.

          const wireItem = this._wireItems.find(record => {
            return record.value === recordId;
          });

          const pills = Object.assign([], this._pills);
          pills.push({
            iconAlternativeText: wireItem.iconAlternativeText,
            iconName: wireItem.iconName,
            iconSize: wireItem.iconSize,
            label: wireItem.text,
            type: PILL_TYPE_ICON,
            value: wireItem.value
          }); // Update values, and pills.

          this.updateValue(values, pills); // Reset combobox.

          this.resetCombobox();
        }
      }
      /**
       * Handles the select event fired from combo-box when an option is selected.
       * @param {Object} event - Contains details of the event being handled.
       */


      handleSelect(event) {
        const value = event.detail.value;

        switch (value) {
          case ACTION_ADVANCED_SEARCH:
            this.handleAdvancedSearchAction();
            break;

          case ACTION_CREATE_NEW:
            this.handleCreateNewAction();
            break;

          default:
            this.handleRecordOptionSelect(value);
            break;
        }
      }
      /**
       * Handles entity filter change.
       * @param {Object} event - The filter's onchange event object.
       */


      handleSelectFilter(event) {
        if (!event.detail) {
          return;
        } // Log click on filter item interaction.


        log(LOG_EVENT_CLICK, LOG_SCOPE_ENTITY_SELECTOR, LOG_TARGET_FILTER_ITEM, {
          scopeName: this._targetObjectInfo.apiName
        });
        const selectedEntity = event.detail.value; // No-op if newly selected target api is the same as the previous one.

        if (selectedEntity === this._targetObjectInfo.apiName) {
          return;
        } // If it's a single value lookup then clear values for the previous target api.


        if (this._maxValues === 1) {
          this.updateValue([]);
        } // Update target object info as per newly selected entity.


        this._targetObjectInfo = computeObjectInfo(this._objectInfos, selectedEntity); // Update internal state.

        this.updateState();
      }
      /**
       * Resets combobox, and aborts receiving new items.
       */


      resetCombobox() {
        if (this.items.length) {
          this.items = [];
        }

        this.inputText = '';
        this.abortWireAction();
      }
      /**
       * Adds advanced search action option to the display items.
       */


      setAdvancedSearchOption() {
        const term = this.inputText || ''; // Insert the advanced search action if a valid search term found.

        if (isValidSearchTerm(term)) {
          const advancedSearchOption = computeAdvancedSearchOption(term, this._targetObjectInfo.labelPlural);
          this.items.unshift(advancedSearchOption); // Trigger items setter for the combobox.

          this.items = this.items.slice();
        }
      }
      /**
       * Adds the create new action option to the display items.
       */


      setCreateNewOption() {
        if (this.showCreateNew && // TODO - Remove when @wire(getLookupActions) response is invocable.
        this._referenceInfos[this._targetObjectInfo.apiName].createNewEnabled) {
          this.items.push(computeCreateNewOption(this._targetObjectInfo.label)); // Trigger items setter for the combobox.

          this.items = this.items.slice();
        }
      }
      /**
       * Checks if combobox items should be displayed.
       * @returns {Boolean} - True if items should be shown.
       */


      shouldDisplayItems() {
        let displayItems;

        if (!this._hasDropdownOpened) {
          displayItems = false;
        } else if (this._maxValues === 1 && this.inputPill) {
          // Don't show items if it's a single-value lookup, and inputPill is already present.
          displayItems = false;
        } else {
          displayItems = true;
        } // Clear display items.


        if (!displayItems && this.items.length) {
          this.items = [];
        }

        return displayItems;
      }
      /**
       * Updates combobox filter items.
       */


      updateFilterItems() {
        // For single-value lookup, if an inputPill is present then filter items shouldn't be shown.
        if (this._maxValues === 1 && this.inputPill) {
          this.filterItems = null;
        } else {
          this.filterItems = computeFilterItems(this._referenceInfos, this._targetObjectInfo.apiName);
        }

        this.updatePlaceholder();
      }
      /**
       * Updates the list of items displayed in the grouped-combobox dropdown,
       * adding the advanced search option if a valid search term is present.
       */


      updateItems() {
        // No-op if items are not expected to be displayed.
        if (!this.shouldDisplayItems()) {
          return;
        } // Clear previous items.


        if (this.items.length) {
          this.items = [];
        }

        const term = this.inputText || '';
        const filteredItems = computeDedupedItems(this._wireItems, this._value, DEFAULT_LIST_SIZE);

        if (filteredItems.length > 0) {
          if (!term.length) {
            // Show MRU items with the heading.
            this.items = [{
              label: computeHeading(this._targetObjectInfo.labelPlural),
              items: filteredItems
            }];
          } else if (term.length > 0) {
            // Get items with highlighting.
            this.items = computeHighlightedItems(filteredItems, term);
          }
        } // Add advanced search option.


        this.setAdvancedSearchOption(); // Add create new option.

        this.setCreateNewOption();
      }
      /**
       * Updates max value count. Also updates existing values, and pills correspondingly.
       * @param {Number} count - The maximum number of values supported by the lookup.
       */


      updateMaxValues(count) {
        // Update internal state of maxValues.
        this._maxValues = count; // No-op if values are not defined.

        if (!Array.isArray(this._value) || !this._value.length) {
          return;
        }

        let pills; // Trim existing values as per new max count.

        if (this._value.length > this._maxValues) {
          const values = this._value.slice(0, this._maxValues); // Trim existing pills as per new max count.


          const pillValues = this._pills.map(pill => {
            return pill.value;
          });

          if (arraysIdentical(pillValues, this._value)) {
            // Trim pills if they are up to date with the values.
            pills = this._pills.slice(0, this._maxValues);
            this.updateValue(values, pills, false);
          } else {
            this.updateValue(values, [], false);
          }
        } else {
          pills = Object.assign([], this._pills); // Update pills arrangement only since values remain the same.

          this.updatePills(pills);
        }
      }
      /**
       * Updates the pill using info it obtained via argument, local data or wire.
       * @param {Array} pills - An array of pills infos representing values.
       */


      updatePills(pills = []) {
        // Check if any pills are missing, if so then trigger @wire(getRecordUi) to resolve them.
        const pillValues = pills.map(pill => {
          return pill.value;
        });
        let pillsResolved = arraysIdentical(pillValues, this._value);

        if (!pillsResolved) {
          try {
            // Try to resolve pill from the source record itself to avoid hitting wire.
            const values = computeRecordValues(this._record, this._fieldApiName);

            if (arraysIdentical(values, this._value)) {
              pills = computeRecordPills(this._record, this._fieldInfo, this._referenceInfos);

              if (pills.length) {
                pillsResolved = true;
              }
            }
          } catch (error) {
            this.fireEvent(EVENT_ERROR, {
              error
            });
          }
        }

        if (pillsResolved) {
          // Update internal copy of pills.
          this._pills = pills; // Pills are empty, hence clear input as well as container pills.

          if (!pills.length) {
            this.inputPill = null;
            this.pills = [];
          } else if (pills.length > 0) {
            // inputPill, and pills can never co-exist.
            if (this._maxValues === 1) {
              this.inputPill = this._pills[0];
              this.pills = [];
            } else if (this._maxValues > 1) {
              this.pills = this._pills;
              this.inputPill = null;
            }
          } // Check if items should be displayed, and clear if necessary.


          this.shouldDisplayItems(); // Update filter items.

          this.updateFilterItems(); // Grab the focus after populating pills.

          this.focus();
          return;
        }

        if (!pillsResolved && this._value.length) {
          // Trigger wire to get record representations of live values, and update pills.
          this.updateWireStatus('getRecordUi', true);
          this._optionalFields = computeOptionalNameFields(this._referenceInfos);
          this._recordIds = this._value.slice();
        }
      }
      /**
       * Updates combobox input placeholder
       */


      updatePlaceholder() {
        const referenceApiNames = Object.keys(this._referenceInfos); // If it's a multi-entity lookup then the placeholder should be "Search..."

        const label = referenceApiNames.length === 1 ? this._targetObjectInfo.labelPlural : null;
        this.placeholder = computePlaceholder(label);
      }
      /**
       * Updates _requestParams to trigger @wire's observable.
       * @param {String} key - A property on _requestParams.
       * @param {String} value - A value corresponding to the property.
       */


      updateRequestParams(key, value) {
        // No-op if items are not expected to be displayed.
        if (!this.shouldDisplayItems()) {
          return;
        }

        this._requestParams[key] = value;
        this._requestParams = Object.assign({}, this._requestParams); // Trigger wire.

        this._targetApiName = this._targetObjectInfo.apiName;

        if (this._targetApiName && this._fieldApiName) {
          this.updateWireStatus('getLookupRecords', true);
        }
      }
      /**
       * Updates lookup's internal state.
       */


      updateState() {
        if (!this._fieldName || !Object.keys(this._record || {}).length || !Object.keys(this._objectInfos || {}).length) {
          return;
        }

        try {
          // Update source object info.
          this._sourceObjectInfo = computeObjectInfo(this._objectInfos, this._record.apiName); // Update field info.

          this._fieldApiName = computeFieldApiName(this._fieldName, this._sourceObjectInfo.apiName);
          this._fieldInfo = computeFieldInfo(this._objectInfos, this._sourceObjectInfo.apiName, this._fieldApiName);
          this.fieldLevelHelp = this._fieldInfo.inlineHelpText;
          this._referenceInfos = computeReferenceInfos(this._objectInfos, this._fieldInfo.references); // If field is marked as required in the field info then override the public property.

          if (this._fieldInfo.isRequired) {
            this._required = this._fieldInfo.isRequired;
          }

          this.isRequired = this._required; // Update dependent field bindings for the request params.

          this.updateRequestParams(QUERY_PARAMS_DEPENDENT_FIELD_BINDINGS, computeBindingsString(this._record, this._fieldInfo.dependentFields)); // Update target info.
          // Select first field reference apiName as target api if targetObjectInfo is empty or stale.

          if (isEmptyObject(this._targetObjectInfo) || !this._referenceInfos.hasOwnProperty(this._targetObjectInfo.apiName)) {
            let targetApi;
            const fieldReferences = this._fieldInfo.references;

            if (Array.isArray(fieldReferences) && fieldReferences.length) {
              targetApi = fieldReferences[0].apiName;
            }

            this._targetObjectInfo = computeObjectInfo(this._objectInfos, targetApi);
          } else {
            // Update state could be triggered due to updating of objectInfos hence re-create
            // targetObjectInfo for it's apiName.
            this._targetObjectInfo = computeObjectInfo(this._objectInfos, this._targetObjectInfo.apiName);
          } // Update filter items for entity selection.


          this.updateFilterItems(); // Update values.

          if (this._value === undefined) {
            const values = computeRecordValues(this._record, this._fieldApiName); // Don't fire change event since default values is assigned from the record.

            this.updateValue(values, [], false);
          } // Update action info.
          // Defer wire action until user activates the lookup.


          const referenceApiNames = Object.keys(this._referenceInfos);

          if (this.showCreateNew && this._hasDropdownOpened) {
            // Trigger wire only if new reference apis found.
            this.updateWireStatus('getLookupActions', true);
            this._actionObjectApiNames = referenceApiNames;
          } // Reset combobox.


          this.resetCombobox();
        } catch (error) {
          this.fireEvent(EVENT_ERROR, {
            error
          });
        }
      }
      /**
       * Updates term state, triggering the @wire service on term change.
       * @param  {String} term - The search term.
       */


      updateTerm(term) {
        // Update combobox input text value.
        this.inputText = term; // Allow processing of the wire items.

        this._abortWireItems = false; // Determine if it's a MRU or TypeAhead request, and update request params.

        this.updateRequestParams(QUERY_PARAMS_SEARCH_TYPE, isValidTypeAheadTerm(term) ? SEARCH_TYPE_TYPEAHEAD : SEARCH_TYPE_RECENT); // Update search term, and trigger wire.

        this.updateRequestParams(QUERY_PARAMS_Q, term.trim());
      }
      /**
       * Updates the live value, sets the pills and fires 'change' event if requested.
       * Typically 'change' event should be triggered when values are committed by the user.
       * @param {Array} value - An array of record ids.
       * @param {Array} pills - An array of pill infos corresponding to the values.
       * @param {Boolean} triggerEvent - Whether or not to fire change event.
       */


      updateValue(value = [], pills = [], triggerEvent = true) {
        if (value === null) {
          value = [];
        }

        if (!Array.isArray(value)) {
          return;
        }

        if (value.length) {
          value = value.filter(val => val) // Drop empty.
          .map(val => normalizeRecordId(val.trim())) // Convert to 18-char record ids.
          .filter((elem, index, self) => {
            return index === self.indexOf(elem); // De-deupe.
          });
        } // No-op if values remain unchanged.


        if (arraysIdentical(value, this._value)) {
          return;
        } // Trim values as per the max count.


        if (value.length > this._maxValues) {
          value = value.slice(0, this._maxValues);
        } // Update internal copy of values.


        this._value = value; // Update pills.

        this.updatePills(pills);

        if (triggerEvent) {
          // Fire an event to notify that values have been changed.
          this.fireEvent(EVENT_CHANGE, {
            value: this._value
          });
        }
      }
      /**
       * Updates the wire activity status.
       * @param {String} adapterName - Name of the wire adapter.
       * @param {Boolean} inProgress - True if wire action is in progress.
       */


      updateWireStatus(adapterName, inProgress = true) {
        if (!adapterName) {
          return;
        }

        const flag = '_' + adapterName + 'InProgress'; // Update internal status.

        this[flag] = inProgress; // Update combobox input spinner.

        this.showActivityIndicator = this._getLookupActionsInProgress || this._getLookupRecordsInProgress || this._getRecordUiInProgress;
      }

    }

    lwc.registerDecorators(LightningLookupDesktop, {
      publicProps: {
        disabled: {
          config: 0
        },
        fieldName: {
          config: 3
        },
        label: {
          config: 0
        },
        maxValues: {
          config: 3
        },
        messageWhenBadInput: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        objectInfos: {
          config: 3
        },
        record: {
          config: 3
        },
        required: {
          config: 3
        },
        showCreateNew: {
          config: 3
        },
        validity: {
          config: 1
        },
        value: {
          config: 3
        },
        variant: {
          config: 0
        }
      },
      publicMethods: ["checkValidity", "focus", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      wire: {
        wiredLookupActions: {
          adapter: lds.getLookupActions,
          params: {
            objectApiNames: "_actionObjectApiNames"
          },
          static: {},
          method: 1
        },
        wiredLookupRecords: {
          adapter: lds.getLookupRecords,
          params: {
            fieldApiName: "_fieldApiName",
            requestParams: "_requestParams",
            targetApiName: "_targetApiName"
          },
          static: {},
          method: 1
        },
        wiredRecordUi: {
          adapter: lds.getRecordUi,
          params: {
            optionalFields: "_optionalFields",
            recordIds: "_recordIds"
          },
          static: {
            layoutTypes: [LAYOUT_TYPE_FULL],
            modes: [MODE_VIEW]
          },
          method: 1
        }
      },
      track: {
        fieldLevelHelp: 1,
        filterItems: 1,
        filterLabel: 1,
        inputIconName: 1,
        inputMaxlength: 1,
        inputPill: 1,
        inputText: 1,
        items: 1,
        isRequired: 1,
        pills: 1,
        placeholder: 1,
        showActivityIndicator: 1
      }
    });

    var _lightningLookupDesktop = lwc.registerComponent(LightningLookupDesktop, {
      tmpl: _tmpl$C
    });

    function stylesheet$h(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$h = [stylesheet$h];

    function tmpl$H($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": $cmp.disabled,
          "fieldLevelHelp": $cmp.fieldLevelHelp,
          "label": $cmp.label,
          "maxLength": $cmp.maxlength,
          "messageWhenBadInput": $cmp.messageWhenBadInput,
          "messageWhenValueMissing": $cmp.messageWhenValueMissing,
          "name": $cmp.fieldName,
          "required": $cmp.isRequired,
          "value": $cmp.inputValue,
          "variant": $cmp.variant
        },
        key: 2,
        on: {
          "change": _m0 || ($ctx._m0 = api_bind($cmp.handleInputValueChange))
        }
      }, [])];
    }

    var _tmpl$D = lwc.registerTemplate(tmpl$H);
    tmpl$H.stylesheets = [];

    if (_implicitStylesheets$h) {
      tmpl$H.stylesheets.push.apply(tmpl$H.stylesheets, _implicitStylesheets$h);
    }
    tmpl$H.stylesheetTokens = {
      hostAttribute: "lightning-lookupMobile_lookupMobile-host",
      shadowAttribute: "lightning-lookupMobile_lookupMobile"
    };

    /**
     * An event indicating a change in lookup value.
     * @type {String}
     */
    const EVENT_CHANGE$1 = 'change';
    /**
     * The lightning input component name
     * @type {String}
     */

    const LIGHTNING_INPUT = 'lightning-input';
    /**
     * The max length for input.
     * @type {Number}
     */

    const INPUT_MAX_LENGTH$1 = 255;

    /**
     * Given a record, field, and objectInfos, returns a map of field attributes.
     *
     * Returned schema -
     * {
     *      inlineHelpText: {String},
     *      isRequired: {Boolean},
     * }
     *
     * @param {Object} record - A record representation.
     * @param {String} fieldName - A field api name.
     * @param {Object} objectInfos - A map of objectInfos.
     * @return {Object} A map of field attributes.
     */
    function getFieldProperties(record, fieldName, objectInfos) {
      if (Object.keys(record || {}).length === 0 || !fieldName || Object.keys(objectInfos || {}).length === 0) {
        return {
          fieldLevelHelp: null,
          isRequired: false
        };
      }

      const objectApiName = record.apiName;
      const objectInfo = objectInfos[objectApiName];

      if (!objectInfo) {
        throw new Error(`ObjectInfo [${objectApiName}] was not found`);
      }

      const fieldInfo = objectInfo.fields[fieldName];

      if (!fieldInfo) {
        throw new Error(`Field [${fieldName}] was not found`);
      }

      return {
        fieldLevelHelp: fieldInfo.inlineHelpText,
        isRequired: fieldInfo.required
      };
    }

    class LightningLookupMobile extends lwc.LightningElement {
      // ================================================================================
      // PUBLIC PROPERTIES
      // ================================================================================

      /**
       * Checks the lookup validity, and fires an 'invalid' event if it's in invalid state.
       * @return {Boolean} - The validity status of the lookup.
       */
      checkValidity() {
        return this._constraint.checkValidity();
      }
      /**
       * Indicates whether the field is disabled.
       * @type {Boolean}
       */


      /**
       * @return {String} The lookup field API name.
       */
      get fieldName() {
        return this._fieldName;
      }
      /**
       * Sets the api name for the lookup field.
       * @param {String} value - The lookup field api name.
       */


      set fieldName(value) {
        this._fieldName = value;
        const {
          fieldLevelHelp,
          isRequired
        } = getFieldProperties(this._record, this._fieldName, this._objectInfos);
        this.fieldLevelHelp = fieldLevelHelp;
        this.isRequired = isRequired;
      }
      /**
       * Sets focus on the input element.
       */


      focus() {
        if (!this._connected) {
          return;
        }

        const input = this.template.querySelector(LIGHTNING_INPUT);

        if (input) {
          input.focus();
        }
      }
      /**
       * The text label for the layout field.
       * @type {String}
       */


      /**
       * @return {Number} - The maximum number of values supported by the lookup.
       */
      get maxValues() {
        return this._maxValues;
      }
      /**
       * Sets the maximum number of values that can be inserted into the lookup.
       * @param {Number} value - The maximum number of values for the lookup.
       */


      set maxValues(value) {
        this._maxValues = value;
        const values = Object.assign([], this._value);
        this.updateValue(values);
      }
      /**
       * The error message to be displayed when the user enters bad input.
       * @type {String}
       */


      /**
       * @return {Object} The source record's objectInfos.
       */
      get objectInfos() {
        return this._objectInfos;
      }
      /**
       * Sets the source record's objectInfos.
       * @param {Object} value - The source record's objectInfos.
       */


      set objectInfos(value) {
        this._objectInfos = value;
        const {
          fieldLevelHelp,
          isRequired
        } = getFieldProperties(this._record, this._fieldName, this._objectInfos);
        this.fieldLevelHelp = fieldLevelHelp;
        this.isRequired = isRequired;
      }
      /**
       * @return {Object} Returns the source record representation.
       */


      get record() {
        return this._record;
      }
      /**
       * Sets the source record representation.
       * @param {Object} value - The source record.
       */


      set record(value) {
        this._record = value;
        const {
          fieldLevelHelp,
          isRequired
        } = getFieldProperties(this._record, this._fieldName, this._objectInfos);
        this.fieldLevelHelp = fieldLevelHelp;
        this.isRequired = isRequired;
      }
      /**
       * Shows validation message based on the validity status.
       * @return {Boolean} - The validity status of the lookup.
       */


      reportValidity() {
        const input = this.template.querySelector(LIGHTNING_INPUT);

        if (input) {
          return this._constraint.reportValidity(message => {
            input.setCustomValidity(message);
            input.reportValidity();
          });
        }

        return null;
      }
      /**
       * Sets a custom validity message.
       * @param {String} message - The validation message to be shown in an error state.
       */


      setCustomValidity(message) {
        const input = this.template.querySelector(LIGHTNING_INPUT);

        if (input) {
          this._constraint.setCustomValidity(message);

          input.setCustomValidity(message);
        }
      }
      /**
       * Indicates whether or not the field is required.
       * // TODO - Consume required api.
       * @type {Boolean}
       */


      /**
       * Displays an error message if the combobox value is required but missing.
       */
      showHelpMessageIfInvalid() {
        this.reportValidity();
      }
      /**
       * Gets the validity constraint of the lookup.
       * @return {Object} - The current validity constraint.
       */


      get validity() {
        return this._constraint.validity;
      }
      /**
       * @return {Array} An array of selected lookup values.
       */


      get value() {
        return this._value;
      }
      /**
       * Sets the values for the lookup.
       * @param {Array} value - An array of record ids.
       */


      set value(value) {
        this.updateValue(value);
      }
      /**
       * Sets the variant type for the lookup.
       * @type {String}
       */


      // ================================================================================
      // ACCESSOR METHODS
      // ================================================================================

      /**
       * Gets the validity constaint.
       */
      get _constraint() {
        if (!this._constraintApi) {
          this._constraintApi = new FieldConstraintApi(() => this, {
            valueMissing: () => this.isRequired && (!Array.isArray(this._value) || !this._value.length)
          });
        }

        return this._constraintApi;
      } // ================================================================================
      // LIFECYCLE METHODS
      // ================================================================================


      constructor() {
        super();
        this.disabled = false;
        this.label = void 0;
        this.messageWhenBadInput = void 0;
        this.messageWhenValueMissing = void 0;
        this.required = false;
        this.showCreateNew = false;
        this.variant = void 0;
        this.fieldLevelHelp = void 0;
        this.inputValue = void 0;
        this.isRequired = void 0;
        this.maxlength = void 0;
        this._connected = false;
        this._fieldName = void 0;
        this._maxValues = void 0;
        this._objectInfos = void 0;
        this._record = void 0;
        this._value = void 0;
        this.maxlength = INPUT_MAX_LENGTH$1;
      }

      connectedCallback() {
        this._connected = true;
      }

      disconnectedCallback() {
        this._connected = false;
      } // ================================================================================
      // PRIVATE METHODS
      // ================================================================================

      /**
       * Fires an event with details for parent component to handle.
       * @param {String} type - The type of event being dispatched.
       * @param {Object} detail - The event data.
       * @param {Boolean} bubbles - Whether or not the event bubbles.
       */


      fireEvent(type, detail, bubbles) {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-identifier-arguments
        new CustomEvent(type, {
          composed: bubbles,
          bubbles,
          detail
        }));
      }

      handleInputValueChange(event) {
        // Stop input event propagation.
        event.stopPropagation(); // No-op if event detail is empty.

        if (!event.detail) {
          return;
        }

        const text = (event.detail.value || '').trim();
        let values;

        if (!text.length) {
          // Default empty string value to an empty array.
          values = [];
        } else {
          // Convert comma separated values to an array.
          values = text.split(',');
        }

        this.updateValue(values);
      }
      /**
       * Updates the live value and sets the pills.
       * @param {Array} value - An array of record ids.
       */


      updateValue(value) {
        if (value === undefined) {
          this._value = value;
          return;
        } else if (value === null) {
          value = [];
        }

        if (!Array.isArray(value)) {
          return;
        } // Drop empty values, and trim them to remove extra white spaces.


        value = value.filter(val => val).map(val => val.trim()); // Trim values to the max value count.

        if (value.length > this._maxValues) {
          value = value.slice(0, this._maxValues);
        }

        this._value = value;
        this.inputValue = value.join(','); // Fire event to notify that values have been changed.

        this.fireEvent(EVENT_CHANGE$1, {
          value: this._value
        }, true);
      }

    }

    lwc.registerDecorators(LightningLookupMobile, {
      publicProps: {
        disabled: {
          config: 0
        },
        fieldName: {
          config: 3
        },
        label: {
          config: 0
        },
        maxValues: {
          config: 3
        },
        messageWhenBadInput: {
          config: 0
        },
        messageWhenValueMissing: {
          config: 0
        },
        objectInfos: {
          config: 3
        },
        record: {
          config: 3
        },
        required: {
          config: 0
        },
        showCreateNew: {
          config: 0
        },
        validity: {
          config: 1
        },
        value: {
          config: 3
        },
        variant: {
          config: 0
        }
      },
      publicMethods: ["checkValidity", "focus", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"],
      track: {
        fieldLevelHelp: 1,
        inputValue: 1,
        isRequired: 1,
        maxlength: 1
      }
    });

    var _lightningLookupMobile = lwc.registerComponent(LightningLookupMobile, {
      tmpl: _tmpl$D
    });

    function tmpl$I($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [$cmp.isDesktop ? api_custom_element("lightning-lookup-desktop", _lightningLookupDesktop, {
        props: {
          "disabled": $cmp.disabled,
          "fieldName": $cmp.fieldName,
          "label": $cmp.label,
          "maxValues": $cmp.maxValues,
          "objectInfos": $cmp.objectInfos,
          "record": $cmp.record,
          "required": $cmp.required,
          "showCreateNew": $cmp.showCreateNew,
          "value": $cmp.value,
          "variant": $cmp.variant
        },
        key: 3
      }, []) : null, !$cmp.isDesktop ? api_custom_element("lightning-lookup-mobile", _lightningLookupMobile, {
        props: {
          "disabled": $cmp.disabled,
          "fieldName": $cmp.fieldName,
          "label": $cmp.label,
          "maxValues": $cmp.maxValues,
          "objectInfos": $cmp.objectInfos,
          "record": $cmp.record,
          "required": $cmp.required,
          "showCreateNew": $cmp.showCreateNew,
          "value": $cmp.value,
          "variant": $cmp.variant
        },
        key: 5
      }, []) : null];
    }

    var _tmpl$E = lwc.registerTemplate(tmpl$I);
    tmpl$I.stylesheets = [];

    if (_implicitStylesheets$e) {
      tmpl$I.stylesheets.push.apply(tmpl$I.stylesheets, _implicitStylesheets$e);
    }
    tmpl$I.stylesheetTokens = {
      hostAttribute: "lightning-lookup_lookup-host",
      shadowAttribute: "lightning-lookup_lookup"
    };

    /**
     * The desktop form factor.
     * @type {String}
     */
    const FORM_FACTOR_DESKTOP = 'DESKTOP';
    /**
     * The query selector used for the desktop implementation of lookups.
     * @type {String}
     */

    const LIGHTNING_LOOKUP_DESKTOP = 'lightning-lookup-desktop';
    /**
     * The query selector used for the mobile implementation of lookups.
     * @type {String}
     */

    const LIGHTNING_LOOKUP_MOBILE = 'lightning-lookup-mobile';

    class LightningLookup extends lwc.LightningElement {
      // ================================================================================
      // PUBLIC PROPERTIES
      // ================================================================================

      /**
       * Checks the lookup validity, and fires an 'invalid' event if it's in invalid state.
       * @return {Boolean} - The validity status of the lookup.
       */
      checkValidity() {
        if (this._lookupElement) {
          return this._lookupElement.checkValidity();
        }

        return false;
      }
      /**
       * Indicates whether the field is disabled.
       * @type {Boolean}
       */


      /**
       * Sets focus on the input element.
       */
      focus() {
        if (!this._connected) {
          return;
        }

        if (this._lookupElement) {
          this._lookupElement.focus();
        }
      }
      /**
       * The text label for the layout field.
       * @type {String}
       */


      /**
       * @return {String} The error message to be displayed when the user enters the text in
       * the input but does not select a valid option.
       */
      get messageWhenBadInput() {
        if (this._lookupElement) {
          this._messageWhenBadInput = this._lookupElement.messageWhenBadInput;
        }

        return this._messageWhenBadInput;
      }
      /**
       * Sets the error message to be displayed when the user enters the text in the input
       * but does not select a valid option.
       * @param {String} value - The error message.
       */


      set messageWhenBadInput(value) {
        this._messageWhenBadInput = value;

        if (this._lookupElement) {
          this._lookupElement.messageWhenBadInput = this._messageWhenBadInput;
        }
      }
      /**
       * @return {String} The error message to be displayed when the lookup value
       * is required but is currently missing.
       */


      get messageWhenValueMissing() {
        if (this._lookupElement) {
          this._messageWhenValueMissing = this._lookupElement.messageWhenValueMissing;
        }

        return this._messageWhenValueMissing;
      }
      /**
       * The error message to be displayed when the lookup value is required but is currently missing.
       * @param {String} value - The error message.
       */


      set messageWhenValueMissing(value) {
        this._messageWhenValueMissing = value;

        if (this._lookupElement) {
          this._lookupElement.messageWhenValueMissing = this._messageWhenValueMissing;
        }
      }
      /**
       * The source record's objectInfos.
       * @param {Object}
       */


      /**
       * Shows validation message based on the validity status.
       * @return {Boolean} - The validity status of the lookup.
       */
      reportValidity() {
        if (this._lookupElement) {
          return this._lookupElement.reportValidity();
        }

        return false;
      }
      /**
       * Sets a custom validity message.
       * @param {String} message - The validation message to be shown in an error state.
       */


      setCustomValidity(message) {
        if (this._lookupElement) {
          this._lookupElement.setCustomValidity(message);
        }
      }
      /**
       * Indicates whether or not the show create new option.
       * TODO - Remove when @wire(getLookupActions) response is invocable.
       * @type {Boolean}
       */


      /**
       * Displays a validation message if the lookup is in invalid state.
       */
      showHelpMessageIfInvalid() {
        if (this._lookupElement) {
          this._lookupElement.showHelpMessageIfInvalid();
        }
      }
      /**
       * Gets the validity constraint of the lookup.
       * @return {Object} - The current validity constraint.
       */


      get validity() {
        if (this._lookupElement) {
          return this._lookupElement.validity;
        }

        return null;
      }
      /**
       * @return {Array} An array of selected lookup values.
       */


      get value() {
        if (this._lookupElement) {
          this._value = this._lookupElement.value;
        }

        return this._value;
      }
      /**
       * Sets the values for the lookup.
       * @param {Array} value - An array of record ids.
       */


      set value(value) {
        this._value = value;

        if (this._lookupElement) {
          this._lookupElement.value = value;
        }
      }
      /**
       * @return {String} The value of variant.
       */


      get variant() {
        if (this._lookupElement) {
          this._variant = this._lookupElement.variant;
        }

        return this._variant || VARIANT.STANDARD;
      }
      /**
       * Sets the variant type for the lookup.
       * @param {String} value - The value of variant.
       */


      set variant(value) {
        this._variant = normalizeVariant$1(value);

        if (this._lookupElement) {
          this._lookupElement.variant = this._variant;
        }

        this.updateClassList();
      } // ================================================================================
      // PRIVATE PROPERTIES
      // ================================================================================

      /**
       * Indicates whether or not the component is connected.
       * @type {Boolean}
       */


      // ================================================================================
      // ACCESSOR METHODS
      // ================================================================================

      /**
       * Indicates whether or not the component is loaded on the desktop form factor.
       * @return {Boolean} - See desc.
       */
      get isDesktop() {
        return this._isDesktop;
      }
      /**
       * Returns the lookup DOM element.
       * @returns {Object} - See desc.
       */


      get lookupElement() {
        if (!this._connected) {
          return null;
        }

        if (this._lookupElement) {
          return this._lookupElement;
        }

        return null;
      } // ================================================================================
      // LIFECYCLE METHODS
      // ================================================================================


      constructor() {
        super();
        this.disabled = false;
        this.fieldName = void 0;
        this.label = void 0;
        this.maxValues = 1;
        this.objectInfos = void 0;
        this.record = void 0;
        this.required = false;
        this.showCreateNew = false;
        this._connected = false;
        this._isDesktop = void 0;
        this._initProps = false;
        this._lookupElement = void 0;
        this._messageWhenBadInput = void 0;
        this._messageWhenValueMissing = void 0;
        this._value = void 0;
        this._variant = void 0;
        const formFactor = configProvider.getFormFactor();
        this._isDesktop = formFactor === FORM_FACTOR_DESKTOP;
      }

      connectedCallback() {
        this._connected = true;
        this.classList.add('slds-form-element');
        this.updateClassList();
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this._connected = false;
        this._initProps = false;
        this._lookupElement = undefined;
      }

      renderedCallback() {
        if (!this._lookupElement) {
          const lookupSelector = this._isDesktop ? LIGHTNING_LOOKUP_DESKTOP : LIGHTNING_LOOKUP_MOBILE;
          this._lookupElement = this.template.querySelector(lookupSelector);
        }

        if (!this._initProps) {
          this.synchronizeProps();
          this._initProps = true;
        }
      } // ================================================================================
      // PRIVATE METHODS
      // ================================================================================

      /**
       * Synchronizes properties with child lookup element.
       */


      synchronizeProps() {
        if (this._lookupElement) {
          this._lookupElement.value = this._value;
          this._lookupElement.variant = this._variant;

          if (this._messageWhenBadInput !== undefined) {
            this._lookupElement.messageWhenBadInput = this._messageWhenBadInput;
          }

          if (this._messageWhenValueMissing !== undefined) {
            this._lookupElement.messageWhenValueMissing = this._messageWhenValueMissing;
          }
        }
      }

    }

    lwc.registerDecorators(LightningLookup, {
      publicProps: {
        disabled: {
          config: 0
        },
        fieldName: {
          config: 0
        },
        label: {
          config: 0
        },
        maxValues: {
          config: 0
        },
        messageWhenBadInput: {
          config: 3
        },
        messageWhenValueMissing: {
          config: 3
        },
        objectInfos: {
          config: 0
        },
        record: {
          config: 0
        },
        required: {
          config: 0
        },
        showCreateNew: {
          config: 0
        },
        validity: {
          config: 1
        },
        value: {
          config: 3
        },
        variant: {
          config: 3
        }
      },
      publicMethods: ["checkValidity", "focus", "reportValidity", "setCustomValidity", "showHelpMessageIfInvalid"]
    });

    var _lightningLookup = lwc.registerComponent(LightningLookup, {
      tmpl: _tmpl$E
    });

    function stylesheet$i(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$i = [stylesheet$i];

    function tmpl$J($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element,
        c: api_custom_element,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_element("fieldset", {
        classMap: {
          "slds-form-element": true
        },
        key: 2
      }, [api_element("legend", {
        className: $cmp.computedLegendClass,
        key: 3
      }, [api_dynamic($cmp.label)]), $cmp.fieldLevelHelp ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.fieldLevelHelp
        },
        key: 5
      }, []) : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 6
      }, [api_element("div", {
        classMap: {
          "slds-form-element__group": true
        },
        key: 7
      }, [api_element("div", {
        classMap: {
          "slds-form-element__row": true
        },
        key: 8
      }, [api_element("div", {
        classMap: {
          "slds-size_1-of-2": true
        },
        key: 9
      }, [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-latitude": true
        },
        props: {
          "label": $cmp.i18n.latitude,
          "name": "latitude",
          "value": $cmp.latitude,
          "required": $cmp.required,
          "disabled": $cmp.disabled,
          "readOnly": $cmp.readOnly,
          "messageWhenBadInput": $cmp.i18n.invalidLatitude,
          "messageWhenValueMissing": $cmp.i18n.coordinateIsRequired
        },
        key: 10,
        on: {
          "change": _m0 || ($ctx._m0 = api_bind($cmp.handleLatitudeChange)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleLatitudeBlur))
        }
      }, [])]), api_element("div", {
        classMap: {
          "slds-size_1-of-2": true
        },
        key: 11
      }, [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-longitude": true
        },
        props: {
          "label": $cmp.i18n.longitude,
          "name": "longitude",
          "value": $cmp.longitude,
          "required": $cmp.required,
          "disabled": $cmp.disabled,
          "readOnly": $cmp.readOnly,
          "messageWhenBadInput": $cmp.i18n.invalidLongitude,
          "messageWhenValueMissing": $cmp.i18n.coordinateIsRequired
        },
        key: 12,
        on: {
          "change": _m3 || ($ctx._m3 = api_bind($cmp.handleLongitudeChange)),
          "focus": _m4 || ($ctx._m4 = api_bind($cmp.handleFocus)),
          "blur": _m5 || ($ctx._m5 = api_bind($cmp.handleLongitudeBlur))
        }
      }, [])])])])])])];
    }

    var _tmpl$F = lwc.registerTemplate(tmpl$J);
    tmpl$J.stylesheets = [];

    if (_implicitStylesheets$i) {
      tmpl$J.stylesheets.push.apply(tmpl$J.stylesheets, _implicitStylesheets$i);
    }
    tmpl$J.stylesheetTokens = {
      hostAttribute: "lightning-inputLocation_inputLocation-host",
      shadowAttribute: "lightning-inputLocation_inputLocation"
    };

    var labelCoordinateIsRequired = 'Coordinate is required';

    var labelInvalidLatitude = 'Latitude should be a decimal number in a range [-90, 90]';

    var labelInvalidLongitude = 'Longitude should be a decimal number in a range [-180, 180]';

    var labelLatitude = 'Latitude';

    var labelLongitude = 'Longitude';

    const VALID_RANGES = {
      LATITUDE: [-90, 90],
      LONGITUDE: [-180, 180]
    };

    function isNumber(value) {
      return value !== '' && value !== null && isFinite(value);
    }

    function isValidRange(start, end, dec) {
      const val = parseFloat(dec);
      return !isNaN(val) && val <= end && val >= start ? true : false;
    }

    function validateFormatAndRange(coordinate, range) {
      const truncatedCoordinate = coordinate.trim();
      return isNumber(truncatedCoordinate) && isValidRange(range[0], range[1], truncatedCoordinate);
    }

    function validateCoordinate(name, value) {
      return validateFormatAndRange(value, VALID_RANGES[name.toUpperCase()]);
    }

    const i18n$n = {
      coordinateIsRequired: labelCoordinateIsRequired,
      invalidLatitude: labelInvalidLatitude,
      invalidLongitude: labelInvalidLongitude,
      latitude: labelLatitude,
      longitude: labelLongitude
    };
    /**
     * Represents a geolocation compound field that accepts a latitude and longitude value.
     */

    class LightningInputLocation extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.label = void 0;
        this.fieldLevelHelp = void 0;
        this._latitude = '';
        this._longitude = '';
        this._disabled = false;
        this._readonly = false;
        this._required = false;
        this._variant = void 0;
      }

      connectedCallback() {
        this._connected = true;
        this.interactingState = new InteractingState({
          // keeps interacting state when switch between latitude and longitude
          debounceInteraction: true
        });
        this.interactingState.onenter(() => {
          this.dispatchEvent(new CustomEvent('focus'));
        });
        this.interactingState.onleave(() => {
          this.reportValidity();
          this.dispatchEvent(new CustomEvent('blur'));
        });
        this.classList.add('slds-form-element', 'slds-form-compound');
        this.updateClassList();
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.variant === VARIANT.LABEL_STACKED,
          'slds-form-element_horizontal': this.variant === VARIANT.LABEL_INLINE
        });
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * The latitude value. Latitude values must be within -90 and 90.
       * @type {string}
       *
       */


      get latitude() {
        return this._latitude;
      }

      set latitude(value) {
        //  Converting the value to string when value is of type decimal to be consistent
        if (value != null) {
          value = value.toString();
        }

        this._latitude = normalizeString(value);
      }
      /**
       * The longitude value. Longitude values must be within -180 and 180.
       * @type {string}
       *
       */


      get longitude() {
        return this._longitude;
      }

      set longitude(value) {
        //  Converting the value to string when value is of type decimal to be consistent
        if (value != null) {
          value = value.toString();
        }

        this._longitude = normalizeString(value);
      }
      /**
       * If present, the geolocation fields are disabled and users cannot interact with them.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, the geolocations fields are read-only and cannot be edited.
       * @type {boolean}
       * @default false
       */


      get readOnly() {
        return this._readonly;
      }

      set readOnly(value) {
        this._readonly = normalizeBoolean(value);
      }
      /**
       * If present, the geolocation fields must be filled out before the form is submitted.
       * An error message is displayed if a user interacts with the field
       * and does not provide a value.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._required;
      }

      set required(value) {
        this._required = normalizeBoolean(value);
      }
      /**
       * The variant changes the appearance of a geolocation compound field.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * This value defaults to standard.
       * Use label-hidden to hide the label but make it available to assistive technology.
       * Use label-inline to horizontally align the label and geolocation fields.
       * Use label-stacked to place the label above the geolocation fields.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant$1(value);
        this.updateClassList();
      }
      /**
       * Sets focus on the latitude field.
       */


      focus() {
        if (this._connected) {
          this.getCoordinateElement('latitude').focus();
        }
      }
      /**
       * Removes keyboard focus from the latitude and longitude fields.
       */


      blur() {
        if (this._connected) {
          this.getCoordinateElement('latitude').blur();
          this.getCoordinateElement('longitude').blur();
        }
      }
      /**
       * Represents the validity states that an element can be in, with respect to constraint validation.
       * @type {object}
       *
       */


      get validity() {
        return this._combinedConstraint.validity;
      }
      /**
       * Returns the valid attribute value (Boolean) on the ValidityState object.
       * @returns {boolean} Indicates whether the latitude and longitude field meet all constraint validations.
       */


      checkValidity() {
        return this._combinedConstraint.checkValidity();
      }
      /**
       * Displays error messages on the latitude or longitude field if the coordinates are invalid.
       */


      showHelpMessageIfInvalid() {
        this.reportValidity();
      }
      /**
       * Sets a custom error message to be displayed for the latitude or longitude field when
       * the value is submitted.
       * @param {string} message - The string that describes the error. If message is an empty string, the error message is reset.
       * @param {string} fieldName - Name of the field, which must be latitude or longitude.
       */


      setCustomValidityForField(message, fieldName) {
        assert(['latitude', 'longitude'].indexOf(fieldName) >= 0, '"fieldName" must be "latitude" or "longitude"');

        this._coordinateConstraints[fieldName].setCustomValidity(message);
      }
      /**
       * Displays the error messages and returns false if the input is invalid.
       * If the input is valid, reportValidity() clears displayed error messages and returns true.
       * @returns {boolean} - The validity status of the input fields.
       */


      reportValidity() {
        const valid = this.checkValidity();

        if (!this._connected) {
          return valid;
        }

        Object.keys(this._coordinateConstraints).forEach(coordinate => {
          this._reportValidityForCoordinate(coordinate);
        });
        return valid;
      }

      get i18n() {
        return i18n$n;
      }

      get isLabelHidden() {
        return this.variant === VARIANT.LABEL_HIDDEN;
      }

      get computedLegendClass() {
        return classSet('slds-form-element__label slds-form-element__legend').add({
          'slds-assistive-text': this.isLabelHidden
        }).toString();
      }

      handleLatitudeBlur() {
        this.interactingState.leave();

        this._reportValidityForCoordinate('latitude');
      }

      handleLongitudeBlur() {
        this.interactingState.leave();

        this._reportValidityForCoordinate('longitude');
      }

      handleFocus() {
        this.interactingState.enter();
      }

      handleLatitudeChange(event) {
        this.handleChange('latitude', event);
      }

      handleLongitudeChange(event) {
        this.handleChange('longitude', event);
      }

      handleChange(coordinate, event) {
        event.stopPropagation();
        const value = event.detail.value;

        if (this[coordinate] === value) {
          // Value didn't change. No need to dispatch.
          return;
        } // Update component state accordingly


        if (coordinate === 'longitude') {
          this._longitude = value;
        } else if (coordinate === 'latitude') {
          this._latitude = value;
        }

        this.dispatchEvent(new CustomEvent('change', {
          composed: true,
          bubbles: true,
          detail: {
            latitude: this.latitude,
            longitude: this.longitude
          }
        }));
      }

      get _coordinateConstraints() {
        if (!this._coordinateConstraintApis) {
          this._coordinateConstraintApis = ['latitude', 'longitude'].reduce((constraints, coordinate) => {
            const constraintProviders = {
              badInput: () => !this.disabled && !isEmptyString(this[coordinate]) && !validateCoordinate(coordinate, this[coordinate]),
              valueMissing: () => !this.disabled && this.required && isEmptyString(this[coordinate])
            };
            constraints[coordinate] = new FieldConstraintApi(this.getCoordinateElement.bind(this, coordinate), constraintProviders);
            return constraints;
          }, {});
        }

        return this._coordinateConstraintApis;
      }

      get _combinedConstraint() {
        if (!this._combinedConstraintApi) {
          const {
            _coordinateConstraints
          } = this;

          const checkCoordinates = property => Object.values(_coordinateConstraints).some(coordinateConstraint => coordinateConstraint.validity[property]);

          this._combinedConstraintApi = new FieldConstraintApi(() => this, {
            customError: () => checkCoordinates('customError'),
            badInput: () => checkCoordinates('badInput'),
            valueMissing: () => checkCoordinates('valueMissing')
          });
        }

        return this._combinedConstraintApi;
      }

      getCoordinateElement(fieldName) {
        const propertyName = `_${fieldName}Element`;

        if (!this[propertyName]) {
          this[propertyName] = this.template.querySelector(`lightning-input[data-${fieldName}]`);
        }

        return this[propertyName];
      }

      _reportValidityForCoordinate(coordinate) {
        this._coordinateConstraints[coordinate].reportValidity(helpMessage => {
          const coordinateElement = this.getCoordinateElement(coordinate);
          coordinateElement.setCustomValidity(helpMessage);
          coordinateElement.reportValidity();
        });
      }

    }

    LightningInputLocation.delegatesFocus = true;

    lwc.registerDecorators(LightningInputLocation, {
      publicProps: {
        label: {
          config: 0
        },
        fieldLevelHelp: {
          config: 0
        },
        latitude: {
          config: 3
        },
        longitude: {
          config: 3
        },
        disabled: {
          config: 3
        },
        readOnly: {
          config: 3
        },
        required: {
          config: 3
        },
        variant: {
          config: 3
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "blur", "checkValidity", "showHelpMessageIfInvalid", "setCustomValidityForField", "reportValidity"],
      track: {
        _latitude: 1,
        _longitude: 1,
        _disabled: 1,
        _readonly: 1,
        _required: 1,
        _variant: 1
      }
    });

    var _lightningInputLocation = lwc.registerComponent(LightningInputLocation, {
      tmpl: _tmpl$F
    });

    function tmpl$K($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        d: api_dynamic,
        h: api_element,
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14
      } = $ctx;
      return [$cmp.failed ? api_element("span", {
        classMap: {
          "slds-hide": true
        },
        key: 3
      }, [api_text("No input rendered: "), api_dynamic($cmp.errorMessage)]) : null, $cmp.ready ? $cmp.isTypeName ? api_custom_element("lightning-input-name", _lightningInputName, {
        props: {
          "label": $cmp.label,
          "firstName": $cmp.internalValue.FirstName,
          "lastName": $cmp.internalValue.LastName,
          "salutation": $cmp.internalValue.Salutation,
          "options": $cmp.picklistOptions,
          "disabled": $cmp._disabled,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 6,
        on: {
          "change": _m0 || ($ctx._m0 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeAddress ? api_custom_element("lightning-input-address", _lightningInputAddress, {
        props: {
          "streetLabel": $cmp.addressField.Street.label,
          "cityLabel": $cmp.addressField.City.label,
          "provinceLabel": $cmp.state.label,
          "countryLabel": $cmp.country.label,
          "postalCodeLabel": $cmp.addressField.PostalCode.label,
          "street": $cmp._street,
          "city": $cmp._city,
          "province": $cmp._state,
          "postalCode": $cmp._postalCode,
          "country": $cmp._country,
          "provinceOptions": $cmp.state.options,
          "countryOptions": $cmp.country.options,
          "disabled": $cmp._disabled,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 8,
        on: {
          "change": _m1 || ($ctx._m1 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeNumber ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": $cmp._disabled,
          "name": $cmp._fieldName,
          "type": "number",
          "variant": $cmp.inputVariant,
          "required": $cmp.required,
          "label": $cmp.label,
          "formatter": $cmp.numberFormatter,
          "value": $cmp.internalValue,
          "step": $cmp.numberStep,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 10,
        on: {
          "change": _m2 || ($ctx._m2 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeText ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": $cmp._disabled,
          "label": $cmp.label,
          "variant": $cmp.inputVariant,
          "value": $cmp.internalValue,
          "name": $cmp._fieldName,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 12,
        on: {
          "change": _m3 || ($ctx._m3 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeCheckbox ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": $cmp._disabled,
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "checked": $cmp.internalValue,
          "type": "checkbox",
          "variant": $cmp.inputVariant,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 14,
        on: {
          "change": _m4 || ($ctx._m4 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeEmail ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": $cmp._disabled,
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "value": $cmp.internalValue,
          "required": $cmp.required,
          "type": "email",
          "variant": $cmp.inputVariant,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 16,
        on: {
          "change": _m5 || ($ctx._m5 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeTextArea ? api_custom_element("lightning-textarea", _lightningTextarea, {
        props: {
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "value": $cmp.internalValue,
          "disabled": $cmp._disabled,
          "required": $cmp.required,
          "variant": $cmp.inputVariant,
          "maxLength": $cmp.uiField.length,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 18,
        on: {
          "change": _m6 || ($ctx._m6 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeRichText ? api_custom_element("lightning-quill", _lightningQuill, {
        props: {
          "label": $cmp.label,
          "value": $cmp.internalValue,
          "disabled": $cmp._disabled,
          "required": $cmp.required,
          "variant": $cmp.inputVariant,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 20,
        on: {
          "change": _m7 || ($ctx._m7 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeDate ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "type": "date",
          "variant": $cmp.inputVariant,
          "value": $cmp.internalValue,
          "disabled": $cmp._disabled,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 22,
        on: {
          "change": _m8 || ($ctx._m8 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeDateTime ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "type": "datetime",
          "variant": $cmp.inputVariant,
          "value": $cmp.internalValue,
          "required": $cmp.required,
          "disabled": $cmp._disabled,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 24,
        on: {
          "change": _m9 || ($ctx._m9 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypePicklist ? api_custom_element("lightning-picklist", _lightningPicklist, {
        props: {
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "variant": $cmp.inputVariant,
          "value": $cmp.internalValue,
          "disabled": $cmp._disabled,
          "options": $cmp.picklistOptions,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 26,
        on: {
          "change": _m10 || ($ctx._m10 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeMultiPicklist ? api_custom_element("lightning-picklist", _lightningPicklist, {
        props: {
          "multiple": true,
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "variant": $cmp.inputVariant,
          "value": $cmp.internalValue,
          "disabled": $cmp._disabled,
          "options": $cmp.picklistOptions,
          "required": $cmp.required,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 28,
        on: {
          "change": _m11 || ($ctx._m11 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeReference ? api_custom_element("lightning-lookup", _lightningLookup, {
        props: {
          "disabled": $cmp._disabled,
          "fieldName": $cmp._fieldName,
          "objectInfos": $cmp.objectInfos,
          "record": $cmp.record.record,
          "value": $cmp.lookupValue,
          "variant": $cmp.inputVariant,
          "label": $cmp.label
        },
        key: 30,
        on: {
          "change": _m12 || ($ctx._m12 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeLocation ? api_custom_element("lightning-input-location", _lightningInputLocation, {
        props: {
          "longitude": $cmp.value.longitude,
          "latitude": $cmp.value.latitude,
          "label": $cmp.label,
          "disabled": $cmp._disabled,
          "required": $cmp.required
        },
        key: 32,
        on: {
          "change": _m13 || ($ctx._m13 = api_bind($cmp.handleChange))
        }
      }, []) : null : null, $cmp.ready ? $cmp.isTypeUnsupportedReference ? api_custom_element("lightning-input", _lightningInput, {
        props: {
          "disabled": true,
          "label": $cmp.label,
          "name": $cmp._fieldName,
          "value": $cmp.displayValue,
          "required": $cmp.required,
          "type": "text",
          "variant": $cmp.inputVariant,
          "fieldLevelHelp": $cmp.inlineHelpText
        },
        key: 34,
        on: {
          "change": _m14 || ($ctx._m14 = api_bind($cmp.handleChange))
        }
      }, []) : null : null];
    }

    var _tmpl$G = lwc.registerTemplate(tmpl$K);
    tmpl$K.stylesheets = [];
    tmpl$K.stylesheetTokens = {
      hostAttribute: "lightning-inputField_inputField-host",
      shadowAttribute: "lightning-inputField_inputField"
    };

    function isInDependencyChain(uiField, fields, picklistValues) {
      return hasDependents(uiField, fields, picklistValues) || hasController(uiField, fields, picklistValues);
    }
    function hasDependents(uiField, fields, picklistValues) {
      for (const fieldName in fields) {
        if (fields.hasOwnProperty(fieldName)) {
          const field = fields[fieldName];

          if (field.controllerName === uiField.apiName) {
            // make sure the dependent field exists in the form
            if (picklistFieldInForm(fieldName, picklistValues)) {
              return true;
            }
          }
        }
      }

      return false;
    }

    function hasController(uiField, fields, picklistValues) {
      const controllerName = uiField.controllerName;
      const hasControllingField = fields[controllerName] !== undefined;
      return hasControllingField && (picklistFieldInForm(controllerName, picklistValues) || checkboxFieldInForm(controllerName, fields));
    }

    function isControllerMissing(uiField, fields, picklistValues) {
      const controllerName = uiField.controllerName;
      const hasControllingField = fields[controllerName] !== undefined;
      return hasControllingField && !picklistFieldInForm(controllerName, picklistValues) && !checkboxFieldInForm(controllerName, fields);
    }

    function picklistFieldInForm(fieldName, picklistValues) {
      return picklistValues[fieldName] !== undefined;
    }

    function checkboxFieldInForm(fieldName, fields) {
      return fields[fieldName] !== undefined && Fields.BOOLEAN === fields[fieldName].dataType;
    }

    /**
     * Given a scale returns the corresponding decimal places 'step' (ie. lowest unit of decrease/increase for a number
     * in the given scale).
     * for example given the scale 1 result in 0.1, for 2 -> 0.01, etc.
     * @param {number} scale an integer number.
     * @returns {number} 'step' for the given scale.
     */
    function scaleToDecimalPlaces(scale) {
      // Using toFixed to correct for bad js arithmetic precision, resulting
      // in 0.000009999999999999999 for Math.pow(10, -5) instead of the expected
      // 0.00001
      const resultAsString = Math.pow(10, -parseInt(scale, 10)).toFixed(scale);
      return parseFloat(resultAsString);
    }

    const NUMBER_TYPES = [Fields.DECIMAL, Fields.INT, Fields.PERCENT, Fields.CURRENCY, Fields.DOUBLE];
    const STATE_CODE = 'StateCode';
    const COUNTRY_CODE = 'CountryCode';

    function uncapitalize(str) {
      return `${str[0].toLowerCase()}${str.slice(1)}`;
    }

    function isUnsupportedReferenceField(name) {
      return UNSUPPORTED_REFERENCE_FIELDS.indexOf(name) !== -1;
    } // Returns a normalized string name by removing the prefix (e.g. removes 'Billing' from 'BillingStreet' for Address fields)


    function removePrefix(str, prefix) {
      return prefix ? str.replace(prefix, '') : str;
    } // Adds a prefix to the string (e.g. adds 'Billing' to 'Street' for Address fields)


    function addPrefix(str, prefix) {
      return prefix ? prefix + str : str;
    }

    function isEmptyObject$1(obj) {
      // fastest way to do this!
      // eslint-disable-next-line guard-for-in
      for (const name in obj) {
        return false;
      }

      return true;
    }
    /**
     * Returns a map of changed values from a compound field,
     * normalizing the names and capitalization rules
     * @param {Object} originalValue A map of the original values
     * @param {Object} changedValues Values that have changed
     * @param {Object} fieldPrefix The field prefix in the map of original values (e.g. 'Billing' in 'BillingStreet')
     *
     * @returns {Object} Map of changed values
     */


    function normalizeCompoundFieldValues(originalValue, changedValues, fieldPrefix) {
      return Object.keys(originalValue).reduce((ret, rawKey) => {
        const key = removePrefix(rawKey, fieldPrefix); // map state and country values to code if code is present,
        // rather than raw value

        let normalizedKey;

        if (key === STATE_CODE || uncapitalize(key) === 'state') {
          normalizedKey = 'province';
        } else if (key === COUNTRY_CODE) {
          normalizedKey = 'country';
        } else {
          normalizedKey = uncapitalize(key);
        }

        const normalizedValue = changedValues[normalizedKey] ? changedValues[normalizedKey] : null;

        if (normalizedValue !== originalValue[key]) {
          ret[addPrefix(key, fieldPrefix)] = normalizedValue;
        }

        return ret;
      }, {});
    }

    const VARIANT_MAPPING = {
      stacked: VARIANT.LABEL_STACKED,
      horizontal: VARIANT.LABEL_INLINE
    };
    /**
     * Represents an editable input for a field on a Salesforce object.
     */

    class LightningInputField extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.readonly = false;
        this.uiField = {};
        this.failed = false;
        this.errorMessage = '';
        this.ready = false;
        this.picklistOptions = void 0;
        this.isCompoundField = false;
        this.nameField = {};
        this.addressField = {};
        this.label = '';
        this._uiFieldRequired = false;
        this._externalRequired = false;
        this.inlineHelpText = '';
        this._disabled = void 0;
        this.internalValue = void 0;
        this.objectInfos = void 0;
        this.record = void 0;
        this._fieldName = void 0;
        this._street = void 0;
        this._country = void 0;
        this._postalCode = void 0;
        this._state = void 0;
        this._city = void 0;
        this._labelAlignment = '';
        this._variant = void 0;
        this._rawFieldName = void 0;
        this.originalValue = void 0;
        this.isDirty = false;
        this.serverError = void 0;
        this.serverErrorValue = void 0;
        this._inChangeCycle = false;
      }

      connectedCallback() {
        this.classList.add('slds-form-element');
        this.updateClassList();
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this.isStackedLabel() && !this.isTypeAddress && !this.isTypeName,
          'slds-form-element_horizontal': this.isHorizontalLabel() && !this.isTypeAddress && !this.isTypeName
        });
      }

      isStackedLabel() {
        // only add the form class if density or variant is stacked
        return this._labelAlignment === 'stacked' && !this.variant || this.variant === VARIANT.LABEL_STACKED;
      }

      isHorizontalLabel() {
        // only add the form class if density or variant is horizontal
        return this._labelAlignment === 'horizontal' && !this.variant || this.variant === VARIANT.LABEL_INLINE;
      }
      /**
       * The variant changes the label position of an input field.
       * Accepted variants include standard, label-hidden, label-inline, and label-stacked.
       * If variant is specified, the label position is determined by the variant.
       * Otherwise, it is determined by the density setting of the parent form.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant;
      }

      set variant(value) {
        this._variant = value;
        this.updateClassList();
      }
      /**
       * Reserved for internal use.
       * @param {*} record Reserved for internal use.
       */


      wireRecordUi(record) {
        let uiField; // TODO break up wireRecordUi method, too much stuff happening here

        try {
          uiField = getUiField(this.fieldName, record.record, record.objectInfo);
        } catch (e) {
          this.failed = true;
          this.errorMessage = `Field "${this.fieldName}" not found in response.`;
          return;
        }

        this.record = record;
        this.uiField = uiField;
        this.label = uiField.label;
        this._uiFieldRequired = uiField.required;
        this.objectInfos = record.objectInfos;
        this.inlineHelpText = uiField.inlineHelpText;
        this._labelAlignment = record.labelAlignment ? record.labelAlignment : '';
        this.updateClassList();

        if (!this.isDirty) {
          this.internalValue = uiField.value;
        }

        if (this._rawFieldName && this._rawFieldName.objectApiName && this._rawFieldName.objectApiName !== record.objectInfo.apiName) {
          throw new Error(`objectApiName (${this._rawFieldName.objectApiName}) for field ${this.fieldName} does not match the objectApiName provided for the form (${record.objectInfo.apiName}).`);
        }

        this.originalValue = uiField.value;

        if (isCompoundField(this.fieldName, record.objectInfo, isPersonAccount(record.record))) {
          this.isCompoundField = true;
          this.fieldPrefix = this.getFieldPrefix();
          this.initializeCompoundField(uiField, record);
        } else if (!record.createMode && uiField.updateable === false || record.createMode && uiField.createable === false) {
          this._disabled = true;
          this.readonly = true;
        }

        if (!this.isAnyPicklistType && !this.isCompoundField) {
          // compound fields without picklists will be marked ready in initializeCompoundField
          // picklists and compound fields that have picklist constituents will be marked ready after the options are wired
          this.ready = true;
        }
      }

      get inputVariant() {
        // precendence to variant over density
        if (this.variant) {
          return this.variant;
        }

        if (VARIANT_MAPPING[this._labelAlignment]) {
          return VARIANT_MAPPING[this._labelAlignment];
        }

        return this.variant;
      }
      /**
       * Reserved for internal use.
       * @param {*} picklistValues Reserved for internal use
       */


      wirePicklistValues(picklistValues) {
        // picklist fields rely on the record for dependency management.
        // The initialization logic will fail if record-ui isn't already wired.
        if (!this.record) {
          return;
        }

        this._picklistValues = picklistValues;

        if (this.isAnyPicklistType) {
          this.initializePicklist(this.fieldName);
        } else if (this.isCompoundField) {
          this.initializePicklistsForCompoundField(this.uiField, this.record);
        } else if (this.isTypeCheckbox) {
          // Also need to register checkbox fields that are part of a dependency chain
          this.registerCheckboxDependency();
        }

        this.ready = true;
      }

      updateAddressField(changedValues = {}) {
        let address = {
          country: this.getNormalizedStateCountryField('Country').value,
          postalCode: this.addressField.PostalCode.value,
          city: this.addressField.City.value,
          province: this.getNormalizedStateCountryField('State').value,
          street: this.addressField.Street.value
        };
        address = Object.assign(address, changedValues);
        this._country = address.country;
        this._postalCode = address.postalCode;
        this._state = address.province;
        this._street = address.street;
        this._city = address.city;
      }

      initializeCompoundField(uiField, record) {
        const compoundFields = getCompoundFields(this.fieldName, record.record, record.objectInfo);
        let compoundField = this.addressField;

        if (uiField.extraTypeInfo === Fields.PERSON_NAME) {
          compoundField = this.nameField;
        }

        if (!compoundFieldIsUpdateable(compoundFields, record.record, record.objectInfo)) {
          this._disabled = true;
        }

        let hasPicklists = false;
        compoundFields.forEach(field => {
          const fieldName = removePrefix(field, this.fieldPrefix);
          compoundField[fieldName] = getUiField(field, record.record, record.objectInfo);

          if (compoundField[fieldName].type === Fields.PICKLIST) {
            hasPicklists = true;
          }
        }); // if the compound field doesn't have a picklist constituent, mark it ready

        if (!hasPicklists) {
          this.ready = true;
        }

        if (this.isTypeAddress) {
          this.updateAddressField();
        }
      }
      /**
       * Resets the form fields to their initial values.
       */


      reset() {
        this.isDirty = false;
        this.wireRecordUi(this.record);

        if (this.canBeControllingField) {
          this.dispatchControllerFieldChangeEvent(this.fieldName, this.internalValue);
        }
      } // TODO this should be removed after records experience updates their code to not rely on this method

      /**
       * Reserved for internal use.
       * @param {*} fieldName Reserved for internal use.
       * @param {*} options Reserved for internal use.
       */


      updateDependentField(fieldName, options) {
        this.updateFieldOptions(fieldName, options); // make sure the component is marked ready

        this.ready = true;
      }
      /**
       * Reserved for internal use.
       * @param {*} errors Reserved for internal use.
       */


      setErrors(errors) {
        if (errors.body && errors.body.output && errors.body.output.fieldErrors && errors.body.output.fieldErrors[this.fieldName]) {
          this.setCustomValidity(errors.body.output.fieldErrors[this.fieldName][0].message);
          this.serverError = errors.body.output.fieldErrors[this.fieldName];
          this.serverErrorValue = this.value;
        } else {
          this.serverError = undefined;
        }
      }
      /**
       * The field value, which overrides the existing value.
       * @type {string}
       *
       */


      get value() {
        return this.internalValue;
      }

      set fieldName(name) {
        this._rawFieldName = name;

        if (name && name.fieldApiName) {
          this._fieldName = name.fieldApiName;
        } else {
          this._fieldName = name;
        }
      }
      /**
       * The API name of the field to be displayed.
       * @type {string}
       */


      get fieldName() {
        return this._fieldName;
      }

      set value(val) {
        if (this._inChangeCycle && this.isTypeReference) {
          // reject values being set from outside
          return;
        } // uninitialized values passed through
        // templates are undefined but should not
        // mark the field as dirty


        if (val !== undefined) {
          this.internalValue = val;
          this.isDirty = true;
        }
      }
      /**
       * If present, the field is disabled and users cannot interact with it.
       * Read-only fields are also disabled by default.
       * @type {boolean}
       *
       */


      get disabled() {
        return this._disabled ? true : false;
      }
      /**
       * If present, the input field must be filled out before the form is submitted.
       * @type {boolean}
       * @default false
       */


      get required() {
        return this._uiFieldRequired || this._externalRequired;
      }

      set required(value) {
        this._externalRequired = normalizeBoolean(value);
      }
      /**
       * Reserved for internal use.
       * @returns {boolean} Returns true if the input field is valid.
       */


      reportValidity() {
        const input = this.getInputComponent();

        if (input) {
          return input.reportValidity();
        }

        return true;
      }

      set disabled(val) {
        this._disabled = val;
      }
      /**
       * Reserved for internal use. If present, the field has been modified by the user but not saved or submitted.
       * @type {boolean}
       * @default false
       */


      get dirty() {
        return this.isDirty;
      }

      get isTypeName() {
        return this.isCompoundField && (Fields.PERSON_NAME === this.uiField.extraTypeInfo || Fields.SWITCHABLE_PERSON_NAME === this.uiField.extraTypeInfo);
      }

      get isTypeAddress() {
        return this.uiField.compound && Fields.ADDRESS === this.uiField.type;
      }

      get country() {
        return this.getNormalizedStateCountryField('Country');
      }

      get state() {
        return this.getNormalizedStateCountryField('State');
      }

      getNormalizedStateCountryField(fieldName) {
        if (this.addressField && this.addressField[`${fieldName}Code`]) {
          return this.addressField[`${fieldName}Code`];
        } else if (this.addressField && this.addressField[fieldName]) {
          return this.addressField[fieldName];
        }

        return {};
      }

      get isTypeNumber() {
        return NUMBER_TYPES.includes(this.uiField.type);
      }

      get numberFormatter() {
        let formatter = 'decimal';

        switch (this.uiField.type) {
          case 'Currency':
            formatter = 'currency';
            break;

          case 'Percent':
            formatter = 'percent-fixed';
            break;

          default:
        }

        return formatter;
      }

      get numberStep() {
        switch (this.uiField.type) {
          case 'Currency':
            return 0.01;

          case 'Percent':
          case 'Double':
          case 'Decimal':
            return scaleToDecimalPlaces(this.uiField.scale);

          default:
            return 1;
        }
      } // text type is the default


      get isTypeText() {
        return !this.isTypeNumber && !this.isTypeRichText && !this.isTypeTextArea && !this.isTypeCheckbox && !this.isTypeDate && !this.isTypeDateTime && !this.isTypeEmail && !this.isTypePicklist && !this.isTypeMultiPicklist && !this.isTypeName && !this.isTypeReference && !this.isTypeLocation && !this.isTypeUnsupportedReference && !this.isTypeAddress;
      }

      get isTypeRichText() {
        return Fields.TEXTAREA === this.uiField.type && Fields.RICH_TEXTAREA === this.uiField.extraTypeInfo && this.uiField.htmlFormatted;
      }

      get isTypeTextArea() {
        return Fields.TEXTAREA === this.uiField.type && Fields.PLAIN_TEXTAREA === this.uiField.extraTypeInfo && !this.uiField.htmlFormatted;
      }

      get isTypeCheckbox() {
        return Fields.BOOLEAN === this.uiField.type;
      }

      get isTypeEmail() {
        return Fields.EMAIL === this.uiField.type;
      }

      get isTypeDate() {
        return Fields.DATE === this.uiField.type;
      }

      get isTypeDateTime() {
        return Fields.DATETIME === this.uiField.type;
      }

      get isTypePicklist() {
        return Fields.PICKLIST === this.uiField.type;
      }

      get isTypeMultiPicklist() {
        return Fields.MULTI_PICKLIST === this.uiField.type;
      }

      get canBeControllingField() {
        return this.isTypePicklist || this.isTypeCheckbox;
      }

      get isAnyPicklistType() {
        return this.isTypePicklist || this.isTypeMultiPicklist;
      }

      get isTypeReference() {
        if (this.isTypeUnsupportedReference) {
          return false;
        }

        return Fields.REFERENCE === this.uiField.type;
      }

      get isTypeLocation() {
        return Fields.LOCATION === this.uiField.type;
      }

      get isTypeUnsupportedReference() {
        return isUnsupportedReferenceField(this.fieldName);
      }

      get displayValue() {
        return this.uiField.displayValue;
      }
      /**
       * Lookup needs an array,
       * so this casts the value to an array
       */


      get lookupValue() {
        if (this.value === undefined) {
          return [];
        } else if (Array.isArray(this.value)) {
          return this.value;
        }

        return [this.value];
      }

      renderedCallback() {
        if (!this.ready) {
          this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
          new CustomEvent('registerinputfield', {
            bubbles: true,
            composed: true,
            cancelable: true
          }));
        }
      }

      setCustomValidity(message) {
        const input = this.getInputComponent();

        if (input && input.setCustomValidity) {
          input.setCustomValidity(message ? message : '');
          input.showHelpMessageIfInvalid();
        }
      } // TODO refactor this function into smaller pieces


      handleChange(e) {
        // ignore change events until ready
        if (!this.ready) {
          return;
        } // change events without detail should be ignored


        if (!e.detail) {
          return;
        }

        if (this.isTypeName || this.isTypeAddress || this.isTypeLocation) {
          this.handleCompoundFieldChange(e);
          return;
        }

        if (e.detail.checked !== undefined) {
          this.internalValue = e.detail.checked;
        } else if (this.isTypeReference) {
          // multiselect doesn't actually work yet,
          // normalize falsey values
          this.internalValue = e.detail.value[0] ? e.detail.value[0] : ''; // ignore reset of value from bubble to interop

          this._inChangeCycle = true; // eslint-disable-next-line lwc/no-set-timeout

          setTimeout(() => {
            this._inChangeCycle = false;
          }, 0);
        } else {
          this.internalValue = e.detail.value;
        }

        if (this.internalValue !== this.originalValue) {
          this.isDirty = true;

          if (this.serverError) {
            this.setCustomValidity();
            this.serverError = false;
          }
        } else {
          this.isDirty = false;
        }

        if (this.canBeControllingField) {
          this.dispatchControllerFieldChangeEvent(this.fieldName, this.internalValue);
        }
      }

      handleCompoundFieldChange(e) {
        const newValue = normalizeCompoundFieldValues(this.originalValue, e.detail, this.fieldPrefix);
        const countryCodeField = addPrefix(COUNTRY_CODE, this.fieldPrefix); // currently input-address return 'province' as both stateCode and state. Having both of these
        // set to the same value returns an API error.

        if (this.originalValue.hasOwnProperty(countryCodeField)) {
          delete newValue[this.fieldPrefix + 'Country'];
          delete newValue[this.fieldPrefix + 'State'];
        } // if the newValue is not an empty object
        // this is a dirty record


        if (!isEmptyObject$1(newValue)) {
          this.isDirty = true; // CountryCode is a controlling picklist, so we need to update the options for StateCode

          if (newValue[countryCodeField] !== this.internalValue[countryCodeField]) {
            this.dispatchControllerFieldChangeEvent(countryCodeField, newValue[countryCodeField]);
          }

          const modifiedObject = Object.assign({}, this.internalValue, newValue);
          this.internalValue = modifiedObject;

          if (this.isTypeAddress) {
            this.updateAddressField(e.detail);
          }
        }
      }

      registerCheckboxDependency() {
        // no need to bother with dependency management if there are no picklists in the form.
        if (!this._picklistValues) {
          return;
        }

        const hasDependents$$1 = hasDependents(this.uiField, this.record.objectInfo.fields, this._picklistValues); // register checkboxes that are part of a dependency chain

        if (hasDependents$$1) {
          this.dispatchRegisterDependencyEvent(this.fieldName);
        }
      }

      initializePicklistsForCompoundField() {
        const compoundFields = getCompoundFields(this.fieldName, this.record.record, this.record.objectInfo);
        let compoundField = this.addressField;

        if (this.uiField.extraTypeInfo === Fields.PERSON_NAME) {
          compoundField = this.nameField;
        }

        compoundFields.forEach(field => {
          const fieldName = removePrefix(field, this.fieldPrefix);

          if (compoundField[fieldName].type === Fields.PICKLIST) {
            this.initializePicklist(field);
          }
        });
      }

      initializePicklist(fieldName) {
        if (!this._picklistValues || !this._picklistValues[fieldName]) {
          throw new Error(`Could not find picklist values for field [${fieldName}]`);
        } // should disable the picklist if the controlling field is missing


        const controllerMissing = isControllerMissing(this.uiField, this.record.objectInfo.fields, this._picklistValues);

        if (controllerMissing) {
          this.internalValue = '';
          this.picklistOptions = [];
          throw new Error(`Field [${this.uiField.controllerName}] controls the field [${fieldName}] but was not found in the form`);
        } // state and country picklists are in a dependency chain, no need to check.


        let isInDependencyChain$$1 = false;

        if (this.isTypeAddress) {
          isInDependencyChain$$1 = true;
        } else {
          isInDependencyChain$$1 = this.isAnyPicklistType && isInDependencyChain(this.uiField, this.record.objectInfo.fields, this._picklistValues);
        }

        if (isInDependencyChain$$1) {
          // initializing picklists in empty state, dependency manager will later update the options.
          this.picklistOptions = [];
          this.dispatchRegisterDependencyEvent(fieldName);
        } else {
          // regular picklist field not within a dependency chain
          this.picklistOptions = this._picklistValues[fieldName].values;
        }
      }

      updateFieldOptions(fieldName, options) {
        if (this.isTypeAddress) {
          const field = removePrefix(fieldName, this.fieldPrefix);
          this.addressField[field].options = options;
        } else if (this.isAnyPicklistType) {
          this.picklistOptions = options;
        }
      }

      getFieldPrefix() {
        if (this.isTypeAddress) {
          // Address fields usually have a prefix, e.g. `BillingStreet` or `ShippingStreet`
          return this.fieldName.split(/Address$/)[0];
        }

        return null;
      }

      dispatchRegisterDependencyEvent(fieldName) {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('registerfielddependency', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            fieldName,
            // field-dependency-manager only needs the update method and the live value of the input-field
            fieldElement: {
              updateFieldOptions: this.updateFieldOptions.bind(this),
              getFieldValue: () => {
                return this.value;
              }
            }
          }
        }));
      }

      dispatchControllerFieldChangeEvent(fieldName, value) {
        this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
        new CustomEvent('updatedependentfields', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            fieldName,
            value
          }
        }));
      }

      getInputComponent() {
        return this.template.querySelector('lightning-input,lightning-textarea,lightning-picklist,lightning-lookup');
      }

    }

    lwc.registerDecorators(LightningInputField, {
      publicProps: {
        readonly: {
          config: 0
        },
        variant: {
          config: 3
        },
        value: {
          config: 3
        },
        fieldName: {
          config: 3
        },
        disabled: {
          config: 3
        },
        required: {
          config: 3
        },
        dirty: {
          config: 1
        }
      },
      publicMethods: ["wireRecordUi", "wirePicklistValues", "reset", "updateDependentField", "setErrors", "reportValidity"],
      track: {
        uiField: 1,
        failed: 1,
        errorMessage: 1,
        ready: 1,
        picklistOptions: 1,
        isCompoundField: 1,
        nameField: 1,
        addressField: 1,
        label: 1,
        _uiFieldRequired: 1,
        _externalRequired: 1,
        inlineHelpText: 1,
        _disabled: 1,
        internalValue: 1,
        objectInfos: 1,
        record: 1,
        _fieldName: 1,
        _street: 1,
        _country: 1,
        _postalCode: 1,
        _state: 1,
        _city: 1,
        _labelAlignment: 1,
        _variant: 1
      }
    });

    var _lightningInputField = lwc.registerComponent(LightningInputField, {
      tmpl: _tmpl$G
    });

    function stylesheet$j(hostSelector, shadowSelector, nativeShadow) {
      return "lightning-input" + shadowSelector + " {display: inline-block;}\n";
    }
    var _implicitStylesheets$j = [stylesheet$j];

    function tmpl$L($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [$cmp.state.isNavigable ? api_element("a", {
        attrs: {
          "href": $cmp.state.url
        },
        key: 3,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleClick))
        }
      }, [api_dynamic($cmp.displayValue)]) : null, !$cmp.state.isNavigable ? api_dynamic($cmp.displayValue) : null];
    }

    var _tmpl$H = lwc.registerTemplate(tmpl$L);
    tmpl$L.stylesheets = [];
    tmpl$L.stylesheetTokens = {
      hostAttribute: "lightning-formattedLookup_formattedLookup-host",
      shadowAttribute: "lightning-formattedLookup_formattedLookup"
    };

    class LightningFormattedLookup extends lwc.LightningElement {
      /**
       * {string} The related name/record name to display
       */

      /**
       * @param {string} value - The record id to point to.
       */
      set recordId(value) {
        // hanging value on state makes sure changes
        // trigger a re-render
        this.state.recordId = value; // re-fetch url info

        this.updateLinkData();
      }

      get recordId() {
        return this.state.recordId;
      }
      /**
       * {boolean} Determines if the output is navigable or not along
       * with the url and dispatcher returned from routing-service
       */


      get disabled() {
        return this.state.disabled;
      }

      set disabled(value) {
        this.state.disabled = normalizeBoolean(value);
        this.state.isNavigable = !this.disabled && !!this.dispatcher && !!this.state.url;
      }

      constructor() {
        super();
        this.displayValue = void 0;
        this._connected = void 0;
        this.dispatcher = void 0;
        this.state = {
          disabled: false,
          recordId: null,
          url: null,
          isNavigable: false
        };
        this._connected = false;
        this.dispatcher = null;
      }
      /**
       * Lifecycle callback for connected.
       * @returns {undefined}
       */


      connectedCallback() {
        // this is to guard getLinkInfo, which will
        // not work if called before the component is connected
        this._connected = true;
        this.updateLinkData();
      }
      /**
       * Lifecycle callback for disconnected
       * @returns {undefined}
       */


      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * Fetch info for the link url
       * async, updates this.state
       * @returns {undefined}
       */


      updateLinkData() {
        if (this._connected && this.state.recordId) {
          getLinkInfo(this, {
            stateType: 'standard__recordPage',
            attributes: {
              recordId: this.state.recordId,
              actionName: 'view'
            }
          }).then(linkInfo => {
            this.state.url = linkInfo.url;
            this.dispatcher = linkInfo.dispatcher;
            this.state.isNavigable = !this.disabled && !!this.dispatcher && !!this.state.url;
          });
        }
      }
      /**
       * Handles the click event on the link.
       * @param {Event} event The event that triggered this handler.
       * @returns {undefined}
       */


      handleClick(event) {
        this.dispatcher(event);
      }

    }

    lwc.registerDecorators(LightningFormattedLookup, {
      publicProps: {
        displayValue: {
          config: 0
        },
        recordId: {
          config: 3
        },
        disabled: {
          config: 3
        }
      },
      track: {
        state: 1
      }
    });

    var _lightningFormattedLookup = lwc.registerComponent(LightningFormattedLookup, {
      tmpl: _tmpl$H
    });

    function tmpl$M($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        k: api_key,
        h: api_element,
        i: api_iterator
      } = $api;
      return api_iterator($cmp.formattedParts, function (part) {
        return [part.isLink ? api_element("a", {
          attrs: {
            "target": "_blank",
            "href": part.href,
            "rel": "noopener"
          },
          key: api_key(4, part.value)
        }, [api_dynamic(part.value)]) : null, part.isText ? api_dynamic(part.value) : null, part.isNewline ? api_element("br", {
          key: api_key(7, part.value)
        }, []) : null];
      });
    }

    var _tmpl$I = lwc.registerTemplate(tmpl$M);
    tmpl$M.stylesheets = [];
    tmpl$M.stylesheetTokens = {
      hostAttribute: "lightning-formattedText_formattedText-host",
      shadowAttribute: "lightning-formattedText_formattedText"
    };

    /*
     * Regex was taken from aura lib and refactored
     */

    const linkRegex$1 = new RegExp(`(${newLineRegexString})|${urlRegexString}|${emailRegexString}`, 'gi');
    const emailRegex = new RegExp(emailRegexString, 'gi');
    const newLineRegex = new RegExp(newLineRegexString, 'gi');

    function getTextPart(text) {
      return {
        isText: true,
        value: text
      };
    }

    function getUrlPart(url) {
      return {
        isLink: true,
        value: url,
        href: createHttpHref(url)
      };
    }

    function getEmailPart(email) {
      return {
        isLink: true,
        value: email,
        href: createEmailHref(email)
      };
    }

    function getNewlinePart() {
      return {
        isNewline: true
      };
    }

    function getLinkPart(link) {
      if (link.match(newLineRegex)) {
        return getNewlinePart();
      } else if (link.match(emailRegex)) {
        return getEmailPart(link);
      }

      return getUrlPart(link);
    }

    function parseToFormattedLinkifiedParts(text) {
      const parts = [];
      const re = linkRegex$1;
      let match;

      while ((match = re.exec(text)) !== null) {
        const indexOfMatch = text.indexOf(match[0]);
        let link = match[0];
        const endsWithQuote = link && link.endsWith('&quot'); // If we found an email or url match, then create a text part for everything
        // up to the match and then create the part for the email or url

        if (indexOfMatch > 0) {
          parts.push(getTextPart(text.slice(0, text.indexOf(match[0]))));
        }

        if (endsWithQuote) {
          link = link.slice(0, link.lastIndexOf('&quot'));
        }

        parts.push(getLinkPart(link));

        if (endsWithQuote) {
          parts.push(getTextPart('&quot'));
        }

        text = text.substring(re.lastIndex);
        re.lastIndex = 0;
      }

      if (text != null && text !== '') {
        parts.push(getTextPart(text));
      }

      return parts;
    }
    function parseToFormattedParts(text) {
      return text.split(newLineRegex).map((part, index) => {
        return index % 2 === 0 ? getTextPart(part) : getNewlinePart();
      });
    }

    /**
     * Displays text, replaces newlines with line breaks, and linkifies if requested.
     */

    class FormattedText extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.value = '';
        this._linkify = false;
      }

      /**
       * If present, URLs and email addresses are displayed in anchor tags.
       * They are displayed in plain text by default.
       * @type {boolean}
       * @default false
       */
      get linkify() {
        return this._linkify;
      }

      set linkify(value) {
        this._linkify = normalizeBoolean(value);
      }

      get formattedParts() {
        if (!this.value || typeof this.value !== 'string') {
          return [];
        }

        return this.linkify ? parseToFormattedLinkifiedParts(this.value) : parseToFormattedParts(this.value);
      }

    }

    lwc.registerDecorators(FormattedText, {
      publicProps: {
        value: {
          config: 0
        },
        linkify: {
          config: 3
        }
      },
      track: {
        _linkify: 1
      }
    });

    var _lightningFormattedText = lwc.registerComponent(FormattedText, {
      tmpl: _tmpl$I
    });

    function tmpl$N($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        t: api_text,
        d: api_dynamic,
        ti: api_tab_index,
        h: api_element
      } = $api;
      return [$cmp.hasValue ? api_element("a", {
        attrs: {
          "href": $cmp.href,
          "tabindex": api_tab_index($cmp.tabIndex)
        },
        key: 3
      }, [!$cmp.hideIcon ? api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "iconName": "utility:email",
          "size": "x-small",
          "alternativeText": $cmp.i18n.emailLabel
        },
        key: 5
      }, []) : null, api_text(" "), api_dynamic($cmp.computedLabel)]) : null];
    }

    var _tmpl$J = lwc.registerTemplate(tmpl$N);
    tmpl$N.stylesheets = [];
    tmpl$N.stylesheetTokens = {
      hostAttribute: "lightning-formattedEmail_formattedEmail-host",
      shadowAttribute: "lightning-formattedEmail_formattedEmail"
    };

    var labelEmailLabel = 'Email';

    // also be added to the static `labels` prop inside the class.
    // https://git.soma.salesforce.com/raptor/raptor/issues/196

    const i18n$o = {
      emailLabel: labelEmailLabel
    };
    /**
     * Displays an email as a hyperlink with the mailto: URL scheme.
     */

    class LightningFormattedEmail extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.value = void 0;
        this.label = void 0;
        this.tabIndex = void 0;
        this.hideIcon = false;
        this._connected = false;
      }

      connectedCallback() {
        this._connected = true;
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * Sets focus on the element.
       */


      focus() {
        if (this.emailAnchor) {
          this.emailAnchor.focus();
        }
      }
      /**
       * Removes keyboard focus from the element.
       */


      blur() {
        if (this.emailAnchor) {
          this.emailAnchor.blur();
        }
      }
      /**
       * Clicks the email address and opens the default email app.
       */


      click() {
        const anchor = this.emailAnchor;

        if (anchor && anchor.click) {
          anchor.click();
        }
      }

      get emailAnchor() {
        if (this._connected && this.hasValue) {
          return this.template.querySelector('a');
        }

        return undefined;
      }

      get trimmedValue() {
        return (this.value || '').trim();
      }

      get trimmedLabel() {
        return (this.label || '').trim();
      }

      get hasValue() {
        return !!this.trimmedValue;
      }

      get href() {
        return 'mailto:' + this.trimmedValue;
      }

      get computedLabel() {
        return this.trimmedLabel || this.trimmedValue;
      }

      get i18n() {
        return i18n$o;
      }

    }

    lwc.registerDecorators(LightningFormattedEmail, {
      publicProps: {
        value: {
          config: 0
        },
        label: {
          config: 0
        },
        tabIndex: {
          config: 0
        },
        hideIcon: {
          config: 0
        }
      },
      publicMethods: ["focus", "blur", "click"]
    });

    var _lightningFormattedEmail = lwc.registerComponent(LightningFormattedEmail, {
      tmpl: _tmpl$J
    });

    function tmpl$O($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        t: api_text
      } = $api;
      return [$cmp.isValid ? api_dynamic($cmp.latitude) : null, $cmp.isValid ? api_text(", ") : null, $cmp.isValid ? api_dynamic($cmp.longitude) : null];
    }

    var _tmpl$K = lwc.registerTemplate(tmpl$O);
    tmpl$O.stylesheets = [];
    tmpl$O.stylesheetTokens = {
      hostAttribute: "lightning-formattedLocation_formattedLocation-host",
      shadowAttribute: "lightning-formattedLocation_formattedLocation"
    };

    const MAX_LONGITUDE = 180.0;
    const MAX_LATITUDE = 90.0;

    function isNumber$1(value) {
      return value !== '' && value !== null && isFinite(value);
    }

    function isLongitude(longitude) {
      return isNumber$1(longitude) && Math.abs(longitude) <= MAX_LONGITUDE;
    }

    function isLatitude(latitude) {
      return isNumber$1(latitude) && Math.abs(latitude) <= MAX_LATITUDE;
    }
    /**
     * Displays a geolocation in decimal degrees using the format [latitude, longitude].
     */


    class LightningFormattedLocation extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.latitude = void 0;
        this.longitude = void 0;
      }

      get isValid() {
        const valid = isLatitude(this.latitude) && isLongitude(this.longitude);

        if (!valid) {
          // eslint-disable-next-line no-console
          console.warn(`<lightning-formatted-location> expects latitude in range [-90.0, 90.0], longitude in range [-180.0, 180.0].`);
        }

        return valid;
      }

    }

    lwc.registerDecorators(LightningFormattedLocation, {
      publicProps: {
        latitude: {
          config: 0
        },
        longitude: {
          config: 0
        }
      }
    });

    var _lightningFormattedLocation = lwc.registerComponent(LightningFormattedLocation, {
      tmpl: _tmpl$K
    });

    function stylesheet$k(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? ("[dir=\"rtl\"] :host {direction: ltr;unicode-bidi: embed;}") : ("[dir=\"rtl\"] " + hostSelector + " {direction: ltr;unicode-bidi: embed;}")) + "\n";
    }
    var _implicitStylesheets$k = [stylesheet$k];

    function tmpl$P($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic
      } = $api;
      return [api_dynamic($cmp.formattedNumber)];
    }

    var _tmpl$L = lwc.registerTemplate(tmpl$P);
    tmpl$P.stylesheets = [];

    if (_implicitStylesheets$k) {
      tmpl$P.stylesheets.push.apply(tmpl$P.stylesheets, _implicitStylesheets$k);
    }
    tmpl$P.stylesheetTokens = {
      hostAttribute: "lightning-formattedNumber_formattedNumber-host",
      shadowAttribute: "lightning-formattedNumber_formattedNumber"
    };

    /**
     * Displays formatted numbers for decimals, currency, and percentages.
     */

    class LightningFormattedNumber extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.value = void 0;
        this.formatStyle = 'decimal';
        this.currencyCode = void 0;
        this.currencyDisplayAs = 'symbol';
        this.minimumIntegerDigits = void 0;
        this.minimumFractionDigits = void 0;
        this.maximumFractionDigits = void 0;
        this.minimumSignificantDigits = void 0;
        this.maximumSignificantDigits = void 0;
      }

      get formattedNumber() {
        const value = this.value;
        const options = {
          style: this.formatStyle,
          currency: this.currencyCode,
          currencyDisplay: this.currencyDisplayAs,
          minimumIntegerDigits: this.minimumIntegerDigits,
          minimumFractionDigits: this.minimumFractionDigits,
          maximumFractionDigits: this.maximumFractionDigits,
          minimumSignificantDigits: this.minimumSignificantDigits,
          maximumSignificantDigits: this.maximumSignificantDigits
        };
        const canReturnValue = value !== undefined && value !== null && value !== '' && isFinite(value);

        if (canReturnValue) {
          let valueToFormat = value; // percent-fixed just divides the value by 100
          // before passing to the library, this is to deal with the
          // fact that percentages in salesforce are 0-100, not 0-1

          if (this.formatStyle === 'percent-fixed') {
            options.style = 'percent';
            valueToFormat = parseFloat(value) / 100;
          }

          return numberFormat(options).format(valueToFormat);
        }

        return '';
      }

    }

    lwc.registerDecorators(LightningFormattedNumber, {
      publicProps: {
        value: {
          config: 0
        },
        formatStyle: {
          config: 0
        },
        currencyCode: {
          config: 0
        },
        currencyDisplayAs: {
          config: 0
        },
        minimumIntegerDigits: {
          config: 0
        },
        minimumFractionDigits: {
          config: 0
        },
        maximumFractionDigits: {
          config: 0
        },
        minimumSignificantDigits: {
          config: 0
        },
        maximumSignificantDigits: {
          config: 0
        }
      }
    });

    var _lightningFormattedNumber = lwc.registerComponent(LightningFormattedNumber, {
      tmpl: _tmpl$L
    });
    LightningFormattedNumber.interopMap = {
      props: {
        formatStyle: 'style'
      }
    };

    function tmpl$Q($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        ti: api_tab_index,
        h: api_element
      } = $api;
      return [$cmp.showLink ? api_element("a", {
        attrs: {
          "href": $cmp.link,
          "tabindex": api_tab_index($cmp.tabIndex)
        },
        key: 3
      }, [api_dynamic($cmp.formattedPhoneNumber)]) : null];
    }

    var _tmpl$M = lwc.registerTemplate(tmpl$Q);
    tmpl$Q.stylesheets = [];
    tmpl$Q.stylesheetTokens = {
      hostAttribute: "lightning-formattedPhone_formattedPhone-host",
      shadowAttribute: "lightning-formattedPhone_formattedPhone"
    };

    /**
     * Displays a phone number as a hyperlink with the tel: URL scheme.
     */

    class LightningFormattedPhone extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.value = void 0;
        this.tabIndex = void 0;
        this._connected = false;
      }

      connectedCallback() {
        this._connected = true;
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * Sets focus on the element.
       */


      focus() {
        if (this.phoneAnchor) {
          this.phoneAnchor.focus();
        }
      }
      /**
       * Removes keyboard focus from the element.
       */


      blur() {
        if (this.phoneAnchor) {
          this.phoneAnchor.blur();
        }
      }
      /**
       * Clicks the phone number and opens the default phone app.
       */


      click() {
        const anchor = this.phoneAnchor;

        if (anchor && anchor.click) {
          anchor.click();
        }
      }

      get phoneAnchor() {
        if (this._connected && this.showLink) {
          return this.template.querySelector('a');
        }

        return undefined;
      }

      get showLink() {
        return this.value != null && this.value !== '';
      }

      get formattedPhoneNumber() {
        return toNorthAmericanPhoneNumber(this.value);
      }

      get link() {
        return `tel:${this.value}`;
      }

    }

    lwc.registerDecorators(LightningFormattedPhone, {
      publicProps: {
        value: {
          config: 0
        },
        tabIndex: {
          config: 0
        }
      },
      publicMethods: ["focus", "blur", "click"]
    });

    var _lightningFormattedPhone = lwc.registerComponent(LightningFormattedPhone, {
      tmpl: _tmpl$M
    });

    function tmpl$R($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        ti: api_tab_index,
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [$cmp.hasValue ? api_element("a", {
        attrs: {
          "href": $cmp.computedUrl,
          "title": $cmp.tooltip,
          "target": $cmp.target,
          "tabindex": api_tab_index($cmp.tabIndex)
        },
        key: 3,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleClick))
        }
      }, [api_dynamic($cmp.computedLabel)]) : null];
    }

    var _tmpl$N = lwc.registerTemplate(tmpl$R);
    tmpl$R.stylesheets = [];
    tmpl$R.stylesheetTokens = {
      hostAttribute: "lightning-formattedUrl_formattedUrl-host",
      shadowAttribute: "lightning-formattedUrl_formattedUrl"
    };

    /**
     * Displays a URL as a hyperlink.
     */

    class LightningFormattedUrl extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.target = void 0;
        this.tooltip = void 0;
        this.label = void 0;
        this.tabIndex = void 0;
        this._url = void 0;
        this._value = void 0;
        this._connected = false;

        this._dispatcher = () => {};
      }

      /**
       * The URL to format.
       * @type {string}
       *
       */
      get value() {
        return this._value;
      }

      set value(value) {
        this._value = value;

        if (this._connected) {
          this.updateLinkInfo(value);
        }
      }

      connectedCallback() {
        this._connected = true;
        this.updateLinkInfo(this.value);
      }

      disconnectedCallback() {
        this._connected = false;
      }
      /**
       * Sets focus on the element.
       */


      focus() {
        if (this.urlAnchor) {
          this.urlAnchor.focus();
        }
      }
      /**
       * Removes keyboard focus from the element.
       */


      blur() {
        if (this.urlAnchor) {
          this.urlAnchor.blur();
        }
      }

      get urlAnchor() {
        if (this._connected && this.hasValue) {
          return this.template.querySelector('a');
        }

        return undefined;
      }

      handleClick(event) {
        // For target blank, use the default browser behaviour (open in a new tab)
        if (this.target !== '_blank') {
          this._dispatcher(event);
        }
      }

      updateLinkInfo(url) {
        updateRawLinkInfo(this, {
          url: this.makeAbsoluteUrl(url),
          target: this.target
        }).then(linkInfo => {
          this._url = linkInfo.url;
          this._dispatcher = linkInfo.dispatcher;
        });
      }

      get computedLabel() {
        const {
          label,
          computedUrl
        } = this;
        return label != null && label !== '' ? label : computedUrl;
      }

      get computedUrl() {
        return this._url || this.makeAbsoluteUrl(this.value);
      }

      get hasValue() {
        const url = this.value;
        return url != null && url !== '';
      }

      makeAbsoluteUrl(url) {
        return isAbsoluteUrl(url) ? url : `http://${url}`;
      }

    }

    lwc.registerDecorators(LightningFormattedUrl, {
      publicProps: {
        target: {
          config: 0
        },
        tooltip: {
          config: 0
        },
        label: {
          config: 0
        },
        tabIndex: {
          config: 0
        },
        value: {
          config: 3
        }
      },
      publicMethods: ["focus", "blur"],
      track: {
        _url: 1,
        _value: 1
      }
    });

    var _lightningFormattedUrl = lwc.registerComponent(LightningFormattedUrl, {
      tmpl: _tmpl$N
    });

    function tmpl$S($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic
      } = $api;
      return [$cmp.hasValue ? api_dynamic($cmp.formattedName) : null];
    }

    var _tmpl$O = lwc.registerTemplate(tmpl$S);
    tmpl$S.stylesheets = [];
    tmpl$S.stylesheetTokens = {
      hostAttribute: "lightning-formattedName_formattedName-host",
      shadowAttribute: "lightning-formattedName_formattedName"
    };

    const DEFAULT_FORMAT = 'long';
    /**
     * Displays a formatted name that can include a salutation and suffix.
     */

    class LightningFormattedName extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.format = DEFAULT_FORMAT;
        this._salutation = void 0;
        this._firstName = void 0;
        this._lastName = void 0;
        this._middleName = void 0;
        this._suffix = void 0;
        this._informalName = void 0;
      }

      /**
       * The value for the salutation, such as Dr. or Mrs.
       * @type {string}
       *
       */
      get salutation() {
        return this._salutation;
      }

      set salutation(value) {
        this._salutation = value;
      }
      /**
       * The value for the first name.
       * @type {string}
       *
       */


      get firstName() {
        return this._firstName;
      }

      set firstName(value) {
        this._firstName = value;
      }
      /**
       * The value for the last name.
       * @type {string}
       *
       */


      get lastName() {
        return this._lastName;
      }

      set lastName(value) {
        this._lastName = value;
      }
      /**
       * The value for the middle name.
       * @type {string}
       *
       */


      get middleName() {
        return this._middleName;
      }

      set middleName(value) {
        this._middleName = value;
      }
      /**
       * The value for the suffix, such as Jr. or Esq.
       * @type {string}
       *
       */


      get suffix() {
        return this._suffix;
      }

      set suffix(value) {
        this._suffix = value;
      }
      /**
       * The value for the informal name.
       * @type {string}
       *
       */


      get informalName() {
        return this._informalName;
      }

      set informalName(value) {
        this._informalName = value;
      }

      get normalizedFormat() {
        return normalizeString(this.format, {
          fallbackValue: DEFAULT_FORMAT,
          validValues: ['short', 'medium', 'long']
        });
      }

      get hasValue() {
        return !!(this.salutation || this.firstName || this.lastName || this.middleName || this.suffix || this.informalName);
      }

      get formattedName() {
        const {
          normalizedFormat
        } = this;
        const nameObject = {
          first: this.firstName,
          middle: this.middleName,
          last: this.lastName,
          salutation: this.salutation,
          suffix: this.suffix,
          informal: this.informalName
        };
        let formattedName = '';
        const locale = getLocaleTag().replace(/-/g, '_');

        switch (normalizedFormat) {
          case 'short':
            formattedName = name.formatNameShort(locale, nameObject);
            break;

          case 'medium':
            formattedName = name.formatNameMedium(locale, nameObject);
            break;

          case 'long':
          default:
            formattedName = name.formatNameLong(locale, nameObject);
        }

        return formattedName;
      }

    }

    lwc.registerDecorators(LightningFormattedName, {
      publicProps: {
        format: {
          config: 0
        },
        salutation: {
          config: 3
        },
        firstName: {
          config: 3
        },
        lastName: {
          config: 3
        },
        middleName: {
          config: 3
        },
        suffix: {
          config: 3
        },
        informalName: {
          config: 3
        }
      },
      track: {
        _salutation: 1,
        _firstName: 1,
        _lastName: 1,
        _middleName: 1,
        _suffix: 1,
        _informalName: 1
      }
    });

    var _lightningFormattedName = lwc.registerComponent(LightningFormattedName, {
      tmpl: _tmpl$O
    });

    function stylesheet$l(hostSelector, shadowSelector, nativeShadow) {
      return ".slds-iframe-container" + shadowSelector + " {position: relative;}\n.slds-iframe-cover" + shadowSelector + " {top: 0;left: 0;right: 0;bottom: 0;position: absolute;z-index: 3;}\n";
    }
    var _implicitStylesheets$l = [stylesheet$l];

    function tmpl$T($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element,
        h: api_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-iframe-container": true
        },
        key: 2
      }, [api_custom_element("lightning-primitive-iframe", _lightningPrimitiveIframe, {
        props: {
          "src": $cmp.staticMapSrc,
          "domain": $cmp.apiDomain,
          "width": $cmp.width,
          "height": $cmp.height,
          "frameStyle": $cmp.mapStyle
        },
        key: 3,
        on: {
          "iframeload": _m0 || ($ctx._m0 = api_bind($cmp.handleIframeLoad))
        }
      }, []), api_element("div", {
        classMap: {
          "slds-iframe-cover": true
        },
        key: 4
      }, [])])];
    }

    var _tmpl$P = lwc.registerTemplate(tmpl$T);
    tmpl$T.stylesheets = [];

    if (_implicitStylesheets$l) {
      tmpl$T.stylesheets.push.apply(tmpl$T.stylesheets, _implicitStylesheets$l);
    }
    tmpl$T.stylesheetTokens = {
      hostAttribute: "lightning-staticMap_staticMap-host",
      shadowAttribute: "lightning-staticMap_staticMap"
    };

    function ratioToScale() {
      return 'devicePixelRatio' in window && Math.round(window.devicePixelRatio) > 1 ? 2 : 1;
    }
    function calculateSize(width, height, formFactor) {
      const display = {
        width: window.innerWidth || document.body.clientWidth || 0,
        height: window.innerHeight || document.body.clientHeight || 0
      };

      if (width == null || width === 0) {
        if (formFactor === 'PHONE') {
          if (display.width > 30) {
            width = display.width - 30;
          } else {
            width = 300;
          }
        } else if (formFactor === 'TABLET') {
          width = display.width;

          if (width > 768) {
            width = 768;
          } // assume 2 columns could be used


          width = Number(width / 2).toFixed();

          if (width > 30) {
            width -= 30;
          } else {
            width = 300;
          }
        } else {
          // DESKTOP
          width = formFactor !== 'DESKTOP' ? 564 : display.width;

          if (width > 768) {
            width = 768;
          } // assume 2 columns could be used


          width = Number(width / 2).toFixed();

          if (width > 30) {
            width -= 30;
          } else {
            width = 360;
          }
        }
      } // default height to make a 16:9 aspect ratio


      if (height == null || height === 0) {
        height = Number(width * 9 / 16).toFixed();
      }

      return {
        width,
        height
      };
    }

    const EVENT_NAME$1 = {
      LOADING_MAP: 'loadingMap',
      STATIC_MAP_LOADED: 'lightning:staticMapLoaded'
    };

    class LightningStaticMap extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.width = void 0;
        this.height = void 0;
        this.street = void 0;
        this.city = void 0;
        this.province = void 0;
        this.postalCode = void 0;
        this.country = void 0;
        this._zoom = 14;
        this._scale = 1;
        this._mapType = 'roadmap';
        this._format = 'png';
        this.secureDomain = `https://maps${configProvider.getCoreInfo().untrustedContentDomain}:${configProvider.getCoreInfo().securePort}`;
        this.apiDomain = `*`;
        this._mapSrc = void 0;
        this._mapLoaded = false;
        this._latitude = void 0;
        this._longitude = void 0;
      }

      connectedCallback() {
        this._dispatchId = registerMessageHandler(event => {
          this.handleMessage(event);
        });
        this._scale = ratioToScale();
      }

      get latitude() {
        return this._latitude;
      }

      set latitude(value) {
        if (value != null && value !== '') {
          this._latitude = parseFloat(value);
        }
      }

      get longitude() {
        return this._longitude;
      }

      set longitude(value) {
        if (value != null && value !== '') {
          this._longitude = parseFloat(value);
        }
      }

      get size() {
        if (!this._size) {
          this._size = calculateSize(this.width, this.height, this.formFactor);
        }

        return `${this._size.width}x${this._size.height}`;
      }

      get formFactor() {
        return configProvider.getFormFactor();
      }

      get markers() {
        return `color:red|${this.address}`;
      }

      get mapStyle() {
        if (this._mapLoaded) {
          return 'border: 0px; top: 0; left: 0; right: 0; bottom: 0; position: relative; overflow: hidden; display: inherit';
        }

        return 'display:none';
      }

      get hasValidAddress() {
        return !!(this.state || this.country || this.postalCode);
      }

      get staticMapSrc() {
        if (this.hasValidAddress) {
          return `${this.secureDomain}/lightningmaps/mapsloader?resource=staticMap&center=${this.address}&size=${this.size}&zoom=${this._zoom}&scale=${this._scale}&maptype=${this._mapType}&format=${this._format}&markers=${this.markers}&locale=${configProvider.getLocale().userLocaleLang}&version=${configProvider.getCoreInfo().internalAppVersion}`;
        }

        return '';
      }

      get address() {
        // if latitude/longitude specified use that to avoid expensive Google geo-coding processing
        if (this.latitude != null && this.latitude >= -90.0 && this.latitude <= 90.0 && this.longitude != null && this.longitude >= -180.0 && this.longitude <= 180.0) {
          return `${this.latitude},${this.longitude}`;
        }

        return `${this.street} ${this.city} ${this.province} ${this.postalCode} ${this.country}`;
      }

      handleMessage(data) {
        if (data.event === EVENT_NAME$1.STATIC_MAP_LOADED) {
          this._mapLoaded = true;
        }
      }

      sendMessage(event, params) {
        if (this._handler) {
          const message = createMessage(this._dispatchId, event, params || {});
          postMessage(this._handler, message, '*');
        }
      }

      handleIframeLoad(event) {
        this._handler = event.detail.callbacks.postToWindow;
        this.sendMessage(EVENT_NAME$1.LOADING_MAP, {});
      }

    }

    lwc.registerDecorators(LightningStaticMap, {
      publicProps: {
        width: {
          config: 0
        },
        height: {
          config: 0
        },
        street: {
          config: 0
        },
        city: {
          config: 0
        },
        province: {
          config: 0
        },
        postalCode: {
          config: 0
        },
        country: {
          config: 0
        },
        latitude: {
          config: 3
        },
        longitude: {
          config: 3
        }
      },
      track: {
        _mapSrc: 1,
        _mapLoaded: 1,
        _latitude: 1,
        _longitude: 1
      }
    });

    var _lightningStaticMap = lwc.registerComponent(LightningStaticMap, {
      tmpl: _tmpl$P
    });

    function tmpl$U($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        k: api_key,
        h: api_element,
        i: api_iterator,
        c: api_custom_element,
        f: api_flatten,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0
      } = $ctx;
      return api_flatten([$cmp.showPlainText ? api_flatten([api_iterator($cmp.addressLines, function (line) {
        return api_element("div", {
          classMap: {
            "slds-truncate": true
          },
          key: api_key(4, line)
        }, [api_dynamic(line)]);
      }), $cmp.showStaticMap ? api_custom_element("lightning-static-map", _lightningStaticMap, {
        props: {
          "street": $cmp.street,
          "city": $cmp.city,
          "province": $cmp.province,
          "postalCode": $cmp.postalCode,
          "country": $cmp.country,
          "latitude": $cmp.latitude,
          "longitude": $cmp.longitude
        },
        key: 6
      }, []) : null]) : [], $cmp.showMapLink ? api_element("a", {
        attrs: {
          "title": $cmp.mapQuery,
          "href": $cmp.state.mapUrl,
          "tabindex": api_tab_index($cmp.internalTabIndex),
          "target": "_blank",
          "rel": "noopener"
        },
        key: 8,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleClick))
        }
      }, api_flatten([api_iterator($cmp.addressLines, function (line) {
        return api_element("div", {
          classMap: {
            "slds-truncate": true
          },
          key: api_key(10, line)
        }, [api_dynamic(line)]);
      }), $cmp.showStaticMap ? api_custom_element("lightning-static-map", _lightningStaticMap, {
        props: {
          "street": $cmp.street,
          "city": $cmp.city,
          "province": $cmp.province,
          "postalCode": $cmp.postalCode,
          "country": $cmp.country,
          "latitude": $cmp.latitude,
          "longitude": $cmp.longitude
        },
        key: 12
      }, []) : null])) : null]);
    }

    var _tmpl$Q = lwc.registerTemplate(tmpl$U);
    tmpl$U.stylesheets = [];
    tmpl$U.stylesheetTokens = {
      hostAttribute: "lightning-formattedAddress_formattedAddress-host",
      shadowAttribute: "lightning-formattedAddress_formattedAddress"
    };

    const MAP_HOST = 'https://www.google.com/maps/?q=';
    /**
     * Displays a formatted address with a link to the given location on Google Maps.
     * The link is opened in a new tab.
     * A static map can be displayed with the address for better context.
     */

    class LightningFormattedAddress extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.state = {
          street: '',
          city: '',
          province: '',
          country: '',
          postalCode: '',
          latitude: '',
          longitude: '',
          disabled: false,
          mapUrl: ''
        };
        this.connected = false;
        this._showStaticMap = void 0;

        this.dispatcher = () => {};
      }

      connectedCallback() {
        this.connected = true;
        this.updateLinkInfo();
      }
      /**
       * The street detail for the address.
       * @type {string}
       *
       */


      get street() {
        return this.state.street;
      }

      set street(value) {
        this.state.street = value;
        this.updateLinkInfo();
      }
      /**
       * The city detail for the address.
       * @type {string}
       *
       */


      get city() {
        return this.state.city;
      }

      set city(value) {
        this.state.city = value;
        this.updateLinkInfo();
      }
      /**
       * The province detail for the address.
       * @type {string}
       *
       */


      get province() {
        return this.state.province;
      }

      set province(value) {
        this.state.province = value;
        this.updateLinkInfo();
      }
      /**
       * The country detail for the address.
       * @type {string}
       *
       */


      get country() {
        return this.state.country;
      }

      set country(value) {
        this.state.country = value;
        this.updateLinkInfo();
      }
      /**
       * The postal code detail for the address.
       * @type {string}
       *
       */


      get postalCode() {
        return this.state.postalCode;
      }

      set postalCode(value) {
        this.state.postalCode = value;
        this.updateLinkInfo();
      }
      /**
       * The latitude of the location if known. Latitude values must be within -90 and 90.
       * @type {number}
       *
       */


      get latitude() {
        return this.state.latitude;
      }

      set latitude(value) {
        this.state.latitude = value;
        this.updateLinkInfo();
      }
      /**
       * The longitude of the location if known. Longitude values must be within -180 and 180.
       * @type {number}
       *
       */


      get longitude() {
        return this.state.longitude;
      }

      set longitude(value) {
        this.state.longitude = value;
        this.updateLinkInfo();
      }
      /**
       * If present, the address is displayed as plain text and is not clickable.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this.state.disabled;
      }

      set disabled(value) {
        this.state.disabled = normalizeBoolean(value);
      }

      /**
       * Displays a static map of the location using Google Maps. This value defaults to false.
       * @default false
       */
      get showStaticMap() {
        return this._showStaticMap || false;
      }

      set showStaticMap(value) {
        this._showStaticMap = normalizeBoolean(value);
      }
      /**
       * Workaround for LWC Issue #1028
       * https://github.com/salesforce/lwc/issues/1028
       *
       * When we have two nested conditional templates wrapping
       * an iteration template, LWC fails to clear the template's content
       */


      get showPlainText() {
        return this.hasValue && this.isPlainText;
      }

      get showMapLink() {
        return this.hasValue && this.isMapLink;
      }

      get isPlainText() {
        return this.disabled;
      }

      get isMapLink() {
        return !this.disabled;
      }

      get hasValue() {
        return !!(this.street || this.city || this.province || this.country || this.postalCode);
      }

      get address() {
        const [langCode, countryCode] = getLocaleTag().split('-');
        return address.formatAddressAllFields(langCode, countryCode, {
          address: this.street,
          city: this.city,
          state: this.province,
          country: this.country,
          zipCode: this.postalCode
        }) || '';
      }

      get addressLines() {
        return this.address.split('\n');
      }

      get mapQuery() {
        const {
          address: address$$1,
          latitude,
          longitude
        } = this;
        return latitude && longitude ? `${latitude},${longitude}` : address$$1;
      }

      get internalTabIndex() {
        return this.getAttribute('tabindex');
      }

      updateLinkInfo() {
        // The link is always external and should always open in a new tab, we should remove the use of
        // the routing service here
        if (this.connected) {
          this.state.mapUrl = encodeURI(MAP_HOST + this.mapQuery);
          updateRawLinkInfo(this, {
            url: this.state.mapUrl
          }).then(linkInfo => {
            this.state.mapUrl = linkInfo.url;
            this.dispatcher = linkInfo.dispatcher;
          });
        }
      }

      handleClick(event) {
        this.dispatcher(event);
      }

    }

    lwc.registerDecorators(LightningFormattedAddress, {
      publicProps: {
        street: {
          config: 3
        },
        city: {
          config: 3
        },
        province: {
          config: 3
        },
        country: {
          config: 3
        },
        postalCode: {
          config: 3
        },
        latitude: {
          config: 3
        },
        longitude: {
          config: 3
        },
        disabled: {
          config: 3
        },
        showStaticMap: {
          config: 3
        }
      },
      track: {
        state: 1,
        _showStaticMap: 1
      }
    });

    var _lightningFormattedAddress = lwc.registerComponent(LightningFormattedAddress, {
      tmpl: _tmpl$Q
    });

    function tmpl$V($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element,
        c: api_custom_element,
        s: api_slot
      } = $api;
      return [$cmp.showLabel ? api_element("span", {
        classMap: {
          "slds-form-element__label": true
        },
        key: 3
      }, [api_dynamic($cmp.fieldLabel)]) : null, $cmp.showLabel ? $cmp.showInlineHelpText ? api_custom_element("lightning-helptext", _lightningHelptext, {
        props: {
          "content": $cmp.inlineHelpText
        },
        key: 4
      }, []) : null : null, api_element("div", {
        classMap: {
          "slds-form-element__control": true
        },
        key: 5
      }, [$cmp.isTypeReference ? api_custom_element("lightning-formatted-lookup", _lightningFormattedLookup, {
        className: $cmp.computedFieldClass,
        props: {
          "recordId": $cmp.value,
          "displayValue": $cmp.displayValue
        },
        key: 6
      }, []) : null, $cmp.isTypeBoolean ? api_custom_element("lightning-input", _lightningInput, {
        className: $cmp.computedFieldClass,
        props: {
          "name": $cmp._fieldName,
          "type": "checkbox",
          "disabled": true,
          "variant": "label-hidden",
          "checked": $cmp.value,
          "label": $cmp.fieldLabel
        },
        key: 7
      }, []) : null, $cmp.isTypeCurrency ? api_custom_element("lightning-formatted-text", _lightningFormattedText, {
        className: $cmp.computedFieldClass,
        props: {
          "value": $cmp.displayValue
        },
        key: 8
      }, []) : null, $cmp.isTypeDate ? api_custom_element("lightning-formatted-text", _lightningFormattedText, {
        className: $cmp.computedFieldClass,
        props: {
          "value": $cmp.displayValue
        },
        key: 9
      }, []) : null, $cmp.isTypeDateTime ? api_custom_element("lightning-formatted-text", _lightningFormattedText, {
        className: $cmp.computedFieldClass,
        props: {
          "value": $cmp.displayValue
        },
        key: 10
      }, []) : null, $cmp.isTypeEmail ? api_custom_element("lightning-formatted-email", _lightningFormattedEmail, {
        className: $cmp.computedFieldClass,
        props: {
          "value": $cmp.value
        },
        key: 11
      }, []) : null, $cmp.isTypeLocation ? api_custom_element("lightning-formatted-location", _lightningFormattedLocation, {
        className: $cmp.computedFieldClass,
        props: {
          "latitude": $cmp.latitude,
          "longitude": $cmp.longitude
        },
        key: 12
      }, []) : null, $cmp.isTypeInt ? api_custom_element("lightning-formatted-number", _lightningFormattedNumber, {
        className: $cmp.computedFieldClass,
        props: {
          "formatStyle": "decimal",
          "value": $cmp.value
        },
        key: 13
      }, []) : null, $cmp.isTypeDouble ? api_custom_element("lightning-formatted-number", _lightningFormattedNumber, {
        className: $cmp.computedFieldClass,
        props: {
          "formatStyle": "decimal",
          "value": $cmp.value,
          "minimumFractionDigits": $cmp.scale,
          "maximumFractionDigits": $cmp.scale
        },
        key: 14
      }, []) : null, $cmp.isTypePercent ? api_custom_element("lightning-formatted-number", _lightningFormattedNumber, {
        className: $cmp.fieldClass,
        props: {
          "formatStyle": "percent-fixed",
          "value": $cmp.value,
          "minimumFractionDigits": $cmp.scale,
          "maximumFractionDigits": $cmp.scale
        },
        key: 15
      }, []) : null, $cmp.isTypePhone ? api_custom_element("lightning-formatted-phone", _lightningFormattedPhone, {
        className: $cmp.computedFieldClass,
        props: {
          "value": $cmp.value
        },
        key: 16
      }, []) : null, $cmp.isTypePicklist ? api_custom_element("lightning-formatted-text", _lightningFormattedText, {
        className: $cmp.computedFieldClass,
        props: {
          "value": $cmp.displayValue
        },
        key: 17
      }, []) : null, $cmp.isTypeMultiPicklist ? api_custom_element("lightning-formatted-text", _lightningFormattedText, {
        className: $cmp.computedFieldClass,
        props: {
          "value": $cmp.displayValue
        },
        key: 18
      }, []) : null, $cmp.isTypeString ? api_custom_element("lightning-formatted-text", _lightningFormattedText, {
        className: $cmp.computedFieldClass,
        props: {
          "value": $cmp.value
        },
        key: 19
      }, []) : null, $cmp.isTypeTextArea ? api_custom_element("lightning-formatted-text", _lightningFormattedText, {
        className: $cmp.computedFieldClass,
        props: {
          "linkify": "true",
          "value": $cmp.value
        },
        key: 20
      }, []) : null, $cmp.isTypeRichText ? api_custom_element("lightning-formatted-rich-text", _lightningFormattedRichText, {
        className: $cmp.computedFieldClass,
        props: {
          "value": $cmp.value
        },
        key: 21
      }, []) : null, $cmp.isTypeEncryptedString ? api_custom_element("lightning-formatted-text", _lightningFormattedText, {
        className: $cmp.computedFieldClass,
        props: {
          "value": $cmp.value
        },
        key: 22
      }, []) : null, $cmp.isTypeUrl ? api_custom_element("lightning-formatted-url", _lightningFormattedUrl, {
        className: $cmp.computedFieldClass,
        props: {
          "label": $cmp.displayValue,
          "value": $cmp.value
        },
        key: 23
      }, []) : null, $cmp.isTypeName ? api_custom_element("lightning-formatted-name", _lightningFormattedName, {
        className: $cmp.computedFieldClass,
        props: {
          "salutation": $cmp.value.Salutation,
          "firstName": $cmp.value.FirstName,
          "lastName": $cmp.value.LastName,
          "middleName": $cmp.value.MiddleName,
          "suffix": $cmp.value.Suffix,
          "informalName": $cmp.value.InformalName
        },
        key: 24
      }, []) : null, $cmp.isTypeAddress ? api_custom_element("lightning-formatted-address", _lightningFormattedAddress, {
        className: $cmp.computedFieldClass,
        props: {
          "street": $cmp.value.Street,
          "city": $cmp.value.City,
          "country": $cmp.value.Country,
          "province": $cmp.value.State,
          "postalCode": $cmp.value.PostalCode
        },
        key: 25
      }, []) : null, api_slot("", {
        key: 26
      }, [], $slotset)])];
    }

    var _tmpl$R = lwc.registerTemplate(tmpl$V);
    tmpl$V.slots = [""];
    tmpl$V.stylesheets = [];

    if (_implicitStylesheets$j) {
      tmpl$V.stylesheets.push.apply(tmpl$V.stylesheets, _implicitStylesheets$j);
    }
    tmpl$V.stylesheetTokens = {
      hostAttribute: "lightning-outputField_outputField-host",
      shadowAttribute: "lightning-outputField_outputField"
    };

    const STATE_FIELD = 'State';
    const COUNTRY_FIELD = 'Country';
    const STATE_CODE_FIELD = 'StateCode';
    const COUNTRY_CODE_FIELD = 'CountryCode';
    const SLDS_FIELD_CLASS = 'slds-form-element__static';
    /**
     * Represents a read-only display of a label, help text, and value for a field on a Salesforce object.
     */

    class LightningOutputField extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.computedFieldClass = SLDS_FIELD_CLASS;
        this._fieldName = void 0;
        this._rawFieldName = void 0;
        this._labelAlignment = 'stacked';
        this._variant = void 0;
        this.uiField = {};
      }

      set fieldClass(val) {
        this.computedFieldClass = `${val} ${SLDS_FIELD_CLASS}`;
      }
      /**
       * A CSS class for the outer element, in addition to the component's base classes.
       * @type {string}
       */


      get fieldClass() {
        return this.computedFieldClass;
      }
      /**
       * Changes the appearance of the output. Accepted variants
       * include standard and label-hidden. This value defaults to standard.
       * @type {string}
       * @default standard
       */


      get variant() {
        return this._variant || VARIANT.STANDARD;
      }

      set variant(value) {
        this._variant = normalizeVariant$1(value);
      }

      set fieldName(value) {
        this._rawFieldName = value;
        this._fieldName = value.fieldApiName ? value.fieldApiName : value;
      }
      /**
       * The API name of the field to be displayed.
       * @type {string}
       */


      get fieldName() {
        return this._fieldName;
      }

      setReady() {
        // if no good data ever arrives the empty field stays hidden
        this.classList.remove('slds-hide');
      }

      connectedCallback() {
        this.classList.add('slds-form-element', 'slds-hide');
        this.updateClassList();
      }

      updateClassList() {
        classListMutation(this.classList, {
          'slds-form-element_stacked': this._labelAlignment === 'stacked',
          'slds-form-element_horizontal': this._labelAlignment === 'horizontal'
        });
      }

      renderedCallback() {
        // Fire event to notify containers if we haven't gotten uiField yet
        if (!this.uiField.type) {
          this.dispatchEvent( // eslint-disable-next-line lightning-global/no-custom-event-bubbling
          new CustomEvent('registeroutputfield', {
            bubbles: true,
            composed: true,
            cancelable: true
          }));
        }
      }

      updateFieldInfo(record, objectInfo) {
        try {
          const fieldData = getUiField(this.fieldName, record, objectInfo);
          this.uiField = fieldData;
        } catch (e) {
          console.warn(e); // eslint-disable-line no-console

          return;
        }

        this.setReady();
      }
      /**
       * Reserved for internal use.
       * @param {object} data The record and objectInfo data
       */


      wireRecordUi(data) {
        if (this._rawFieldName && data.objectInfo && this._rawFieldName.objectApiName && this._rawFieldName.objectApiName !== data.objectInfo.apiName) {
          throw new Error(`objectApiName (${this._rawFieldName.objectApiName}) for field ${this.fieldName} does not match the objectApiName provided for the form (${data.objectInfo.apiName}).`);
        }

        this.updateFieldInfo(data.record, data.objectInfo);
        this.isCompoundField = isCompoundField(this.fieldName, data.objectInfo, isPersonAccount(data.record));
        this._labelAlignment = data.labelAlignment ? data.labelAlignment : 'stacked';
        this.updateClassList();
      }
      /** Value Getters **/


      get showLabel() {
        return this.variant !== VARIANT.LABEL_HIDDEN;
      }

      get showInlineHelpText() {
        return this.inlineHelpText && this.inlineHelpText.trim() !== '';
      }

      get fieldLabel() {
        return this.uiField.label;
      }

      get displayValue() {
        return this.uiField.displayValue;
      }

      get value() {
        if (this.isTypeAddress) {
          return this.normalizeAddressValue(this.uiField.value);
        }

        return this.uiField.value;
      }

      get scale() {
        return this.uiField.scale;
      }

      get latitude() {
        return this.uiField.value.latitude;
      }

      get longitude() {
        return this.uiField.value.longitude;
      }

      get inlineHelpText() {
        return this.uiField.inlineHelpText;
      } // Temporary until formatted-date-time is able to accept date time string formats


      get dateValue() {
        const date = new Date(this.uiField.value);
        return date.getTime();
      }
      /** Type resolution getters **/


      get isTypeString() {
        return Fields.STRING === this.uiField.type && !this.uiField.htmlFormatted && !this.isCompoundField;
      }

      get isTypeReference() {
        return Fields.REFERENCE === this.uiField.type;
      }

      get isTypeBoolean() {
        return Fields.BOOLEAN === this.uiField.type;
      }

      get isTypeCurrency() {
        return Fields.CURRENCY === this.uiField.type;
      }

      get isTypeDate() {
        return Fields.DATE === this.uiField.type;
      }

      get isTypeDateTime() {
        return Fields.DATETIME === this.uiField.type;
      }

      get isTypeEmail() {
        return Fields.EMAIL === this.uiField.type;
      }

      get isTypeLocation() {
        return Fields.LOCATION === this.uiField.type;
      }

      get isTypeInt() {
        return Fields.INT === this.uiField.type;
      }

      get isTypeDouble() {
        return Fields.DOUBLE === this.uiField.type;
      }

      get isTypePercent() {
        return Fields.PERCENT === this.uiField.type;
      }

      get isTypePhone() {
        return Fields.PHONE === this.uiField.type;
      }

      get isTypePicklist() {
        return Fields.PICKLIST === this.uiField.type;
      }

      get isTypeMultiPicklist() {
        return Fields.MULTI_PICKLIST === this.uiField.type;
      }

      get isTypeTextArea() {
        return Fields.TEXTAREA === this.uiField.type && Fields.PLAIN_TEXTAREA === this.uiField.extraTypeInfo && !this.uiField.htmlFormatted;
      }

      get isTypeRichText() {
        return Fields.TEXTAREA === this.uiField.type && Fields.RICH_TEXTAREA === this.uiField.extraTypeInfo || Fields.STRING === this.uiField.type && this.uiField.htmlFormatted;
      }

      get isTypeEncryptedString() {
        return Fields.ENCRYPTED_STRING === this.uiField.type;
      }

      get isTypeUrl() {
        return this.uiField.type === Fields.URL;
      }

      get isTypeName() {
        return this.isCompoundField && (Fields.PERSON_NAME === this.uiField.extraTypeInfo || Fields.SWITCHABLE_PERSON_NAME === this.uiField.extraTypeInfo);
      }

      get isTypeAddress() {
        return this.uiField.compound && Fields.ADDRESS === this.uiField.type;
      }

      getStateCountryValue(fieldName) {
        const fieldCodeValue = this.uiField.value[`${fieldName}Code`]; // if stateCode and countryCode values present use that,
        // rather than raw value

        const fieldValue = fieldCodeValue ? fieldCodeValue : this.uiField.value[fieldName];
        return fieldValue;
      }

      normalizeAddressValue(value) {
        const prefix = this.getFieldPrefix();
        return Object.keys(value).reduce((ret, rawKey) => {
          const key = this.removePrefix(rawKey, prefix);

          if (key === STATE_FIELD || key === STATE_CODE_FIELD) {
            ret[STATE_FIELD] = this.getStateCountryValue(rawKey);
          } else if (key === COUNTRY_FIELD || key === COUNTRY_CODE_FIELD) {
            ret[COUNTRY_FIELD] = this.getStateCountryValue(rawKey);
          } else {
            ret[key] = value[rawKey];
          }

          return ret;
        }, {});
      }

      getFieldPrefix() {
        if (!this.fieldPrefix) {
          this.fieldPrefix = this.fieldName.split(/Address$/)[0];
        }

        return this.fieldPrefix;
      }

      removePrefix(str, prefix) {
        return prefix ? str.replace(prefix, '') : str;
      }

    }

    lwc.registerDecorators(LightningOutputField, {
      publicProps: {
        fieldClass: {
          config: 3
        },
        variant: {
          config: 3
        },
        fieldName: {
          config: 3
        }
      },
      publicMethods: ["wireRecordUi"],
      track: {
        computedFieldClass: 1,
        _fieldName: 1,
        _variant: 1,
        uiField: 1
      }
    });

    var _lightningOutputField = lwc.registerComponent(LightningOutputField, {
      tmpl: _tmpl$R
    });

    function tmpl$W($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        b: api_bind,
        k: api_key,
        h: api_element,
        i: api_iterator,
        f: api_flatten
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5
      } = $ctx;
      return [api_custom_element("lightning-record-edit-form", _lightningRecordEditForm, {
        props: {
          "objectApiName": $cmp._objectApiName,
          "recordId": $cmp._recordId,
          "layoutType": $cmp._layout,
          "recordTypeId": $cmp.recordTypeId,
          "density": $cmp.density
        },
        key: 2,
        on: {
          "load": _m2 || ($ctx._m2 = api_bind($cmp.handleLoad)),
          "submit": _m3 || ($ctx._m3 = api_bind($cmp.handleSubmit)),
          "success": _m4 || ($ctx._m4 = api_bind($cmp.handleSuccess)),
          "error": _m5 || ($ctx._m5 = api_bind($cmp.handleError))
        }
      }, [api_element("div", {
        classMap: {
          "slds-form": true
        },
        attrs: {
          "role": "list"
        },
        key: 3
      }, [api_custom_element("lightning-messages", _lightningMessages, {
        key: 4
      }, []), api_element("div", {
        classMap: {
          "slds-is-relative": true,
          "record-form-spinner-holder": true
        },
        key: 5
      }, api_flatten([$cmp._loading ? api_custom_element("lightning-spinner", _lightningSpinner, {
        props: {
          "alternativeText": $cmp._labelLoading
        },
        key: 6
      }, []) : null, api_iterator($cmp._rows, function (row) {
        return api_element("div", {
          classMap: {
            "slds-grid": true,
            "slds-gutters_small": true
          },
          key: api_key(8, row.key)
        }, api_iterator(row.fields, function (field) {
          return api_element("div", {
            classMap: {
              "slds-col": true,
              "slds-has-flexi-truncate": true
            },
            attrs: {
              "role": "listitem"
            },
            key: api_key(10, field.field)
          }, [$cmp._editMode ? api_custom_element("lightning-input-field", _lightningInputField, {
            className: $cmp.computedInputClass,
            props: {
              "fieldName": field.field
            },
            key: 12
          }, []) : null, $cmp._viewMode ? api_custom_element("lightning-output-field", _lightningOutputField, {
            className: $cmp.computedOutputClass,
            props: {
              "fieldClass": "slds-border_bottom",
              "fieldName": field.field
            },
            key: api_key(14, field.field)
          }, [field.editable ? api_custom_element("lightning-button-icon", _lightningButtonIcon, {
            props: {
              "iconClass": "slds-button__icon_hint",
              "iconName": "utility:edit",
              "variant": "bare"
            },
            key: 15,
            on: {
              "click": _m0 || ($ctx._m0 = api_bind($cmp.toggleEdit))
            }
          }, []) : null]) : null]);
        }));
      })])), $cmp._editMode ? api_element("div", {
        classMap: {
          "slds-align_absolute-center": true,
          "slds-p-around_medium": true
        },
        key: 17
      }, [api_custom_element("lightning-button", _lightningButton, {
        classMap: {
          "slds-m-around_xx-small": true,
          "lightning-record-form-cancel": true
        },
        props: {
          "name": "cancel",
          "label": $cmp._labelCancel
        },
        key: 18,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleCancel))
        }
      }, []), api_custom_element("lightning-button", _lightningButton, {
        classMap: {
          "slds-m-around_xx-small": true,
          "lightning-record-form-submit": true
        },
        props: {
          "type": "submit",
          "name": "submit",
          "variant": "brand",
          "label": $cmp._labelSave
        },
        key: 19
      }, [])]) : null])])];
    }

    var _tmpl$S = lwc.registerTemplate(tmpl$W);
    tmpl$W.stylesheets = [];

    if (_implicitStylesheets$1) {
      tmpl$W.stylesheets.push.apply(tmpl$W.stylesheets, _implicitStylesheets$1);
    }
    tmpl$W.stylesheetTokens = {
      hostAttribute: "lightning-recordForm_recordForm-host",
      shadowAttribute: "lightning-recordForm_recordForm"
    };

    var labelSave = 'Save';

    var labelCancel = 'Cancel';

    var labelLoading = 'Loading';

    const EDIT_MODE = 'edit';
    const VIEW_MODE = 'view';
    const READ_ONLY_MODE = 'readonly';

    function isUnsupportedReferenceField$1(name) {
      return UNSUPPORTED_REFERENCE_FIELDS.indexOf(name) !== -1;
    }

    function extractLayoutFromLayouts(layouts, apiName, layout) {
      const layoutId = Object.keys(layouts[apiName])[0];

      if (layoutId && layouts[apiName] && layouts[apiName][layoutId] && layouts[apiName][layoutId][layout] && layouts[apiName][layoutId][layout].View) {
        return layouts[apiName][layoutId][layout].View;
      }

      return null;
    }
    /**
     * Creates an editable form or display form for a record.
     */


    class LightningRecordForm extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.readOnly = false;
        this._recordId = void 0;
        this._objectApiName = void 0;
        this._fields = [];
        this._editMode = false;
        this.cols = 1;
        this._loading = true;
        this.fieldsReady = false;
        this.recordTypeId = void 0;
        this._firstLoad = true;
        this._loadError = false;
        this._layout = void 0;
        this._dupMapper = {};
        this._mode = void 0;
        this._labelSave = labelSave;
        this._labelCancel = labelCancel;
        this._labelLoading = labelLoading;
        this._loadedPending = false;
        this._rawFields = void 0;
        this._density = densityValues.AUTO;
      }

      set mode(val) {
        val = val.toLowerCase(); // just to make it easier for customers

        this._mode = val;

        switch (val) {
          case EDIT_MODE:
            this.readOnly = false;
            this._editMode = true;
            break;

          case VIEW_MODE:
            this.readOnly = false;
            this._editMode = false;
            break;

          case READ_ONLY_MODE:
            this.readOnly = true;
            this._editMode = false;
            break;

          default:
            this.readOnly = false;

            if (!this._recordId) {
              this._editMode = true;
            } else {
              this._editMode = false;
            }

        }
      }
      /**
       * Specifies the interaction and display style for the form.
       * Possible values: view, edit, readonly.
       * If a record ID is not provided, the default mode is edit, which displays a form to create new records.
       * If a record ID is provided, the default mode is view, which displays field values with edit icons on updateable fields.
       * @type {string}
       */


      get mode() {
        return this._mode;
      }

      set layoutType(val) {
        if (val.match(/Full|Compact/)) {
          this._layout = val;
        } else {
          throw new Error(`Invalid layout "${val}". Layout must be "Full" or "Compact"`);
        }
      }
      /**
       * The type of layout to use to display the form fields. Possible values: Compact, Full.
       * When creating a new record, only the full layout is supported.
       * @type {string}
       */


      get layoutType() {
        return this._layout;
      }
      /**
       * Sets the arrangement style of fields and labels in the form.
       * Accepted values are compact, comfy, and auto (default).
       * Use compact to display fields and their labels on the same line.
       * Use comfy to display fields below their labels.
       * Use auto to let the component dynamically set
       * the density according to the user's Display Density setting
       * and the width of the form.
       * @type {string}
       */


      get density() {
        return this._density;
      }

      set density(val) {
        this._density = normalizeString(val, {
          fallbackValue: densityValues.AUTO,
          validValues: [densityValues.AUTO, densityValues.COMPACT, densityValues.COMFY]
        });
      }

      set recordId(val) {
        if (!val && !this._mode) {
          this._editMode = true;
        }

        this._recordId = val;
      }
      /**
       * The ID of the record to be displayed.
       * @type {string}
       *
       */


      get recordId() {
        return this._recordId;
      }

      set objectApiName(val) {
        this._objectApiName = val;
      }
      /**
       * The API name of the object.
       * @type {string}
       * @required
       */


      get objectApiName() {
        return this._objectApiName;
      }

      set columns(val) {
        // cols must always be a positive integer
        this.cols = parseInt(val, 10);

        if (isNaN(this.cols) || this.cols < 1) {
          this.cols = 1;
        }
      }
      /**
       * Specifies the number of columns for the form.
       * @type {number}
       */


      get columns() {
        return this.cols;
      }
      /**
       * Submits the form using an array of record fields or field IDs.
       * The field ID is provisioned from @salesforce/schema/.
       * Invoke this method only after the load event.
       * @param {string[]|FieldId[]} fields - Array of record field names or field IDs.
       */


      submit(fields) {
        this.template.querySelector('lightning-record-edit-form').submit(fields);
      } // fast de-dupe because Set polyfill is not great


      addField(val) {
        // duck type reference objects
        const fieldName = val.fieldApiName ? val.fieldApiName : val;

        if (!this._dupMapper[fieldName]) {
          this._fields.push(fieldName);

          this._dupMapper[fieldName] = true;
        }
      }
      /*
       * Retrieves a layout from the cache. If it doesn't exist in the cache it will retrieve it from the server and put it into the cache.
       * @param objectApiName: string - The object api name of the layout to retrieve.
       * @param layoutType: string - The layout type of the layout to retrieve.
       * @param mode: string - The mode of the layout to retrieve.
       * @param recordTypeId: string - The record type id of the layout to retrieve.
       * @returns {Object} The observable used to get the value and keep watch on it for changes.
       */


      connectedCallback() {
        if (!this._recordId && !this._mode) {
          this._editMode = true;
        }
      }

      set fields(val) {
        this.fieldsReady = true;

        if (Array.isArray(val)) {
          for (let i = 0; i < val.length; i++) {
            this.addField(val[i]);
          }
        } else {
          this.addField(val);
        }
      }
      /**
       * List of fields to be displayed. The fields display in the order you list them.
       * @type {string[]}
       */


      get fields() {
        return this._rawFields;
      }

      get _editable() {
        return !this._loading && !this.readOnly && !this._loadError;
      }

      get _viewMode() {
        return !this._editMode;
      }

      set _viewMode(val) {
        this._editMode = !val;
      }

      get _rows() {
        const out = [];
        const rowLength = this.cols;

        const fields = this._fields.slice();

        let rowkey = 0;
        let thisRow = {
          fields: [],
          key: rowkey
        };

        while (fields.length > 0) {
          if (thisRow.fields.length < rowLength) {
            const field = fields.shift();
            thisRow.fields.push({
              field,
              editable: !isUnsupportedReferenceField$1(field) && this._editable && (this._objectInfo ? this._objectInfo.fields[field].updateable : false)
            });
          } else {
            out.push(thisRow);
            thisRow = {
              fields: [],
              key: ++rowkey
            };
          }
        }

        if (thisRow.fields.length) {
          out.push(thisRow);
        }

        return out;
      }

      get computedInputClass() {
        if (this.cols === 1) {
          return 'slds-form-element_1-col';
        }

        return '';
      }

      get computedOutputClass() {
        const classnames = classSet('slds-form-element_small slds-form-element_edit slds-hint-parent');
        return classnames.add({
          'slds-form-element_1-col': this.cols === 1
        }).toString();
      }

      toggleEdit(e) {
        if (e) {
          e.stopPropagation();
        }

        this._editMode = !this._editMode;
      }

      handleLoad(e) {
        e.stopPropagation();
        let fields;
        const apiName = this._objectApiName.objectApiName ? this._objectApiName.objectApiName : this._objectApiName;

        if (this._layout && e.detail.objectInfos) {
          if (e.detail.layout) {
            fields = getFieldsForLayout(e.detail.layout, e.detail.objectInfos[apiName]);
          } else if (e.detail.layouts) {
            const layout = extractLayoutFromLayouts(e.detail.layouts, apiName, this._layout);

            if (layout) {
              fields = getFieldsForLayout(layout, e.detail.objectInfos[apiName]);
            }
          }
        }

        if (fields) {
          // Fields is populated from event data (e.detail.objectInfos), which is wrapped inside
          // of a shadow dom membrane. In order to set fields into
          // this.fields, which is a reactive membrane, fields has to first
          // be unwrapped to avoid issues of discontinuity
          this.fields = lwc.unwrap(fields);
        }

        if (this._firstLoad) {
          this._loading = false;
          this._firstLoad = false;
        } // This timeout is so that the edit buttons
        // don't appear before the fields,
        // this tails the render if loading until later


        if (this._loadedPending) {
          // eslint-disable-next-line lwc/no-set-timeout
          setTimeout(() => {
            this._loading = false;
            this._loadedPending = false;
          }, 0);
        }

        this._objectInfo = lwc.unwrap(e.detail.objectInfos[this._objectApiName]);
        this.dispatchEvent(new CustomEvent('load', {
          detail: e.detail
        }));
      }

      handleError(e) {
        e.stopPropagation();
        this._loading = false;

        if (this._firstLoad) {
          this._loadError = true;
        }

        this.dispatchEvent(new CustomEvent('error', {
          detail: e.detail
        }));
      }

      handleSubmit(e) {
        // eslint-disable-next-line lwc/no-set-timeout
        setTimeout(() => {
          // The user may have canceled the submit.
          // For example to do some validation prior to submitting the form. See W-5472812
          this._loading = !e.defaultPrevented;
        }, 0);
      }

      clearForm() {
        const inputFields = this.template.querySelectorAll('lightning-input-field');

        if (inputFields) {
          inputFields.forEach(field => {
            field.reset();
          });
        }
      }

      handleCancel(e) {
        if (this._recordId) {
          this.toggleEdit(e);
        } else {
          this.clearForm();
        } // clear any existing errors


        this.template.querySelector('lightning-messages').setError(null);
        this.dispatchEvent(new CustomEvent('cancel'));
      }

      handleSuccess(e) {
        e.stopPropagation();
        this._loadedPending = true;
        this._editMode = false;
        this.recordId = e.detail.id;
        this.dispatchEvent(new CustomEvent('success', {
          detail: e.detail
        }));
      }

    }

    lwc.registerDecorators(LightningRecordForm, {
      publicProps: {
        recordTypeId: {
          config: 0
        },
        mode: {
          config: 3
        },
        layoutType: {
          config: 3
        },
        density: {
          config: 3
        },
        recordId: {
          config: 3
        },
        objectApiName: {
          config: 3
        },
        columns: {
          config: 3
        },
        fields: {
          config: 3
        }
      },
      publicMethods: ["submit"],
      track: {
        readOnly: 1,
        _recordId: 1,
        _objectApiName: 1,
        _fields: 1,
        _editMode: 1,
        cols: 1,
        _loading: 1,
        fieldsReady: 1,
        _density: 1
      }
    });

    var _lightningRecordForm = lwc.registerComponent(LightningRecordForm, {
      tmpl: _tmpl$S
    });

    function tmpl$X($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        s: api_slot
      } = $api;
      return [$cmp.required ? api_element("abbr", {
        classMap: {
          "slds-required": true,
          "slds-col": true,
          "slds-grow-none": true,
          "slds-m-right_xx-small": true
        },
        attrs: {
          "aria-hidden": "true"
        },
        key: 3
      }, [api_text("*")]) : null, api_slot("", {
        key: 4
      }, [], $slotset)];
    }

    var _tmpl$T = lwc.registerTemplate(tmpl$X);
    tmpl$X.slots = [""];
    tmpl$X.stylesheets = [];
    tmpl$X.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditInputWrapper_primitiveDatatableIeditInputWrapper-host",
      shadowAttribute: "lightning-primitiveDatatableIeditInputWrapper_primitiveDatatableIeditInputWrapper"
    };

    /**
     * @TODO: This component should be removed once the issue with label is solved in SLDS or IO
     */

    class LightningPrimitiveDatatableIeditInputWrapper extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.required = void 0;
      }

    }

    lwc.registerDecorators(LightningPrimitiveDatatableIeditInputWrapper, {
      publicProps: {
        required: {
          config: 0
        }
      }
    });

    var _lightningPrimitiveDatatableIeditInputWrapper = lwc.registerComponent(LightningPrimitiveDatatableIeditInputWrapper, {
      tmpl: _tmpl$T
    });

    function tmpl$Y($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "required": $cmp.required,
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-text",
          "variant": "label-hidden",
          "value": $cmp.editedValue
        },
        key: 2
      }, [])];
    }

    var TextTpl = lwc.registerTemplate(tmpl$Y);
    tmpl$Y.stylesheets = [];
    tmpl$Y.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_text-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_text"
    };

    function tmpl$Z($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "required": $cmp.required,
          "type": "tel",
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-phone",
          "variant": "label-hidden",
          "value": $cmp.editedValue
        },
        key: 2
      }, [])];
    }

    var PhoneTpl = lwc.registerTemplate(tmpl$Z);
    tmpl$Z.stylesheets = [];
    tmpl$Z.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_phone-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_phone"
    };

    function tmpl$_($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "required": $cmp.required,
          "type": "email",
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-email",
          "variant": "label-hidden",
          "value": $cmp.editedValue
        },
        key: 2
      }, [])];
    }

    var EmailTpl = lwc.registerTemplate(tmpl$_);
    tmpl$_.stylesheets = [];
    tmpl$_.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_email-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_email"
    };

    function tmpl$10($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "required": $cmp.required,
          "type": "number",
          "formatter": "percent",
          "step": "0.01",
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-percent",
          "variant": "label-hidden",
          "value": $cmp.editedValue
        },
        key: 2
      }, [])];
    }

    var PercentTpl = lwc.registerTemplate(tmpl$10);
    tmpl$10.stylesheets = [];
    tmpl$10.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_percent-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_percent"
    };

    function tmpl$11($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "required": $cmp.required,
          "type": "url",
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-url",
          "variant": "label-hidden",
          "value": $cmp.editedValue
        },
        key: 2
      }, [])];
    }

    var UrlTpl = lwc.registerTemplate(tmpl$11);
    tmpl$11.stylesheets = [];
    tmpl$11.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_url-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_url"
    };

    function tmpl$12($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "required": $cmp.required,
          "type": "number",
          "formatter": "currency",
          "step": "0.01",
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-currency",
          "variant": "label-hidden",
          "value": $cmp.editedValue
        },
        key: 2
      }, [])];
    }

    var CurrencyTpl = lwc.registerTemplate(tmpl$12);
    tmpl$12.stylesheets = [];
    tmpl$12.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_currency-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_currency"
    };

    function tmpl$13($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "required": $cmp.required,
          "type": "number",
          "label": $cmp.columnLabel,
          "step": "any",
          "name": "dt-inline-edit-number",
          "variant": "label-hidden",
          "value": $cmp.editedValue
        },
        key: 2
      }, [])];
    }

    var NumberTpl = lwc.registerTemplate(tmpl$13);
    tmpl$13.stylesheets = [];
    tmpl$13.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_number-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_number"
    };

    function tmpl$14($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "required": $cmp.required,
          "type": "checkbox",
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-text",
          "checked": $cmp.editedValue
        },
        key: 2
      }, [])];
    }

    var BooleanTpl = lwc.registerTemplate(tmpl$14);
    tmpl$14.stylesheets = [];
    tmpl$14.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_boolean-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_boolean"
    };

    function tmpl$15($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        classMap: {
          "datatable-inline-edit": true
        },
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "type": "date",
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-dateLocal",
          "variant": "label-hidden",
          "value": $cmp.editedValue
        },
        key: 2
      }, [])];
    }

    var DateLocalTpl = lwc.registerTemplate(tmpl$15);
    tmpl$15.stylesheets = [];
    tmpl$15.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_dateLocal-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_dateLocal"
    };

    function tmpl$16($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-inputable": "true"
        },
        props: {
          "type": "datetime",
          "label": $cmp.columnLabel,
          "name": "dt-inline-edit-datetime",
          "variant": "label-hidden",
          "value": $cmp.editedDateValue
        },
        key: 2
      }, [])];
    }

    var DateTpl = lwc.registerTemplate(tmpl$16);
    tmpl$16.stylesheets = [];
    tmpl$16.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_date-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_date"
    };

    function tmpl$17($api, $cmp, $slotset, $ctx) {
      return [];
    }

    var DefaultTpl = lwc.registerTemplate(tmpl$17);
    tmpl$17.stylesheets = [];
    tmpl$17.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditTypeFactory_default-host",
      shadowAttribute: "lightning-primitiveDatatableIeditTypeFactory_default"
    };

    const TYPE_TPL_MAPPINGS = {
      text: TextTpl,
      phone: PhoneTpl,
      email: EmailTpl,
      percent: PercentTpl,
      url: UrlTpl,
      currency: CurrencyTpl,
      number: NumberTpl,
      boolean: BooleanTpl,
      'date-local': DateLocalTpl,
      date: DateTpl
    };
    const INVALID_TYPE_FOR_EDIT = 'column type not supported for inline edit';

    class LightningPrimitiveDatatableIeditTypeFactory extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.columnLabel = void 0;
        this.editedValue = void 0;
        this.required = void 0;
      }

      get columnDef() {
        return this._columnDef;
      }

      set columnDef(value) {
        assert(TYPE_TPL_MAPPINGS.hasOwnProperty(value.type), INVALID_TYPE_FOR_EDIT);
        this._columnDef = value;
        this.columnLabel = value.label;
      }

      get columnType() {
        return this._columnDef.type;
      }

      render() {
        return TYPE_TPL_MAPPINGS[this.columnType] || DefaultTpl;
      }

      connectedCallback() {
        this._blurHandler = this.handleComponentBlur.bind(this);
        this._focusHandler = this.handleComponentFocus.bind(this);
        this._changeHandler = this.handleComponentChange.bind(this);
      }

      renderedCallback() {
        this.concreteComponent.addEventListener('blur', this._blurHandler);
        this.concreteComponent.addEventListener('focus', this._focusHandler);
        this.concreteComponent.addEventListener('change', this._changeHandler);
      }

      get concreteComponent() {
        return this.template.querySelector('[data-inputable="true"]');
      }

      focus() {
        if (this.concreteComponent) {
          this.concreteComponent.focus();
        }
      }

      get value() {
        if (this.columnDef.type === 'boolean') {
          return this.concreteComponent.checked;
        }

        return this.concreteComponent.value;
      }

      get validity() {
        return this.concreteComponent.validity;
      }

      showHelpMessageIfInvalid() {
        this.concreteComponent.showHelpMessageIfInvalid();
      }

      get editedDateValue() {
        const dateValue = new Date(this.editedValue);

        if (this.editedValue === null || isNaN(dateValue.getTime())) {
          return '';
        }

        return dateValue.toISOString();
      }

      handleComponentFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handleComponentBlur() {
        this.dispatchEvent(new CustomEvent('blur'));
      }

      handleComponentChange() {
        this.showHelpMessageIfInvalid();
      }

    }

    lwc.registerDecorators(LightningPrimitiveDatatableIeditTypeFactory, {
      publicProps: {
        editedValue: {
          config: 0
        },
        required: {
          config: 0
        },
        columnDef: {
          config: 3
        },
        value: {
          config: 1
        },
        validity: {
          config: 1
        }
      },
      publicMethods: ["focus", "showHelpMessageIfInvalid"],
      track: {
        columnLabel: 1
      }
    });

    var _lightningPrimitiveDatatableIeditTypeFactory = lwc.registerComponent(LightningPrimitiveDatatableIeditTypeFactory, {
      tmpl: _tmpl$1
    });

    function tmpl$18($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        h: api_element,
        k: api_key,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14,
        _m15,
        _m16
      } = $ctx;
      return [$cmp.visible ? api_element("section", {
        classMap: {
          "slds-popover": true,
          "slds-popover_edit": true
        },
        style: $cmp.computedStyle,
        attrs: {
          "role": "dialog",
          "tabindex": "-1"
        },
        key: 2,
        on: {
          "blur": _m14 || ($ctx._m14 = api_bind($cmp.handleTypeElemBlur)),
          "focus": _m15 || ($ctx._m15 = api_bind($cmp.handleTypeElemFocus)),
          "keydown": _m16 || ($ctx._m16 = api_bind($cmp.handleCellKeydown))
        }
      }, [api_element("span", {
        classMap: {
          "inline-edit-form-start": true
        },
        attrs: {
          "tabindex": "0"
        },
        key: 3,
        on: {
          "focus": _m0 || ($ctx._m0 = api_bind($cmp.handleFormStartFocus))
        }
      }, []), api_element("div", {
        classMap: {
          "slds-popover__body": true
        },
        key: 4
      }, [api_element("form", {
        props: {
          "noValidate": true
        },
        key: 5,
        on: {
          "submit": _m6 || ($ctx._m6 = api_bind($cmp.handleEditFormSubmit))
        }
      }, [api_custom_element("lightning-primitive-datatable-iedit-input-wrapper", _lightningPrimitiveDatatableIeditInputWrapper, {
        classMap: {
          "slds-grid": true,
          "slds-p-left_xx-small": true
        },
        props: {
          "required": $cmp.required
        },
        key: 6
      }, [api_custom_element("lightning-primitive-datatable-iedit-type-factory", _lightningPrimitiveDatatableIeditTypeFactory, {
        classMap: {
          "dt-type-edit-factory": true,
          "slds-col": true
        },
        props: {
          "required": $cmp.required,
          "columnDef": $cmp.columnDef,
          "editedValue": $cmp.editedValue
        },
        key: api_key(7, $cmp.inputKey),
        on: {
          "blur": _m1 || ($ctx._m1 = api_bind($cmp.handleTypeElemBlur)),
          "focus": _m2 || ($ctx._m2 = api_bind($cmp.handleTypeElemFocus))
        }
      }, [])]), $cmp.isMassEditEnabled ? api_custom_element("lightning-input", _lightningInput, {
        attrs: {
          "data-mass-selection": "true"
        },
        props: {
          "type": "checkbox",
          "name": "dt-iedit-mass-edit",
          "label": $cmp.massEditCheckboxLabel
        },
        key: 9,
        on: {
          "change": _m3 || ($ctx._m3 = api_bind($cmp.handleMassCheckboxChange)),
          "blur": _m4 || ($ctx._m4 = api_bind($cmp.handleTypeElemBlur)),
          "focus": _m5 || ($ctx._m5 = api_bind($cmp.handleTypeElemFocus))
        }
      }, []) : null, !$cmp.isMassEditEnabled ? api_element("button", {
        classMap: {
          "slds-hide": true
        },
        attrs: {
          "type": "submit",
          "aria-hidden": "true",
          "tabindex": "-1",
          "value": "save"
        },
        key: 11
      }, []) : null])]), $cmp.isMassEditEnabled ? api_element("div", {
        classMap: {
          "slds-popover__footer": true
        },
        key: 13
      }, [api_element("div", {
        classMap: {
          "slds-grid": true,
          "slds-grid_align-end": true
        },
        key: 14
      }, [api_custom_element("lightning-button", _lightningButton, {
        props: {
          "label": $cmp.cancelLabel
        },
        key: 15,
        on: {
          "blur": _m7 || ($ctx._m7 = api_bind($cmp.handleTypeElemBlur)),
          "focus": _m8 || ($ctx._m8 = api_bind($cmp.handleTypeElemFocus)),
          "click": _m9 || ($ctx._m9 = api_bind($cmp.cancelEdition))
        }
      }, []), api_custom_element("lightning-button", _lightningButton, {
        styleMap: {
          "marginLeft": ".25rem"
        },
        attrs: {
          "data-form-last-element": "true"
        },
        props: {
          "label": $cmp.applyLabel,
          "variant": "brand"
        },
        key: 16,
        on: {
          "blur": _m10 || ($ctx._m10 = api_bind($cmp.handleTypeElemBlur)),
          "focus": _m11 || ($ctx._m11 = api_bind($cmp.handleTypeElemFocus)),
          "click": _m12 || ($ctx._m12 = api_bind($cmp.processSubmission))
        }
      }, [])])]) : null, api_element("div", {
        classMap: {
          "inline-edit-form-end": true
        },
        attrs: {
          "tabindex": "0"
        },
        key: 17,
        on: {
          "focus": _m13 || ($ctx._m13 = api_bind($cmp.handleFormEndsFocus))
        }
      }, [])]) : null];
    }

    var _tmpl$U = lwc.registerTemplate(tmpl$18);
    tmpl$18.stylesheets = [];
    tmpl$18.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableIeditPanel_primitiveDatatableIeditPanel-host",
      shadowAttribute: "lightning-primitiveDatatableIeditPanel_primitiveDatatableIeditPanel"
    };

    var labelUpdateSelectedItems = 'Update {0} selected items';

    var labelCancel$1 = 'Cancel';

    var labelApply = 'Apply';

    const i18n$p = {
      updateSelectedItems: labelUpdateSelectedItems,
      cancel: labelCancel$1,
      apply: labelApply
    };

    class PrimitiveDatatableIeditPanel extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.visible = void 0;
        this.rowKeyValue = void 0;
        this.colKeyValue = void 0;
        this.editedValue = void 0;
        this.columnDef = void 0;
        this.isMassEditEnabled = false;
        this.numberOfSelectedRows = void 0;
      }

      connectedCallback() {
        this.interactingState = new InteractingState({
          duration: 10,
          debounceInteraction: true
        });
        this.interactingState.onleave(() => this.handlePanelLoosedFocus());
      }

      get computedStyle() {
        const styleHash = {
          'z-index': 1000,
          'background-color': 'white',
          'margin-top': '1px'
        };
        styleHash.display = this.visible ? 'block' : 'none';
        return Object.keys(styleHash).map(styleProp => `${styleProp}:${styleHash[styleProp]}`).join(';');
      }

      get inputKey() {
        return this.rowKeyValue + this.colKeyValue;
      }

      get massEditCheckboxLabel() {
        return this.formatString(i18n$p.updateSelectedItems, this.numberOfSelectedRows);
      }

      get applyLabel() {
        return i18n$p.apply;
      }

      get cancelLabel() {
        return i18n$p.cancel;
      }

      get required() {
        return this.columnDef.typeAttributes && this.columnDef.typeAttributes.required;
      }

      handleFormStartFocus() {
        this.interactingState.enter();

        if (this.isMassEditEnabled) {
          // on mass edit the panel dont loses the focus with the keyboard.
          this.focusLastElement();
        } else {
          this.triggerEditFinished({
            reason: 'tab-pressed-prev'
          });
        }
      }

      handleFormEndsFocus() {
        this.interactingState.enter();

        if (this.isMassEditEnabled) {
          // on mass edit the panel dont loses the focus with the keyboard.
          this.focus();
        } else {
          this.triggerEditFinished({
            reason: 'tab-pressed-next'
          });
        }
      }

      triggerEditFinished(detail) {
        detail.rowKeyValue = detail.rowKeyValue || this.rowKeyValue;
        detail.colKeyValue = detail.colKeyValue || this.colKeyValue;
        const event = new CustomEvent('ieditfinished', {
          detail
        });
        this.dispatchEvent(event);
      }

      focus() {
        const elem = this.inputableElement;
        this.interactingState.enter();

        if (elem) {
          elem.focus();
        }
      }

      get inputableElement() {
        return this.template.querySelector('.dt-type-edit-factory');
      }

      get value() {
        return this.inputableElement.value;
      }

      get validity() {
        return this.inputableElement.validity;
      }

      get isMassEditChecked() {
        return this.isMassEditEnabled && this.template.querySelector('[data-mass-selection="true"]').checked;
      }

      getPositionedElement() {
        return this.template.querySelector('section');
      }

      handleTypeElemBlur() {
        if (this.visible && !this.template.activeElement) {
          this.interactingState.leave();
        }
      }

      handleTypeElemFocus() {
        this.interactingState.enter();
      }

      handleEditFormSubmit(event) {
        event.preventDefault();
        event.stopPropagation();

        if (!this.isMassEditEnabled) {
          this.processSubmission();
        }

        return false;
      }

      handleCellKeydown(event) {
        const {
          keyCode
        } = event;

        if (keyCode === 27) {
          // Esc key
          event.stopPropagation();
          this.cancelEdition();
        }
      }

      handlePanelLoosedFocus() {
        if (this.visible) {
          this.triggerEditFinished({
            reason: 'loosed-focus'
          });
        }
      }

      formatString(str, ...args) {
        return str.replace(/{(\d+)}/g, (match, i) => {
          return args[i];
        });
      }

      focusLastElement() {
        this.template.querySelector('[data-form-last-element="true"]').focus();
      }

      processSubmission() {
        if (this.validity.valid) {
          this.triggerEditFinished({
            reason: 'submit-action'
          });
        } else {
          this.inputableElement.showHelpMessageIfInvalid();
        }
      }

      cancelEdition() {
        this.triggerEditFinished({
          reason: 'edit-canceled'
        });
      }

      handleMassCheckboxChange(event) {
        const customEvent = new CustomEvent('masscheckboxchange', {
          detail: {
            checked: event.detail.checked
          }
        });
        this.dispatchEvent(customEvent);
      }

    }

    lwc.registerDecorators(PrimitiveDatatableIeditPanel, {
      publicProps: {
        visible: {
          config: 0
        },
        rowKeyValue: {
          config: 0
        },
        colKeyValue: {
          config: 0
        },
        editedValue: {
          config: 0
        },
        columnDef: {
          config: 0
        },
        isMassEditEnabled: {
          config: 0
        },
        numberOfSelectedRows: {
          config: 0
        },
        value: {
          config: 1
        },
        validity: {
          config: 1
        },
        isMassEditChecked: {
          config: 1
        }
      },
      publicMethods: ["focus", "getPositionedElement"]
    });

    var _lightningPrimitiveDatatableIeditPanel = lwc.registerComponent(PrimitiveDatatableIeditPanel, {
      tmpl: _tmpl$U
    });

    var labelChooseARow = 'Choose a Row to Select';

    var labelSelectAll = 'Select All';

    var labelSort = 'Sort by:';

    var labelSortAsc = 'Sorted Ascending';

    var labelSortDesc = 'Sorted Descending';

    var labelSortNone = 'Sorted: None';

    function tmpl$19($api, $cmp, $slotset, $ctx) {
      return [];
    }

    var _tmpl$V = lwc.registerTemplate(tmpl$19);
    tmpl$19.stylesheets = [];
    tmpl$19.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableCell_primitiveDatatableCell-host",
      shadowAttribute: "lightning-primitiveDatatableCell_primitiveDatatableCell"
    };

    class PrimitiveDatatableCell extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.rowKeyValue = void 0;
        this.colKeyValue = void 0;
        this._hasFocus = 0;
        this.state = {
          mode: 'NAVIGATION',
          currentInputIndex: 0,
          internalTabIndex: -1
        };
      }

      get hasFocus() {
        return this._hasFocus;
      }

      get keyboardMode() {
        return this.state.mode;
      }

      set hasFocus(value) {
        this._hasFocus = value;

        if (value) {
          this.classList.add('slds-has-focus');
        } else {
          this.classList.remove('slds-has-focus');
        }
      }

      setMode(keyboardMode, info) {
        const normalizedInfo = info || {
          action: 'none'
        };
        this.state.mode = keyboardMode;

        if (keyboardMode === 'ACTION') {
          this.state.internalTabIndex = 0; // focus without changing tabindex doesnt work
          // eslint-disable-next-line lwc/no-set-timeout

          setTimeout(() => {
            this.setFocusToActionableElement(this.state.currentInputIndex);
          }, 0);
          const actionableElements = this.getActionableElements(); // check if we have an edit button first (tab should open the inline edit)

          if (normalizedInfo.action === 'tab') {
            let editActionElement = false;
            actionableElements.some(elem => {
              if (elem.getAttribute('data-action-edit')) {
                editActionElement = elem;
                return true;
              }

              return false;
            });

            if (editActionElement) {
              editActionElement.click();
            }
          } else if (actionableElements.length === 1) {
            const elem = actionableElements[0];
            let defaultActions = elem.getAttribute('data-action-triggers');
            defaultActions = defaultActions || '';

            if (defaultActions.indexOf(normalizedInfo.action) !== -1) {
              actionableElements[this.state.currentInputIndex].click();
            }
          }
        } else {
          this.state.internalTabIndex = -1;
        }
      }

      addFocusStyles() {
        this.classList.add('slds-has-focus');
      }

      removeFocusStyles(setTabIndex) {
        this.classList.remove('slds-has-focus');

        if (setTabIndex) {
          this.state.internalTabIndex = -1;
        }
      }

      resetCurrentInputIndex(direction) {
        switch (direction) {
          case -1:
            {
              const inputs = this.getActionableElements();
              this.state.currentInputIndex = inputs.length ? inputs.length - 1 : 0;
              break;
            }

          case 1:
          case 2:
            this.state.currentInputIndex = 0;
            break;

          default:
        }

        if (this.state.mode === 'ACTION') {
          this.setFocusToActionableElement(this.state.currentInputIndex);
        }
      }

      connectedCallback() {
        this.addEventListener('focus', this.handleFocus.bind(this));
        this.addEventListener('click', this.handleClick.bind(this));
        this.addEventListener('keydown', this.handleKeydown.bind(this));
      }

      get internalTabIndex() {
        return this.state.internalTabIndex;
      }

      get canMoveLeft() {
        return this.state.currentInputIndex > 0;
      }

      get canMoveRight() {
        return this.state.actionableElementsCount > 1 && this.state.currentInputIndex < this.state.actionableElementsCount - 1;
      }

      moveToNextActionableElement() {
        this.setFocusToActionableElement(this.state.currentInputIndex + 1);
      }

      moveToPrevActionableElement() {
        this.setFocusToActionableElement(this.state.currentInputIndex - 1);
      } // eslint-disable-next-line no-unused-vars


      handleClick(event) {
        this.addFocusStyles();
        this.fireCellFocusByClickEvent();
      }

      handleKeydown(event) {
        const {
          keyCode,
          shiftKey
        } = event;
        const {
          mode
        } = this.state;
        let passThroughEvent = keyCode !== keyCodes.shift; // if it is in Action mode, then traverse to the next or previous
        // focusable element.
        // if there is no focusable element, or reach outside of the range, then move to
        // previous or next cell.

        if (mode === 'ACTION') {
          switch (keyCode) {
            case keyCodes.left:
              if (this.canMoveLeft) {
                // there are still actionable element before the current one
                // move to the previous actionable element.
                event.preventDefault();
                this.moveToPrevActionableElement();
                passThroughEvent = false;
              }

              break;

            case keyCodes.right:
              if (this.canMoveRight) {
                // there are still actionable element before the current one
                // move to the previous actionable element.
                event.preventDefault();
                this.moveToNextActionableElement();
                passThroughEvent = false;
              }

              break;

            case keyCodes.tab:
              // if in action mode, try to navigate through the element inside
              // always prevent the default tab behavior
              // so that the tab will not focus outside of the table.
              if (shiftKey) {
                // moving to the left
                if (this.canMoveLeft) {
                  event.preventDefault();
                  this.moveToPrevActionableElement();
                  passThroughEvent = false;
                }
              } else {
                // moving to the right
                // eslint-disable-next-line no-lonely-if
                if (this.canMoveRight) {
                  event.preventDefault();
                  this.moveToNextActionableElement();
                  passThroughEvent = false;
                }
              }

              break;

            default:
          }
        } else if (mode === 'NAVIGATION') {
          // click the header, press enter, it does not go to action mode without this code.
          if (keyCode === keyCodes.left || keyCode === keyCodes.right || keyCode === keyCodes.up || keyCode === keyCodes.down || keyCode === keyCodes.enter) {
            this.fireCellKeydown(event);
          }
        }

        if (passThroughEvent && mode === 'ACTION') {
          this.fireCellKeydown(event);
        }
      }

      getActionableElements() {
        return Array.prototype.slice.call(this.template.querySelectorAll('[data-navigation="enable"]'));
      }

      get resizeElement() {
        return this.template.querySelector('.slds-resizable');
      }

      setFocusToActionableElement(activeInputIndex) {
        const actionableElements = this.getActionableElements();
        this.state.actionableElementsCount = actionableElements.length;

        if (actionableElements.length > 0) {
          if (activeInputIndex > 0 && activeInputIndex < actionableElements.length) {
            // try to locate to the previous active index of previous row.
            actionableElements[activeInputIndex].focus();
            this.state.currentInputIndex = activeInputIndex;
          } else {
            actionableElements[0].focus();
            this.state.currentInputIndex = 0;
          }
        } // TODO: Fire event back to the datatable, so that the activeInputIndex can be
        // stored in the datatable level state.  So that when user use up and down arrow to
        // navigate throught the datatable in ACTION mode, we can rememeber the active input position

      }

      handleFocus() {
        if (this.state.mode === 'ACTION') {
          this.setFocusToActionableElement(this.state.currentInputIndex);
        }
      }

      fireCellKeydown(keyEvent) {
        const {
          rowKeyValue,
          colKeyValue
        } = this;
        const {
          keyCode,
          shiftKey
        } = keyEvent;
        const event = new CustomEvent('privatecellkeydown', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            rowKeyValue,
            colKeyValue,
            keyCode,
            shiftKey,
            keyEvent
          }
        });
        this.dispatchEvent(event);
      }

      fireCellFocusByClickEvent() {
        const {
          rowKeyValue,
          colKeyValue
        } = this;
        const event = new CustomEvent('privatecellfocusedbyclick', {
          bubbles: true,
          composed: true,
          detail: {
            rowKeyValue,
            colKeyValue
          }
        });
        this.dispatchEvent(event);
      }

    }

    lwc.registerDecorators(PrimitiveDatatableCell, {
      publicProps: {
        rowKeyValue: {
          config: 0
        },
        colKeyValue: {
          config: 0
        },
        hasFocus: {
          config: 3
        }
      },
      publicMethods: ["setMode", "addFocusStyles", "removeFocusStyles", "resetCurrentInputIndex"],
      track: {
        state: 1
      }
    });

    var PrimitiveDatatableCell$1 = lwc.registerComponent(PrimitiveDatatableCell, {
      tmpl: _tmpl$V
    });

    function tmpl$1a($api, $cmp, $slotset, $ctx) {
      const {
        gid: api_scoped_id,
        ti: api_tab_index,
        b: api_bind,
        h: api_element,
        d: api_dynamic
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-th__action": true,
          "slds-th__action_form": true,
          "slds-cell-fixed": true
        },
        style: $cmp.columnStyles,
        key: 2
      }, [$cmp.showCheckbox ? api_element("span", {
        classMap: {
          "slds-checkbox": true
        },
        key: 4
      }, [api_element("input", {
        classMap: {
          "datatable-select-all": true
        },
        attrs: {
          "type": "checkbox",
          "name": $cmp.computedOptionName,
          "id": api_scoped_id("lgt-dt-header-factory-id"),
          "tabindex": api_tab_index($cmp.internalTabIndex),
          "data-navigation": "enable"
        },
        props: {
          "disabled": $cmp.def.isBulkSelectionDisabled
        },
        key: 5,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleSelectAllRows))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-checkbox__label": true
        },
        attrs: {
          "for": `${api_scoped_id("lgt-dt-header-factory-id")}`
        },
        key: 6
      }, [api_element("span", {
        classMap: {
          "slds-checkbox_faux": true
        },
        key: 7
      }, []), api_element("span", {
        classMap: {
          "slds-form-element__label": true,
          "slds-assistive-text": true
        },
        key: 8
      }, [api_dynamic($cmp.i18n.selectAll)])])]) : null, !$cmp.showCheckbox ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 10
      }, [api_dynamic($cmp.i18n.chooseARow)]) : null])];
    }

    var selectable = lwc.registerTemplate(tmpl$1a);
    tmpl$1a.stylesheets = [];
    tmpl$1a.stylesheetTokens = {
      hostAttribute: "lightning-primitiveHeaderFactory_selectableHeader-host",
      shadowAttribute: "lightning-primitiveHeaderFactory_selectableHeader"
    };

    function tmpl$1b($api, $cmp, $slotset, $ctx) {
      const {
        t: api_text,
        h: api_element,
        d: api_dynamic,
        c: api_custom_element,
        b: api_bind,
        s: api_slot
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11,
        _m12,
        _m13,
        _m14
      } = $ctx;
      return [api_element("button", {
        className: $cmp.computedButtonClass,
        attrs: {
          "aria-expanded": $cmp.computedAriaExpanded,
          "title": $cmp.computedTitle,
          "accesskey": $cmp.computedAccessKey,
          "value": $cmp.value,
          "aria-haspopup": "true",
          "type": "button"
        },
        props: {
          "disabled": $cmp.disabled
        },
        key: 2,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleButtonClick)),
          "keydown": _m1 || ($ctx._m1 = api_bind($cmp.handleButtonKeyDown)),
          "blur": _m2 || ($ctx._m2 = api_bind($cmp.handleBlur)),
          "focus": _m3 || ($ctx._m3 = api_bind($cmp.handleFocus)),
          "mousedown": _m4 || ($ctx._m4 = api_bind($cmp.handleButtonMouseDown))
        }
      }, [$cmp.isDraft ? api_element("abbr", {
        classMap: {
          "slds-indicator_unsaved": true,
          "slds-p-right_xx-small": true
        },
        attrs: {
          "title": $cmp.draftAlternativeText
        },
        key: 3
      }, [api_text("*")]) : null, api_dynamic($cmp.label), api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.iconName,
          "svgClass": "slds-button__icon",
          "variant": "bare"
        },
        key: 4
      }, []), $cmp.computedShowDownIcon ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:down",
          "svgClass": "slds-button_icon slds-button__icon_x-small slds-m-left_xx-small",
          "variant": "bare"
        },
        key: 6
      }, []) : null, api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 7
      }, [api_dynamic($cmp.computedAlternativeText)])]), $cmp._dropdownOpened ? api_element("div", {
        className: $cmp.computedDropdownClass,
        key: 9,
        on: {
          "mousedown": _m11 || ($ctx._m11 = api_bind($cmp.handleDropdownMouseDown)),
          "mouseup": _m12 || ($ctx._m12 = api_bind($cmp.handleDropdownMouseUp)),
          "mouseleave": _m13 || ($ctx._m13 = api_bind($cmp.handleDropdownMouseLeave)),
          "scroll": _m14 || ($ctx._m14 = api_bind($cmp.handleDropdownScroll))
        }
      }, [$cmp.isLoading ? api_custom_element("lightning-spinner", _lightningSpinner, {
        props: {
          "size": "small",
          "alternativeText": $cmp.computedLoadingStateAlternativeText
        },
        key: 11
      }, []) : null, !$cmp.isLoading ? api_element("div", {
        classMap: {
          "slds-dropdown__list": true
        },
        attrs: {
          "role": "menu"
        },
        key: 13,
        on: {
          "privateselect": _m5 || ($ctx._m5 = api_bind($cmp.handleMenuItemPrivateSelect)),
          "privateblur": _m6 || ($ctx._m6 = api_bind($cmp.handlePrivateBlur)),
          "privatefocus": _m7 || ($ctx._m7 = api_bind($cmp.handlePrivateFocus)),
          "mouseover": _m8 || ($ctx._m8 = api_bind($cmp.handleMouseOverOnMenuItem)),
          "mouseout": _m9 || ($ctx._m9 = api_bind($cmp.allowBlur)),
          "keydown": _m10 || ($ctx._m10 = api_bind($cmp.handleKeyOnMenuItem))
        }
      }, [api_slot("", {
        key: 14
      }, [], $slotset)]) : null]) : null];
    }

    var _tmpl$W = lwc.registerTemplate(tmpl$1b);
    tmpl$1b.slots = [""];
    tmpl$1b.stylesheets = [];
    tmpl$1b.stylesheetTokens = {
      hostAttribute: "lightning-buttonMenu_buttonMenu-host",
      shadowAttribute: "lightning-buttonMenu_buttonMenu"
    };

    var labelLoading$1 = 'Loading menu items...';

    var labelShowMenu = 'Show menu';

    /*
     * This is following the practices listed in
     *
     * https://www.w3.org/TR/wai-aria-practices/#menu
     *
     * and
     *
     * https://www.w3.org/TR/wai-aria-practices/#menubutton
     */

    function preventDefaultAndStopPropagation$4(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    function moveFocusToTypedCharacters(event, menuInterface) {
      runActionOnBufferedTypedCharacters(event, menuInterface.focusMenuItemWithText);
    }

    function handleKeyDownOnMenuItem(event, menuItemIndex, menuInterface) {
      switch (event.keyCode) {
        // W3: Down Arrow and Up Arrow: move focus to the next and previous items, respectively, optionally
        // wrapping from last to first and vice versa.
        case keyCodes.down:
        case keyCodes.up:
          // eslint-disable-line no-case-declarations
          preventDefaultAndStopPropagation$4(event);
          let nextIndex = event.keyCode === keyCodes.up ? menuItemIndex - 1 : menuItemIndex + 1;
          const totalMenuItems = menuInterface.getTotalMenuItems();

          if (nextIndex >= totalMenuItems) {
            nextIndex = 0;
          } else if (nextIndex < 0) {
            nextIndex = totalMenuItems - 1;
          }

          menuInterface.focusOnIndex(nextIndex);
          break;
        // W3: Home and End: If arrow key wrapping is not supported, move focus to first and last item
        // Note: We do support wrapping, but it doesn't hurt to support these keys anyway.

        case keyCodes.home:
          preventDefaultAndStopPropagation$4(event);
          menuInterface.focusOnIndex(0);
          break;

        case keyCodes.end:
          preventDefaultAndStopPropagation$4(event);
          menuInterface.focusOnIndex(menuInterface.getTotalMenuItems() - 1);
          break;
        // W3: Escape: Close the menu and return focus to the element or context, e.g., menu button or
        // parent menu item, from which the menu was opened
        // Tab: Close the menu and all open parent menus and move focus to the next element in the tab sequence.
        // Note: We don't have to do anything special for Tab because we're not stopping the event, we'll first
        // return the focus and the browser will then handle the tab key default event and will move the focus
        // appropriately. It's handy to return focus for 'Tab' anyway for cases where the menu is in a detached
        // popup (one that's using a panel attached directly to the body).

        case keyCodes.escape:
        case keyCodes.tab:
          // hide menu item list if it is visible
          if (menuInterface.isMenuVisible()) {
            // prevent default escape key action only when menu is visible
            if (event.keyCode === keyCodes.escape) {
              preventDefaultAndStopPropagation$4(event);
            }

            menuInterface.toggleMenuVisibility();
          }

          menuInterface.returnFocus();
          break;

        default:
          // W3: Any key that corresponds to a printable character: Move focus to the next menu item in the
          // current menu whose label begins with that printable character.
          // Note: we actually support a buffer, and in the current implementation it would jump to
          // the first menu item that matches not next.
          moveFocusToTypedCharacters(event, menuInterface);
      }
    }
    function handleKeyDownOnMenuTrigger(event, menuInterface) {
      const isVisible = menuInterface.isMenuVisible();

      switch (event.keyCode) {
        // W3 suggests that opening a menu should place the focus on the first item (as we do with Up/Down),
        // but we're not doing that because it would differ from most of the native menus behaviour.
        case keyCodes.enter:
        case keyCodes.space:
          preventDefaultAndStopPropagation$4(event);
          menuInterface.toggleMenuVisibility();
          break;

        case keyCodes.down:
        case keyCodes.up:
          preventDefaultAndStopPropagation$4(event);

          if (!isVisible) {
            // default to first menu item
            let focusNextIndex = 0; // if key was up-arrow then set to last menu item

            if (event.keyCode === keyCodes.up) {
              focusNextIndex = 'LAST';
            }

            menuInterface.setNextFocusIndex(focusNextIndex);
            menuInterface.toggleMenuVisibility();
          }

          break;
        // W3: Home and End: If arrow key wrapping is not supported, move focus to first and last item
        // Note: We do support wrapping, but it doesn't hurt to support these keys anyway.

        case keyCodes.home:
          preventDefaultAndStopPropagation$4(event);
          menuInterface.focusOnIndex(0);
          break;

        case keyCodes.end:
          preventDefaultAndStopPropagation$4(event);
          menuInterface.focusOnIndex(menuInterface.getTotalMenuItems() - 1);
          break;
        // W3: Escape: Close the menu and return focus to the element or context, e.g., menu button or
        // parent menu item, from which the menu was opened

        case keyCodes.escape:
        case keyCodes.tab:
          if (isVisible) {
            preventDefaultAndStopPropagation$4(event);
            menuInterface.toggleMenuVisibility();
          }

          break;

        default:
          if (!isVisible && menuInterface.showDropdownWhenTypingCharacters) {
            preventDefaultAndStopPropagation$4(event);
            menuInterface.toggleMenuVisibility();
          } else if (!isVisible) {
            break;
          } // eslint-disable-next-line lwc/no-raf


          window.requestAnimationFrame(() => {
            moveFocusToTypedCharacters(event, menuInterface);
          });
      }
    }

    const i18n$q = {
      loading: labelLoading$1,
      showMenu: labelShowMenu
    }; // CSS class and selectors for menu items

    const menuItemCSSClassName = 'slds-dropdown__item';
    const menuItemCSSSelector = `.slds-dropdown__list .${menuItemCSSClassName}`;
    /**
     * Represents a dropdown menu with a list of actions or functions.
     * @slot default Placeholder for menu-item
     */

    class LightningButtonMenu extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.iconSize = 'medium';
        this.iconName = 'utility:down';
        this.value = '';
        this.alternativeText = i18n$q.showMenu;
        this.loadingStateAlternativeText = i18n$q.loading;
        this.label = void 0;
        this.draftAlternativeText = void 0;
        this._accesskey = null;
        this._disabled = false;
        this._dropdownVisible = false;
        this._dropdownOpened = false;
        this._nubbin = false;
        this._title = null;
        this._isDraft = false;
        this._isLoading = false;
        this._focusOnIndexDuringRenderedCallback = null;
        this._tabindex = 0;
        this._order = null;
        this._variant = 'border';
        this._positioning = false;
        this._menuAlignment = 'left';
        this._boundingRect = {};
        this._tooltip = null;
      }

      connectedCallback() {
        this._connected = true;
        this.keyboardInterface = this.menuKeyboardInterface();
        this.classList.add('slds-dropdown-trigger', 'slds-dropdown-trigger_click');

        if (this.isDraft) {
          this.classList.add('slds-is-unsaved');
        } // button-group necessities


        const privatebuttonregister = new CustomEvent('privatebuttonregister', {
          bubbles: true,
          detail: {
            callbacks: {
              setOrder: this.setOrder.bind(this),
              setDeRegistrationCallback: deRegistrationCallback => {
                this._deRegistrationCallback = deRegistrationCallback;
              }
            }
          }
        });
        this.dispatchEvent(privatebuttonregister);
      }

      disconnectedCallback() {
        this._connected = false;

        if (this._deRegistrationCallback) {
          this._deRegistrationCallback();
        }
      }

      renderedCallback() {
        if (this._tooltip && !this._tooltip.initialized) {
          this._tooltip.initialize();
        } // if we are using autopositioning focus happens in its own cycle


        if (!this._positioning && this._dropdownVisible) {
          // logic to focus on first menu item after render
          this.focusOnMenuItemAfterRender();
        }
      }
      /**
       * The variant changes the look of the button.
       * Accepted variants include bare, container, border, border-filled, bare-inverse, and border-inverse.
       * This value defaults to border.
       *
       * @type {string}
       * @default border
       */


      get variant() {
        return this._variant;
      }

      set variant(variant) {
        this._variant = normalizeString(variant, {
          fallbackValue: 'border',
          validValues: ['border', 'border-inverse', 'border-filled', 'bare', 'bare-inverse', 'container']
        });
      }
      /**
       * Determines the alignment of the menu relative to the button.
       * Available options are: auto, left, center, right, bottom-left, bottom-center, bottom-right.
       * The auto option aligns the dropdown menu based on available space.
       * This value defaults to left.
       *
       * @type {string}
       * @default left
       */


      get menuAlignment() {
        return this._menuAlignment;
      }

      set menuAlignment(value) {
        this._menuAlignment = normalizeString(value, {
          fallbackValue: 'left',
          validValues: ['auto', 'auto-right', 'auto-left', 'left', 'center', 'right', 'bottom-left', 'bottom-center', 'bottom-right']
        });
      }
      /**
       * If present, the menu can be opened by users.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, a nubbin is present on the menu.
       * A nubbin is a stub that protrudes from the menu item towards the button menu.
       * The nubbin position is based on the menu-alignment.
       * @type {boolean}
       * @default false
       */


      get nubbin() {
        return this._nubbin;
      }

      set nubbin(value) {
        this._nubbin = normalizeBoolean(value);
      }
      /**
       * Displays tooltip text when the mouse moves over the button menu.
       * @type {string}
       */


      get title() {
        return this._title;
      }

      set title(newValue) {
        this._title = newValue;
      }
      /**
       * If present, the menu trigger shows a draft indicator.
       * @type {boolean}
       * @default false
       */


      get isDraft() {
        return this._isDraft;
      }

      set isDraft(value) {
        this._isDraft = normalizeBoolean(value);
      }
      /**
       * If present, the menu is in a loading state and shows a spinner.
       * @type {boolean}
       * @default false
       */


      get isLoading() {
        return this._isLoading;
      }

      set isLoading(value) {
        const normalizedValue = normalizeBoolean(value);

        if (this.isAutoAlignment()) {
          // stop previous positioning if any as it maintains old position relationship
          this.stopPositioning();

          if (this._isLoading && !normalizedValue) {
            // was loading before and now is not, we need to reposition
            this.startPositioning();
          }
        }

        this._isLoading = normalizedValue;
      }
      /**
       * The keyboard shortcut for the button menu.
       * @type {string}
       */


      get accessKey() {
        return this._accesskey;
      }

      set accessKey(newValue) {
        this._accesskey = newValue;
      }
      /**
       * Text to display when the user mouses over or focuses on the button.
       * The tooltip is auto-positioned relative to the button and screen space.
       * @type {string}
       */


      get tooltip() {
        return this._tooltip ? this._tooltip.value : undefined;
      }

      set tooltip(value) {
        if (this._tooltip) {
          this._tooltip.value = value;
        } else if (value) {
          // Note that because the tooltip target is a child element it may not be present in the
          // dom during initial rendering.
          this._tooltip = new Tooltip(value, {
            root: this,
            target: () => this.template.querySelector('button')
          });

          this._tooltip.initialize();
        }
      }
      /**
       * Sets focus on the button.
       */


      focus() {
        if (this._connected) {
          this.focusOnButton();
        }
      }

      get computedAriaExpanded() {
        return String(this._dropdownVisible); // default value must be a string for the attribute to always be present with a string value
      }

      focusOnMenuItemAfterRender() {
        // if no menu items are focused then set focus on the first or last one once registered
        // :: this can occur if there's a delay in loading the menu items (loading from server for example)
        // :: revealing the menu in an empty state to later have menu items loaded
        let focusOnIndex = this._focusOnIndexDuringRenderedCallback || 0; // if focus index is greater than the size of the list,
        // or next focus should be on LAST,
        // set to the last item

        const menuItems = this.getMenuItems(); // if specified as 'LAST' set it to a valid numeric value instead

        if (focusOnIndex === 'LAST') {
          focusOnIndex = menuItems.length - 1; // maintain 'LAST' value if menu items aren't available yet

          if (focusOnIndex < 0) {
            focusOnIndex = 'LAST';
          }
        } // only perform operations when we have a valid numeric index


        if (focusOnIndex !== 'LAST') {
          if (focusOnIndex > menuItems.length - 1 && menuItems.length > 0) {
            focusOnIndex = menuItems.length - 1;
          } // set the focus


          this.focusOnMenuItem(focusOnIndex); // reset tracker value

          this._focusOnIndexDuringRenderedCallback = null;
        }
      }

      get computedAccessKey() {
        return this._accesskey;
      }

      get computedTitle() {
        return this._title;
      }

      get computedAlternativeText() {
        return this.alternativeText || i18n$q.showMenu;
      }

      get computedLoadingStateAlternativeText() {
        return this.loadingStateAlternativeText || i18n$q.loading;
      }

      get computedButtonClass() {
        const isDropdownIcon = !this.computedShowDownIcon;
        const isBare = this.variant === 'bare' || this.variant === 'bare-inverse';
        const classes = classSet('slds-button');

        if (this.label) {
          classes.add({
            'slds-button_neutral': this.variant === 'border' && isDropdownIcon,
            'slds-button_inverse': this.variant === 'border-inverse'
          });
        } else {
          // The inverse check is to allow for a combination of a non-default icon and an -inverse variant
          const useMoreContainer = this.variant === 'container' || this.variant === 'bare-inverse' || this.variant === 'border-inverse';
          classes.add({
            'slds-button_icon': !isDropdownIcon,
            'slds-button_icon-bare': isBare,
            'slds-button_icon-more': !useMoreContainer && !isDropdownIcon,
            'slds-button_icon-container-more': useMoreContainer && !isDropdownIcon,
            'slds-button_icon-container': this.variant === 'container' && isDropdownIcon,
            'slds-button_icon-border': this.variant === 'border' && isDropdownIcon,
            'slds-button_icon-border-filled': this.variant === 'border-filled',
            'slds-button_icon-border-inverse': this.variant === 'border-inverse',
            'slds-button_icon-inverse': this.variant === 'bare-inverse',
            'slds-button_icon-xx-small': this.iconSize === 'xx-small' && !isBare,
            'slds-button_icon-x-small': this.iconSize === 'x-small' && !isBare,
            'slds-button_icon-small': this.iconSize === 'small' && !isBare
          });
        }

        return classes.add({
          // order classes when part of a button-group
          'slds-button_first': this._order === 'first',
          'slds-button_middle': this._order === 'middle',
          'slds-button_last': this._order === 'last'
        }).toString();
      }

      get computedShowDownIcon() {
        return !(this.iconName === 'utility:down' || this.iconName === 'utility:chevrondown');
      }

      get computedDropdownClass() {
        return classSet('slds-dropdown').add({
          'slds-dropdown_left': this.menuAlignment === 'left' || this.isAutoAlignment(),
          'slds-dropdown_center': this.menuAlignment === 'center',
          'slds-dropdown_right': this.menuAlignment === 'right',
          'slds-dropdown_bottom': this.menuAlignment === 'bottom-center',
          'slds-dropdown_bottom slds-dropdown_right slds-dropdown_bottom-right': this.menuAlignment === 'bottom-right',
          'slds-dropdown_bottom slds-dropdown_left slds-dropdown_bottom-left': this.menuAlignment === 'bottom-left',
          'slds-nubbin_top-left': this.nubbin && this.menuAlignment === 'left',
          'slds-nubbin_top-right': this.nubbin && this.menuAlignment === 'right',
          'slds-nubbin_top': this.nubbin && this.menuAlignment === 'center',
          'slds-nubbin_bottom-left': this.nubbin && this.menuAlignment === 'bottom-left',
          'slds-nubbin_bottom-right': this.nubbin && this.menuAlignment === 'bottom-right',
          'slds-nubbin_bottom': this.nubbin && this.menuAlignment === 'bottom-center',
          'slds-p-vertical_large': this.isLoading
        }).toString();
      }

      handleMenuItemPrivateSelect(event) {
        if (this._dropdownVisible) {
          this.toggleMenuVisibility();
          this.focusOnButton();
        } //


        this.dispatchSelect(event);
      }

      dispatchSelect(event) {
        this.dispatchEvent(new CustomEvent('select', {
          cancelable: true,
          detail: {
            value: event.detail.value // pass value through from original private event

          }
        }));
      }

      handleButtonClick() {
        this.allowBlur();
        this.toggleMenuVisibility(); // Focus on the button even if the browser doesn't do it by default
        // (the behaviour differs between Chrome, Safari, Firefox)

        this.focusOnButton();
      }

      handleButtonKeyDown(event) {
        handleKeyDownOnMenuTrigger(event, this.keyboardInterface);
      }

      handleButtonMouseDown(event) {
        const mainButton = 0;

        if (event.button === mainButton) {
          this.cancelBlur();
        }
      }

      handleDropdownMouseDown(event) {
        // if the menu contais a scrollbar due to large number of menu-items
        // this is needed so that menu doesnt close on dragging the scrollbar with the mouse
        const mainButton = 0;

        if (event.button === mainButton) {
          this.cancelBlur();
        }
      }

      handleDropdownMouseUp() {
        // We need this to make sure that if a scrollbar is being dragged with the mouse, upon release
        // of the drag we allow blur, otherwise the dropdown would not close on blur since we'd have cancel blur
        // set
        this.allowBlur();
      }

      handleDropdownMouseLeave() {
        // this is to close the menu after mousedown happens on scrollbar
        // in this case we close immediately if no menu-items were hovered/focused
        // without this the menu would remain open since the blur on the menuitems has happened already
        // when clicking the scrollbar
        if (!this._menuHasFocus) {
          this.close();
        }
      }

      handleDropdownScroll(event) {
        // We don't want this to bubble up to the modal which due to event retargeting wouldn't be able
        // to know what is actually being scrolled and thus may lead to the scrolling of the modal
        event.stopPropagation();
      }

      focusOnButton() {
        this.template.querySelector('button').focus();
      }

      focusOnMenuItem(itemIndex) {
        if (this._dropdownVisible) {
          const menuItem = this.getMenuItemByIndex(itemIndex);
          this.cancelBlurAndFocusOnMenuItem(menuItem);
        }
      }

      isAutoAlignment() {
        return this.menuAlignment.startsWith('auto');
      }

      startPositioning() {
        if (!this.isAutoAlignment()) {
          return;
        }

        this._positioning = true;
        const align = {
          horizontal: Direction.Left,
          vertical: Direction.Top
        };
        const targetAlign = {
          horizontal: Direction.Left,
          vertical: Direction.Bottom
        };
        let autoFlip = true;
        let autoFlipVertical;

        if (this.menuAlignment === 'auto-right') {
          align.horizontal = Direction.Right;
          targetAlign.horizontal = Direction.Right;
        }

        if (this.menuAlignment === 'auto-right' || this.menuAlignment === 'auto-left') {
          autoFlip = false;
          autoFlipVertical = true;
        }

        requestAnimationFrame(() => {
          this.stopPositioning();
          this._autoPosition = startPositioning(this, {
            target: () => this.template.querySelector('button'),
            element: () => this.template.querySelector('.slds-dropdown'),
            align,
            targetAlign,
            autoFlip,
            autoFlipVertical
          });
        }); // focus on the first item in next cycle
        // eslint-disable-next-line lwc/no-set-timeout

        setTimeout(() => {
          this._positioning = false;
          this.focusOnMenuItemAfterRender();
        }, 0);
      }

      stopPositioning() {
        if (this._autoPosition) {
          stopPositioning(this._autoPosition);
          this._autoPosition = null;
        }

        this._positioning = false;
      }

      toggleMenuVisibility() {
        if (!this.disabled) {
          this._dropdownVisible = !this._dropdownVisible;

          if (!this._dropdownOpened && this._dropdownVisible) {
            this._dropdownOpened = true;
          }

          if (this._dropdownVisible) {
            this.startPositioning();
            this.dispatchEvent(new CustomEvent('open')); // update the bounding rect when the menu is toggled

            this._boundingRect = this.getBoundingClientRect();
            this.pollBoundingRect();
          } else {
            this.stopPositioning();
          }

          this.classList.toggle('slds-is-open');
        }
      }

      getMenuItems() {
        return Array.from(this.querySelectorAll(menuItemCSSSelector));
      }

      getMenuItemByIndex(index) {
        return this.getMenuItems()[index];
      }

      findMenuItemIndex(menuItemElement) {
        // Get children (HTMLCollection) and transform into an array.
        const listChildren = Array.prototype.map.call(this.getMenuItems(), item => {
          return lwc.unwrap(item);
        });
        return listChildren.indexOf(menuItemElement);
      }

      findMenuItemFromEventTarget(element) {
        let currentNode = lwc.unwrap(element);
        const stopAtElement = lwc.unwrap(this.template.querySelector("[role='menu']"));

        while (currentNode !== stopAtElement) {
          if (currentNode.classList && currentNode.classList.contains(menuItemCSSClassName)) {
            return currentNode;
          }

          if (currentNode.parentNode) {
            currentNode = currentNode.parentNode;
          } else {
            return null;
          }
        }

        return null;
      }

      handleKeyOnMenuItem(event) {
        const menuItem = this.findMenuItemFromEventTarget(event.target);

        if (menuItem) {
          handleKeyDownOnMenuItem(event, this.findMenuItemIndex(menuItem), this.keyboardInterface);
        }
      }

      handleMouseOverOnMenuItem(event) {
        const menuItem = this.findMenuItemFromEventTarget(event.target);

        if (menuItem) {
          const menuItemIndex = this.findMenuItemIndex(menuItem);
          this.focusOnMenuItem(menuItemIndex);
        }
      }

      cancelBlurAndFocusOnMenuItem(menuItem) {
        if (menuItem) {
          // prevent blur during a non-blurring focus change
          // set lock so that while focusing on menutitem, menu doesnt close
          this.cancelBlur();
          menuItem.focus();
        } // allowBlur is called when the menu items receives focus

      }

      handleFocus() {
        this.dispatchEvent(new CustomEvent('focus'));
      }

      handlePrivateBlur(event) {
        // The event may be synthetic from the menu items
        event.stopPropagation(); // perform common blurring behavior

        this.handleBlur();
        this._menuHasFocus = false;
      }

      handlePrivateFocus(event) {
        // synthetic from the menu items
        event.stopPropagation(); // reset the cancelBlur so any clicks outside the menu can now close the menu

        this.allowBlur();
        this._menuHasFocus = true;
      }

      handleBlur() {
        // Don't handle the blur event if the focus events are inside the menu (see the cancelBlur/allowBlur functions)
        if (this._cancelBlur) {
          return;
        } // Hide only when the focus moved away from the container


        if (this._dropdownVisible) {
          this.toggleMenuVisibility();
        } // dispatch standard blur event


        this.dispatchEvent(new CustomEvent('blur'));
      }

      allowBlur() {
        this._cancelBlur = false;
      }

      cancelBlur() {
        this._cancelBlur = true;
      }

      menuKeyboardInterface() {
        const that = this;
        return {
          getTotalMenuItems() {
            return that.getMenuItems().length;
          },

          focusOnIndex(index) {
            that.focusOnMenuItem(index);
          },

          setNextFocusIndex(index) {
            that._focusOnIndexDuringRenderedCallback = index;
          },

          returnFocus() {
            that.focusOnButton();
          },

          isMenuVisible() {
            return that._dropdownVisible;
          },

          toggleMenuVisibility() {
            that.toggleMenuVisibility();
          },

          focusMenuItemWithText(text) {
            const match = [...that.getMenuItems()].filter(menuItem => {
              const label = menuItem.label;
              return label && label.toLowerCase().indexOf(text) === 0;
            });

            if (match.length > 0) {
              that.focusOnMenuItem(match[0]);
            }
          }

        };
      }
      /**
       * {Function} setOrder - Sets the order value of the button when in the context of a button-group or other ordered component
       * @param {String} order -  The order string (first, middle, last)
       */


      setOrder(order) {
        this._order = order;
      }
      /**
       * {Function} close - Closes the dropdown if it's open
       */


      close() {
        // should only do something if dropdown is visible
        if (this._dropdownVisible) {
          this.toggleMenuVisibility();
        }
      }
      /**
       * Poll for change in bounding rectangle
       * only if it is menuAlignment=auto since that is
       * position:fixed and is opened
       */


      pollBoundingRect() {
        // only poll if the dropdown is auto aligned
        if (this.isAutoAlignment() && this._dropdownVisible) {
          // eslint-disable-next-line lwc/no-set-timeout
          setTimeout(() => {
            if (this._connected) {
              observePosition(this, 300, this._boundingRect, () => {
                this.close();
              }); // continue polling

              this.pollBoundingRect();
            }
          }, 250 // check every 0.25 second
          );
        }
      }

    }

    LightningButtonMenu.delegatesFocus = true;

    lwc.registerDecorators(LightningButtonMenu, {
      publicProps: {
        iconSize: {
          config: 0
        },
        iconName: {
          config: 0
        },
        value: {
          config: 0
        },
        alternativeText: {
          config: 0
        },
        loadingStateAlternativeText: {
          config: 0
        },
        label: {
          config: 0
        },
        draftAlternativeText: {
          config: 0
        },
        variant: {
          config: 3
        },
        menuAlignment: {
          config: 3
        },
        disabled: {
          config: 3
        },
        nubbin: {
          config: 3
        },
        title: {
          config: 3
        },
        isDraft: {
          config: 3
        },
        isLoading: {
          config: 3
        },
        accessKey: {
          config: 3
        },
        tooltip: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        _accesskey: 1,
        _disabled: 1,
        _dropdownVisible: 1,
        _dropdownOpened: 1,
        _nubbin: 1,
        _title: 1,
        _isDraft: 1,
        _isLoading: 1,
        _focusOnIndexDuringRenderedCallback: 1,
        _tabindex: 1,
        _order: 1,
        _variant: 1
      }
    });

    var _lightningButtonMenu = lwc.registerComponent(LightningButtonMenu, {
      tmpl: _tmpl$W
    });

    function stylesheet$m(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$m = [stylesheet$m];

    function tmpl$1c($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        t: api_text,
        h: api_element,
        d: api_dynamic,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [api_element("a", {
        attrs: {
          "href": $cmp.computedHref,
          "role": $cmp.computedRole,
          "tabindex": api_tab_index($cmp.computedTabIndex),
          "accesskey": $cmp.computedAccessKey,
          "aria-checked": $cmp.computedAriaChecked,
          "aria-disabled": $cmp.computedAriaDisabled
        },
        key: 2,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleClick)),
          "focus": _m1 || ($ctx._m1 = api_bind($cmp.handleFocus)),
          "keydown": _m2 || ($ctx._m2 = api_bind($cmp.handleKeyDown)),
          "blur": _m3 || ($ctx._m3 = api_bind($cmp.handleBlur))
        }
      }, [api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        key: 3
      }, [$cmp.isMenuItemCheckbox ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:check",
          "size": "x-small",
          "svgClass": $cmp.computedCheckedIconClass,
          "variant": "bare"
        },
        key: 5
      }, []) : null, $cmp.isDraft ? api_element("abbr", {
        classMap: {
          "slds-indicator_unsaved": true
        },
        attrs: {
          "title": $cmp.draftAlternativeText
        },
        key: 6
      }, [api_text("*")]) : null, $cmp.prefixIconName ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.prefixIconName,
          "size": "x-small",
          "svgClass": "slds-icon slds-icon_x-small slds-icon-text-default slds-m-right_x-small",
          "variant": "bare"
        },
        key: 8
      }, []) : null, api_dynamic($cmp.label)]), $cmp.iconName ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.iconName,
          "size": "x-small",
          "svgClass": "slds-icon-text-default slds-m-left_small slds-shrink-none",
          "variant": "bare"
        },
        key: 10
      }, []) : null])];
    }

    var _tmpl$X = lwc.registerTemplate(tmpl$1c);
    tmpl$1c.stylesheets = [];

    if (_implicitStylesheets$m) {
      tmpl$1c.stylesheets.push.apply(tmpl$1c.stylesheets, _implicitStylesheets$m);
    }
    tmpl$1c.stylesheetTokens = {
      hostAttribute: "lightning-menuItem_menuItem-host",
      shadowAttribute: "lightning-menuItem_menuItem"
    };

    /**
     * Represents a list item in a menu.
     */

    class LightningMenuItem extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.value = void 0;
        this.label = void 0;
        this.iconName = void 0;
        this._accesskey = null;
        this._disabled = false;
        this._tabindex = '-1';
        this._checked = undefined;
        this._isDraft = false;
        this.prefixIconName = void 0;
        this.href = void 0;
        this.draftAlternativeText = void 0;
      }

      connectedCallback() {
        this.classList.add('slds-dropdown__item');
        this.setAttribute('role', 'presentation');
      }
      /**
       * If present, a draft indicator is shown on the menu item.
       * A draft indicator is denoted by blue asterisk on the left of the menu item.
       * When you use a draft indicator, include alternative text for accessibility using draft-alternative-text.
       * @type {boolean}
       * @default false
       */


      get isDraft() {
        return this._isDraft;
      }

      set isDraft(value) {
        this._isDraft = normalizeBoolean(value);
      }
      /**
       * The keyboard shortcut for the menu item.
       * @type {string}
       */


      get accessKey() {
        return this._accesskey;
      }

      set accessKey(newValue) {
        this._accesskey = newValue;
        this.handleAccessKeyChange(newValue);
      }
      /**
       * Reserved for internal use. Use tabindex instead to indicate if an element should be focusable.
       * tabindex can be set to 0 or -1.
       * The default tabindex value is 0, which means that the menu item is focusable and
       * participates in sequential keyboard navigation. The value -1 means
       * that the menu item is focusable but does not participate in keyboard navigation.
       * @type {number}
       */


      get tabIndex() {
        return this._tabindex;
      }

      set tabIndex(newValue) {
        this._tabindex = newValue;
        this.handleTabIndexChange(newValue);
      }

      handleAccessKeyChange(value) {
        this._accesskey = value;
      }

      handleTabIndexChange(value) {
        this._tabindex = value;
      }

      get computedAccessKey() {
        return this._accesskey;
      }

      get computedTabIndex() {
        return this._tabindex;
      }
      /**
       * If present, the menu item is disabled and users cannot interact with it.
       * @type {boolean}
       * @default false
       */


      get disabled() {
        return this._disabled;
      }

      set disabled(value) {
        this._disabled = normalizeBoolean(value);
      }
      /**
       * If present, a check mark displays on the left of the menu item if it's selected.
       * @type {boolean}
       * @default false
       */


      get checked() {
        return this._checked;
      }

      set checked(value) {
        if (typeof value === 'string') {
          // handle string
          value = normalizeString(value, {
            fallbackValue: undefined,
            validValues: ['true', 'false']
          });

          if (value !== undefined) {
            value = value === 'true';
          }
        }

        if (value !== undefined) {
          // handle boolean which is from above or user
          value = normalizeBoolean(value);
        }

        this._checked = value;
        this.classList.toggle('slds-is-selected', this.checked === true);
      }

      get computedCheckedIconClass() {
        // note that what .slds-icon_selected does is to hide the checked icon
        return classSet('slds-icon slds-icon_x-small slds-icon-text-default slds-m-right_x-small').add({
          'slds-icon_selected': !this.checked
        }).toString();
      }

      get computedHref() {
        // eslint-disable-next-line no-script-url
        return this.href ? this.href : 'javascript:void(0)';
      }

      get computedAriaChecked() {
        return this.isMenuItemCheckbox ? this.checked + '' : null;
      }

      get computedAriaDisabled() {
        // Note: Needed to explicitly set aria-disabled="true"
        return this.disabled ? 'true' : 'false';
      }

      get isMenuItemCheckbox() {
        return this.checked !== undefined;
      }

      get computedRole() {
        return this.isMenuItemCheckbox ? 'menuitemcheckbox' : 'menuitem';
      }

      handleBlur() {
        this.dispatchEvent(new CustomEvent('blur')); // we need to trigger a private blur to make it bubble and be handled by parent button-menu

        this.dispatchEvent(new CustomEvent('privateblur', {
          composed: true,
          bubbles: true,
          cancelable: true
        }));
      }

      handleFocus() {
        // trigger a private focus to make it bubble and be handled by parent button-menu
        // this is used for resetting cancelBlur in button-menu
        this.dispatchEvent(new CustomEvent('privatefocus', {
          bubbles: true,
          cancelable: true
        }));
      }

      handleClick(event) {
        // no action needed when item is disabled
        if (this.disabled) {
          event.preventDefault(); // do nothing and return

          return;
        } // allow HREF to be followed


        if (this.href) ; else {
          event.preventDefault();
          this.dispatchSelect();
        }
      }

      handleKeyDown(event) {
        // no action needed when item is disabled
        if (this.disabled) {
          // do nothing and return
          return;
        }

        if (event.keyCode === keyCodes.space) {
          // follow HREF if a value was provided
          if (this.href) {
            // trigger click behavior
            this.template.querySelector('a').click();
          } else {
            // if no HREF is provided follow usual select behavior
            this.dispatchSelect();
          }
        }
      }
      /**
       *
       * The select event is a non-navigational event.
       * The purpose of the event is to toggle the selected state of a menu item.
       * It will not be dispatched if a menu item has an HREF value to navigate to (other than the default).
       * This event will be handled by the parent button-menu component.
       *
       **/


      dispatchSelect() {
        if (!this.disabled) {
          this.dispatchEvent(new CustomEvent('privateselect', {
            composed: true,
            bubbles: true,
            cancelable: true,
            detail: {
              value: lwc.unwrap(this.value)
            }
          }));
        }
      }
      /**
       * Sets focus on the anchor element in the menu item.
       */


      focus() {
        // set the focus on the anchor element
        this.template.querySelector('a').focus(); // dispatch a focus event for the menu item component

        this.dispatchEvent(new CustomEvent('focus'));
      }

    }

    lwc.registerDecorators(LightningMenuItem, {
      publicProps: {
        value: {
          config: 0
        },
        label: {
          config: 0
        },
        iconName: {
          config: 0
        },
        prefixIconName: {
          config: 0
        },
        href: {
          config: 0
        },
        draftAlternativeText: {
          config: 0
        },
        isDraft: {
          config: 3
        },
        accessKey: {
          config: 3
        },
        tabIndex: {
          config: 3
        },
        disabled: {
          config: 3
        },
        checked: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        _accesskey: 1,
        _disabled: 1,
        _tabindex: 1,
        _checked: 1,
        _isDraft: 1
      }
    });

    var _lightningMenuItem = lwc.registerComponent(LightningMenuItem, {
      tmpl: _tmpl$X
    });

    function stylesheet$n(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$n = [stylesheet$n];

    function tmpl$1d($api, $cmp, $slotset, $ctx) {
      return [];
    }

    var _tmpl$Y = lwc.registerTemplate(tmpl$1d);
    tmpl$1d.stylesheets = [];

    if (_implicitStylesheets$n) {
      tmpl$1d.stylesheets.push.apply(tmpl$1d.stylesheets, _implicitStylesheets$n);
    }
    tmpl$1d.stylesheetTokens = {
      hostAttribute: "lightning-menuDivider_menuDivider-host",
      shadowAttribute: "lightning-menuDivider_menuDivider"
    };

    class LightningMenuDivider extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this._variant = 'standard';
      }

      connectedCallback() {
        this.setAttribute('role', 'separator');
        this.updateClass();
      }

      updateClass() {
        classListMutation(this.classList, {
          'slds-has-divider_top-space': this.variant === 'standard',
          'slds-has-divider_top': this.variant === 'compact'
        });
      }

      get variant() {
        return this._variant;
      }

      set variant(value) {
        this._variant = normalizeString(value, {
          fallbackValue: 'standard',
          validValues: ['standard', 'compact']
        });
        this.updateClass();
      }

    }

    lwc.registerDecorators(LightningMenuDivider, {
      publicProps: {
        variant: {
          config: 3
        }
      },
      track: {
        _variant: 1
      }
    });

    var _lightningMenuDivider = lwc.registerComponent(LightningMenuDivider, {
      tmpl: _tmpl$Y
    });

    function tmpl$1e($api, $cmp, $slotset, $ctx) {
      const {
        k: api_key,
        c: api_custom_element,
        i: api_iterator,
        f: api_flatten,
        gid: api_scoped_id,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [$cmp.hasActions ? api_custom_element("lightning-button-menu", _lightningButtonMenu, {
        classMap: {
          "slds-th__action-button": true
        },
        styleMap: {
          "zIndex": "1"
        },
        props: {
          "id": api_scoped_id("primitive-header-action-button-menu-id"),
          "iconSize": "x-small",
          "menuAlignment": $cmp.computedMenuAlignment,
          "alternativeText": $cmp.i18n.showActions,
          "variant": "bare",
          "iconName": "utility:chevrondown"
        },
        key: 3,
        on: {
          "open": _m0 || ($ctx._m0 = api_bind($cmp.handleMenuOpen)),
          "select": _m1 || ($ctx._m1 = api_bind($cmp.handleActionSelect))
        }
      }, api_flatten([api_iterator($cmp.state.internalActions, function (action, actionIndex) {
        return api_custom_element("lightning-menu-item", _lightningMenuItem, {
          props: {
            "value": action,
            "label": action.label,
            "iconName": action.iconName,
            "disabled": action.disabled,
            "checked": action.checked
          },
          key: api_key(5, action.label)
        }, []);
      }), $cmp.hasActionsDivider ? api_custom_element("lightning-menu-divider", _lightningMenuDivider, {
        key: 7
      }, []) : null, api_iterator($cmp.state.customerActions, function (action, actionIndex) {
        return api_custom_element("lightning-menu-item", _lightningMenuItem, {
          props: {
            "value": action,
            "label": action.label,
            "iconName": action.iconName,
            "disabled": action.disabled,
            "checked": action.checked
          },
          key: api_key(9, action.label)
        }, []);
      })])) : null];
    }

    var _tmpl$Z = lwc.registerTemplate(tmpl$1e);
    tmpl$1e.stylesheets = [];
    tmpl$1e.stylesheetTokens = {
      hostAttribute: "lightning-primitiveHeaderActions_primitiveHeaderActions-host",
      shadowAttribute: "lightning-primitiveHeaderActions_primitiveHeaderActions"
    };

    var labelClipText = 'Clip text';

    var labelShowActions = 'Show actions';

    var labelWrapText = 'Wrap text';

    const i18n$r = {
      clipText: labelClipText,
      showActions: labelShowActions,
      wrapText: labelWrapText
    };

    class PrimitiveHeaderActions extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.colKeyValue = void 0;
        this.containerRect = void 0;
        this.state = {
          internalActions: [],
          customerActions: []
        };
      }

      focus() {
        const btnMenu = this.template.querySelector('lightning-button-menu');

        if (btnMenu) {
          btnMenu.focus();
        }
      }

      get actions() {
        return this._actions;
      }

      set actions(value) {
        this._actions = value;
        this.updateActions();
      }

      get i18n() {
        return i18n$r;
      }

      get computedMenuAlignment() {
        return this.state.actionMenu.menuAlignment;
      }

      updateActions() {
        const actionTypeReducer = type => (actions, action) => {
          const overrides = {
            _type: type,
            _action: action
          };
          actions.push(Object.assign({}, action, overrides));
          return actions;
        };

        this.state.internalActions = this.getActionsByType('internalActions').reduce(actionTypeReducer('internal'), []);
        this.state.customerActions = this.getActionsByType('customerActions').reduce(actionTypeReducer('customer'), []);
        this.state.actionMenu = {
          menuAlignment: this._actions.menuAlignment
        };
      }

      get hasActions() {
        return this.state.internalActions.length > 0 || this.state.customerActions.length > 0;
      }

      get hasActionsDivider() {
        return this.state.internalActions.length > 0 && this.state.customerActions.length > 0;
      }

      getActionsByType(type) {
        return Array.isArray(this._actions[type]) ? this._actions[type] : [];
      }

      handleMenuOpen(event) {
        event.preventDefault();
        event.stopPropagation();
        this.elementRect = this.template.querySelector('lightning-button-menu').getBoundingClientRect();
        this.dispatchEvent(new CustomEvent('privatecellheaderactionmenuopening', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            saveContainerPosition: containerRect => {
              this.containerRect = containerRect;
            }
          }
        }));
      }

      handleActionSelect(evt) {
        const action = evt.detail.value;
        this.dispatchEvent(new CustomEvent('privatecellheaderactiontriggered', {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            action: lwc.unwrap(action._action),
            actionType: action._type,
            colKeyValue: this.colKeyValue
          }
        }));
      }

    }

    PrimitiveHeaderActions.delegatesFocus = true;

    lwc.registerDecorators(PrimitiveHeaderActions, {
      publicProps: {
        colKeyValue: {
          config: 0
        },
        actions: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        containerRect: 1,
        state: 1
      }
    });

    var _lightningPrimitiveHeaderActions = lwc.registerComponent(PrimitiveHeaderActions, {
      tmpl: _tmpl$Z
    });

    function stylesheet$o(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$o = [stylesheet$o];

    function tmpl$1f($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2
      } = $ctx;
      return [api_element("input", {
        classMap: {
          "slds-resizable__input": true,
          "slds-assistive-text": true
        },
        attrs: {
          "type": "range",
          "min": $cmp.minWidth,
          "max": $cmp.maxWidth,
          "aria-label": $cmp.resizerLabel
        },
        props: {
          "value": $cmp.value
        },
        key: 2,
        on: {
          "keydown": _m0 || ($ctx._m0 = api_bind($cmp.handleKeydown))
        }
      }, []), api_element("span", {
        classMap: {
          "slds-resizable__handle": true
        },
        styleMap: {
          "willChange": "transform"
        },
        key: 3,
        on: {
          "mousedown": _m1 || ($ctx._m1 = api_bind($cmp.onStart)),
          "click": _m2 || ($ctx._m2 = api_bind($cmp.onClick))
        }
      }, [api_element("span", {
        classMap: {
          "slds-resizable__divider": true
        },
        key: 4
      }, [])])];
    }

    var _tmpl$_ = lwc.registerTemplate(tmpl$1f);
    tmpl$1f.stylesheets = [];

    if (_implicitStylesheets$o) {
      tmpl$1f.stylesheets.push.apply(tmpl$1f.stylesheets, _implicitStylesheets$o);
    }
    tmpl$1f.stylesheetTokens = {
      hostAttribute: "lightning-primitiveResizeHandler_primitiveResizeHandler-host",
      shadowAttribute: "lightning-primitiveResizeHandler_primitiveResizeHandler"
    };

    var labelColumnWidth = 'column width';

    const i18n$s = {
      columnWidth: labelColumnWidth
    };

    class PrimitiveResizeHandler extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.minWidth = 0;
        this.maxWidth = 1000;
        this.label = '';
        this.colIndex = void 0;
        this.internalTabIndex = void 0;
        this.step = 10;
        this.value = void 0;
        this.state = {};
      }

      get resizerLabel() {
        const label = this.label || '';
        return `${label} ${i18n$s.columnWidth}`;
      }

      get resizeElement() {
        return this.template.querySelector('.slds-resizable__handle');
      }

      focus() {
        const inputEle = this.template.querySelector('input');

        if (inputEle) {
          inputEle.focus();
        }
      }

      onClick(event) {
        // capture the click event on button, to prevent the sorting of the column
        this.preventDefaultAndStopPropagation(event);
      }

      onStart(event) {
        // prevent selecting text when mouse down
        event.returnValue = false;
        this.preventDefaultAndStopPropagation(event);
        const headerClientWidth = this.value;
        this.lowRange = this.minWidth - headerClientWidth;
        this.highRange = this.maxWidth - headerClientWidth;
        this.startX = event.pageX;
        this.currentX = this.startX;
        this.touchingResizer = true;
        document.body.addEventListener('mousemove', this.onMove.bind(this));
        document.body.addEventListener('mouseup', this.onEnd.bind(this));
        document.body.addEventListener('mouseleave', this.onEnd.bind(this));
        requestAnimationFrame(this.resizing.bind(this));
      }

      onMove(event) {
        if (!this.touchingResizer) {
          return;
        }

        this.currentX = event.pageX;
      } // eslint-disable-next-line no-unused-vars


      onEnd(event) {
        if (!this.touchingResizer) {
          return;
        }

        this.touchingResizer = false;
        document.body.removeEventListener('mousemove', this.onMove.bind(this));
        document.body.removeEventListener('mouseup', this.onEnd.bind(this));
        document.body.removeEventListener('mouseleave', this.onEnd.bind(this));
        const translateX = this.currentX - this.startX;
        this.resizeElement.style.transform = '';
        this.fireResizeEvent(translateX);
      }

      resizing() {
        if (!this.touchingResizer) {
          return;
        }

        requestAnimationFrame(this.resizing.bind(this));
        const translateX = this.currentX - this.startX;

        if (this.lowRange === undefined || translateX >= this.lowRange && translateX <= this.highRange) {
          this.resizeElement.style.transform = `translateX(${translateX}px)`;
        }
      }

      preventDefaultAndStopPropagation(event) {
        event.preventDefault();
        event.stopPropagation();
      }

      handleKeydown(event) {
        switch (event.keyCode) {
          case keyCodes.left:
            this.preventDefaultAndStopPropagation(event);
            this.fireResizeEvent(0 - this.step);
            break;

          case keyCodes.right:
            this.preventDefaultAndStopPropagation(event);
            this.fireResizeEvent(this.step);
            break;

          case keyCodes.up:
          case keyCodes.down:
          case keyCodes.enter:
          case keyCodes.space:
            this.preventDefaultAndStopPropagation(event);
            break;

          case keyCodes.escape:
            break;

          default:
        }
      }

      fireResizeEvent(widthDelta) {
        const actionName = 'resizecol'; // eslint-disable-next-line lightning-global/no-custom-event-identifier-arguments

        const actionEvent = new CustomEvent(actionName, {
          bubbles: true,
          composed: true,
          detail: {
            colIndex: this.colIndex,
            widthDelta
          }
        });
        this.dispatchEvent(actionEvent);
      }

    }

    PrimitiveResizeHandler.delegatesFocus = true;

    lwc.registerDecorators(PrimitiveResizeHandler, {
      publicProps: {
        minWidth: {
          config: 0
        },
        maxWidth: {
          config: 0
        },
        label: {
          config: 0
        },
        colIndex: {
          config: 0
        },
        internalTabIndex: {
          config: 0
        },
        step: {
          config: 0
        },
        value: {
          config: 0
        }
      },
      publicMethods: ["focus"],
      track: {
        state: 1
      }
    });

    var _lightningPrimitiveResizeHandler = lwc.registerComponent(PrimitiveResizeHandler, {
      tmpl: _tmpl$_
    });

    function tmpl$1g($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element,
        c: api_custom_element,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("span", {
        className: $cmp.computedClass,
        style: $cmp.columnStyles,
        attrs: {
          "tabindex": api_tab_index($cmp.internalTabIndex)
        },
        key: 2
      }, [api_element("a", {
        className: $cmp.computedSortClass,
        style: $cmp.columnStyles,
        attrs: {
          "href": "javascript:void(0);",
          "role": $cmp.headerRole,
          "tabindex": api_tab_index($cmp.internalTabIndex),
          "data-navigation": "enable"
        },
        key: 3,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleSortingClick)),
          "keydown": _m1 || ($ctx._m1 = api_bind($cmp.handleSortingKeyDown))
        }
      }, [api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 4
      }, [api_dynamic($cmp.i18n.sort)]), $cmp.def.iconName ? api_element("div", {
        classMap: {
          "slds-grid": true,
          "slds-grid_vertical-align-center": true,
          "slds-has-flexi-truncate": true
        },
        key: 6
      }, [api_custom_element("lightning-icon", _lightningIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-m-right_xx-small": true
        },
        props: {
          "iconName": $cmp.def.iconName,
          "size": "x-small"
        },
        key: 7
      }, []), api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.def.label
        },
        key: 8
      }, [api_dynamic($cmp.def.label)]), api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        classMap: {
          "slds-icon_container": true
        },
        props: {
          "svgClass": "slds-icon slds-icon-text-default slds-is-sortable__icon",
          "iconName": "utility:arrowdown",
          "size": "x-small"
        },
        key: 9
      }, [])]) : null, !$cmp.def.iconName ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.def.label
        },
        key: 11
      }, [api_dynamic($cmp.def.label)]) : null, !$cmp.def.iconName ? api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        classMap: {
          "slds-icon_container": true
        },
        props: {
          "svgClass": "slds-icon slds-icon-text-default slds-is-sortable__icon",
          "iconName": "utility:arrowdown",
          "size": "x-small"
        },
        key: 12
      }, []) : null]), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        attrs: {
          "aria-live": "assertive",
          "aria-atomic": "true"
        },
        key: 13
      }, [api_dynamic($cmp.sortedOrderLabel)]), $cmp.hasActions ? api_custom_element("lightning-primitive-header-actions", _lightningPrimitiveHeaderActions, {
        attrs: {
          "data-navigation": "enable"
        },
        props: {
          "colKeyValue": $cmp.def.colKeyValue,
          "actions": $cmp.actions,
          "tabIndex": api_tab_index($cmp.state.internalTabIndex)
        },
        key: 15
      }, []) : null, $cmp.isResizable ? api_custom_element("lightning-primitive-resize-handler", _lightningPrimitiveResizeHandler, {
        classMap: {
          "slds-resizable": true
        },
        attrs: {
          "data-navigation": "enable"
        },
        props: {
          "value": $cmp.columnWidth,
          "minWidth": $cmp.def.minWidth,
          "maxWidth": $cmp.def.maxWidth,
          "internalTabIndex": $cmp.internalTabIndex,
          "label": $cmp.def.label,
          "tabIndex": api_tab_index($cmp.internalTabIndex),
          "colIndex": $cmp.colIndex,
          "step": $cmp.resizeStep
        },
        key: 17
      }, []) : null])];
    }

    var sortable = lwc.registerTemplate(tmpl$1g);
    tmpl$1g.stylesheets = [];
    tmpl$1g.stylesheetTokens = {
      hostAttribute: "lightning-primitiveHeaderFactory_sortableHeader-host",
      shadowAttribute: "lightning-primitiveHeaderFactory_sortableHeader"
    };

    function tmpl$1h($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element,
        ti: api_tab_index
      } = $api;
      return [api_element("div", {
        className: $cmp.computedClass,
        style: $cmp.columnStyles,
        key: 2
      }, [api_element("span", {
        classMap: {
          "slds-th__action": true
        },
        key: 3
      }, [$cmp.def.iconName ? api_element("div", {
        classMap: {
          "slds-grid": true,
          "slds-grid_vertical-align-center": true,
          "slds-has-flexi-truncate": true
        },
        key: 5
      }, [api_custom_element("lightning-icon", _lightningIcon, {
        classMap: {
          "slds-icon_container": true,
          "slds-m-right_xx-small": true
        },
        props: {
          "iconName": $cmp.def.iconName,
          "size": "x-small"
        },
        key: 6
      }, []), api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.def.label
        },
        key: 7
      }, [api_dynamic($cmp.def.label)])]) : null, !$cmp.def.iconName ? $cmp.def.label ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.def.label
        },
        key: 9
      }, [api_dynamic($cmp.def.label)]) : null : null, !$cmp.def.iconName ? !$cmp.def.label ? api_element("span", {
        classMap: {
          "slds-truncate": true
        },
        attrs: {
          "title": $cmp.def.ariaLabel
        },
        key: 10
      }, []) : null : null, $cmp.hasActions ? api_custom_element("lightning-primitive-header-actions", _lightningPrimitiveHeaderActions, {
        attrs: {
          "data-navigation": "enable"
        },
        props: {
          "colKeyValue": $cmp.def.colKeyValue,
          "actions": $cmp.actions,
          "tabIndex": api_tab_index($cmp.state.internalTabIndex)
        },
        key: 12
      }, []) : null, $cmp.isResizable ? api_custom_element("lightning-primitive-resize-handler", _lightningPrimitiveResizeHandler, {
        classMap: {
          "slds-resizable": true
        },
        attrs: {
          "data-navigation": "enable"
        },
        props: {
          "value": $cmp.columnWidth,
          "minWidth": $cmp.def.minWidth,
          "maxWidth": $cmp.def.maxWidth,
          "internalTabIndex": $cmp.internalTabIndex,
          "label": $cmp.def.label,
          "tabIndex": api_tab_index($cmp.internalTabIndex),
          "colIndex": $cmp.colIndex,
          "step": $cmp.resizeStep
        },
        key: 14
      }, []) : null])])];
    }

    var nonsortable = lwc.registerTemplate(tmpl$1h);
    tmpl$1h.stylesheets = [];
    tmpl$1h.stylesheetTokens = {
      hostAttribute: "lightning-primitiveHeaderFactory_nonsortableHeader-host",
      shadowAttribute: "lightning-primitiveHeaderFactory_nonsortableHeader"
    };

    const i18n$t = {
      chooseARow: labelChooseARow,
      selectAll: labelSelectAll,
      sort: labelSort,
      sortAsc: labelSortAsc,
      sortDesc: labelSortDesc,
      sortNone: labelSortNone
    };

    function preventDefaultAndStopPropagation$5(event) {
      event.preventDefault();
      event.stopPropagation();
    }

    class PrimitiveHeaderFactory extends PrimitiveDatatableCell$1 {
      constructor(...args) {
        super(...args);
        this.colIndex = void 0;
        this.sorted = void 0;
        this.sortedDirection = void 0;
        this.resizestep = void 0;
        this.columnWidth = void 0;
        this.actions = void 0;
        this.showCheckbox = false;
        this.dtContextId = void 0;
        this._resizable = void 0;
        this._def = {};
        this._sortable = false;
      }

      get resizable() {
        return this._resizable;
      }

      set resizable(value) {
        this._resizable = value;
        this.updateElementClasses();
      }

      get def() {
        return this._def;
      }

      set def(value) {
        this._def = value;
        this.updateElementClasses();
      }

      get sortable() {
        return this._sortable;
      }

      set sortable(value) {
        this._sortable = value;
        this.updateElementClasses();
      }

      render() {
        if (this.isSelectableHeader) {
          return selectable;
        } else if (this.sortable) {
          return sortable;
        }

        return nonsortable;
      }

      renderedCallback() {
        if (this.isSelectableHeader && this.showCheckbox) {
          this.updateBulkSelectionCheckbox();
        }
      }

      updateElementClasses() {
        classListMutation(this.classList, {
          'slds-text-title_caps': true,
          'slds-is-sortable': this.isSortable,
          'slds-is-resizable': this.isResizable
        });
      }

      get columnStyles() {
        const outlineStyle = this.isSortable ? '' : 'outline:none;';
        return `
            width: ${this.columnWidth}px;
            ${outlineStyle}
        `;
      }

      get computedClass() {
        return classSet('slds-cell-fixed').add({
          'slds-has-button-menu': this.hasActions
        }).toString();
      }

      get computedSortClass() {
        return classSet('slds-th__action slds-text-link_reset').add({
          'slds-is-sorted': this.sorted
        }).add({
          'slds-is-sorted_asc': this.isAscSorting
        }).add({
          'slds-is-sorted_desc': this.isDescSorting
        }).toString();
      }

      get isAscSorting() {
        return this.sortedDirection === 'asc';
      }

      get isDescSorting() {
        return this.sortedDirection === 'desc';
      }

      get sortedOrderLabel() {
        if (this.sorted) {
          return this.sortedDirection === 'desc' ? i18n$t.sortDesc : i18n$t.sortAsc;
        }

        return i18n$t.sortNone;
      }

      get isSelectableHeader() {
        return this.def.type === 'SELECTABLE_CHECKBOX';
      }

      get isRegularHeader() {
        return this.def.type !== 'SELECTABLE_CHECKBOX';
      }

      get isResizable() {
        return this.resizable && this.def.resizable !== false;
      }

      get isSortable() {
        return this.sortable;
      }

      get i18n() {
        return i18n$t;
      }

      get headerRole() {
        return this.isResizable || this.sortable ? 'button' : false;
      }

      get resizeStep() {
        return this.resizestep;
      }

      get computedOptionName() {
        return `${this.dtContextId}-options`;
      }

      handleSelectAllRows() {
        const actionName = this.def.bulkSelection === 'none' ? 'selectallrows' : 'deselectallrows'; // eslint-disable-next-line lightning-global/no-custom-event-identifier-arguments

        const actionEvent = new CustomEvent(actionName, {
          bubbles: true,
          composed: true
        });
        this.dispatchEvent(actionEvent);
      }

      handleSortingClick(event) {
        event.preventDefault();

        if (this.isSortable) {
          preventDefaultAndStopPropagation$5(event);
          this.fireSortedColumn(this.def.fieldName, this.getTargetSortDirection());
          this.fireCellFocusByClickEvent();
        }
      }

      handleSortingKeyDown(event) {
        if (this.isSortable && event.keyCode === keyCodes.enter) {
          preventDefaultAndStopPropagation$5(event);
          this.fireSortedColumn(this.def.fieldName, this.getTargetSortDirection());
        }
      }

      getTargetSortDirection() {
        if (this.sorted) {
          return this.sortedDirection === 'desc' ? 'asc' : 'desc';
        }

        return this.sortedDirection;
      }

      fireSortedColumn(fieldName, sortDirection) {
        const event = new CustomEvent('privateupdatecolsort', {
          bubbles: true,
          composed: true,
          detail: {
            fieldName,
            sortDirection
          }
        });
        this.dispatchEvent(event);
      }

      get hasActions() {
        return this.actions.customerActions.length > 0 || this.actions.internalActions.length > 0;
      }

      updateBulkSelectionCheckbox() {
        const allCheckbox = this.template.querySelector('.datatable-select-all');
        allCheckbox.indeterminate = this.def.bulkSelection === 'some'; // Note: since we have to handle the indeterminate state,
        //       this is to remove a raptor warning `Unneccessary update of property "checked"`

        allCheckbox.checked = !(this.def.bulkSelection === 'none');
      }

    }

    lwc.registerDecorators(PrimitiveHeaderFactory, {
      publicProps: {
        colIndex: {
          config: 0
        },
        sorted: {
          config: 0
        },
        sortedDirection: {
          config: 0
        },
        resizestep: {
          config: 0
        },
        columnWidth: {
          config: 0
        },
        actions: {
          config: 0
        },
        showCheckbox: {
          config: 0
        },
        dtContextId: {
          config: 0
        },
        resizable: {
          config: 3
        },
        def: {
          config: 3
        },
        sortable: {
          config: 3
        }
      },
      track: {
        _resizable: 1,
        _def: 1,
        _sortable: 1
      }
    });

    var _lightningPrimitiveHeaderFactory = lwc.registerComponent(PrimitiveHeaderFactory, {
      tmpl: _tmpl$1
    });

    var labelSelectItem = 'Select Item';

    function tmpl$1i($api, $cmp, $slotset, $ctx) {
      const {
        gid: api_scoped_id,
        ti: api_tab_index,
        b: api_bind,
        h: api_element,
        d: api_dynamic
      } = $api;
      const {
        _m0,
        _m1,
        _m2
      } = $ctx;
      return [api_element("span", {
        classMap: {
          "slds-checkbox": true
        },
        key: 2,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleCheckboxContainerClick)),
          "mousedown": _m2 || ($ctx._m2 = api_bind($cmp.handleCheckboxContainerMouseDown))
        }
      }, [api_element("input", {
        attrs: {
          "type": "checkbox",
          "name": $cmp.computedOptionName,
          "id": api_scoped_id("primitive-cell-checkbox-id"),
          "tabindex": api_tab_index($cmp.internalTabIndex),
          "data-navigation": "enable",
          "data-action-triggers": "space"
        },
        props: {
          "disabled": $cmp.isDisabled,
          "checked": $cmp.isSelected
        },
        key: 3,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleCheckboxClick))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-checkbox__label": true
        },
        attrs: {
          "for": `${api_scoped_id("primitive-cell-checkbox-id")}`
        },
        key: 4
      }, [api_element("span", {
        classMap: {
          "slds-checkbox_faux": true
        },
        key: 5
      }, []), api_element("span", {
        classMap: {
          "slds-form-element__label": true,
          "slds-assistive-text": true
        },
        key: 6
      }, [api_dynamic($cmp.selectItemAssistiveText)])])])];
    }

    var checkbox = lwc.registerTemplate(tmpl$1i);
    tmpl$1i.stylesheets = [];
    tmpl$1i.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellCheckbox_checkbox-host",
      shadowAttribute: "lightning-primitiveCellCheckbox_checkbox"
    };

    function tmpl$1j($api, $cmp, $slotset, $ctx) {
      const {
        gid: api_scoped_id,
        ti: api_tab_index,
        b: api_bind,
        h: api_element,
        d: api_dynamic
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("span", {
        classMap: {
          "slds-radio": true
        },
        key: 2
      }, [api_element("input", {
        attrs: {
          "type": "radio",
          "name": $cmp.computedOptionName,
          "id": api_scoped_id("primitive-checkbox-radio-id"),
          "tabindex": api_tab_index($cmp.internalTabIndex),
          "data-navigation": "enable",
          "data-action-triggers": "space",
          "aria-labelledby": api_scoped_id($cmp.ariaLabelledBy)
        },
        props: {
          "disabled": $cmp.isDisabled,
          "checked": $cmp.isSelected
        },
        key: 3,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleRadioClick)),
          "keydown": _m1 || ($ctx._m1 = api_bind($cmp.handleRadioKeyDown))
        }
      }, []), api_element("label", {
        classMap: {
          "slds-radio__label": true
        },
        attrs: {
          "for": `${api_scoped_id("primitive-checkbox-radio-id")}`
        },
        key: 4
      }, [api_element("span", {
        classMap: {
          "slds-radio_faux": true
        },
        key: 5
      }, []), api_element("span", {
        classMap: {
          "slds-form-element__label": true,
          "slds-assistive-text": true
        },
        key: 6
      }, [api_dynamic($cmp.selectItemAssistiveText)])])])];
    }

    var radio = lwc.registerTemplate(tmpl$1j);
    tmpl$1j.stylesheets = [];
    tmpl$1j.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellCheckbox_radio-host",
      shadowAttribute: "lightning-primitiveCellCheckbox_radio"
    };

    const i18n$u = {
      selectItem: labelSelectItem
    };

    class PrimitiveCellCheckbox extends PrimitiveDatatableCell$1 {
      constructor(...args) {
        super(...args);
        this.rowIndex = 0;
        this.isSelected = false;
        this.isDisabled = false;
        this.type = 'checkbox';
        this.dtContextId = void 0;
      }

      render() {
        if (this.type === 'radio') {
          return radio;
        }

        return checkbox;
      }

      get selectItemAssistiveText() {
        return `${i18n$u.selectItem} ${this.rowIndex + 1}`;
      }

      get labelId() {
        return `radio-button-label-${this.rowIndex + 1}`;
      }

      get ariaLabelledBy() {
        return `${this.labelId} radio-group-header`;
      }

      get computedOptionName() {
        return `${this.dtContextId}-options`;
      }

      handleRadioClick(event) {
        event.stopPropagation();

        if (!this.isSelected) {
          this.dispatchSelection(false);
        }
      }
      /**
       * We control the checkbox behaviour with the state and we handle it in the container,
       * but we need to prevent default in order to avoid the checkbox to change state
       * with the click and the generated click in the input from the label
       *
       * @param {Object} event - click event of the checkbox
       */


      handleCheckboxClick(event) {
        // click was catch on the input, stop propagation to avoid to be handled in container.
        // ideally you can let it bubble and be handled in there, but there is a raptor issue:
        // https://git.soma.salesforce.com/raptor/raptor/issues/838
        event.stopPropagation();
        this.dispatchSelection(event.shiftKey);
      }

      handleCheckboxContainerClick(event) {
        if (!this.isDisabled) {
          // click was catch in the label, the default its to activate the checkbox,
          // lets prevent it to avoid to send a double event.
          event.preventDefault();
          this.dispatchSelection(event.shiftKey);
        }
      }

      handleCheckboxContainerMouseDown(event) {
        // Prevent selecting text by Shift+click
        if (event.shiftKey) {
          event.preventDefault();
        }
      }

      handleRadioKeyDown(event) {
        const keyCode = event.keyCode;

        if (keyCode === keyCodes.left || keyCode === keyCodes.right) {
          // default behavior for radios is to select the prev/next radio with the same name
          event.preventDefault();
        }
      }

      dispatchSelection(isMultipleSelection) {
        const actionName = !this.isSelected ? 'selectrow' : 'deselectrow'; // eslint-disable-next-line lightning-global/no-custom-event-identifier-arguments

        const actionEvent = new CustomEvent(actionName, {
          bubbles: true,
          composed: true,
          detail: {
            rowKeyValue: this.rowKeyValue,
            isMultiple: isMultipleSelection
          }
        });
        this.dispatchEvent(actionEvent);
      }

    }

    lwc.registerDecorators(PrimitiveCellCheckbox, {
      publicProps: {
        rowIndex: {
          config: 0
        },
        isSelected: {
          config: 0
        },
        isDisabled: {
          config: 0
        },
        type: {
          config: 0
        },
        dtContextId: {
          config: 0
        }
      }
    });

    var _lightningPrimitiveCellCheckbox = lwc.registerComponent(PrimitiveCellCheckbox, {
      tmpl: _tmpl$1
    });

    function tmpl$1k($api, $cmp, $slotset, $ctx) {
      const {
        k: api_key,
        c: api_custom_element,
        i: api_iterator,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_custom_element("lightning-button-menu", _lightningButtonMenu, {
        props: {
          "iconSize": "x-small",
          "alternativeText": $cmp.buttonAlternateText,
          "menuAlignment": $cmp.computedMenuAlignment,
          "isLoading": $cmp.state.isLoadingActions,
          "loadingStateAlternativeText": $cmp.spinnerAlternateText
        },
        key: 2,
        on: {
          "select": _m0 || ($ctx._m0 = api_bind($cmp.handleActionSelect)),
          "open": _m1 || ($ctx._m1 = api_bind($cmp.handleMenuOpen))
        }
      }, api_iterator($cmp.state.actions, function (action) {
        return api_custom_element("lightning-menu-item", _lightningMenuItem, {
          props: {
            "value": action,
            "label": action.label,
            "iconName": action.iconName,
            "disabled": action.disabled
          },
          key: api_key(4, action.label)
        }, []);
      }))];
    }

    var _tmpl$10 = lwc.registerTemplate(tmpl$1k);
    tmpl$1k.stylesheets = [];
    tmpl$1k.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellActions_primitiveCellActions-host",
      shadowAttribute: "lightning-primitiveCellActions_primitiveCellActions"
    };

    var labelLoadingActions = 'Loading actions';

    var labelShowActions$1 = 'Show actions';

    const DEFAULT_MENU_ALIGNMENT = 'auto-right';
    const VALID_MENU_ALIGNMENT = ['auto-right', 'auto-left', 'auto', 'left', 'center', 'right', 'bottom-left', 'bottom-center', 'bottom-right'];
    const i18n$v = {
      loadingActions: labelLoadingActions,
      showActions: labelShowActions$1
    };

    class PrimitiveCellActions extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.rowKeyValue = void 0;
        this.colKeyValue = void 0;
        this.rowActions = void 0;
        this.containerRect = void 0;
        this.state = {
          actions: [],
          menuAlignment: DEFAULT_MENU_ALIGNMENT,
          internalTabIndex: false
        };
      }

      get menuAlignment() {
        return this.state.menuAlignment;
      }

      set menuAlignment(value) {
        this.state.menuAlignment = normalizeString(value, {
          fallbackValue: DEFAULT_MENU_ALIGNMENT,
          validValues: VALID_MENU_ALIGNMENT
        });
      }

      focus() {
        this.template.querySelector('lightning-button-menu').focus();
      }

      get computedMenuAlignment() {
        return this.menuAlignment;
      }

      get buttonAlternateText() {
        return `${i18n$v.showActions}`;
      }

      get spinnerAlternateText() {
        return `${i18n$v.loadingActions}`;
      }

      handleActionSelect(event) {
        this.dispatchEvent(new CustomEvent('privatecellactiontriggered', {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            rowKeyValue: this.rowKeyValue,
            colKeyValue: this.colKeyValue,
            action: event.detail.value
          }
        }));
      }

      handleMenuOpen() {
        this.elementRect = this.template.querySelector('lightning-button-menu').getBoundingClientRect();
        const detail = {
          rowKeyValue: this.rowKeyValue,
          colKeyValue: this.colKeyValue,
          doneCallback: this.finishLoadingActions.bind(this),
          saveContainerPosition: containerRect => {
            this.containerRect = containerRect;
          }
        };

        if (typeof this.rowActions === 'function') {
          this.state.isLoadingActions = true;
          this.state.actions = [];
          detail.actionsProviderFunction = this.rowActions; // This callback should always be async

          Promise.resolve().then(() => {
            this.dispatchEvent(new CustomEvent('privatecellactionmenuopening', {
              composed: true,
              bubbles: true,
              cancelable: true,
              detail
            }));
          });
        } else {
          this.state.actions = this.rowActions;
        }
      }

      finishLoadingActions(actions) {
        this.state.isLoadingActions = false;
        this.state.actions = actions;
      }

    }

    PrimitiveCellActions.delegatesFocus = true;

    lwc.registerDecorators(PrimitiveCellActions, {
      publicProps: {
        rowKeyValue: {
          config: 0
        },
        colKeyValue: {
          config: 0
        },
        rowActions: {
          config: 0
        },
        menuAlignment: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        containerRect: 1,
        state: 1
      }
    });

    var _lightningPrimitiveCellActions = lwc.registerComponent(PrimitiveCellActions, {
      tmpl: _tmpl$10
    });

    function tmpl$1l($api, $cmp, $slotset, $ctx) {
      const {
        ti: api_tab_index,
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-primitive-cell-actions", _lightningPrimitiveCellActions, {
        attrs: {
          "data-navigation": "enable",
          "data-action-triggers": "enter,space"
        },
        props: {
          "rowKeyValue": $cmp.rowKeyValue,
          "colKeyValue": $cmp.colKeyValue,
          "tabIndex": api_tab_index($cmp.internalTabIndex),
          "menuAlignment": $cmp.typeAttribute0,
          "rowActions": $cmp.typeAttribute1
        },
        key: 2
      }, [])];
    }

    var action = lwc.registerTemplate(tmpl$1l);
    tmpl$1l.stylesheets = [];
    tmpl$1l.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellTypes_action-host",
      shadowAttribute: "lightning-primitiveCellTypes_action"
    };

    function tmpl$1m($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [$cmp.isButtonIconType ? api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        className: $cmp.buttonClass,
        props: {
          "variant": $cmp.variant,
          "alternativeText": $cmp.alternativeText,
          "iconName": $cmp.iconName,
          "iconClass": $cmp.iconClass,
          "disabled": $cmp.disabled,
          "name": $cmp.buttonName,
          "title": $cmp.computedTitle
        },
        key: 3,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleButtonClick))
        }
      }, []) : null, !$cmp.isButtonIconType ? api_custom_element("lightning-button", _lightningButton, {
        className: $cmp.buttonClass,
        props: {
          "variant": $cmp.variant,
          "label": $cmp.label,
          "iconName": $cmp.iconName,
          "iconPosition": $cmp.iconPosition,
          "disabled": $cmp.disabled,
          "name": $cmp.buttonName,
          "title": $cmp.computedTitle
        },
        key: 5,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleButtonClick))
        }
      }, []) : null];
    }

    var _tmpl$11 = lwc.registerTemplate(tmpl$1m);
    tmpl$1m.stylesheets = [];
    tmpl$1m.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellButton_primitiveCellButton-host",
      shadowAttribute: "lightning-primitiveCellButton_primitiveCellButton"
    };

    class PrivateCellButton extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.rowKeyValue = void 0;
        this.colKeyValue = void 0;
        this.variant = void 0;
        this.label = void 0;
        this.iconName = void 0;
        this.iconPosition = void 0;
        this.buttonName = void 0;
        this.buttonClass = void 0;
        this.buttonTitle = void 0;
        this.internalTabIndex = void 0;
        this.type = void 0;
        this.alternativeText = void 0;
        this.iconClass = void 0;
        this.initialRender = true;
        this.buttonHasFocus = false;
        this.state = {
          disabled: false
        };
      }

      get computedTitle() {
        return this.buttonTitle || this.label;
      }

      get disabled() {
        return this.state.disabled;
      }

      set disabled(value) {
        const newValue = normalizeBoolean(value);
        const oldValue = this.state.disabled;

        if (oldValue === false && newValue === true && this.buttonHasFocus) {
          this.fireCellFalseBlurred();
        }

        this.state.disabled = newValue;
      }

      get isButtonIconType() {
        return this.type === 'button-icon';
      }

      renderedCallback() {
        if (this.initialRender) {
          this.addListeners();
        }

        this.initialRender = false;
      }

      get buttonCustomElement() {
        const qs = this.isButtonIconType ? 'lightning-button-icon' : 'lightning-button';
        return this.template.querySelector(qs);
      }

      addListeners() {
        const buttonCustomElement = this.buttonCustomElement;
        buttonCustomElement.addEventListener('focus', this.handleButtonFocused.bind(this));
        buttonCustomElement.addEventListener('blur', this.handleButtonBlurred.bind(this));
      }

      focus() {
        if (this.buttonCustomElement) {
          this.buttonCustomElement.focus();
        }
      }

      handleButtonFocused(event) {
        if (event.target.localName.indexOf('button') > -1) {
          this.buttonHasFocus = true;
        }
      }

      handleButtonBlurred(event) {
        if (event.target.localName.indexOf('button') > -1) {
          this.buttonHasFocus = false;
        }
      }

      fireCellFalseBlurred() {
        const {
          rowKeyValue,
          colKeyValue
        } = this;
        this.dispatchEvent(new CustomEvent('privatecellfalseblurred', {
          composed: true,
          bubbles: true,
          cancelable: true,
          detail: {
            rowKeyValue,
            colKeyValue
          }
        }));
      }

      handleButtonClick() {
        const {
          rowKeyValue,
          colKeyValue
        } = this; // fire this event in the next tick so that dt can do things it has to do for correct focus
        // eslint-disable-next-line lwc/no-set-timeout

        setTimeout(() => {
          this.dispatchEvent(new CustomEvent('privatecellbuttonclicked', {
            composed: true,
            bubbles: true,
            cancelable: true,
            detail: {
              rowKeyValue,
              colKeyValue
            }
          }));
        }, 0);
      }

    }

    PrivateCellButton.delegatesFocus = true;

    lwc.registerDecorators(PrivateCellButton, {
      publicProps: {
        rowKeyValue: {
          config: 0
        },
        colKeyValue: {
          config: 0
        },
        variant: {
          config: 0
        },
        label: {
          config: 0
        },
        iconName: {
          config: 0
        },
        iconPosition: {
          config: 0
        },
        buttonName: {
          config: 0
        },
        buttonClass: {
          config: 0
        },
        buttonTitle: {
          config: 0
        },
        internalTabIndex: {
          config: 0
        },
        type: {
          config: 0
        },
        alternativeText: {
          config: 0
        },
        iconClass: {
          config: 0
        },
        disabled: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        state: 1
      }
    });

    var _lightningPrimitiveCellButton = lwc.registerComponent(PrivateCellButton, {
      tmpl: _tmpl$11
    });

    function tmpl$1n($api, $cmp, $slotset, $ctx) {
      const {
        ti: api_tab_index,
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-primitive-cell-button", _lightningPrimitiveCellButton, {
        attrs: {
          "data-navigation": "enable",
          "data-action-triggers": "enter,space"
        },
        props: {
          "rowKeyValue": $cmp.rowKeyValue,
          "colKeyValue": $cmp.colKeyValue,
          "variant": $cmp.typeAttribute0,
          "label": $cmp.typeAttribute1,
          "iconName": $cmp.typeAttribute2,
          "iconPosition": $cmp.typeAttribute3,
          "disabled": $cmp.typeAttribute4,
          "buttonName": $cmp.typeAttribute5,
          "buttonClass": $cmp.typeAttribute6,
          "buttonTitle": $cmp.typeAttribute7,
          "tabIndex": api_tab_index($cmp.internalTabIndex),
          "internalTabIndex": $cmp.internalTabIndex
        },
        key: 2
      }, [])];
    }

    var button = lwc.registerTemplate(tmpl$1n);
    tmpl$1n.stylesheets = [];
    tmpl$1n.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellTypes_button-host",
      shadowAttribute: "lightning-primitiveCellTypes_button"
    };

    function tmpl$1o($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-formatted-number", _lightningFormattedNumber, {
        props: {
          "value": $cmp.value,
          "formatStyle": "currency",
          "currencyCode": $cmp.typeAttribute0,
          "currencyDisplayAs": $cmp.typeAttribute1,
          "minimumIntegerDigits": $cmp.typeAttribute2,
          "minimumFractionDigits": $cmp.typeAttribute3,
          "maximumFractionDigits": $cmp.typeAttribute4,
          "minimumSignificantDigits": $cmp.typeAttribute5,
          "maximumSignificantDigits": $cmp.typeAttribute6
        },
        key: 2
      }, [])];
    }

    var currency = lwc.registerTemplate(tmpl$1o);
    tmpl$1o.stylesheets = [];
    tmpl$1o.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellTypes_currency-host",
      shadowAttribute: "lightning-primitiveCellTypes_currency"
    };

    function tmpl$1p($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic
      } = $api;
      return [api_dynamic($cmp.formattedValue)];
    }

    var _tmpl$12 = lwc.registerTemplate(tmpl$1p);
    tmpl$1p.stylesheets = [];
    tmpl$1p.stylesheetTokens = {
      hostAttribute: "lightning-formattedDateTime_formattedDateTime-host",
      shadowAttribute: "lightning-formattedDateTime_formattedDateTime"
    };

    /**
     * Displays formatted date and time.
     */

    class LightningFormattedDateTime extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.value = void 0;
        this.weekday = void 0;
        this.era = void 0;
        this.year = void 0;
        this.month = void 0;
        this.day = void 0;
        this.hour = void 0;
        this.minute = void 0;
        this.second = void 0;
        this.timeZoneName = void 0;
        this.timeZone = void 0;
        this._hour12 = false;
        this._hour12Set = false;
      }

      /**
       * Determines whether time is displayed as 12-hour. If false, time displays as 24-hour. The default setting is determined by the user's locale.
       * @type {boolean}
       *
       */
      get hour12() {
        return this._hour12;
      }

      set hour12(value) {
        // If hour12 is not explicitly set then locale default is used instead.
        this._hour12Set = true;
        this._hour12 = normalizeBoolean(value);
      }

      get formattedValue() {
        return this.computeFormattedValue();
      }

      computeFormattedValue() {
        const {
          value
        } = this;

        if (!this.isEmpty(value) && this.isValid(value)) {
          const formatted = dateTimeFormat(this.getOptions()).format(value);

          if (formatted) {
            return formatted;
          }
        }

        this.printError(value);
        return '';
      }

      isEmpty(value) {
        return value === undefined || value === null || value === '';
      }

      isValid(value) {
        return isFinite(value) || isValidISODateTimeString(value);
      }

      printError(value) {
        const errorMsg = `<lightning-formatted-date-time> The value attribute accepts either a Date object, a timestamp, or a valid ISO8601 formatted string ` + `with timezone offset. but we are getting the ${typeof value} value "${value}" instead.`;
        console.warn(errorMsg); // eslint-disable-line no-console
      }

      getOptions() {
        const options = {
          weekday: this.weekday,
          era: this.era,
          year: this.year,
          month: this.month,
          day: this.day,
          hour: this.hour,
          minute: this.minute,
          second: this.second,
          timeZoneName: this.timeZoneName,
          timeZone: this.timeZone
        }; // If hour12 is set, then we use it, otherwise locale defaults will be used

        if (this._hour12Set) {
          options.hour12 = this.hour12;
        }

        return options;
      }

    }

    lwc.registerDecorators(LightningFormattedDateTime, {
      publicProps: {
        value: {
          config: 0
        },
        weekday: {
          config: 0
        },
        era: {
          config: 0
        },
        year: {
          config: 0
        },
        month: {
          config: 0
        },
        day: {
          config: 0
        },
        hour: {
          config: 0
        },
        minute: {
          config: 0
        },
        second: {
          config: 0
        },
        timeZoneName: {
          config: 0
        },
        timeZone: {
          config: 0
        },
        hour12: {
          config: 3
        }
      },
      track: {
        _hour12: 1,
        _hour12Set: 1
      }
    });

    var _lightningFormattedDateTime = lwc.registerComponent(LightningFormattedDateTime, {
      tmpl: _tmpl$12
    });

    function tmpl$1q($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-formatted-date-time", _lightningFormattedDateTime, {
        props: {
          "value": $cmp.dateValue,
          "day": $cmp.typeAttribute0,
          "era": $cmp.typeAttribute1,
          "hour": $cmp.typeAttribute2,
          "hour12": $cmp.typeAttribute3,
          "minute": $cmp.typeAttribute4,
          "month": $cmp.typeAttribute5,
          "second": $cmp.typeAttribute6,
          "timeZone": $cmp.typeAttribute7,
          "timeZoneName": $cmp.typeAttribute8,
          "weekday": $cmp.typeAttribute9,
          "year": $cmp.typeAttribute10
        },
        key: 2
      }, [])];
    }

    var date = lwc.registerTemplate(tmpl$1q);
    tmpl$1q.stylesheets = [];
    tmpl$1q.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellTypes_date-host",
      shadowAttribute: "lightning-primitiveCellTypes_date"
    };

    function tmpl$1r($api, $cmp, $slotset, $ctx) {
      const {
        ti: api_tab_index,
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-formatted-email", _lightningFormattedEmail, {
        attrs: {
          "data-navigation": "enable"
        },
        props: {
          "value": $cmp.value,
          "tabIndex": api_tab_index($cmp.internalTabIndex)
        },
        key: 2
      }, [])];
    }

    var email = lwc.registerTemplate(tmpl$1r);
    tmpl$1r.stylesheets = [];
    tmpl$1r.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellTypes_email-host",
      shadowAttribute: "lightning-primitiveCellTypes_email"
    };

    function tmpl$1s($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-formatted-location", _lightningFormattedLocation, {
        props: {
          "latitude": $cmp.value.latitude,
          "longitude": $cmp.value.longitude
        },
        key: 2
      }, [])];
    }

    var location = lwc.registerTemplate(tmpl$1s);
    tmpl$1s.stylesheets = [];
    tmpl$1s.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellTypes_location-host",
      shadowAttribute: "lightning-primitiveCellTypes_location"
    };

    function tmpl$1t($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-formatted-number", _lightningFormattedNumber, {
        props: {
          "value": $cmp.value,
          "minimumIntegerDigits": $cmp.typeAttribute0,
          "minimumFractionDigits": $cmp.typeAttribute1,
          "maximumFractionDigits": $cmp.typeAttribute2,
          "minimumSignificantDigits": $cmp.typeAttribute3,
          "maximumSignificantDigits": $cmp.typeAttribute4
        },
        key: 2
      }, [])];
    }

    var number = lwc.registerTemplate(tmpl$1t);
    tmpl$1t.stylesheets = [];
    tmpl$1t.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellTypes_number-host",
      shadowAttribute: "lightning-primitiveCellTypes_number"
    };

    function tmpl$1u($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-formatted-number", _lightningFormattedNumber, {
        props: {
          "value": $cmp.value,
          "formatStyle": "percent",
          "minimumIntegerDigits": $cmp.typeAttribute0,
          "minimumFractionDigits": $cmp.typeAttribute1,
          "maximumFractionDigits": $cmp.typeAttribute2,
          "minimumSignificantDigits": $cmp.typeAttribute3,
          "maximumSignificantDigits": $cmp.typeAttribute4
        },
        key: 2
      }, [])];
    }

    var percent = lwc.registerTemplate(tmpl$1u);
    tmpl$1u.stylesheets = [];
    tmpl$1u.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellTypes_percent-host",
      shadowAttribute: "lightning-primitiveCellTypes_percent"
    };

    function tmpl$1v($api, $cmp, $slotset, $ctx) {
      const {
        ti: api_tab_index,
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-formatted-phone", _lightningFormattedPhone, {
        attrs: {
          "data-navigation": "enable"
        },
        props: {
          "value": $cmp.value,
          "tabIndex": api_tab_index($cmp.internalTabIndex)
        },
        key: 2
      }, [])];
    }

    var phone = lwc.registerTemplate(tmpl$1v);
    tmpl$1v.stylesheets = [];
    tmpl$1v.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellTypes_phone-host",
      shadowAttribute: "lightning-primitiveCellTypes_phone"
    };

    function tmpl$1w($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0,
        _m1,
        _m2
      } = $ctx;
      return [api_element("button", {
        className: $cmp.computedButtonClass,
        attrs: {
          "data-trigger": "true",
          "tabindex": api_tab_index($cmp.internalTabIndex)
        },
        key: 2,
        on: {
          "mouseover": _m0 || ($ctx._m0 = api_bind($cmp.handleMouseOver)),
          "mouseout": _m1 || ($ctx._m1 = api_bind($cmp.handleMouseOut)),
          "click": _m2 || ($ctx._m2 = api_bind($cmp.handleClick))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.computedHeaderIconName,
          "variant": $cmp.variant,
          "size": $cmp.size
        },
        key: 3
      }, []), $cmp.alternativeText ? api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 4
      }, [api_dynamic($cmp.alternativeText)]) : null])];
    }

    var _tmpl$13 = lwc.registerTemplate(tmpl$1w);
    tmpl$1w.stylesheets = [];
    tmpl$1w.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableTooltip_primitiveDatatableTooltip-host",
      shadowAttribute: "lightning-primitiveDatatableTooltip_primitiveDatatableTooltip"
    };

    function tmpl$1x($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element,
        h: api_element,
        d: api_dynamic,
        gid: api_scoped_id,
        k: api_key,
        i: api_iterator
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3
      } = $ctx;
      return [api_element("section", {
        styleMap: {
          "outline": "none"
        },
        attrs: {
          "role": "dialog",
          "aria-describedby": `${api_scoped_id("primitive-datatable-tooltip-bubble-body-id")}`,
          "aria-labelledby": `${api_scoped_id("primitive-datatable-tooltip-bubble-header-id")}`,
          "tabindex": "0"
        },
        key: 2,
        on: {
          "focusout": _m2 || ($ctx._m2 = api_bind($cmp.handleBlur)),
          "keydown": _m3 || ($ctx._m3 = api_bind($cmp.handleBubbleKey))
        }
      }, [!$cmp.hideCloseButton ? api_custom_element("lightning-button-icon", _lightningButtonIcon, {
        classMap: {
          "slds-float_right": true,
          "slds-popover__close": true
        },
        attrs: {
          "data-close": "true"
        },
        props: {
          "iconName": "utility:close",
          "variant": "bare-inverse",
          "size": "small",
          "alternativeText": $cmp.i18n.closeButtonAssistiveText
        },
        key: 4,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleCloseButtonClick)),
          "keydown": _m1 || ($ctx._m1 = api_bind($cmp.handleCloseButtonKey))
        }
      }, []) : null, api_element("header", {
        classMap: {
          "slds-popover__header": true
        },
        key: 5
      }, [api_element("div", {
        classMap: {
          "slds-media": true,
          "slds-media_center": true,
          "slds-has-flexi-truncate": true
        },
        key: 6
      }, [api_element("div", {
        classMap: {
          "slds-media__figure": true
        },
        key: 7
      }, [api_element("span", {
        classMap: {
          "slds-icon_container": true,
          "slds-icon-utility-ban": true
        },
        key: 8
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": $cmp.computedHeaderIconName,
          "size": "x-small",
          "variant": "inverse"
        },
        key: 9
      }, [])])]), api_element("div", {
        classMap: {
          "slds-media__body": true
        },
        key: 10
      }, [api_element("h2", {
        classMap: {
          "slds-truncate": true,
          "slds-text-heading_medium": true
        },
        attrs: {
          "id": api_scoped_id("primitive-datatable-tooltip-bubble-header-id"),
          "title": $cmp.header
        },
        key: 11
      }, [api_dynamic($cmp.header)])])])]), api_element("div", {
        classMap: {
          "slds-popover__body": true
        },
        attrs: {
          "id": api_scoped_id("primitive-datatable-tooltip-bubble-body-id")
        },
        key: 12
      }, [$cmp.isContentList ? api_element("ul", {
        styleMap: {
          "listStyle": "disc",
          "marginLeft": "1.5rem"
        },
        key: 14
      }, api_iterator($cmp.content, function (item, index) {
        return api_element("li", {
          key: api_key(16, item)
        }, [api_dynamic(item)]);
      })) : null, !$cmp.isContentList ? api_dynamic($cmp.content) : null])])];
    }

    var _tmpl$14 = lwc.registerTemplate(tmpl$1x);
    tmpl$1x.stylesheets = [];
    tmpl$1x.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableTooltipBubble_primitiveDatatableTooltipBubble-host",
      shadowAttribute: "lightning-primitiveDatatableTooltipBubble_primitiveDatatableTooltipBubble"
    };

    var labelCloseButtonAssistiveText = 'Close dialog';

    const i18n$w = {
      closeButtonAssistiveText: labelCloseButtonAssistiveText
    };
    const DEFAULT_ALIGN$1 = {
      horizontal: 'left',
      vertical: 'bottom'
    };

    class LightningPrimitiveDatatableTooltipBubble extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.state = {
          inDom: false,
          visible: false,
          align: DEFAULT_ALIGN$1
        };
        this.anchor = void 0;
        this.header = '';
        this.content = '';
        this.variant = 'bare';
        this.hideCloseButton = false;

        this.handleBlur = evt => {
          // A valid blur is when the focus goes to an element outside the bubble.
          // If the element with the focus is inside the bubble, then the component as a whole was not blurred.
          const isValidBlur = evt.relatedTarget === null || !this.template.contains(evt.relatedTarget);

          if (isValidBlur) {
            this.handleBubbleFocusLost();
          }
        };

        this.handleBubbleFocusLost = () => {
          this.dispatchCloseButtonEvent('bubbleLoseFocus');
        };

        this.handleBubbleKey = event => {
          if (keyCodes.escape === event.keyCode) {
            this.dispatchCloseButtonEvent();
          }

          if (keyCodes.tab === event.keyCode) {
            event.preventDefault();
            event.stopPropagation();
            this.focus();
          }
        };

        this.handleCloseButtonClick = () => {
          this.dispatchCloseButtonEvent();
        };

        this.handleCloseButtonKey = event => {
          // block tab and all other keys to keep focus
          event.preventDefault();
          event.stopPropagation();
          const keysToClose = [keyCodes.enter, keyCodes.space, keyCodes.escape];

          if (keysToClose.includes(event.keyCode)) {
            this.dispatchCloseButtonEvent();
          }
        };
      }

      connectedCallback() {
        this.state.inDOM = true;
        this.updateClassList();
      }

      disconnectedCallback() {
        this.state.inDOM = false;
      }

      get align() {
        return this.state.align;
      }

      set align(value) {
        this.state.align = value;

        if (this.state.inDOM) {
          this.updateClassList();
        }
      }

      get visible() {
        return this.state.visible;
      }

      set visible(value) {
        this.state.visible = value;

        if (this.state.inDOM) {
          this.updateClassList();
        }
      }

      focus() {
        this.closeButton.focus();
      }

      get i18n() {
        return i18n$w;
      }

      get isContentList() {
        return Array.isArray(this.content);
      }

      get computedHeaderIconName() {
        switch (this.variant) {
          case 'error':
            return 'utility:ban';

          case 'warning':
            return 'utility:warning';

          case 'bare':
          default:
            return 'utility:info';
        }
      }

      get closeButton() {
        return this.template.querySelector('[data-close="true"]');
      }

      updateClassList() {
        const classes = classSet('slds-popover');
        classes.add({
          'slds-popover_error': this.variant === 'error',
          'slds-popover_warning': this.variant === 'warning'
        }); // apply fading effect

        classes.add({
          'slds-rise-from-ground': this.state.visible === true,
          'slds-fall-into-ground': this.state.visible === false
        }); // apply the proper nubbin CSS class

        const {
          horizontal,
          vertical
        } = this.align;
        classes.add({
          'slds-nubbin_top-left': horizontal === 'left' && vertical === 'top',
          'slds-nubbin_top-right': horizontal === 'right' && vertical === 'top',
          'slds-nubbin_bottom-left': horizontal === 'left' && vertical === 'bottom',
          'slds-nubbin_bottom-right': horizontal === 'right' && vertical === 'bottom'
        });
        classListMutation(this.classList, classes);
      }

      dispatchCloseButtonEvent(reason) {
        this.dispatchEvent(new CustomEvent('close', {
          detail: {
            reason: reason || 'userCloseBubble',
            anchor: this.anchor
          }
        }));
      }

    }

    lwc.registerDecorators(LightningPrimitiveDatatableTooltipBubble, {
      publicProps: {
        anchor: {
          config: 0
        },
        header: {
          config: 0
        },
        content: {
          config: 0
        },
        variant: {
          config: 0
        },
        hideCloseButton: {
          config: 0
        },
        align: {
          config: 3
        },
        visible: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        state: 1
      }
    });

    var LightningPrimitiveDatatableTooltipBubble$1 = lwc.registerComponent(LightningPrimitiveDatatableTooltipBubble, {
      tmpl: _tmpl$14
    });

    function getBubbleAlignAndPosition(triggerBoundingClientRect, bubbleBoundingClientRect, defaultAlign, shiftAmounts, availableHeight, availableWidth, xOffset, yOffset) {
      const bubbleOverflows = {};
      const align = {
        horizontal: defaultAlign.horizontal,
        vertical: defaultAlign.vertical
      };
      const positionAt = {
        top: null,
        right: null,
        bottom: null,
        left: null
      };
      bubbleOverflows.right = triggerBoundingClientRect.left + bubbleBoundingClientRect.width > availableWidth;
      bubbleOverflows.left = triggerBoundingClientRect.right - bubbleBoundingClientRect.width < 0;
      bubbleOverflows.top = triggerBoundingClientRect.top - (bubbleBoundingClientRect.height + shiftAmounts.vertical) < 0;
      bubbleOverflows.bottom = triggerBoundingClientRect.bottom + bubbleBoundingClientRect.height + shiftAmounts.vertical > availableHeight;

      if (bubbleOverflows.right) {
        align.horizontal = 'right';
        positionAt.right = availableWidth - triggerBoundingClientRect.right;
      }

      if (bubbleOverflows.left) {
        align.horizontal = 'left';
        positionAt.left = triggerBoundingClientRect.right;
      }

      if (bubbleOverflows.top) {
        align.vertical = 'top';
        positionAt.top = triggerBoundingClientRect.bottom;
      }

      if (bubbleOverflows.bottom) {
        align.vertical = 'bottom';
        positionAt.bottom = availableHeight - triggerBoundingClientRect.top;
      }

      const result = {
        align
      }; // assign default values for position bottom & left based on trigger element if needed
      // - default anchor point of popover is bottom left attached to trigger element's top left

      positionAt.bottom = positionAt.top || positionAt.top === 0 ? null : availableHeight - triggerBoundingClientRect.top;
      positionAt.left = positionAt.right || positionAt.right === 0 ? null : triggerBoundingClientRect.left; // apply calculated position values

      result.top = positionAt.top ? positionAt.top + shiftAmounts.vertical + yOffset + 'px' : positionAt.top;
      result.right = positionAt.right ? positionAt.right - shiftAmounts.horizontal - xOffset + 'px' : positionAt.right;
      result.bottom = positionAt.bottom ? positionAt.bottom + shiftAmounts.vertical - yOffset + 'px' : positionAt.bottom;
      result.left = positionAt.left ? positionAt.left - shiftAmounts.horizontal + xOffset + 'px' : positionAt.left;
      return result;
    }
    function getNubbinShiftAmount(nubbinComputedStyles, triggerWidth) {
      // calculate smallest positive value of horizontal nubbin distance, right or left
      // - the nubbin is the pointy element on the bubble
      const nubbinShiftLeft = parseInt(nubbinComputedStyles.left, 10) || -1;
      const nubbinShiftRight = parseInt(nubbinComputedStyles.right, 10) || -1; // check which measurement is the lesser of the two (closest to edge)

      let nubbinShift = nubbinShiftLeft < nubbinShiftRight ? nubbinShiftLeft : nubbinShiftRight; // use the positive, greater than zero, shift value

      if (nubbinShift < 0 && nubbinShiftLeft < 0 && nubbinShiftRight > 0) {
        nubbinShift = nubbinShiftRight;
      }

      if (nubbinShift < 0 && nubbinShiftRight < 0 && nubbinShiftLeft > 0) {
        nubbinShift = nubbinShiftLeft;
      }

      return {
        horizontal: nubbinShift - triggerWidth / 2,
        // prettier-ignore
        vertical: parseInt(nubbinComputedStyles.height, 10)
      };
    }

    function _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$4(target, key, source[key]); }); } return target; }

    function _defineProperty$4(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
    const CACHED_BUBBLE_ELEMENT$1 = lwc.createElement('lightning-primitive-datatable-tooltip-bubble', {
      is: LightningPrimitiveDatatableTooltipBubble$1
    });
    CACHED_BUBBLE_ELEMENT$1.style.position = 'absolute';
    CACHED_BUBBLE_ELEMENT$1.style.minWidth = '75px';
    const DEFAULT_ANCHORING = {
      trigger: {
        horizontal: 'left',
        vertical: 'top'
      },
      bubble: {
        horizontal: 'left',
        vertical: 'bottom'
      }
    };
    const ZERO_OFFSET = {
      horizontal: 0,
      // right if > 0, left if < 0
      vertical: 0 // down if > 0, up if < 0

    };

    class LightningPrimitiveDatatableTooltip extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.header = '';
        this.content = [];
        this.size = 'medium';
        this.trigger = 'click';
        this.hideCloseButton = false;
        this.variant = 'bare';
        this.alternativeText = void 0;
        this.internalTabIndex = void 0;
        this._uniqueId = `primitive-datatable-tooltip_${guid()}`;
        this.state = {
          showErrorBubble: false,
          offset: ZERO_OFFSET
        };
        this.handleBrowserEvent = raf(() => {
          // only perform changes for the currently focused/active trigger
          if (this.state.showErrorBubble && this.isBubbleAttachedToTrigger()) {
            this.setBubblePosition();
          }
        });

        this.handleBubbleClose = event => {
          // only keep 1 listener at a time and always turn off this.state.showErrorBubble
          // on close
          const bubbleEl = CACHED_BUBBLE_ELEMENT$1;
          bubbleEl.removeEventListener('close', this.handleBubbleClose);

          if (event.detail.anchor === this._uniqueId) {
            this.hideBubble();

            if (event.detail.reason !== 'bubbleLoseFocus') {
              this.triggerElement.focus();
            }
          }
        };
      }

      connectedCallback() {
        // watch for resize & scroll events to recalculate when needed
        window.addEventListener('resize', this.handleBrowserEvent, false);
        window.addEventListener('scroll', this.handleBrowserEvent, true);
      }

      disconnectedCallback() {
        // remove event listeners
        window.removeEventListener('resize', this.handleBrowserEvent, false);
        window.removeEventListener('scroll', this.handleBrowserEvent, true);
        const bubbleEl = CACHED_BUBBLE_ELEMENT$1;
        bubbleEl.removeEventListener('close', this.handleBubbleClose);
      }

      get offset() {
        return this.state.offset;
      }

      set offset(value) {
        this.state.offset = _objectSpread$4({}, ZERO_OFFSET, value);
      }

      focus() {
        this.triggerElement.focus();
      }

      get computedButtonClass() {
        const classes = classSet('slds-button').add('slds-button_icon');
        classes.add({
          'slds-button_icon-error': this.variant === 'error'
        });
        return classes.toString();
      }

      get computedHeaderIconName() {
        switch (this.variant) {
          case 'error':
            return 'utility:ban';

          case 'warning':
            return 'utility:warning';

          case 'bare':
          default:
            return 'utility:info';
        }
      }

      get triggerElement() {
        return this.template.querySelector('[data-trigger="true"]');
      }

      handleMouseOver() {
        if (this.trigger === 'hover') {
          this.showBubble();
        }
      }

      handleMouseOut() {
        if (this.trigger === 'hover') {
          this.hideBubble();
          this.triggerElement.focus();
        }
      }

      handleClick(event) {
        event.preventDefault();

        if (this.trigger === 'click') {
          // since we share bubble element with other tooltip triggers,
          // we need to keep it open if bubble is not attached to the trigger
          if (this.state.showErrorBubble && this.isBubbleAttachedToTrigger()) {
            this.hideBubble();
          } else {
            this.showBubble();
          }
        }
      }

      showBubble() {
        this.state.showErrorBubble = true;
        const bubbleEl = CACHED_BUBBLE_ELEMENT$1;
        this.initBubble();
        this.setBubblePosition();
        bubbleEl.visible = true; // 100ms for bubble to fade in before becoming focusable
        // eslint-disable-next-line lwc/no-set-timeout

        setTimeout(() => {
          bubbleEl.focus();
        }, 100);
      }

      hideBubble() {
        this.state.showErrorBubble = false;
        const bubbleEl = CACHED_BUBBLE_ELEMENT$1;
        bubbleEl.visible = false; // 25ms for bubble to fade out before trigger becoming focusable
        // eslint-disable-next-line lwc/no-set-timeout

        setTimeout(() => {
          this.focus();
        }, 25);
      }

      isBubbleAttachedToTrigger() {
        return CACHED_BUBBLE_ELEMENT$1.anchor === this._uniqueId;
      }

      getTriggerBoundingRect() {
        return this.triggerElement ? this.triggerElement.getBoundingClientRect() : null;
      }

      calculateShiftAmounts() {
        // only calculate once
        if (typeof this.shiftAmounts === 'undefined') {
          const bubbleEl = CACHED_BUBBLE_ELEMENT$1; // initialize position in top left corner

          bubbleEl.style.top = 0;
          bubbleEl.style.left = 0;
          bubbleEl.style.bottom = null;
          bubbleEl.style.right = null; // calculate initial position of trigger element

          const triggerElRect = this.getTriggerBoundingRect(); // calculate shift to align nubbin

          const nubbinComputedStyles = window.getComputedStyle(bubbleEl, ':before') || bubbleEl.style;
          this.shiftAmounts = getNubbinShiftAmount(nubbinComputedStyles, triggerElRect.width);
        }
      }

      initBubble() {
        const bubbleEl = CACHED_BUBBLE_ELEMENT$1;
        bubbleEl.anchor = this._uniqueId;
        bubbleEl.content = this.content;
        bubbleEl.header = this.header;
        bubbleEl.variant = this.variant;
        bubbleEl.hideCloseButton = this.hideCloseButton;
        bubbleEl.addEventListener('close', this.handleBubbleClose);

        if (bubbleEl.parentNode === null) {
          document.body.appendChild(bubbleEl);
        }

        this.calculateShiftAmounts();
      }

      setBubblePosition() {
        const rootEl = document.documentElement;
        const bubbleEl = CACHED_BUBBLE_ELEMENT$1;
        const result = getBubbleAlignAndPosition(this.getTriggerBoundingRect(), bubbleEl.getBoundingClientRect(), DEFAULT_ANCHORING.bubble, this.shiftAmounts, rootEl.clientHeight || window.innerHeight, rootEl.clientWidth || window.innerWidth, window.pageXOffset + this.offset.horizontal, window.pageYOffset + this.offset.vertical);
        bubbleEl.align = result.align;
        bubbleEl.style.top = result.top;
        bubbleEl.style.right = result.right;
        bubbleEl.style.bottom = result.bottom;
        bubbleEl.style.left = result.left;
      }

    }

    lwc.registerDecorators(LightningPrimitiveDatatableTooltip, {
      publicProps: {
        header: {
          config: 0
        },
        content: {
          config: 0
        },
        size: {
          config: 0
        },
        trigger: {
          config: 0
        },
        hideCloseButton: {
          config: 0
        },
        variant: {
          config: 0
        },
        alternativeText: {
          config: 0
        },
        internalTabIndex: {
          config: 0
        },
        offset: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        state: 1
      }
    });

    var _lightningPrimitiveDatatableTooltip = lwc.registerComponent(LightningPrimitiveDatatableTooltip, {
      tmpl: _tmpl$13
    });

    function tmpl$1y($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        h: api_element
      } = $api;
      return [api_custom_element("lightning-primitive-datatable-tooltip", _lightningPrimitiveDatatableTooltip, {
        className: $cmp.rowNumberErrorClass,
        attrs: {
          "data-navigation": "enable",
          "data-action-triggers": "enter,space"
        },
        props: {
          "size": "xx-small",
          "header": $cmp.typeAttribute0.title,
          "content": $cmp.typeAttribute0.messages,
          "variant": "error",
          "internalTabIndex": $cmp.internalTabIndex,
          "alternativeText": $cmp.typeAttribute0.alternativeText
        },
        key: 2
      }, []), api_element("span", {
        classMap: {
          "slds-row-number": true,
          "slds-text-body_small": true,
          "slds-text-color_weak": true
        },
        key: 3
      }, [])];
    }

    var rowNumber = lwc.registerTemplate(tmpl$1y);
    tmpl$1y.stylesheets = [];
    tmpl$1y.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellTypes_rowNumber-host",
      shadowAttribute: "lightning-primitiveCellTypes_rowNumber"
    };

    function tmpl$1z($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-formatted-text", _lightningFormattedText, {
        props: {
          "value": $cmp.value
        },
        key: 2
      }, [])];
    }

    var text = lwc.registerTemplate(tmpl$1z);
    tmpl$1z.stylesheets = [];
    tmpl$1z.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellTypes_text-host",
      shadowAttribute: "lightning-primitiveCellTypes_text"
    };

    function tmpl$1A($api, $cmp, $slotset, $ctx) {
      const {
        ti: api_tab_index,
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-formatted-url", _lightningFormattedUrl, {
        attrs: {
          "data-navigation": "enable"
        },
        props: {
          "value": $cmp.value,
          "tooltip": $cmp.urlTooltip,
          "tabIndex": api_tab_index($cmp.internalTabIndex),
          "label": $cmp.typeAttribute0,
          "target": $cmp.urlTarget
        },
        key: 2
      }, [])];
    }

    var url = lwc.registerTemplate(tmpl$1A);
    tmpl$1A.stylesheets = [];
    tmpl$1A.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellTypes_url-host",
      shadowAttribute: "lightning-primitiveCellTypes_url"
    };

    function tmpl$1B($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        h: api_element
      } = $api;
      return [$cmp.isChecked ? api_element("temaplte", {
        key: 2
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "size": "x-small",
          "iconName": "utility:check"
        },
        key: 3
      }, [])]) : null];
    }

    var boolean = lwc.registerTemplate(tmpl$1B);
    tmpl$1B.stylesheets = [];
    tmpl$1B.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellTypes_boolean-host",
      shadowAttribute: "lightning-primitiveCellTypes_boolean"
    };

    function tmpl$1C($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-formatted-date-time", _lightningFormattedDateTime, {
        props: {
          "value": $cmp.value,
          "day": $cmp.computedDateLocalDay,
          "month": $cmp.computedDateLocalMonth,
          "year": $cmp.computedDateLocalYear,
          "timeZone": "UTC"
        },
        key: 2
      }, [])];
    }

    var dateLocal = lwc.registerTemplate(tmpl$1C);
    tmpl$1C.stylesheets = [];
    tmpl$1C.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellTypes_dateLocal-host",
      shadowAttribute: "lightning-primitiveCellTypes_dateLocal"
    };

    function tmpl$1D($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-primitive-cell-button", _lightningPrimitiveCellButton, {
        attrs: {
          "data-navigation": "enable",
          "data-action-triggers": "enter,space"
        },
        props: {
          "type": "button-icon",
          "rowKeyValue": $cmp.rowKeyValue,
          "colKeyValue": $cmp.colKeyValue,
          "variant": $cmp.typeAttribute0,
          "alternativeText": $cmp.typeAttribute1,
          "iconName": $cmp.typeAttribute2,
          "iconClass": $cmp.typeAttribute3,
          "disabled": $cmp.typeAttribute4,
          "buttonName": $cmp.typeAttribute5,
          "buttonClass": $cmp.typeAttribute6,
          "buttonTitle": $cmp.typeAttribute7,
          "internalTabIndex": $cmp.internalTabIndex
        },
        key: 2
      }, [])];
    }

    var buttonIcon = lwc.registerTemplate(tmpl$1D);
    tmpl$1D.stylesheets = [];
    tmpl$1D.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellTypes_buttonIcon-host",
      shadowAttribute: "lightning-primitiveCellTypes_buttonIcon"
    };

    const typesMap = {
      action,
      button,
      currency,
      date,
      email,
      location,
      number,
      percent,
      phone,
      rowNumber,
      text,
      url,
      boolean,
      'date-local': dateLocal,
      'button-icon': buttonIcon
    };

    class PrimitiveTypes extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.types = void 0;
        this.columnType = void 0;
        this.value = void 0;
        this.columnLabel = void 0;
        this.rowKeyValue = void 0;
        this.colKeyValue = void 0;
        this.columnSubType = void 0;
        this.typeAttribute0 = void 0;
        this.typeAttribute1 = void 0;
        this.typeAttribute2 = void 0;
        this.typeAttribute3 = void 0;
        this.typeAttribute4 = void 0;
        this.typeAttribute5 = void 0;
        this.typeAttribute6 = void 0;
        this.typeAttribute7 = void 0;
        this.typeAttribute8 = void 0;
        this.typeAttribute9 = void 0;
        this.typeAttribute10 = void 0;
        this.typeAttribute21 = void 0;
        this.typeAttribute22 = void 0;
        this.internalTabIndex = void 0;
        this.keyboardMode = void 0;
      }

      get type() {
        const type = this.types.getType(this.columnType);

        if (type.type === 'custom') {
          return type.template;
        }

        if (this.columnType === 'tree' && typesMap[this.columnSubType]) {
          return typesMap[this.columnSubType];
        }

        if (typesMap[this.columnType]) {
          return typesMap[this.columnType];
        }

        return typesMap.text;
      }

      render() {
        return this.type;
      }

      get hasTreeData() {
        return this.columnType === 'tree';
      }

      get urlTarget() {
        return this.typeAttribute1 || '_self';
      }

      get urlTooltip() {
        if (this.typeAttribute2 === '') {
          return '';
        }

        return this.typeAttribute2 || this.value;
      }

      get isChecked() {
        return !!this.value;
      }

      get typeAttributes() {
        const typeAttributes = this.types.getType(this.columnType).typeAttributes;

        if (Array.isArray(typeAttributes)) {
          return typeAttributes.reduce((seed, attrName, index) => {
            seed[attrName] = this[`typeAttribute${index}`];
            return seed;
          }, {});
        }

        return {};
      }

      get dateValue() {
        // new Date(null) returns new Date(0), which is not expected.
        // for undefined, '', or any other invalid values, formatted-date-time
        // just displays ''
        if (this.value === null) {
          return '';
        } // this is temporary, formatted-date-time should accept
        // date time string formats like '2017-03-01 08:45:12Z'
        // it's accepting only timestamp and Date objects


        return new Date(this.value);
      }

      get computedDateLocalDay() {
        return this.typeAttribute0 || 'numeric';
      }

      get computedDateLocalMonth() {
        return this.typeAttribute1 || 'short';
      }

      get computedDateLocalYear() {
        return this.typeAttribute2 || 'numeric';
      }

      get rowNumberErrorClass() {
        const classes = classSet('slds-m-horizontal_xxx-small');
        const error = this.typeAttribute0;

        if (error) {
          classes.add({
            'slds-hidden': !error.title && !error.messages
          });
        }

        return classes.toString();
      }

      getActionableElements() {
        return queryFocusable(this.template);
      }

    }

    lwc.registerDecorators(PrimitiveTypes, {
      publicProps: {
        types: {
          config: 0
        },
        columnType: {
          config: 0
        },
        value: {
          config: 0
        },
        columnLabel: {
          config: 0
        },
        rowKeyValue: {
          config: 0
        },
        colKeyValue: {
          config: 0
        },
        columnSubType: {
          config: 0
        },
        typeAttribute0: {
          config: 0
        },
        typeAttribute1: {
          config: 0
        },
        typeAttribute2: {
          config: 0
        },
        typeAttribute3: {
          config: 0
        },
        typeAttribute4: {
          config: 0
        },
        typeAttribute5: {
          config: 0
        },
        typeAttribute6: {
          config: 0
        },
        typeAttribute7: {
          config: 0
        },
        typeAttribute8: {
          config: 0
        },
        typeAttribute9: {
          config: 0
        },
        typeAttribute10: {
          config: 0
        },
        typeAttribute21: {
          config: 0
        },
        typeAttribute22: {
          config: 0
        },
        internalTabIndex: {
          config: 0
        },
        keyboardMode: {
          config: 0
        }
      },
      publicMethods: ["getActionableElements"]
    });

    var _lightningPrimitiveCellTypes = lwc.registerComponent(PrimitiveTypes, {
      tmpl: _tmpl$1
    });

    function tmpl$1E($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element,
        ti: api_tab_index,
        b: api_bind
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("button", {
        className: $cmp.computedButtonClass,
        attrs: {
          "type": "button",
          "tabindex": api_tab_index($cmp.buttonTabIndex),
          "title": $cmp.buttonTitle
        },
        key: 2,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleChevronClick))
        }
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:chevronright",
          "variant": "bare",
          "svgClass": "slds-button__icon slds-button__icon_small"
        },
        key: 3
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 4
      }, [api_dynamic($cmp.buttonTitle)])])];
    }

    var _tmpl$15 = lwc.registerTemplate(tmpl$1E);
    tmpl$1E.stylesheets = [];
    tmpl$1E.stylesheetTokens = {
      hostAttribute: "lightning-primitiveTreegridCellToggle_primitiveTreegridCellToggle-host",
      shadowAttribute: "lightning-primitiveTreegridCellToggle_primitiveTreegridCellToggle"
    };

    var labelCollapseBranch = 'Collapse {0}';

    var labelExpandBranch = 'Expand {0}';

    const i18n$x = {
      collapseBranch: labelCollapseBranch,
      expandBranch: labelExpandBranch
    };

    class PrivateTreeGridCellToggle extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.rowKeyValue = void 0;
        this.colKeyValue = void 0;
        this.value = void 0;
        this.state = {
          expanded: false,
          hasChildren: false
        };
        this._tabindex = 0;
      }

      get computedButtonClass() {
        return classSet('slds-button slds-button_icon slds-m-right_x-small').add({
          'slds-is-disabled': !this.hasChildren
        }).toString();
      }

      get tabIndex() {
        return -1;
      }

      set tabIndex(newValue) {
        this.setAttribute('tabindex', newValue);
        this._tabindex = newValue;
      }

      get buttonTabIndex() {
        return this._tabindex;
      }

      get hasChildren() {
        return this.state.hasChildren;
      }

      set hasChildren(value) {
        this.state.hasChildren = normalizeBoolean(value);
      }

      get isExpanded() {
        return this.state.expanded;
      }

      set isExpanded(value) {
        this.state.expanded = normalizeBoolean(value);
      }

      get buttonTitle() {
        if (this.isExpanded) {
          return this.formatString(i18n$x.collapseBranch, this.value);
        }

        return this.formatString(i18n$x.expandBranch, this.value);
      }

      formatString(str, ...args) {
        if (str) {
          return str.replace(/{(\d+)}/g, (match, i) => {
            return typeof args[i] !== 'undefined' ? args[i] : match;
          });
        }

        return '';
      }

      handleChevronClick() {
        const customEvent = new CustomEvent('privatetogglecell', {
          bubbles: true,
          composed: true,
          cancelable: true,
          detail: {
            name: this.rowKeyValue,
            nextState: this.isExpanded ? false : true // True = expanded, False = collapsed

          }
        });
        this.dispatchEvent(customEvent);
      }

      focus() {
        this.template.querySelector('button').focus();
      }

    }

    lwc.registerDecorators(PrivateTreeGridCellToggle, {
      publicProps: {
        rowKeyValue: {
          config: 0
        },
        colKeyValue: {
          config: 0
        },
        value: {
          config: 0
        },
        tabIndex: {
          config: 3
        },
        hasChildren: {
          config: 3
        },
        isExpanded: {
          config: 3
        }
      },
      publicMethods: ["focus"],
      track: {
        state: 1,
        _tabindex: 1
      }
    });

    var _lightningPrimitiveTreegridCellToggle = lwc.registerComponent(PrivateTreeGridCellToggle, {
      tmpl: _tmpl$15
    });

    function tmpl$1F($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        h: api_element,
        ti: api_tab_index
      } = $api;
      return [api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_icon": true,
          "slds-cell-edit__button": true,
          "slds-m-left_x-small": true
        },
        attrs: {
          "tabindex": api_tab_index($cmp.tabIndex)
        },
        key: 2
      }, [api_custom_element("lightning-primitive-icon", _lightningPrimitiveIcon, {
        props: {
          "iconName": "utility:edit",
          "size": "xx-small",
          "svgClass": "slds-button__icon slds-button__icon_hint slds-button__icon_lock slds-button__icon_small slds-button__icon_edit"
        },
        key: 3
      }, []), api_element("span", {
        classMap: {
          "slds-assistive-text": true
        },
        key: 4
      }, [api_dynamic($cmp.assistiveText)])])];
    }

    var _tmpl$16 = lwc.registerTemplate(tmpl$1F);
    tmpl$1F.stylesheets = [];
    tmpl$1F.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellEditableButton_primitiveCellEditableButton-host",
      shadowAttribute: "lightning-primitiveCellEditableButton_primitiveCellEditableButton"
    };

    var labelEdit = 'Edit';

    var labelEditHasError = 'has error';

    const i18n$y = {
      edit: labelEdit,
      editHasError: labelEditHasError
    };

    class PrivateCellEditableButton extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.columnLabel = void 0;
        this.hasError = void 0;
        this._htmlButton = null;
      }

      focus() {
        if (this.htmlButton) {
          this.htmlButton.focus();
        }
      }

      click() {
        if (this.htmlButton) {
          this.htmlButton.click();
        }
      }

      get tabIndex() {
        return this.getAttribute('tabindex');
      }

      set tabIndex(value) {
        this.setAttribute('tabindex', value);
      }

      get htmlButton() {
        if (!this._htmlButton) {
          this._htmlButton = this.template.querySelector('button');
        }

        return this._htmlButton;
      }

      disconnectedCallback() {
        this._htmlButton = null;
      }

      get assistiveText() {
        const suffix = this.hasError ? ` ${i18n$y.editHasError}` : '';
        return `${i18n$y.edit} ${this.columnLabel}${suffix}`;
      }

    }

    lwc.registerDecorators(PrivateCellEditableButton, {
      publicProps: {
        columnLabel: {
          config: 0
        },
        hasError: {
          config: 0
        },
        tabIndex: {
          config: 3
        }
      },
      publicMethods: ["focus", "click"]
    });

    var _lightningPrimitiveCellEditableButton = lwc.registerComponent(PrivateCellEditableButton, {
      tmpl: _tmpl$16
    });

    function tmpl$1G($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        t: api_text,
        d: api_dynamic,
        ti: api_tab_index,
        s: api_slot,
        h: api_element,
        b: api_bind
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_element("div", {
        className: $cmp.computedCellDivClass,
        key: 2
      }, [$cmp.hasLeftIcon ? api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "iconName": $cmp.iconName,
          "size": "x-small",
          "alternativeText": $cmp.iconAlternativeText
        },
        key: 4
      }, []) : null, $cmp.hasLeftIcon ? api_text("\xA0 ") : null, $cmp.hasLeftIcon ? api_dynamic($cmp.iconLabel) : null, $cmp.hasLeftIcon ? api_text(" \xA0") : null, $cmp.hasTreeData ? api_custom_element("lightning-primitive-treegrid-cell-toggle", _lightningPrimitiveTreegridCellToggle, {
        attrs: {
          "data-navigation": "enable"
        },
        props: {
          "rowKeyValue": $cmp.rowKeyValue,
          "colKeyValue": $cmp.colKeyValue,
          "value": $cmp.value,
          "hasChildren": $cmp.hasChildren,
          "isExpanded": $cmp.isExpanded,
          "tabIndex": api_tab_index($cmp.internalTabIndex)
        },
        key: 6
      }, []) : null, api_slot("", {
        key: 7
      }, [], $slotset), $cmp.hasRightIcon ? api_text("\xA0") : null, $cmp.hasRightIcon ? api_custom_element("lightning-icon", _lightningIcon, {
        props: {
          "iconName": $cmp.iconName,
          "size": "x-small",
          "alternativeText": $cmp.iconAlternativeText
        },
        key: 9
      }, []) : null, $cmp.hasRightIcon ? api_text("\xA0 ") : null, $cmp.hasRightIcon ? api_dynamic($cmp.iconLabel) : null]), $cmp.editable ? api_custom_element("lightning-primitive-cell-editable-button", _lightningPrimitiveCellEditableButton, {
        attrs: {
          "data-navigation": "enable",
          "data-action-triggers": "enter,space",
          "data-action-edit": "true"
        },
        props: {
          "columnLabel": $cmp.columnLabel,
          "hasError": $cmp.hasError,
          "tabIndex": api_tab_index($cmp.internalTabIndex)
        },
        key: 11,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleEditButtonClick))
        }
      }, []) : null];
    }

    var _tmpl$17 = lwc.registerTemplate(tmpl$1G);
    tmpl$1G.slots = [""];
    tmpl$1G.stylesheets = [];
    tmpl$1G.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellWrapper_primitiveCellWrapper-host",
      shadowAttribute: "lightning-primitiveCellWrapper_primitiveCellWrapper"
    };

    class PrimitiveCellWrapper extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.iconName = void 0;
        this.iconPosition = void 0;
        this.iconAlternativeText = void 0;
        this.isAction = false;
        this.wrapText = void 0;
        this.iconLabel = void 0;
        this.editable = false;
        this.hasError = false;
        this.type = 'text';
        this.rowKeyValue = void 0;
        this.colKeyValue = void 0;
        this.hasTreeData = false;
        this.value = void 0;
        this.hasChildren = void 0;
        this.isExpanded = void 0;
        this.columnLabel = void 0;
        this.internalTabIndex = void 0;
      }

      get hasLeftIcon() {
        return !this.hasTreeData && this.iconName && (!this.iconPosition || this.iconPosition === 'left');
      }

      get hasRightIcon() {
        return this.iconName && this.iconPosition === 'right';
      }

      get computedCellDivClass() {
        return classSet().add({
          'slds-truncate': !this.isAction && this.type !== 'button-icon' && !this.wrapText
        }).add({
          'slds-hyphenate': this.wrapText
        }).toString();
      } // Inline edit button


      handleEditButtonClick() {
        // this event does not bubble, it is not composed
        const event = new CustomEvent('edit');
        this.dispatchEvent(event);
      }

      getActionableElements() {
        return Array.prototype.slice.call(this.template.querySelectorAll('[data-navigation="enable"]'));
      }

    }

    lwc.registerDecorators(PrimitiveCellWrapper, {
      publicProps: {
        iconName: {
          config: 0
        },
        iconPosition: {
          config: 0
        },
        iconAlternativeText: {
          config: 0
        },
        isAction: {
          config: 0
        },
        wrapText: {
          config: 0
        },
        iconLabel: {
          config: 0
        },
        editable: {
          config: 0
        },
        hasError: {
          config: 0
        },
        type: {
          config: 0
        },
        rowKeyValue: {
          config: 0
        },
        colKeyValue: {
          config: 0
        },
        hasTreeData: {
          config: 0
        },
        value: {
          config: 0
        },
        hasChildren: {
          config: 0
        },
        isExpanded: {
          config: 0
        },
        columnLabel: {
          config: 0
        },
        internalTabIndex: {
          config: 0
        }
      },
      publicMethods: ["getActionableElements"]
    });

    var _lightningPrimitiveCellWrapper = lwc.registerComponent(PrimitiveCellWrapper, {
      tmpl: _tmpl$17
    });

    function tmpl$1H($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        h: api_element,
        b: api_bind
      } = $api;
      const {
        _m0
      } = $ctx;
      return [$cmp.isRowNumber ? api_element("div", {
        classMap: {
          "slds-truncate": true
        },
        key: 3
      }, [api_custom_element("lightning-primitive-cell-types", _lightningPrimitiveCellTypes, {
        props: {
          "types": $cmp.types,
          "keyboardMode": $cmp.keyboardMode,
          "columnType": "rowNumber",
          "internalTabIndex": $cmp.state.internalTabIndex,
          "rowKeyValue": $cmp.rowKeyValue,
          "colKeyValue": $cmp.colKeyValue,
          "typeAttribute0": $cmp.typeAttribute0
        },
        key: 4
      }, [])]) : null, !$cmp.isRowNumber ? !$cmp.isCustomType ? api_custom_element("lightning-primitive-cell-wrapper", _lightningPrimitiveCellWrapper, {
        className: $cmp.computedWrapperClass,
        props: {
          "editable": $cmp.editable,
          "hasError": $cmp.hasError,
          "iconName": $cmp.iconName,
          "iconPosition": $cmp.iconPosition,
          "iconLabel": $cmp.iconLabel,
          "iconAlternativeText": $cmp.iconAlternativeText,
          "isAction": $cmp.isAction,
          "type": $cmp.columnType,
          "wrapText": $cmp.wrapText,
          "hasTreeData": $cmp.hasTreeData,
          "rowKeyValue": $cmp.rowKeyValue,
          "colKeyValue": $cmp.colKeyValue,
          "columnLabel": $cmp.columnLabel,
          "value": $cmp.value,
          "internalTabIndex": $cmp.state.internalTabIndex,
          "hasChildren": $cmp.typeAttribute21,
          "isExpanded": $cmp.typeAttribute22
        },
        key: 7,
        on: {
          "edit": _m0 || ($ctx._m0 = api_bind($cmp.handleEditButtonClick))
        }
      }, [api_custom_element("lightning-primitive-cell-types", _lightningPrimitiveCellTypes, {
        props: {
          "types": $cmp.types,
          "keyboardMode": $cmp.keyboardMode,
          "columnType": $cmp.columnType,
          "columnSubType": $cmp.columnSubType,
          "value": $cmp.value,
          "internalTabIndex": $cmp.state.internalTabIndex,
          "rowKeyValue": $cmp.rowKeyValue,
          "colKeyValue": $cmp.colKeyValue,
          "typeAttribute0": $cmp.typeAttribute0,
          "typeAttribute1": $cmp.typeAttribute1,
          "typeAttribute2": $cmp.typeAttribute2,
          "typeAttribute3": $cmp.typeAttribute3,
          "typeAttribute4": $cmp.typeAttribute4,
          "typeAttribute5": $cmp.typeAttribute5,
          "typeAttribute6": $cmp.typeAttribute6,
          "typeAttribute7": $cmp.typeAttribute7,
          "typeAttribute8": $cmp.typeAttribute8,
          "typeAttribute9": $cmp.typeAttribute9,
          "typeAttribute10": $cmp.typeAttribute10,
          "typeAttribute21": $cmp.typeAttribute21,
          "typeAttribute22": $cmp.typeAttribute22
        },
        key: 8
      }, [])]) : null : null, !$cmp.isRowNumber ? $cmp.isCustomType ? api_element("div", {
        classMap: {
          "slds-truncate": true
        },
        key: 10
      }, [api_custom_element("lightning-primitive-cell-types", _lightningPrimitiveCellTypes, {
        props: {
          "types": $cmp.types,
          "keyboardMode": $cmp.keyboardMode,
          "columnType": $cmp.columnType,
          "columnSubType": $cmp.columnSubType,
          "value": $cmp.value,
          "internalTabIndex": $cmp.state.internalTabIndex,
          "rowKeyValue": $cmp.rowKeyValue,
          "colKeyValue": $cmp.colKeyValue,
          "typeAttribute0": $cmp.typeAttribute0,
          "typeAttribute1": $cmp.typeAttribute1,
          "typeAttribute2": $cmp.typeAttribute2,
          "typeAttribute3": $cmp.typeAttribute3,
          "typeAttribute4": $cmp.typeAttribute4,
          "typeAttribute5": $cmp.typeAttribute5,
          "typeAttribute6": $cmp.typeAttribute6,
          "typeAttribute7": $cmp.typeAttribute7,
          "typeAttribute8": $cmp.typeAttribute8,
          "typeAttribute9": $cmp.typeAttribute9,
          "typeAttribute10": $cmp.typeAttribute10,
          "typeAttribute21": $cmp.typeAttribute21,
          "typeAttribute22": $cmp.typeAttribute22
        },
        key: 11
      }, [])]) : null : null];
    }

    var _tmpl$18 = lwc.registerTemplate(tmpl$1H);
    tmpl$1H.stylesheets = [];
    tmpl$1H.stylesheetTokens = {
      hostAttribute: "lightning-primitiveCellFactory_primitiveCellFactory-host",
      shadowAttribute: "lightning-primitiveCellFactory_primitiveCellFactory"
    };

    function isNumberedBasedType(cellType) {
      return cellType === 'currency' || cellType === 'number' || cellType === 'percent';
    }

    function isTypeCenteredByDefault(cellType) {
      return cellType === 'button-icon';
    }

    class PrivateCellFactory extends PrimitiveDatatableCell$1 {
      constructor(...args) {
        super(...args);
        this.types = void 0;
        this.alignment = void 0;
        this.value = void 0;
        this.iconName = void 0;
        this.iconLabel = void 0;
        this.iconPosition = void 0;
        this.iconAlternativeText = void 0;
        this.editable = void 0;
        this.hasError = void 0;
        this.columnLabel = void 0;
        this.columnSubType = void 0;
        this.typeAttribute0 = void 0;
        this.typeAttribute1 = void 0;
        this.typeAttribute2 = void 0;
        this.typeAttribute3 = void 0;
        this.typeAttribute4 = void 0;
        this.typeAttribute5 = void 0;
        this.typeAttribute6 = void 0;
        this.typeAttribute7 = void 0;
        this.typeAttribute8 = void 0;
        this.typeAttribute9 = void 0;
        this.typeAttribute10 = void 0;
        this.typeAttribute21 = void 0;
        this.typeAttribute22 = void 0;
      }

      get wrapText() {
        return this.state.wrapText;
      }

      set wrapText(value) {
        if (value) {
          this.classList.add('slds-cell-wrap');
        } else {
          this.classList.remove('slds-cell-wrap');
        }

        this.state.wrapText = value;
      }

      get columnType() {
        return this.state.columnType;
      }

      set columnType(value) {
        if (value === 'tree') {
          this.classList.add('slds-no-space');
        }

        this.state.columnType = value;
      }

      get computedWrapperClass() {
        const alignment = this.computedAlignment;
        return classSet('slds-grid').add({
          'slds-no-space': this.hasTreeData,
          'slds-align_absolute-center': this.isAction,
          'slds-grid_align-end': alignment === 'right',
          'slds-grid_align-center': alignment === 'center',
          'slds-grid_align-spread': this.isSpreadAlignment
        }).toString();
      }

      get hasTreeData() {
        return this.columnType === 'tree';
      }

      get isAction() {
        return this.columnType === 'action';
      }

      get isCustomType() {
        return this.types.getType(this.columnType).type === 'custom';
      }

      render() {
        return _tmpl$18;
      } // Inline edit button


      handleEditButtonClick() {
        const {
          rowKeyValue,
          colKeyValue
        } = this;
        const event = new CustomEvent('privateeditcell', {
          bubbles: true,
          composed: true,
          detail: {
            rowKeyValue,
            colKeyValue
          }
        });
        this.dispatchEvent(event);
      }
      /**
       * Overridden click handler from the datatable-cell.
       *
       */


      handleClick() {
        if (!this.classList.contains('slds-has-focus')) {
          this.addFocusStyles();
          this.fireCellFocusByClickEvent();
        }
      }

      getActionableElements() {
        const wrapper = this.template.querySelector('lightning-primitive-cell-wrapper');
        const types = this.template.querySelector('lightning-primitive-cell-types');
        const result = [];
        const typeActionableElements = types.getActionableElements();
        typeActionableElements.forEach(elem => result.push(elem));

        if (wrapper) {
          const wrapperActionableElements = wrapper.getActionableElements();
          wrapperActionableElements.forEach(elem => result.push(elem));
        }

        return result;
      }

      get isSpreadAlignment() {
        const alignment = this.computedAlignment;
        return !alignment || alignment === 'left' || alignment !== 'center' && alignment !== 'right';
      }
      /**
       * Note: this should be passed from above, but we dont have a defined architecture that lets customize / provide defaults
       * on cell attributes per type.
       */


      get computedAlignment() {
        if (!this.alignment && isNumberedBasedType(this.columnType)) {
          return 'right';
        }

        if (!this.alignment && isTypeCenteredByDefault(this.columnType)) {
          return 'center';
        }

        return this.alignment;
      }

      get isRowNumber() {
        return this.columnType === 'rowNumber';
      }

    }

    lwc.registerDecorators(PrivateCellFactory, {
      publicProps: {
        types: {
          config: 0
        },
        alignment: {
          config: 0
        },
        value: {
          config: 0
        },
        iconName: {
          config: 0
        },
        iconLabel: {
          config: 0
        },
        iconPosition: {
          config: 0
        },
        iconAlternativeText: {
          config: 0
        },
        editable: {
          config: 0
        },
        hasError: {
          config: 0
        },
        columnLabel: {
          config: 0
        },
        columnSubType: {
          config: 0
        },
        typeAttribute0: {
          config: 0
        },
        typeAttribute1: {
          config: 0
        },
        typeAttribute2: {
          config: 0
        },
        typeAttribute3: {
          config: 0
        },
        typeAttribute4: {
          config: 0
        },
        typeAttribute5: {
          config: 0
        },
        typeAttribute6: {
          config: 0
        },
        typeAttribute7: {
          config: 0
        },
        typeAttribute8: {
          config: 0
        },
        typeAttribute9: {
          config: 0
        },
        typeAttribute10: {
          config: 0
        },
        typeAttribute21: {
          config: 0
        },
        typeAttribute22: {
          config: 0
        },
        wrapText: {
          config: 3
        },
        columnType: {
          config: 3
        }
      }
    });

    var _lightningPrimitiveCellFactory = lwc.registerComponent(PrivateCellFactory, {
      tmpl: _tmpl$18
    });

    function stylesheet$p(hostSelector, shadowSelector, nativeShadow) {
      return "\n" + (nativeShadow ? (":host {display: block;}") : (hostSelector + " {display: block;}")) + "\n";
    }
    var _implicitStylesheets$p = [stylesheet$p];

    function tmpl$1I($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element
      } = $api;
      return [api_custom_element("lightning-spinner", _lightningSpinner, {
        styleMap: {
          "height": "40px"
        },
        props: {
          "variant": "brand",
          "alternativeText": $cmp.i18n.loading
        },
        key: 2
      }, [])];
    }

    var _tmpl$19 = lwc.registerTemplate(tmpl$1I);
    tmpl$1I.stylesheets = [];

    if (_implicitStylesheets$p) {
      tmpl$1I.stylesheets.push.apply(tmpl$1I.stylesheets, _implicitStylesheets$p);
    }
    tmpl$1I.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableLoadingIndicator_primitiveDatatableLoadingIndicator-host",
      shadowAttribute: "lightning-primitiveDatatableLoadingIndicator_primitiveDatatableLoadingIndicator"
    };

    var labelLoading$2 = 'Loading';

    const i18n$z = {
      loading: labelLoading$2
    };

    class LightningPrimitiveDatatableLoadingIndicator extends lwc.LightningElement {
      get i18n() {
        return i18n$z;
      }

    }

    var _lightningPrimitiveDatatableLoadingIndicator = lwc.registerComponent(LightningPrimitiveDatatableLoadingIndicator, {
      tmpl: _tmpl$19
    });

    function tmpl$1J($api, $cmp, $slotset, $ctx) {
      const {
        c: api_custom_element,
        d: api_dynamic,
        b: api_bind,
        h: api_element
      } = $api;
      const {
        _m0,
        _m1
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "slds-docked-form-footer": true,
          "slds-is-absolute": true
        },
        key: 2
      }, [api_element("div", {
        classMap: {
          "slds-grid": true,
          "slds-grid_align-center": true
        },
        key: 3
      }, [$cmp.showError ? api_custom_element("lightning-primitive-datatable-tooltip", _lightningPrimitiveDatatableTooltip, {
        classMap: {
          "slds-button": true
        },
        props: {
          "size": "small",
          "variant": "error",
          "header": $cmp.error.title,
          "content": $cmp.error.messages,
          "alternativeText": $cmp.i18n.error,
          "offset": $cmp.bubbleOffset
        },
        key: 5
      }, []) : null, api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_neutral": true
        },
        attrs: {
          "type": "button"
        },
        key: 6,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleCancelButtonClick))
        }
      }, [api_dynamic($cmp.i18n.cancel)]), api_element("button", {
        classMap: {
          "slds-button": true,
          "slds-button_brand": true,
          "save-btn": true
        },
        attrs: {
          "type": "button"
        },
        key: 7,
        on: {
          "click": _m1 || ($ctx._m1 = api_bind($cmp.handleSaveButtonClick))
        }
      }, [api_dynamic($cmp.i18n.save)])])])];
    }

    var _tmpl$1a = lwc.registerTemplate(tmpl$1J);
    tmpl$1J.stylesheets = [];
    tmpl$1J.stylesheetTokens = {
      hostAttribute: "lightning-primitiveDatatableStatusBar_primitiveDatatableStatusBar-host",
      shadowAttribute: "lightning-primitiveDatatableStatusBar_primitiveDatatableStatusBar"
    };

    var labelSave$1 = 'Save';

    var labelError = 'Fix the errors and try saving again';

    const i18n$A = {
      save: labelSave$1,
      cancel: labelCancel$1,
      error: labelError
    };

    class LightningPrimitiveDatatableStatusBar extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.privateError = {};
      }

      get error() {
        return this.privateError;
      }

      set error(value) {
        this.privateError = value;

        if (this.showError && this.isSaveBtnFocused()) {
          this.focusOnErrorMessages();
        }
      }

      get i18n() {
        return i18n$A;
      }

      get showError() {
        const {
          error
        } = this;
        return error && (error.title || error.messages);
      }

      get bubbleOffset() {
        // move bubble above the docked bar since docked bar has higher z-index
        // and can block the nubbin of the bubble
        return {
          vertical: -10
        };
      }

      handleCancelButtonClick(event) {
        event.preventDefault();
        event.stopPropagation();
        this.dispatchEvent(new CustomEvent('privatecancel', {
          bubbles: true,
          composed: true,
          cancelable: true
        }));
      }

      handleSaveButtonClick(event) {
        event.preventDefault();
        event.stopPropagation(); // safari and firefox does not focus on click.

        if (document.activeElement !== event.target) {
          event.target.focus();
        }

        this.dispatchEvent(new CustomEvent('privatesave', {
          bubbles: true,
          composed: true,
          cancelable: true
        }));
      }

      isSaveBtnFocused() {
        return this.template.querySelector('button.save-btn:focus') !== null;
      }

      focusOnErrorMessages() {
        Promise.resolve().then(() => {
          const trigger = this.template.querySelector('lightning-primitive-datatable-tooltip');

          if (trigger) {
            trigger.focus();
          }
        });
      }

    }

    lwc.registerDecorators(LightningPrimitiveDatatableStatusBar, {
      publicProps: {
        error: {
          config: 3
        }
      },
      track: {
        privateError: 1
      }
    });

    var _lightningPrimitiveDatatableStatusBar = lwc.registerComponent(LightningPrimitiveDatatableStatusBar, {
      tmpl: _tmpl$1a
    });

    function tmpl$1K($api, $cmp, $slotset, $ctx) {
      const {
        h: api_element,
        b: api_bind,
        c: api_custom_element,
        k: api_key,
        ti: api_tab_index,
        i: api_iterator,
        f: api_flatten
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4,
        _m5,
        _m6,
        _m7,
        _m8,
        _m9,
        _m10,
        _m11
      } = $ctx;
      return [api_element("div", {
        classMap: {
          "dt-width-observer": true
        },
        styleMap: {
          "width": "100%",
          "height": "0px"
        },
        context: {
          lwc: {
            dom: "manual"
          }
        },
        key: 2
      }, []), api_element("div", {
        styleMap: {
          "height": "100%",
          "position": "relative"
        },
        key: 3
      }, [api_custom_element("lightning-primitive-datatable-iedit-panel", _lightningPrimitiveDatatableIeditPanel, {
        attrs: {
          "data-iedit-panel": "true"
        },
        props: {
          "visible": $cmp.state.inlineEdit.isPanelVisible,
          "rowKeyValue": $cmp.state.inlineEdit.rowKeyValue,
          "colKeyValue": $cmp.state.inlineEdit.colKeyValue,
          "editedValue": $cmp.state.inlineEdit.editedValue,
          "columnDef": $cmp.state.inlineEdit.columnDef,
          "isMassEditEnabled": $cmp.state.inlineEdit.massEditEnabled,
          "numberOfSelectedRows": $cmp.state.inlineEdit.massEditSelectedRows
        },
        key: 4,
        on: {
          "ieditfinished": _m0 || ($ctx._m0 = api_bind($cmp.handleInlineEditFinish)),
          "masscheckboxchange": _m1 || ($ctx._m1 = api_bind($cmp.handleMassCheckboxChange))
        }
      }, []), api_element("div", {
        classMap: {
          "slds-table_header-fixed_container": true,
          "slds-scrollable_x": true
        },
        style: $cmp.scrollerXStyles,
        key: 5,
        on: {
          "scroll": _m9 || ($ctx._m9 = api_bind($cmp.handleHorizontalScroll))
        }
      }, [api_element("div", {
        classMap: {
          "slds-scrollable_y": true
        },
        style: $cmp.computedScrollerStyle,
        key: 6,
        on: {
          "scroll": _m8 || ($ctx._m8 = api_bind($cmp.handleVerticalScroll))
        }
      }, [api_element("div", {
        key: 7
      }, [api_element("table", {
        className: $cmp.computedTableClass,
        style: $cmp.computedTableStyle,
        attrs: {
          "role": $cmp.computedTableRole,
          "tabindex": api_tab_index($cmp.state.tabindex)
        },
        key: 8,
        on: {
          "focus": _m3 || ($ctx._m3 = api_bind($cmp.handleTableFocus)),
          "keydown": _m4 || ($ctx._m4 = api_bind($cmp.handleTableKeydown)),
          "click": _m5 || ($ctx._m5 = api_bind($cmp.handleCellClick)),
          "focusin": _m6 || ($ctx._m6 = api_bind($cmp.handleTableFocusIn)),
          "focusout": _m7 || ($ctx._m7 = api_bind($cmp.handleTableFocusOut))
        }
      }, [$cmp.hasValidKeyField ? api_element("thead", {
        className: $cmp.computedTableHeaderClass,
        key: 11
      }, [api_element("tr", {
        classMap: {
          "slds-line-height_reset": true
        },
        key: 12
      }, api_iterator($cmp.state.columns, function (def, colIndex) {
        return api_element("th", {
          style: def.style,
          attrs: {
            "scope": "col",
            "tabindex": api_tab_index(def.tabIndex),
            "aria-label": def.ariaLabel,
            "aria-sort": def.sortAriaLabel
          },
          key: api_key(14, def.colKeyValue)
        }, [def.fixedWidth ? api_custom_element("lightning-primitive-header-factory", _lightningPrimitiveHeaderFactory, {
          style: def.style,
          props: {
            "def": def,
            "dtContextId": $cmp.privateDatatableId,
            "rowKeyValue": "HEADER",
            "colKeyValue": def.colKeyValue,
            "hasFocus": def.hasFocus,
            "columnWidth": def.columnWidth,
            "colIndex": colIndex,
            "sortable": def.sortable,
            "sorted": def.sorted,
            "sortedDirection": def.sortedDirection,
            "showCheckbox": $cmp.showSelectAllCheckbox,
            "actions": def.actions
          },
          key: api_key(16, def.colKeyValue)
        }, []) : null, !def.fixedWidth ? api_custom_element("lightning-primitive-header-factory", _lightningPrimitiveHeaderFactory, {
          style: def.style,
          props: {
            "def": def,
            "dtContextId": $cmp.privateDatatableId,
            "rowKeyValue": "HEADER",
            "colKeyValue": def.colKeyValue,
            "colIndex": colIndex,
            "resizable": $cmp.hasResizebleColumns,
            "sortable": def.sortable,
            "sorted": def.sorted,
            "sortedDirection": def.sortedDirection,
            "hasFocus": def.hasFocus,
            "columnWidth": def.columnWidth,
            "resizestep": $cmp.state.resizeStep,
            "actions": def.actions
          },
          key: api_key(18, def.colKeyValue)
        }, []) : null]);
      }))]) : null, $cmp.hasValidKeyField ? api_element("tbody", {
        style: $cmp.computedTbodyStyle,
        key: 19
      }, api_flatten([api_iterator($cmp.state.rows, function (row, rowIndex) {
        return api_element("tr", {
          className: row.classnames,
          attrs: {
            "data-row-key-value": row.key,
            "aria-selected": row.ariaSelected,
            "aria-level": row.level,
            "aria-expanded": row.isExpanded,
            "aria-setsize": row.setSize,
            "aria-posinset": row.posInSet,
            "tabindex": api_tab_index(row.tabIndex)
          },
          key: api_key(21, row.key),
          on: {
            "keydown": _m2 || ($ctx._m2 = api_bind($cmp.handleTrRowKeyDown))
          }
        }, api_iterator(row.cells, function (cell) {
          return [cell.isCheckbox ? api_element("td", {
            className: cell.class,
            attrs: {
              "role": "gridcell",
              "tabindex": api_tab_index(cell.tabIndex),
              "data-label": cell.dataLabel
            },
            key: api_key(24, cell.colKeyValue)
          }, [api_custom_element("lightning-primitive-cell-checkbox", _lightningPrimitiveCellCheckbox, {
            attrs: {
              "data-label": cell.dataLabel
            },
            props: {
              "dtContextId": $cmp.privateDatatableId,
              "hasFocus": cell.hasFocus,
              "rowKeyValue": row.key,
              "colKeyValue": cell.colKeyValue,
              "rowIndex": rowIndex,
              "type": row.inputType,
              "isSelected": row.isSelected,
              "isDisabled": row.isDisabled
            },
            key: api_key(25, cell.key)
          }, [])]) : null, cell.isDataTypeScope ? api_element("th", {
            className: cell.class,
            style: cell.style,
            attrs: {
              "aria-selected": cell.ariaSelected,
              "scope": "row",
              "tabindex": api_tab_index(cell.tabIndex),
              "data-label": cell.dataLabel
            },
            key: api_key(27, cell.colKeyValue)
          }, [api_custom_element("lightning-primitive-cell-factory", _lightningPrimitiveCellFactory, {
            attrs: {
              "data-label": cell.dataLabel
            },
            props: {
              "types": $cmp.privateTypes,
              "ariaSelected": cell.ariaSelected,
              "alignment": cell.alignment,
              "hasError": cell.hasError,
              "hasFocus": cell.hasFocus,
              "columnLabel": cell.dataLabel,
              "columnType": cell.columnType,
              "columnSubType": cell.columnSubType,
              "wrapText": cell.wrapText,
              "rowKeyValue": row.key,
              "colKeyValue": cell.colKeyValue,
              "value": cell.value,
              "iconName": cell.iconName,
              "iconLabel": cell.iconLabel,
              "iconPosition": cell.iconPosition,
              "iconAlternativeText": cell.iconAlternativeText,
              "editable": cell.editable,
              "typeAttribute0": cell.typeAttribute0,
              "typeAttribute1": cell.typeAttribute1,
              "typeAttribute2": cell.typeAttribute2,
              "typeAttribute3": cell.typeAttribute3,
              "typeAttribute4": cell.typeAttribute4,
              "typeAttribute5": cell.typeAttribute5,
              "typeAttribute6": cell.typeAttribute6,
              "typeAttribute7": cell.typeAttribute7,
              "typeAttribute8": cell.typeAttribute8,
              "typeAttribute9": cell.typeAttribute9,
              "typeAttribute10": cell.typeAttribute10,
              "typeAttribute21": cell.typeAttribute21,
              "typeAttribute22": cell.typeAttribute22
            },
            key: api_key(28, cell.columnType)
          }, [])]) : null, cell.isDataType ? api_element("td", {
            className: cell.class,
            style: cell.style,
            attrs: {
              "aria-selected": cell.ariaSelected,
              "role": "gridcell",
              "tabindex": api_tab_index(cell.tabIndex),
              "data-label": cell.dataLabel
            },
            key: api_key(30, cell.colKeyValue)
          }, [api_custom_element("lightning-primitive-cell-factory", _lightningPrimitiveCellFactory, {
            attrs: {
              "data-label": cell.dataLabel
            },
            props: {
              "types": $cmp.privateTypes,
              "ariaSelected": cell.ariaSelected,
              "role": "gridcell",
              "alignment": cell.alignment,
              "hasFocus": cell.hasFocus,
              "hasError": cell.hasError,
              "columnLabel": cell.dataLabel,
              "columnType": cell.columnType,
              "columnSubType": cell.columnSubType,
              "wrapText": cell.wrapText,
              "rowKeyValue": row.key,
              "colKeyValue": cell.colKeyValue,
              "value": cell.value,
              "iconName": cell.iconName,
              "iconLabel": cell.iconLabel,
              "iconPosition": cell.iconPosition,
              "iconAlternativeText": cell.iconAlternativeText,
              "editable": cell.editable,
              "typeAttribute0": cell.typeAttribute0,
              "typeAttribute1": cell.typeAttribute1,
              "typeAttribute2": cell.typeAttribute2,
              "typeAttribute3": cell.typeAttribute3,
              "typeAttribute4": cell.typeAttribute4,
              "typeAttribute5": cell.typeAttribute5,
              "typeAttribute6": cell.typeAttribute6,
              "typeAttribute7": cell.typeAttribute7,
              "typeAttribute8": cell.typeAttribute8,
              "typeAttribute9": cell.typeAttribute9,
              "typeAttribute10": cell.typeAttribute10,
              "typeAttribute21": cell.typeAttribute21,
              "typeAttribute22": cell.typeAttribute22
            },
            key: api_key(31, cell.columnType)
          }, [])]) : null];
        }));
      }), $cmp.isLoading ? api_element("tr", {
        key: 33
      }, [api_element("td", {
        classMap: {
          "slds-is-relative": true
        },
        attrs: {
          "colspan": $cmp.numberOfColumns
        },
        key: 34
      }, [api_custom_element("lightning-primitive-datatable-loading-indicator", _lightningPrimitiveDatatableLoadingIndicator, {
        key: 35
      }, [])])]) : null])) : null])])])]), $cmp.showStatusBar ? api_custom_element("lightning-primitive-datatable-status-bar", _lightningPrimitiveDatatableStatusBar, {
        props: {
          "error": $cmp.tableError
        },
        key: 37,
        on: {
          "privatesave": _m10 || ($ctx._m10 = api_bind($cmp.handleInlineEditSave)),
          "privatecancel": _m11 || ($ctx._m11 = api_bind($cmp.handleInlineEditCancel))
        }
      }, []) : null])];
    }

    var _tmpl$1b = lwc.registerTemplate(tmpl$1K);
    tmpl$1K.stylesheets = [];
    tmpl$1K.stylesheetTokens = {
      hostAttribute: "lightning-datatable_datatable-host",
      shadowAttribute: "lightning-datatable_datatable"
    };

    /**
     * It creates a row key generator based on the keyField passed by the consumer
     * if the keyField does not point to a value row object passed in computeUniqueRowKey
     * it fallback to a generated key using indexes
     *
     * @param {String} keyField  - keyField provided by the consumer
     * @returns {*} - Object with a computeUniqueRowKey method
     */
    const createRowKeysGenerator = function (keyField) {
      let index = 0;
      return {
        computeUniqueRowKey(row) {
          if (row[keyField]) {
            return row[keyField];
          }

          return `row-${index++}`;
        }

      };
    };
    /**
     * It generate a unique column key value.
     *
     * @param {object} columnMetadata - the object for an specific column metadata
     * @param {int} index - optionally, the index of the column.
     * @returns {string} It generate the column key value based on the column field name and type.
     */

    const generateColKeyValue = function (columnMetadata, index) {
      const prefix = columnMetadata.fieldName || index;
      return `${prefix}-${columnMetadata.type}-${index}`;
    };

    const isObjectLike = function (value) {
      return typeof value === 'object' && value !== null;
    };
    const proto$1 = {
      add(className) {
        if (typeof className === 'string') {
          this[className] = true;
        } else {
          Object.assign(this, className);
        }

        return this;
      },

      invert() {
        Object.keys(this).forEach(key => {
          this[key] = !this[key];
        });
        return this;
      },

      toString() {
        return Object.keys(this).filter(key => this[key]).join(' ');
      }

    };
    const classSet$1 = function (config) {
      if (typeof config === 'string') {
        const key = config;
        config = {};
        config[key] = true;
      }

      return Object.assign(Object.create(proto$1), config);
    };
    const isPositiveInteger = function (value) {
      return /^\d+$/.test(value);
    };
    const clamp = function (num, min, max) {
      return num <= min ? min : num >= max ? max : num;
    };
    function normalizePositiveIntegerAttribute(attrName, value, fallback) {
      if (isPositiveInteger(value)) {
        return parseInt(value, 10);
      } // eslint-disable-next-line no-console


      console.warn(`The attribute "${attrName}" value passed in is incorrect.
            "${attrName}" value should be an integer >= 0.`);
      return fallback;
    }

    const STANDARD_TYPES = {
      text: true,
      boolean: true,
      number: ['minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits', 'minimumSignificantDigits', 'maximumSignificantDigits'],
      currency: ['currencyCode', 'currencyDisplayAs', 'minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits', 'minimumSignificantDigits', 'maximumSignificantDigits'],
      percent: ['minimumIntegerDigits', 'minimumFractionDigits', 'maximumFractionDigits', 'minimumSignificantDigits', 'maximumSignificantDigits'],
      email: true,
      date: ['day', 'era', 'hour', 'hour12', 'minute', 'month', 'second', 'timeZone', 'timeZoneName', 'weekday', 'year'],
      'date-local': ['day', 'month', 'year'],
      phone: true,
      url: ['label', 'target', 'tooltip'],
      location: true,
      rowNumber: ['error'],
      action: ['menuAlignment', 'rowActions'],
      button: ['variant', 'label', 'iconName', 'iconPosition', 'disabled', 'name', 'class', 'title'],
      'button-icon': ['variant', 'alternativeText', 'iconName', 'iconClass', 'disabled', 'name', 'class', 'title'],
      tree: ['hasChildren', 'isExpanded', 'level', 'setSize', 'posInSet', 'subType']
    };
    const TREE_SUPPORTED_TYPES = {
      text: true,
      url: true,
      date: true,
      number: true,
      currency: true,
      percent: true
    };
    function isValidType(typeName) {
      return !!STANDARD_TYPES[typeName];
    }
    function isTreeType(typeName) {
      return typeName === 'tree';
    }
    function getAttributesNames(typeName) {
      assert(isValidType(typeName), `your are trying to access an invalid type (${typeName})`);
      return Array.isArray(STANDARD_TYPES[typeName]) ? STANDARD_TYPES[typeName] : [];
    }
    function isValidTypeForTree(dataType) {
      return !!TREE_SUPPORTED_TYPES[dataType];
    }

    function getStandardTypeAttributesNames(typeName) {
      return Array.isArray(STANDARD_TYPES[typeName]) ? STANDARD_TYPES[typeName] : [];
    }

    class DatatableTypes {
      constructor(types) {
        this.privateCustomTypes = {};
        this.isValidTypeForTree = isValidTypeForTree;

        if (typeof types === 'object' && types !== null) {
          Object.keys(types).reduce((seed, key) => {
            const {
              template,
              typeAttributes = []
            } = types[key];
            seed[key] = {
              template,
              typeAttributes,
              type: 'custom'
            };
            return seed;
          }, this.privateCustomTypes);
        }
      }

      getType(typeName) {
        if (this.privateCustomTypes[typeName]) {
          return this.privateCustomTypes[typeName];
        }

        if (STANDARD_TYPES[typeName]) {
          return {
            typeAttributes: getStandardTypeAttributesNames(typeName),
            type: 'standard'
          };
        }

        return undefined;
      }

      isValidType(typeName) {
        return !!this.getType(typeName);
      }

    }

    var DatatableTypes$1 = lwc.registerComponent(DatatableTypes, {
      tmpl: _tmpl$1
    });

    function getSortDefaultState() {
      return {
        sortedBy: undefined,
        sortedDirection: undefined,
        defaultSortDirection: 'asc'
      };
    }
    const VALID_SORT_DIRECTIONS = {
      asc: true,
      desc: true
    };
    function isValidSortDirection(value) {
      return !!VALID_SORT_DIRECTIONS[value];
    }
    function getSortedBy(state) {
      return state.sortedBy;
    }
    function setSortedBy(state, value) {
      if (typeof value === 'string') {
        state.sortedBy = value;
      } else {
        state.sortedBy = undefined;
      }
    }
    function getSortedDirection(state) {
      return state.sortedDirection;
    }
    function setSortedDirection(state, value) {
      assert(isValidSortDirection(value), `The "sortedDirection" value passed into lightning:datatable
        is incorrect, "sortedDirection" value should be one of
        ${Object.keys(VALID_SORT_DIRECTIONS).join()}.`);
      state.sortedDirection = isValidSortDirection(value) ? value : undefined;
    }
    function getDefaultSortDirection(state) {
      return state.defaultSortDirection;
    }
    function setDefaultSortDirection(state, value) {
      assert(isValidSortDirection(value), `The "defaultSortDirection" value passed into lightning:datatable
        is incorrect, "defaultSortDirection" value should be one of
        ${Object.keys(VALID_SORT_DIRECTIONS).join()}.`);
      state.defaultSortDirection = isValidSortDirection(value) ? value : getDefaultSortDirection(state);
    }
    function updateSorting(state) {
      const columns = getColumns(state);
      columns.forEach(column => updateColumnSortingState(column, state));
    }
    function updateColumnSortingState(column, state) {
      const {
        sortedBy,
        sortedDirection,
        defaultSortDirection
      } = state;

      if (column.fieldName === sortedBy && column.sortable) {
        Object.assign(column, {
          sorted: true,
          sortAriaLabel: sortedDirection === 'desc' ? 'descending' : 'ascending',
          sortedDirection
        });
      } else {
        Object.assign(column, {
          sorted: false,
          sortAriaLabel: column.sortable ? 'none' : null,
          sortedDirection: defaultSortDirection
        });
      }
    }

    const MAX_ROW_SELECTION_DEFAULT = undefined;
    function getSelectorDefaultState() {
      return {
        selectedRowsKeys: {},
        maxRowSelection: MAX_ROW_SELECTION_DEFAULT
      };
    }
    function handleSelectAllRows(event) {
      event.stopPropagation();
      markAllRowsSelected(this.state);
      this.fireSelectedRowsChange(this.getSelectedRows());
    }
    function handleDeselectAllRows(event) {
      event.stopPropagation();
      markAllRowsDeselected(this.state);
      this.fireSelectedRowsChange(this.getSelectedRows());
    }
    /**
     * Will select the cell identified by rowKeyValue, colKeyValue.
     * This will reflect as aria-selected="true" attribute in the cell td or th.
     *
     * Note: This change is volatile, and will be reset (lost) in the next index regeneration.
     *
     * @param {Object} state - the state of the datatable
     * @param {String} rowKeyValue - the row key of the cell to select
     * @param {String} colKeyValue - the col key of the cell to select
     */

    function markSelectedCell(state, rowKeyValue, colKeyValue) {
      const row = getRowByKey(state, rowKeyValue);
      const colIndex = getStateColumnIndex(state, colKeyValue);

      if (row && colIndex) {
        row.cells[colIndex].ariaSelected = 'true';
      }
    }
    /**
     * Will deselect the cell identified by rowKeyValue, colKeyValue.
     * This will reflect in removing aria-selected attribute in the cell td or th (if it was previously added).
     *
     * Note: This change is volatile, and will be reset (lost) in the next index regeneration.
     *
     * @param {Object} state - the state of the datatable
     * @param {String} rowKeyValue - the row key of the cell to select
     * @param {String} colKeyValue - the col key of the cell to select
     */

    function markDeselectedCell(state, rowKeyValue, colKeyValue) {
      const row = getRowByKey(state, rowKeyValue);
      const colIndex = getStateColumnIndex(state, colKeyValue);

      if (row && colIndex) {
        row.cells[colIndex].ariaSelected = false;
      }
    }
    /**
     * Returns the last rowKey that was clicked, false otherwise.
     * @param {Object} state - the datatable state.
     * @return {String | undefined } the row key or false.
     */

    function getLastRowSelection(state) {
      const lastSelectedRowKey = state.selectionLastSelectedRow;
      const keyIsValid = lastSelectedRowKey !== undefined && getRowIndexByKey(state, lastSelectedRowKey) !== undefined;
      return keyIsValid ? lastSelectedRowKey : undefined;
    }

    function setLastRowSelection(state, rowKeyValue) {
      state.selectionLastSelectedRow = rowKeyValue;
    }

    function handleSelectRow(event) {
      event.stopPropagation();
      const {
        rowKeyValue,
        isMultiple
      } = event.detail;
      let fromRowKey = rowKeyValue;

      if (isMultiple) {
        fromRowKey = getLastRowSelection(this.state) || rowKeyValue;
      }

      markSelectedRowsInterval(this.state, fromRowKey, rowKeyValue);
      setLastRowSelection(this.state, rowKeyValue);
      this.fireSelectedRowsChange(this.getSelectedRows());
    }

    function markSelectedRowsInterval(state, startRowKey, endRowKey) {
      const rows = getRows(state);
      const {
        start,
        end
      } = getRowIntervalIndexes(state, startRowKey, endRowKey);
      const maxRowSelection = getMaxRowSelection(state) || getRowsTotal(state);
      let i = start,
          maxSelectionReached;

      do {
        markRowSelected(state, rows[i].key);
        maxSelectionReached = getCurrentSelectionLength(state) >= maxRowSelection;
        i++;
      } while (i <= end && !maxSelectionReached);
    }

    function handleDeselectRow(event) {
      event.stopPropagation();
      const {
        rowKeyValue,
        isMultiple
      } = event.detail;
      let fromRowKey = rowKeyValue;

      if (isMultiple) {
        fromRowKey = getLastRowSelection(this.state) || rowKeyValue;
      }

      markDeselectedRowsInterval(this.state, fromRowKey, rowKeyValue);
      setLastRowSelection(this.state, rowKeyValue);
      this.fireSelectedRowsChange(this.getSelectedRows());
    }

    function getRowIntervalIndexes(state, startRowKey, endRowKey) {
      const start = startRowKey === 'HEADER' ? 0 : getRowIndexByKey(state, startRowKey);
      const end = getRowIndexByKey(state, endRowKey);
      return {
        start: Math.min(start, end),
        end: Math.max(start, end)
      };
    }

    function markDeselectedRowsInterval(state, startRowKey, endRowKey) {
      const rows = getRows(state);
      const {
        start,
        end
      } = getRowIntervalIndexes(state, startRowKey, endRowKey);

      for (let i = start; i <= end; i++) {
        markRowDeselected(state, rows[i].key);
      }
    }

    function getSelectedRowsKeys(state) {
      return Object.keys(state.selectedRowsKeys).filter(key => state.selectedRowsKeys[key]);
    }

    function getSelectedDiff(state, value) {
      const selectedRowsKeys = state.selectedRowsKeys;
      return value.filter(key => !selectedRowsKeys[key]);
    }

    function getDeselectedDiff(state, value) {
      const currentSelectedRowsKeys = state.selectedRowsKeys;
      return Object.keys(currentSelectedRowsKeys).filter(key => currentSelectedRowsKeys[key] && !value[key]);
    }

    function normalizeSelectedRowsKey(value) {
      return value.reduce((map, key) => {
        map[key] = true;
        return map;
      }, {});
    }

    function markRowsSelectedByKeys(state, keys) {
      keys.forEach(rowKeyValue => {
        const row = getRowByKey(state, rowKeyValue);
        row.isSelected = true;
        row.ariaSelected = 'true';
        row.classnames = resolveRowClassNames(row);
      });
    }

    function markRowsDeselectedByKeys(state, keys) {
      keys.forEach(rowKeyValue => {
        const row = getRowByKey(state, rowKeyValue);
        row.isSelected = false;
        row.ariaSelected = false;
        row.classnames = resolveRowClassNames(row);
      });
    }

    function filterValidKeys(state, keys) {
      return keys.filter(key => rowKeyExists(state, key));
    }

    function setSelectedRowsKeys(state, value) {
      if (Array.isArray(value)) {
        const maxRowSelection = getMaxRowSelection(state);
        const previousSelectionLength = getCurrentSelectionLength(state);
        let selectedRows = filterValidKeys(state, value);

        if (selectedRows.length > maxRowSelection) {
          // eslint-disable-next-line no-console
          console.warn(`The number of keys in selectedRows for lightning:datatable
            exceeds the limit defined by maxRowSelection.`);
          selectedRows = selectedRows.slice(0, maxRowSelection);
        }

        const normalizedSelectedRowsKeys = normalizeSelectedRowsKey(selectedRows);
        const selectionOperations = getSelectedDiff(state, selectedRows);
        const deselectionOperations = getDeselectedDiff(state, normalizedSelectedRowsKeys);
        markRowsSelectedByKeys(state, selectionOperations);
        markRowsDeselectedByKeys(state, deselectionOperations);
        state.selectedRowsKeys = normalizedSelectedRowsKeys;

        if (selectedRows.length === maxRowSelection && maxRowSelection > 1) {
          markDeselectedRowDisabled(state);
        } else if (selectedRows.length < maxRowSelection && previousSelectionLength === maxRowSelection) {
          markDeselectedRowEnabled(state);
        }
      } else {
        // eslint-disable-next-line no-console
        console.error(`The "selectedRows" passed into "lightning:datatable"
        must be an Array with the keys of the selected rows. We receive instead ${value}`);
        markAllRowsDeselected(state);
      }
    }
    function getMaxRowSelection(state) {
      return state.maxRowSelection;
    }
    function getHideSelectAllCheckbox(state) {
      return getMaxRowSelection(state) === 1;
    }
    function setMaxRowSelection(state, value) {
      markAllRowsDeselected(state);

      if (isPositiveInteger(value)) {
        const previousMaxRowSelection = getMaxRowSelection(state);
        state.maxRowSelection = Number(value);

        if (inputTypeNeedsToChange(previousMaxRowSelection, getMaxRowSelection(state))) {
          updateRowSelectionInputType(state);
          updateSelectionState(state);
        }
      } else {
        state.maxRowSelection = MAX_ROW_SELECTION_DEFAULT; // eslint-disable-next-line no-console

        console.error(`The maxRowSelection value passed into lightning:datatable
            should be a positive integer. We receive instead (${value}).`);
      }
    }
    function inputTypeNeedsToChange(previousMaxRowSelection, newMaxRowSelection) {
      return previousMaxRowSelection === 1 && isMultiSelection(newMaxRowSelection) || isMultiSelection(previousMaxRowSelection) && newMaxRowSelection === 1 || previousMaxRowSelection === 0 || newMaxRowSelection === 0;
    }
    function isMultiSelection(value) {
      return value > 1 || value === undefined;
    }
    function updateRowSelectionInputType(state) {
      const type = getRowSelectionInputType(state);
      const rows = getRows(state);
      resetSelectedRowsKeys(state);
      rows.forEach(row => {
        row.inputType = type;
        row.isSelected = false;
        row.ariaSelected = false;
        row.isDisabled = isDisabledRow(state, row.key);
      });
    }
    function isSelectedRow(state, rowKeyValue) {
      return !!state.selectedRowsKeys[rowKeyValue];
    }
    function isDisabledRow(state, rowKeyValue) {
      if (!isSelectedRow(state, rowKeyValue)) {
        const maxRowSelection = getMaxRowSelection(state); // W-4819182 when selection is 1, we should not disable selection.

        return maxRowSelection !== 1 && getCurrentSelectionLength(state) === maxRowSelection;
      }

      return false;
    }
    function getRowSelectionInputType(state) {
      if (getMaxRowSelection(state) === 1) {
        return 'radio';
      }

      return 'checkbox';
    }
    function markDeselectedRowDisabled(state) {
      const rows = getRows(state);
      rows.forEach(row => {
        if (!isSelectedRow(state, row.key)) {
          row.isDisabled = true;
        }
      });
    }
    function markDeselectedRowEnabled(state) {
      const rows = getRows(state);
      rows.forEach(row => {
        if (!isSelectedRow(state, row.key)) {
          row.isDisabled = false;
        }
      });
    }
    function getCurrentSelectionLength(state) {
      return getSelectedRowsKeys(state).length;
    }
    function markRowSelected(state, rowKeyValue) {
      const row = getRowByKey(state, rowKeyValue);
      const maxRowSelection = getMaxRowSelection(state) || getRowsTotal(state);
      const previousSelectionLength = getCurrentSelectionLength(state);
      row.isSelected = true;
      row.ariaSelected = 'true';
      row.classnames = resolveRowClassNames(row);

      if (maxRowSelection > 1) {
        addKeyToSelectedRowKeys(state, row.key);

        if (previousSelectionLength + 1 === maxRowSelection) {
          markDeselectedRowDisabled(state);
        }
      } else {
        if (previousSelectionLength === 1) {
          const previousSelectedRow = getRowByKey(state, Object.keys(state.selectedRowsKeys)[0]);
          previousSelectedRow.isSelected = false;
          previousSelectedRow.ariaSelected = false;
          previousSelectedRow.classnames = resolveRowClassNames(previousSelectedRow);
          resetSelectedRowsKeys(state);
        }

        addKeyToSelectedRowKeys(state, row.key);
      }
    }
    function markRowDeselected(state, rowKeyValue) {
      const row = getRowByKey(state, rowKeyValue);
      const maxRowSelection = getMaxRowSelection(state);
      row.isSelected = false;
      row.ariaSelected = false;
      row.classnames = resolveRowClassNames(row);
      removeKeyFromSelectedRowKeys(state, row.key);

      if (getCurrentSelectionLength(state) === maxRowSelection - 1) {
        markDeselectedRowEnabled(state);
      }
    }
    function resetSelectedRowsKeys(state) {
      state.selectedRowsKeys = {};
    }
    function markAllRowsSelected(state) {
      const rows = getRows(state);
      const maxRowSelection = getMaxRowSelection(state);
      resetSelectedRowsKeys(state);
      rows.forEach((row, index) => {
        if (index < maxRowSelection || maxRowSelection === undefined) {
          row.isSelected = true;
          row.ariaSelected = 'true';
          row.classnames = resolveRowClassNames(row);
          addKeyToSelectedRowKeys(state, row.key);
        } else {
          row.isDisabled = true;
          row.isSelected = false;
          row.ariaSelected = false;
          row.classnames = resolveRowClassNames(row);
        }
      });
    }
    function markAllRowsDeselected(state) {
      const rows = getRows(state);
      resetSelectedRowsKeys(state);
      rows.forEach(row => {
        row.isDisabled = false;
        row.isSelected = false;
        row.ariaSelected = false;
        row.classnames = resolveRowClassNames(row);
      });
      return state;
    }
    function syncSelectedRowsKeys(state, selectedRows) {
      let changed = false;
      const {
        selectedRowsKeys,
        keyField
      } = state;

      if (Object.keys(selectedRowsKeys).length !== selectedRows.length) {
        changed = true;
        state.selectedRowsKeys = updateSelectedRowsKeysFromSelectedRows(selectedRows, keyField);
      } else {
        changed = selectedRows.some(row => !selectedRowsKeys[row[keyField]]);

        if (changed) {
          state.selectedRowsKeys = updateSelectedRowsKeysFromSelectedRows(selectedRows, keyField);
        }
      }

      updateSelectionState(state);
      return {
        ifChanged: callback => {
          if (changed && typeof callback === 'function') {
            callback(selectedRows);
          }
        }
      };
    }
    function handleRowSelectionChange() {
      updateSelectionState(this.state);
    }

    function updateSelectedRowsKeysFromSelectedRows(selectedRows, keyField) {
      return selectedRows.reduce((selectedRowsKeys, row) => {
        selectedRowsKeys[row[keyField]] = true;
        return selectedRowsKeys;
      }, {});
    }

    function addKeyToSelectedRowKeys(state, key) {
      state.selectedRowsKeys[key] = true;
    }

    function removeKeyFromSelectedRowKeys(state, key) {
      // not using delete this.state.selectedRowsKeys[key]
      // because that cause perf issues
      state.selectedRowsKeys[key] = false;
    }

    function updateSelectionState(state) {
      const selectBoxesColumnIndex = getSelectBoxesColumnIndex(state);

      if (selectBoxesColumnIndex >= 0) {
        state.columns[selectBoxesColumnIndex] = Object.assign({}, state.columns[selectBoxesColumnIndex], {
          bulkSelection: getBulkSelectionState(state),
          isBulkSelectionDisabled: isBulkSelectionDisabled(state)
        });
      }
    }
    function getBulkSelectionState(state) {
      const selected = getCurrentSelectionLength(state);
      const total = getMaxRowSelection(state) || getRowsTotal(state);

      if (selected === 0) {
        return 'none';
      } else if (selected === total) {
        return 'all';
      }

      return 'some';
    }
    function isBulkSelectionDisabled(state) {
      return getRowsTotal(state) === 0 || getMaxRowSelection(state) === 0;
    }

    function getSelectBoxesColumnIndex(state) {
      const columns = getColumns(state) || [];
      let selectBoxColumnIndex = -1;
      columns.some((column, index) => {
        if (column.type === SELECTABLE_ROW_CHECKBOX) {
          selectBoxColumnIndex = index;
          return true;
        }

        return false;
      });
      return selectBoxColumnIndex;
    }

    function getTreeStateIndicatorFieldNames() {
      return {
        children: 'hasChildren',
        level: 'level',
        expanded: 'isExpanded',
        position: 'posInSet',
        setsize: 'setSize'
      };
    }
    function hasTreeDataType(state) {
      const columns = getColumns(state);
      return columns.some(column => {
        return isTreeType(column.type);
      });
    }
    function getStateTreeColumn(state) {
      const columns = getColumns(state);

      for (let i = 0; i < columns.length; i++) {
        if (isTreeType(columns[i].type)) {
          return columns[i];
        }
      }

      return null;
    }
    function fireRowToggleEvent(rowKeyValue, expanded) {
      const customEvent = new CustomEvent('privatetogglecell', {
        bubbles: true,
        composed: true,
        cancelable: true,
        detail: {
          name: rowKeyValue,
          nextState: expanded ? false : true // True = expanded, False = collapsed

        }
      });
      this.dispatchEvent(customEvent);
    }

    function getErrorsState() {
      return {
        errors: {
          rows: {},
          table: {}
        }
      };
    }
    function getErrors(state) {
      return state.errors;
    }
    function setErrors(state, errors) {
      return state.errors = Object.assign({}, getErrorsState(), errors);
    }
    function getRowError(state, rowKey) {
      const rows = getErrors(state).rows;
      return rows && rows[rowKey] || {};
    }
    function getTableError(state) {
      return getErrors(state).table || {};
    }

    function getRowsDefaultState() {
      return {
        data: [],
        keyField: undefined,
        rows: [],
        indexes: {}
      };
    }
    function setData(state, data) {
      if (Array.isArray(data)) {
        state.data = data;
      } else {
        state.data = [];
      }
    }
    function getData(state) {
      return state.data;
    }
    function getRows(state) {
      return state.rows;
    }
    function setKeyField(state, value) {
      assert(typeof value === 'string', `The "keyField" value expected in lightning:datatable must be type String.`);

      if (typeof value === 'string') {
        state.keyField = value;
      } else {
        state.keyField = undefined;
      }
    }
    function getKeyField(state) {
      return state.keyField;
    }
    function hasValidKeyField(state) {
      const keyField = getKeyField(state);
      return typeof keyField === 'string';
    }
    /**
     * It resolve the css classes for a row based on the row.isSelected state
     * @param {object} row - a row object in state.rows collection
     * @returns {string} the classSet string
     */

    function resolveRowClassNames(row) {
      const classes = classSet$1('slds-hint-parent');

      if (row.isSelected) {
        classes.add('slds-is-selected');
      }

      return classes.toString();
    }
    /**
     *
     * @param {object} state - data table state
     * @param {string} rowKeyValue - computed id for the row
     * @param {string} colKeyValue - computed id for the column
     *
     * @return {object} The user row that its related to the action.
     */

    function getUserRowByCellKeys(state, rowKeyValue, colKeyValue) {
      const rowIndex = state.indexes[rowKeyValue][colKeyValue][0];
      return getData(state)[rowIndex];
    }
    /**
     * It compute the state.rows collection based on the current normalized (data, columns)
     * and generate cells indexes map(state.indexes)
     * @param {object} state - the current datatable state
     */

    function updateRowsAndCellIndexes() {
      const {
        state,
        privateTypes: types
      } = this;
      const {
        keyField
      } = state;
      const data = getData(state);
      const columns = getColumns(state);
      const {
        computeUniqueRowKey
      } = createRowKeysGenerator(keyField);
      const scopeCol = columns.find(colData => types.isValidType(colData.type) && colData.isScopeCol); // initializing indexes

      state.indexes = {};
      state.rows = data.reduce((prev, rowData, rowIndex) => {
        const row = {
          key: computeUniqueRowKey(rowData),
          // attaching unique key to the row
          cells: []
        };
        const rowErrors = getRowError(state, row.key);
        state.indexes[row.key] = {
          rowIndex
        };
        row.inputType = getRowSelectionInputType(state);
        row.isSelected = isSelectedRow(state, row.key);
        row.ariaSelected = row.isSelected ? 'true' : false;
        row.isDisabled = isDisabledRow(state, row.key);
        row.classnames = resolveRowClassNames(row);
        Object.assign(row, getRowStateForTree(rowData, state));
        row.tabIndex = -1;
        columns.reduce((currentRow, colData, colIndex) => {
          const {
            fieldName
          } = colData;
          const colKeyValue = generateColKeyValue(colData, colIndex);
          const dirtyValue = getDirtyValue(state, row.key, colKeyValue);
          const computedCellValue = dirtyValue !== undefined ? dirtyValue : rowData[fieldName];
          const colType = types.getType(colData.type); // cell object creation

          const cell = {
            columnType: colData.type,
            columnSubType: colData.typeAttributes ? colData.typeAttributes.subType : undefined,
            dataLabel: colData.label,
            value: computedCellValue,
            // value based on the fieldName
            rowKeyValue: row.key,
            // unique row key value
            colKeyValue,
            // unique column key value
            tabIndex: -1,
            // tabindex
            isCheckbox: colData.type === 'SELECTABLE_CHECKBOX',
            class: computeCellClassNames(colData, rowErrors, dirtyValue),
            hasError: rowErrors.fieldNames && rowErrors.fieldNames.includes(colData.fieldName),
            isDataType: types.isValidType(colData.type) && !colData.isScopeCol,
            isDataTypeScope: types.isValidType(colData.type) && colData.isScopeCol,
            wrapText: state.wrapText[colKeyValue],
            // wrapText state
            style: colType && colType.type === 'custom' ? 'padding: 0px;' : undefined
          };

          if (isCustomerColumn(colData)) {
            Object.assign(cell, computeCellTypeAttributes(rowData, colData, types), computeCellAttributes(rowData, colData), computeCellEditable(colData));

            if (isTreeType(colData.type)) {
              Object.assign(cell, computeCellStateTypeAttributes(row));
            }
          } else if (isRowNumberColumn(colData)) {
            const scopeColValue = rowData[scopeCol.fieldName];
            const errorColumnDef = getRowNumberErrorColumnDef(rowErrors, scopeColValue);
            Object.assign(cell, computeCellTypeAttributes(rowData, errorColumnDef, types));
          } // adding cell indexes to state.indexes
          // Keeping the hash for backward compatibility, but we need to have 2 indexes, 1 for columns and one for rows,
          // because of memory usage and also at certain point we might have the data but not the columns


          state.indexes[row.key][colKeyValue] = [rowIndex, colIndex];
          currentRow.push(cell);
          return currentRow;
        }, row.cells);
        prev.push(row);
        return prev;
      }, []);
    }
    function computeCellAttributes(row, column) {
      const cellAttributesValues = getCellAttributesValues(column);
      return Object.keys(cellAttributesValues).reduce((attrs, attrName) => {
        const attrValue = cellAttributesValues[attrName];
        attrs[attrName] = resolveAttributeValue(attrValue, row);
        return attrs;
      }, {});
    }
    function computeCellTypeAttributes(row, column, types) {
      if (column.typeAttributes && column.typeAttributes.subType) {
        return computeCellSubTypeAttributes(row, column);
      }

      const attributesNames = types.getType(column.type).typeAttributes;
      const typeAttributesValues = getTypeAttributesValues(column);
      return attributesNames.reduce((attrs, attrName, index) => {
        const typeAttributeName = `typeAttribute${index}`;
        attrs[typeAttributeName] = resolveAttributeValue(typeAttributesValues[attrName], row);
        return attrs;
      }, {});
    }
    function computeCellSubTypeAttributes(row, column) {
      const attributesNames = getAttributesNames(column.typeAttributes.subType);
      const typeAttributesValues = getSubTypeAttributesValues(column);
      return attributesNames.reduce((attrs, attrName, index) => {
        const typeAttributeName = `typeAttribute${index}`;
        attrs[typeAttributeName] = resolveAttributeValue(typeAttributesValues[attrName], row);
        return attrs;
      }, {});
    }

    function computeCellEditable(column) {
      return {
        editable: column.editable
      };
    }

    function computeCellClassNames(column, rowErrors, dirtyValue) {
      const classNames = classSet$1('');
      classNames.add({
        'slds-cell-edit': column.editable === true
      });
      classNames.add({
        'slds-tree__item': isTreeType(column.type)
      });
      classNames.add({
        'slds-has-error': rowErrors.fieldNames && rowErrors.fieldNames.includes(column.fieldName)
      });
      classNames.add({
        'slds-is-edited': dirtyValue !== undefined
      });
      return classNames.toString();
    }
    /**
     * Attaches if the row containing this cell hasChildren or not and isExpanded or not
     * attributes to typeAttribute21 and typeAttribute22 respectively
     * typeAttribute0-typeAttribute20 are reserved for  types supported by tree
     * @param {object}row - current row which is stored in state.rows
     * @returns {{typeAttribute21, typeAttribute22: boolean}} typeAttributes
     * describing state of the row associated
     */


    function computeCellStateTypeAttributes(row) {
      return {
        typeAttribute21: row.hasChildren,
        typeAttribute22: row.isExpanded === 'true'
      };
    }

    function getRowIndexByKey(state, key) {
      if (!state.indexes[key]) {
        return undefined;
      }

      return state.indexes[key].rowIndex;
    }
    function getRowByKey(state, key) {
      const rows = getRows(state);
      return rows[getRowIndexByKey(state, key)];
    }
    function rowKeyExists(state, key) {
      return !!state.indexes[key];
    }
    function getRowsTotal(state) {
      return getRows(state).length;
    }

    function resolveAttributeValue(attrValue, row) {
      if (isObjectLike(attrValue)) {
        const fieldName = attrValue.fieldName;

        if (fieldName) {
          return row[fieldName];
        }
      }

      return attrValue;
    }

    function getRowStateForTree(row, state) {
      const column = getStateTreeColumn(state);

      if (column) {
        return {
          level: getRowLevel(column, row),
          posInSet: getRowPosInSet(column, row),
          setSize: getRowSetSize(column, row),
          isExpanded: isRowExpanded(column, row),
          hasChildren: getRowHasChildren(column, row)
        };
      }

      return {};
    }

    function getRowLevel(column, row) {
      const typeAttributesValues = getTypeAttributesValues(column);
      const attrValue = resolveAttributeValue(typeAttributesValues[getTreeStateIndicatorFieldNames().level], row);
      return attrValue ? attrValue : 1;
    }

    function getRowPosInSet(column, row) {
      const typeAttributesValues = getTypeAttributesValues(column);
      const attrValue = resolveAttributeValue(typeAttributesValues[getTreeStateIndicatorFieldNames().position], row);
      return attrValue ? attrValue : 1;
    }

    function getRowSetSize(column, row) {
      const typeAttributesValues = getTypeAttributesValues(column);
      const attrValue = resolveAttributeValue(typeAttributesValues[getTreeStateIndicatorFieldNames().setsize], row);
      return attrValue ? attrValue : 1;
    }

    function isRowExpanded(column, row) {
      const typeAttributesValues = getTypeAttributesValues(column);
      const hasChildren = resolveAttributeValue(typeAttributesValues[getTreeStateIndicatorFieldNames().children], row);

      if (hasChildren) {
        const attrValue = resolveAttributeValue(typeAttributesValues[getTreeStateIndicatorFieldNames().expanded], row);
        return !!attrValue + '';
      }

      return undefined;
    }
    function getRowHasChildren(column, row) {
      const typeAttributesValues = getTypeAttributesValues(column);
      const hasChildren = resolveAttributeValue(typeAttributesValues[getTreeStateIndicatorFieldNames().children], row);
      return !!hasChildren;
    }

    const ARROW_RIGHT = 39;
    const ARROW_LEFT = 37;
    const ARROW_DOWN = 40;
    const ARROW_UP = 38;
    const ENTER = 13;
    const ESCAPE = 27;
    const TAB = 9;
    const SPACE = 32;
    const NAVIGATION_DIR = {
      RIGHT: 1,
      LEFT: -1,
      USE_CURRENT: 0,
      RESET: 2
    };
    const TOP_MARGIN = 80;
    const BOTTOM_MARGIN = 80;
    const SCROLL_OFFSET = 20;
    const NAVIGATION_MODE = 'NAVIGATION';
    function getKeyboardDefaultState() {
      return {
        keyboardMode: NAVIGATION_MODE,
        rowMode: false,
        activeCell: undefined,
        tabindex: 0,
        cellToFocusNext: null,
        cellClicked: false
      };
    }
    /**
     * It update the current activeCell in the state with the new rowKeyValue, colKeyValue
     * @param {object} state - datatable state
     * @param {string} rowKeyValue  - the unique row key value
     * @param {string} colKeyValue {string} - the unique col key value
     * @returns {object} state - mutated datatable state
     */

    const updateActiveCell = function (state, rowKeyValue, colKeyValue) {
      state.activeCell = {
        rowKeyValue,
        colKeyValue
      };
      return state;
    };
    /**
     * It return if the pair rowKeyValue, colKeyValue are the current activeCell values
     * @param {object} state - datatable state
     * @param {string} rowKeyValue  - the unique row key value
     * @param {string} colKeyValue {string} - the unique col key value
     * @returns {boolean} - true if rowKeyValue, colKeyValue are the current activeCell values.
     */

    const isActiveCell = function (state, rowKeyValue, colKeyValue) {
      if (state.activeCell) {
        const {
          rowKeyValue: currentRowKeyValue,
          colKeyValue: currentColKeyValue
        } = state.activeCell;
        return currentRowKeyValue === rowKeyValue && currentColKeyValue === colKeyValue;
      }

      return false;
    };
    /**
     * It check if in the current (data, columns) the activeCell still valid.
     * When data changed the activeCell could be removed, then we check if there is cellToFocusNext
     * which is calculated from previously focused cell, if so we sync to that
     * If active cell is still valid we keep it the same
     *
     * @param {object} state - datatable state
     * @returns {object} state - mutated datatable state
     */

    const syncActiveCell = function (state) {
      if (!state.activeCell || !stillValidActiveCell(state)) {
        if (state.activeCell && state.cellToFocusNext) {
          // there is previously focused cell
          setNextActiveCellFromPrev(state);
        } else {
          // there is no active cell or there is no previously focused cell
          setDefaultActiveCell(state);
        }
      }

      return state;
    };
    const datatableHasFocus = function (state) {
      return state.tabindex === false || state.cellClicked;
    };
    /**
     * Sets the row and col index of cell to focus next if
     * there is state.activecell
     * datatable has focus
     * there is state.indexes
     * there is no  previously set state.cellToFocusNext
     * Indexes are calculated as to what to focus on next
     * @param {object} state - datatable state
     */

    const setCellToFocusFromPrev = function (state) {
      if (state.activeCell && datatableHasFocus(state) && state.indexes && !state.cellToFocusNext) {
        let {
          rowIndex,
          colIndex
        } = getIndexesActiveCell(state);
        colIndex = 0; // default point to the first column

        if (state.rows && rowIndex === state.rows.length - 1) {
          // if it is last row, make it point to its previous row
          rowIndex = state.rows.length - 1;
          colIndex = state.columns ? state.columns.length - 1 : 0;
        }

        state.cellToFocusNext = {
          rowIndex,
          colIndex
        };
      }
    };
    /**
     * if the current new active still is valid ie exists then set the celltofocusnext to null
     * @param {object} state - datatable state
     */

    const updateCellToFocusFromPrev = function (state) {
      if (state.activeCell && state.cellToFocusNext && stillValidActiveCell(state)) {
        // if the previous focused is there and valid,  dont set the prevActiveFocusedCell
        state.cellToFocusNext = null;
      }
    };
    /**
     * reset celltofocusnext to null (used after render)
     * @param {object} state - datatable state
     */

    const resetCellToFocusFromPrev = function (state) {
      state.cellToFocusNext = null;
    };
    /**
     * Sets the next active if there is a previously focused active cell
     * Logic is:
     * if the rowIndex is existing one - cell = (rowIndex, 0)
     * if the rowIndex is > the number of rows (focused was last row or more) = (lastRow, lastColumn)
     * for columns
     * same as above except if the colIndex is > the number of cols (means no data) = set it to null??
     * @param {object} state - datatable state
     */

    function setNextActiveCellFromPrev(state) {
      const {
        rowIndex,
        colIndex
      } = state.cellToFocusNext;
      let nextRowIndex = rowIndex;
      let nextColIndex = colIndex;
      const rowsCount = state.rows ? state.rows.length : 0;
      const colsCount = state.columns.length ? state.columns.length : 0;

      if (nextRowIndex > rowsCount - 1) {
        // row index not existing after update to new 5 > 5-1, 6 > 5-1,
        nextRowIndex = rowsCount - 1;
      }

      if (nextColIndex > colsCount - 1) {
        // col index not existing after update to new
        nextColIndex = colsCount - 1;
      }

      const nextActiveCell = getCellFromIndexes(state, nextRowIndex, nextColIndex);

      if (nextActiveCell) {
        state.activeCell = nextActiveCell;
      } else {
        setDefaultActiveCell(state);
      }

      state.keyboardMode = 'NAVIGATION';
    }
    /**
     * It update the tabIndex value of a cell in the state for the rowIndex, colIndex passed
     * as consequence of this change
     * datatable is gonna re-render the cell affected with the new tabindex value
     *
     * @param {object} state - datatable state
     * @param {number} rowIndex - the row index
     * @param {number} colIndex - the column index
     * @param {number} [index = 0] - the value for the tabindex
     */


    const updateTabIndex = function (state, rowIndex, colIndex, index = 0) {
      if (isHeaderRow(rowIndex)) {
        const {
          columns
        } = state;
        columns[colIndex].tabIndex = index;
      } else {
        state.rows[rowIndex].cells[colIndex].tabIndex = index;
      }
    };
    /**
     * It updates the tabIndex value of a row in the state for the rowIndex passed
     * as consequence of this change
     * datatable is gonna re-render the row affected with the new tabindex value
     *
     * @param {object} state - datatable state
     * @param {number} rowIndex - the row index
     * @param {number} [index = 0] - the value for the tabindex
     */

    const updateTabIndexRow = function (state, rowIndex, index = 0) {
      if (!isHeaderRow(rowIndex)) {
        // TODO what to do when rowIndex is header row
        state.rows[rowIndex].tabIndex = index;
      }
    };
    /**
     * It update the tabindex for the current activeCell.
     * @param {object} state - datatable state
     * @param {number} [index = 0] - the value for the tabindex
     * @returns {object} state - mutated state
     */

    const updateTabIndexActiveCell = function (state, index = 0) {
      if (state.activeCell && !stillValidActiveCell(state)) {
        syncActiveCell(state);
      } // we need to check again because maybe there is no active cell after sync


      if (state.activeCell && !isRowNavigationMode(state)) {
        const {
          rowIndex,
          colIndex
        } = getIndexesActiveCell(state);
        updateTabIndex(state, rowIndex, colIndex, index);
      }

      return state;
    };
    /**
     * It updates the tabindex for the row of the current activeCell.
     * This happens in rowMode of NAVIGATION_MODE
     * @param {object} state - datatable state
     * @param {number} [index = 0] - the value for the tabindex
     * @returns {object} state - mutated state
     */

    const updateTabIndexActiveRow = function (state, index = 0) {
      if (state.activeCell && !stillValidActiveCell(state)) {
        syncActiveCell(state);
      } // we need to check again because maybe there is no active cell after sync


      if (state.activeCell && isRowNavigationMode(state)) {
        const {
          rowIndex
        } = getIndexesActiveCell(state);
        updateTabIndexRow(state, rowIndex, index);
      }

      return state;
    };
    /**
     * If new set of columns doesnt have tree data mark it to false, as it
     * could be true earlier
     * Else if it has tree data, check if rowMode is false
     * Earlier it didnt have tree data, set rowMode to true to start
     * if rowMode is false and earlier it has tree data, keep it false
     * if rowMode is true and it has tree data, keep it true
     * @param {boolean} hadTreeDataTypePreviously - state object
     * @param {object} state - state object
     * @returns {object} state - mutated state
     */

    function updateRowNavigationMode(hadTreeDataTypePreviously, state) {
      if (!hasTreeDataType(state)) {
        state.rowMode = false;
      } else if (state.rowMode === false && !hadTreeDataTypePreviously) {
        state.rowMode = true;
      }

      return state;
    }
    /**
     * It return the indexes { rowIndex, colIndex } of a cell based of the unique cell values
     * rowKeyValue, colKeyValue
     * @param {object} state - datatable state
     * @param {string} rowKeyValue - the row key value
     * @param {string} colKeyValue - the column key value
     * @returns {object} - {rowIndex, colIndex}
     */

    const getIndexesByKeys = function (state, rowKeyValue, colKeyValue) {
      if (rowKeyValue === 'HEADER') {
        return {
          rowIndex: -1,
          colIndex: state.headerIndexes[colKeyValue]
        };
      }

      return {
        rowIndex: state.indexes[rowKeyValue][colKeyValue][0],
        colIndex: state.indexes[rowKeyValue][colKeyValue][1]
      };
    };
    /**
     * It set the focus to the current activeCell, this operation imply multiple changes
     * - update the tabindex of the activeCell
     * - set the current keyboard mode
     * - set the focus to the cell
     * @param {node} element - the custom element template `this.template`
     * @param {object} state - datatable state
     * @param {int} direction - direction (-1 left, 1 right and 0 for no direction) its used to know which actionable element to activate.
     * @param {object} info - extra information when setting the cell mode.
     */

    const setFocusActiveCell = function (element, state, direction, info) {
      const {
        keyboardMode
      } = state;
      const {
        rowIndex,
        colIndex
      } = getIndexesActiveCell(state);
      updateTabIndex(state, rowIndex, colIndex); // eslint-disable-next-line lwc/no-set-timeout

      setTimeout(() => {
        const cellElement = getCellElementByIndexes(element, rowIndex, colIndex);

        if (cellElement) {
          if (direction) {
            cellElement.resetCurrentInputIndex(direction);
          }

          cellElement.addFocusStyles();
          cellElement.parentElement.classList.add('slds-has-focus');
          cellElement.parentElement.focus();
          cellElement.setMode(keyboardMode, info);
          const scrollingParent = element.querySelector('.slds-table_header-fixed_container');
          const scrollableY = element.querySelector('.slds-scrollable_y');
          const parentRect = scrollingParent.getBoundingClientRect();
          const findMeRect = cellElement.getBoundingClientRect();

          if (findMeRect.top < parentRect.top + TOP_MARGIN) {
            scrollableY.scrollTop -= SCROLL_OFFSET;
          } else if (findMeRect.bottom > parentRect.bottom - BOTTOM_MARGIN) {
            scrollableY.scrollTop += SCROLL_OFFSET;
          }
        }
      }, 0);
    };
    /**
     * It adds and the focus classes to the th/td.
     *
     * @param {node} element - the custom element template `this.template`
     * @param {object} state - datatable state
     */

    const addFocusStylesToActiveCell = function (element, state) {
      const {
        rowIndex,
        colIndex
      } = getIndexesActiveCell(state);
      const cellElement = getCellElementByIndexes(element, rowIndex, colIndex);

      if (cellElement) {
        cellElement.parentElement.classList.add('slds-has-focus');
      }
    };
    /**
     * It blur to the current activeCell, this operation imply multiple changes
     * - blur the activeCell
     * - update the tabindex to -1
     * @param {node} element - the custom element root `this.template`
     * @param {object} state - datatable state
     */

    const setBlurActiveCell = function (element, state) {
      if (state.activeCell) {
        const {
          rowIndex,
          colIndex
        } = getIndexesActiveCell(state); // eslint-disable-next-line lwc/no-set-timeout

        setTimeout(() => {
          const cellElement = getCellElementByIndexes(element, rowIndex, colIndex); // we need to check because of the tree,
          // at this point it may remove/change the rows/keys because opening or closing a row.

          if (cellElement) {
            if (document.activeElement === cellElement) {
              cellElement.blur();
            }

            cellElement.removeFocusStyles(true);
            cellElement.parentElement.classList.remove('slds-has-focus');
          }
        }, 0);
        updateTabIndex(state, rowIndex, colIndex, -1);
      }
    };
    /**
     * It set the focus to the current activeCell, this operation imply multiple changes
     * - update the tabindex of the activeCell
     * - set the current keyboard mode
     * - set the focus to the cell
     * @param {node} element - the custom element root `this.template`
     * @param {object} state - datatable state
     */

    const setFocusActiveRow = function (element, state) {
      const {
        rowIndex
      } = getIndexesActiveCell(state);
      updateTabIndexRow(state, rowIndex); // eslint-disable-next-line lwc/no-set-timeout

      setTimeout(() => {
        const row = getRowElementByIndexes(element, rowIndex);
        row.focus();
        const scrollingParent = element.querySelector('.slds-table_header-fixed_container');
        const scrollableY = element.querySelector('.slds-scrollable_y');
        const parentRect = scrollingParent.getBoundingClientRect();
        const findMeRect = row.getBoundingClientRect();

        if (findMeRect.top < parentRect.top + TOP_MARGIN) {
          scrollableY.scrollTop -= SCROLL_OFFSET;
        } else if (findMeRect.bottom > parentRect.bottom - BOTTOM_MARGIN) {
          scrollableY.scrollTop += SCROLL_OFFSET;
        }
      }, 0);
    };
    /**
     * It blur the active Row, this operation imply multiple changes
     * - blur the active row
     * - update the tabindex to -1
     * @param {node} element - the custom element root `this.template`
     * @param {object} state - datatable state
     */

    const setBlurActiveRow = function (element, state) {
      if (state.activeCell) {
        const {
          rowIndex
        } = getIndexesActiveCell(state); // eslint-disable-next-line lwc/no-set-timeout

        setTimeout(() => {
          const row = getRowElementByIndexes(element, rowIndex);

          if (document.activeElement === row) {
            row.blur();
          }
        }, 0);
        updateTabIndexRow(state, rowIndex, -1);
      }
    };
    /**
     * It changes the datable state based on the keyboard event sent from the cell component,
     * the result of those change may trigger re-render on the table
     * @param {node} element - the custom element root `this.template`
     * @param {object} state - datatable state
     * @param {event} event - custom DOM event sent by the cell
     * @returns {object} - mutated state
     */

    const reactToKeyboard = function (element, state, event) {
      switch (event.detail.keyCode) {
        case ARROW_RIGHT:
          return reactToArrowRight(element, state, event);

        case ARROW_LEFT:
          return reactToArrowLeft(element, state, event);

        case ARROW_DOWN:
          return reactToArrowDown(element, state, event);

        case ARROW_UP:
          return reactToArrowUp(element, state, event);

        case ENTER:
        case SPACE:
          return reactToEnter(element, state, event);

        case ESCAPE:
          return reactToEscape(element, state, event);

        case TAB:
          return reactToTab(element, state, event);

        default:
          return state;
      }
    };

    function reactToKeyboardInNavMode(element, state, event) {
      const mockEvent = {
        detail: {
          rowKeyValue: state.activeCell.rowKeyValue,
          colKeyValue: state.activeCell.colKeyValue,
          keyCode: event.keyCode,
          shiftKey: event.shiftKey
        },
        preventDefault: () => {},
        stopPropagation: () => {}
      };

      switch (event.keyCode) {
        case ARROW_RIGHT:
          event.preventDefault();
          return reactToArrowRight(element, state, mockEvent);

        case ARROW_LEFT:
          event.preventDefault();
          return reactToArrowLeft(element, state, mockEvent);

        case ARROW_DOWN:
          event.preventDefault();
          return reactToArrowDown(element, state, mockEvent);

        case ARROW_UP:
          event.preventDefault();
          return reactToArrowUp(element, state, mockEvent);

        case ENTER:
        case SPACE:
          event.preventDefault();
          return reactToEnter(element, state, mockEvent);

        case ESCAPE:
          // do nothing since this only handles navigation mode.
          return state;

        case TAB:
          // event.preventDefault();
          return reactToTab(element, state, mockEvent);

        default:
          return state;
      }
    }

    const reactToKeyboardOnRow = function (dt, state, event) {
      if (isRowNavigationMode(state) && event.target.localName.indexOf('tr') !== -1) {
        const element = dt.template;

        switch (event.detail.keyCode) {
          case ARROW_RIGHT:
            return reactToArrowRightOnRow.call(dt, element, state, event);

          case ARROW_LEFT:
            return reactToArrowLeftOnRow.call(dt, element, state, event);

          case ARROW_DOWN:
            return reactToArrowDownOnRow.call(dt, element, state, event);

          case ARROW_UP:
            return reactToArrowUpOnRow.call(dt, element, state, event);

          default:
            return state;
        }
      }

      return state;
    };

    function isRowNavigationMode(state) {
      return state.keyboardMode === 'NAVIGATION' && state.rowMode === true;
    }

    function setRowNavigationMode(state) {
      if (hasTreeDataType(state) && state.keyboardMode === 'NAVIGATION') {
        state.rowMode = true;
      }
    }
    function unsetRowNavigationMode(state) {
      state.rowMode = false;
    }
    function canBeRowNavigationMode(state) {
      return hasTreeDataType(state) && state.keyboardMode === 'NAVIGATION';
    }

    function isHeaderRow(rowIndex) {
      return rowIndex === -1;
    }

    function getCellElementByIndexes(element, rowIndex, colIndex) {
      if (isHeaderRow(rowIndex)) {
        const rowElement = element.querySelector(`thead > tr:nth-child(1)`);
        return rowElement && rowElement.querySelector(`th:nth-child(${colIndex + 1}) :first-child`);
      }

      return element.querySelector(`tbody > tr:nth-child(${rowIndex + 1}) > *:nth-child(${colIndex + 1}) > :first-child`);
    }

    function getRowElementByIndexes(element, rowIndex) {
      if (isHeaderRow(rowIndex)) {
        return element.querySelector(`thead > tr:nth-child(1)`);
      }

      return element.querySelector(`tbody > tr:nth-child(${rowIndex + 1})`);
    }

    function reactToEnter(element, state, event) {
      if (state.keyboardMode === 'NAVIGATION') {
        state.keyboardMode = 'ACTION';
        const {
          rowIndex,
          colIndex
        } = getIndexesActiveCell(state);
        const actionsMap = {};
        actionsMap[SPACE] = 'space';
        actionsMap[ENTER] = 'enter';

        if (event.detail.keyEvent) {
          event.detail.keyEvent.preventDefault();
        }

        setModeActiveCell(element, state, {
          action: actionsMap[event.detail.keyCode]
        });
        updateTabIndex(state, rowIndex, colIndex, -1);
      }
    }

    function reactToEscape(element, state, event) {
      if (state.keyboardMode === 'ACTION') {
        // When the table is in action mode this event shouldn't bubble
        // because if the table in inside a modal it should prevent the model closes
        event.detail.keyEvent.stopPropagation();
        state.keyboardMode = 'NAVIGATION';
        setModeActiveCell(element, state);
        setFocusActiveCell(element, state, NAVIGATION_DIR.RESET);
      }
    }
    /**
     * Retrieve the next tab index values for row & column
     * @param {object} state - datatable state
     * @param {string} direction - 'RIGHT' or 'LEFT'
     * @returns {object} - nextRowIndex, nextColIndex values, isExitCell boolean
     */


    function getNextTabIndex(state, direction) {
      const {
        rowIndex,
        colIndex
      } = getIndexesActiveCell(state); // decide which function to use based on the value of direction

      const nextTabFunc = {
        RIGHT: getNextTabIndexRight,
        LEFT: getNextTabIndexLeft
      };
      return nextTabFunc[direction](state, rowIndex, colIndex);
    }
    /**
     * Check if we're in an escape/exit cell (first or last of grid)
     * @param {object} state - datatable state
     * @param {string} direction - 'RIGHT' or 'LEFT'
     * @returns {boolean} - if the current cell is or isn't an exit cell
     */


    function isActiveCellAnExitCell(state, direction) {
      // get next tab index values
      const {
        rowIndex,
        colIndex
      } = getIndexesActiveCell(state);
      const {
        nextRowIndex,
        nextColIndex
      } = getNextTabIndex(state, direction); // is it an exit cell?

      if ( // if first cell and moving left
      rowIndex === -1 && colIndex === 0 && nextRowIndex !== -1 && nextColIndex !== 0 || // or if last cell and moving right
      rowIndex !== -1 && nextRowIndex === -1 && nextColIndex === 0) {
        return true;
      }

      return false;
    }

    function reactToTab(element, state, event) {
      event.preventDefault();
      event.stopPropagation();
      const {
        shiftKey
      } = event.detail;
      const direction = shiftKey ? 'LEFT' : 'RIGHT';
      const isExitCell = isActiveCellAnExitCell(state, direction); // if in ACTION mode

      if (state.keyboardMode === 'ACTION') {
        // if not on last or first cell, tab through each cell of the grid
        if (isExitCell === false) {
          // prevent default key event in action mode when actually moving within the grid
          if (event.detail.keyEvent) {
            event.detail.keyEvent.preventDefault();
          } // tab in proper direction based on shift key press


          if (shiftKey) {
            reactToTabLeft(element, state);
          } else {
            reactToTabRight(element, state);
          }
        } else {
          // exit ACTION mode
          state.keyboardMode = 'NAVIGATION';
          setModeActiveCell(element, state);
          state.isExiting = true;
        }
      } else {
        state.isExiting = true;
      }
    }

    function setModeActiveCell(element, state, info) {
      const cellElement = getActiveCellElement(element, state);
      cellElement.setMode(state.keyboardMode, info);
    }

    function getActiveCellElement(element, state) {
      const {
        rowIndex,
        colIndex
      } = getIndexesActiveCell(state);
      return getCellElementByIndexes(element, rowIndex, colIndex);
    }

    function getIndexesActiveCell(state) {
      const {
        activeCell: {
          rowKeyValue,
          colKeyValue
        }
      } = state;
      return getIndexesByKeys(state, rowKeyValue, colKeyValue);
    }

    function reactToArrowRight(element, state, event) {
      const {
        rowKeyValue,
        colKeyValue
      } = event.detail;
      const {
        colIndex
      } = getIndexesByKeys(state, rowKeyValue, colKeyValue);
      const nextColIndex = getNextIndexRight(state, colIndex);
      const {
        columns
      } = state;

      if (nextColIndex === undefined) {
        return;
      }

      setBlurActiveCell(element, state); // update activeCell

      state.activeCell = {
        rowKeyValue,
        colKeyValue: generateColKeyValue(columns[nextColIndex], nextColIndex)
      };
      setFocusActiveCell(element, state, NAVIGATION_DIR.RIGHT);
    }

    function reactToArrowLeft(element, state, event) {
      const {
        rowKeyValue,
        colKeyValue
      } = event.detail;
      const {
        colIndex
      } = getIndexesByKeys(state, rowKeyValue, colKeyValue);

      if (colIndex === 0 && canBeRowNavigationMode(state)) {
        moveFromCellToRow(element, state);
      } else {
        const nextColIndex = getNextIndexLeft(state, colIndex);

        if (nextColIndex === undefined) {
          return;
        }

        const {
          columns
        } = state;
        setBlurActiveCell(element, state); // update activeCell

        state.activeCell = {
          rowKeyValue,
          colKeyValue: generateColKeyValue(columns[nextColIndex], nextColIndex)
        };
        setFocusActiveCell(element, state, NAVIGATION_DIR.LEFT);
      }
    }

    function reactToArrowRightOnRow(element, state, event) {
      const {
        rowKeyValue,
        rowHasChildren,
        rowExpanded
      } = event.detail; // check if row needs to be expanded
      // expand row if has children and is collapsed
      // otherwise make this.state.rowMode = false
      // move tabindex 0 to first cell in the row and focus there

      if (rowHasChildren && !rowExpanded) {
        fireRowToggleEvent.call(this, rowKeyValue, rowExpanded);
      } else {
        moveFromRowToCell(element, state);
      }
    }

    function reactToArrowLeftOnRow(element, state, event) {
      const {
        rowKeyValue,
        rowHasChildren,
        rowExpanded,
        rowLevel
      } = event.detail; // check if row needs to be collapsed
      // if not go to parent and focus there

      if (rowHasChildren && rowExpanded) {
        fireRowToggleEvent.call(this, rowKeyValue, rowExpanded);
      } else if (rowLevel > 1) {
        const treeColumn = getStateTreeColumn(state);

        if (treeColumn) {
          const colKeyValue = treeColumn.colKeyValue;
          const {
            rowIndex
          } = getIndexesByKeys(state, rowKeyValue, colKeyValue);
          const parentIndex = getRowParent(state, rowLevel, rowIndex);

          if (parentIndex !== -1) {
            const rows = getRows(state);
            setBlurActiveRow(element, state); // update activeCell for the row

            state.activeCell = {
              rowKeyValue: rows[parentIndex].key,
              colKeyValue
            };
            setFocusActiveRow(element, state);
          }
        }
      }
    }

    function reactToArrowDownOnRow(element, state, event) {
      // move tabindex 0 one row down
      const {
        rowKeyValue
      } = event.detail;
      const treeColumn = getStateTreeColumn(state);
      event.detail.keyEvent.stopPropagation();
      event.detail.keyEvent.preventDefault();

      if (treeColumn) {
        const colKeyValue = treeColumn.colKeyValue;
        const {
          rowIndex
        } = getIndexesByKeys(state, rowKeyValue, colKeyValue);
        const nextRowIndex = getNextIndexDownWrapped(state, rowIndex);
        const {
          rows
        } = state;

        if (nextRowIndex !== -1) {
          setBlurActiveRow(element, state); // update activeCell for the row

          state.activeCell = {
            rowKeyValue: rows[nextRowIndex].key,
            colKeyValue
          };
          setFocusActiveRow(element, state);
        }
      }
    }

    function reactToArrowUpOnRow(element, state, event) {
      // move tabindex 0 one row down
      // move tabindex 0 one row down
      const {
        rowKeyValue
      } = event.detail;
      const treeColumn = getStateTreeColumn(state);
      event.detail.keyEvent.stopPropagation();
      event.detail.keyEvent.preventDefault();

      if (treeColumn) {
        const colKeyValue = treeColumn.colKeyValue;
        const {
          rowIndex
        } = getIndexesByKeys(state, rowKeyValue, colKeyValue);
        const prevRowIndex = getNextIndexUpWrapped(state, rowIndex);
        const {
          rows
        } = state;

        if (prevRowIndex !== -1) {
          setBlurActiveRow(element, state); // update activeCell for the row

          state.activeCell = {
            rowKeyValue: rows[prevRowIndex].key,
            colKeyValue
          };
          setFocusActiveRow(element, state);
        }
      }
    }

    function moveFromCellToRow(element, state) {
      setBlurActiveCell(element, state);
      setRowNavigationMode(state);
      setFocusActiveRow(element, state);
    }

    function moveFromRowToCell(element, state) {
      setBlurActiveRow(element, state);
      unsetRowNavigationMode(state);
      setFocusActiveCell(element, state, NAVIGATION_DIR.USE_CURRENT);
    }

    function reactToTabRight(element, state) {
      const {
        nextRowIndex,
        nextColIndex
      } = getNextTabIndex(state, 'RIGHT');
      const {
        columns,
        rows
      } = state;
      setBlurActiveCell(element, state); // update activeCell

      state.activeCell = {
        rowKeyValue: nextRowIndex !== -1 ? rows[nextRowIndex].key : 'HEADER',
        colKeyValue: generateColKeyValue(columns[nextColIndex], nextColIndex)
      };
      setFocusActiveCell(element, state, NAVIGATION_DIR.RIGHT, {
        action: 'tab'
      });
    }
    function reactToTabLeft(element, state) {
      const {
        nextRowIndex,
        nextColIndex
      } = getNextTabIndex(state, 'LEFT');
      const {
        columns,
        rows
      } = state;
      setBlurActiveCell(element, state); // update activeCell

      state.activeCell = {
        rowKeyValue: nextRowIndex !== -1 ? rows[nextRowIndex].key : 'HEADER',
        colKeyValue: generateColKeyValue(columns[nextColIndex], nextColIndex)
      };
      setFocusActiveCell(element, state, NAVIGATION_DIR.LEFT, {
        action: 'tab'
      });
    }

    function reactToArrowDown(element, state, event) {
      const {
        rowKeyValue,
        colKeyValue
      } = event.detail;
      const {
        rowIndex
      } = getIndexesByKeys(state, rowKeyValue, colKeyValue);
      const nextRowIndex = getNextIndexDown(state, rowIndex);
      const {
        rows
      } = state;

      if (nextRowIndex === undefined) {
        return;
      }

      if (state.hideTableHeader && nextRowIndex === -1) {
        return;
      }

      if (event.detail.keyEvent) {
        event.detail.keyEvent.stopPropagation();
      }

      setBlurActiveCell(element, state); // update activeCell

      state.activeCell = {
        rowKeyValue: nextRowIndex !== -1 ? rows[nextRowIndex].key : 'HEADER',
        colKeyValue
      };
      setFocusActiveCell(element, state, NAVIGATION_DIR.USE_CURRENT);
    }

    function reactToArrowUp(element, state, event) {
      const {
        rowKeyValue,
        colKeyValue
      } = event.detail;
      const {
        rowIndex
      } = getIndexesByKeys(state, rowKeyValue, colKeyValue);
      const nextRowIndex = getNextIndexUp(state, rowIndex);
      const {
        rows
      } = state;

      if (nextRowIndex === undefined) {
        return;
      }

      if (state.hideTableHeader && nextRowIndex === -1) {
        return;
      }

      if (event.detail.keyEvent) {
        event.detail.keyEvent.stopPropagation();
      }

      setBlurActiveCell(element, state); // update activeCell

      state.activeCell = {
        rowKeyValue: nextRowIndex !== -1 ? rows[nextRowIndex].key : 'HEADER',
        colKeyValue
      };
      setFocusActiveCell(element, state, NAVIGATION_DIR.USE_CURRENT);
    }

    function getNextIndexUp(state, rowIndex) {
      return rowIndex === -1 ? undefined : rowIndex - 1;
    }

    function getNextIndexDown(state, rowIndex) {
      const rowsCount = state.rows.length;
      return rowIndex + 1 < rowsCount ? rowIndex + 1 : undefined;
    }

    function getNextIndexRight(state, colIndex) {
      const columnsCount = state.columns.length;
      return columnsCount > colIndex + 1 ? colIndex + 1 : undefined;
    }

    function getNextIndexLeft(state, colIndex) {
      return colIndex > 0 ? colIndex - 1 : undefined;
    }

    function getNextIndexUpWrapped(state, rowIndex) {
      const rowsCount = state.rows.length;
      return rowIndex === 0 ? -1 : rowIndex === -1 ? rowsCount - 1 : rowIndex - 1;
    }

    function getNextIndexDownWrapped(state, rowIndex) {
      const rowsCount = state.rows.length;
      return rowIndex + 1 < rowsCount ? rowIndex + 1 : -1;
    }

    function getNextTabIndexRight(state, rowIndex, colIndex) {
      const columnsCount = state.columns.length;

      if (columnsCount > colIndex + 1) {
        return {
          nextRowIndex: rowIndex,
          nextColIndex: colIndex + 1
        };
      }

      return {
        nextRowIndex: getNextIndexDownWrapped(state, rowIndex),
        nextColIndex: 0
      };
    }

    function getNextTabIndexLeft(state, rowIndex, colIndex) {
      const columnsCount = state.columns.length;

      if (colIndex > 0) {
        return {
          nextRowIndex: rowIndex,
          nextColIndex: colIndex - 1
        };
      }

      return {
        nextRowIndex: getNextIndexUpWrapped(state, rowIndex),
        nextColIndex: columnsCount - 1
      };
    }

    function getRowParent(state, rowLevel, rowIndex) {
      const parentIndex = rowIndex - 1;
      const rows = getRows(state);

      for (let i = parentIndex; i >= 0; i--) {
        if (rows[i].level === rowLevel - 1) {
          return i;
        }
      }

      return -1;
    }

    function stillValidActiveCell(state) {
      const {
        activeCell: {
          rowKeyValue,
          colKeyValue
        }
      } = state;

      if (rowKeyValue === 'HEADER') {
        return !!state.headerIndexes[colKeyValue];
      }

      return !!(state.indexes[rowKeyValue] && state.indexes[rowKeyValue][colKeyValue]);
    }

    function setDefaultActiveCell(state) {
      state.activeCell = getDefaultActiveCell(state);
    }

    function getDefaultActiveCell(state) {
      const {
        columns,
        rows
      } = state;

      if (columns.length > 0) {
        let colIndex;
        const existCustomerColumn = columns.some((column, index) => {
          colIndex = index;
          return isCustomerColumn(column);
        });

        if (!existCustomerColumn) {
          colIndex = 0;
        }

        return {
          rowKeyValue: rows.length > 0 ? rows[0].key : 'HEADER',
          colKeyValue: generateColKeyValue(columns[colIndex], colIndex)
        };
      }

      return undefined;
    }

    function getCellFromIndexes(state, rowIndex, colIndex) {
      const {
        columns,
        rows
      } = state;

      if (columns.length > 0) {
        return {
          rowKeyValue: rowIndex === -1 ? 'HEADER' : rows[rowIndex].key,
          colKeyValue: generateColKeyValue(columns[colIndex], colIndex)
        };
      }

      return undefined;
    }

    function handleCellKeydown(event) {
      event.stopPropagation();
      reactToKeyboard(this.template, this.state, event);
    }
    function handleKeyDown(event) {
      const targetTagName = event.target.tagName.toLowerCase(); // when the event came from the td is cause it has the focus.

      if (targetTagName === 'td' || targetTagName === 'th') {
        reactToKeyboardInNavMode(this.template, this.state, event);
      }
    }
    /**
     * This is needed to check if datatable has lost focus but cell has been clicked recently
     * @param {object} state - datatable state
     */

    const setCellClickedForFocus = function (state) {
      state.cellClicked = true;
    };
    /**
     * Once the dt regains focus there is no need to set this
     *  @param {object} state - datatable state
     */

    const resetCellClickedForFocus = function (state) {
      state.cellClicked = false;
    };
    const handleDatatableLosedFocus = function (event) {
      const {
        state
      } = this; // workarounds for delegatesFocus issues

      if ( // needed for initial focus where relatedTarget is empty
      !event.relatedTarget && state.isExiting || // needed when clicked outside
      event.relatedTarget && !event.currentTarget.contains(event.relatedTarget) || // needed when datatable leaves focus and related target is still within datatable W-6185154
      event.relatedTarget && event.currentTarget.contains(event.relatedTarget) && state.isExiting) {
        if (state.activeCell) {
          if (state.rowMode) {
            const {
              rowIndex
            } = getIndexesActiveCell(state);
            updateTabIndexRow(state, rowIndex, -1);
          } else {
            const {
              rowIndex,
              colIndex
            } = getIndexesActiveCell(state);
            const cellElement = getCellElementByIndexes(this.template, rowIndex, colIndex); // we need to check because of the tree,
            // at this point it may remove/change the rows/keys because opening or closing a row.

            if (cellElement) {
              cellElement.removeFocusStyles();
              cellElement.parentElement.classList.remove('slds-has-focus');
              cellElement.tabindex = -1;
            }
          }
        } // workarounds for delegatesFocus issue W-6220374
        // if tabindex is set to 0 immediately, table element gets focus which in turn focuses on cell
        // eslint-disable-next-line lwc/no-set-timeout


        setTimeout(() => {
          state.tabindex = 0;
        }, 0);
      }
    };
    const handleDatatableFocusIn = function (event) {
      const {
        state
      } = this;
      state.isExiting = false;
      const activeElement = getShadowActiveElement(); // workaround for delegatesFocus issue that focusin is called when not supposed to W-6220418

      if (event.currentTarget.contains(activeElement) && !datatableHasFocus(state)) {
        if (!state.rowMode && state.activeCell) {
          const {
            rowIndex,
            colIndex
          } = getIndexesActiveCell(state);
          const cellElement = getCellElementByIndexes(this.template, rowIndex, colIndex); // we need to check because of the tree,
          // at this point it may remove/change the rows/keys because opening or closing a row.

          if (cellElement) {
            cellElement.addFocusStyles();
            cellElement.parentElement.classList.add('slds-has-focus');
            cellElement.tabindex = 0;
          }
        }

        state.tabindex = false;
        resetCellClickedForFocus(state);
      }
    };

    const VALID_EDITABLE_TYPE = {
      text: true,
      percent: true,
      phone: true,
      email: true,
      url: true,
      currency: true,
      number: true,
      boolean: true,
      'date-local': true,
      date: true
    };
    const PANEL_SEL = '[data-iedit-panel="true"]';

    function isEditableType(type) {
      return !!VALID_EDITABLE_TYPE[type];
    }

    function getInlineEditDefaultState() {
      return {
        inlineEdit: {
          dirtyValues: {}
        }
      };
    }
    /**
     * @param {Object} state - Datatable instance.
     * @return {Array} - An array of objects, each object describing the dirty values in the form { colName : dirtyValue }.
     *                   A special key is the { [keyField]: value } pair used to identify the row containing this changed values.
     */

    function getDirtyValues(state) {
      return getChangesForCustomer(state, state.inlineEdit.dirtyValues);
    }
    /**
     * Sets the dirty values in the datatable.
     *
     * @param {Object} state Datatable state for the inline edit.
     * @param {Array} value An array of objects, each object describing the dirty values in the form { colName : dirtyValue }.
     *                      A special key is the { [keyField]: value } pair used to identify the row containing this changed values.
     */

    function setDirtyValues(state, value) {
      const keyField = getKeyField(state);
      const dirtyValues = Array.isArray(value) ? value : [];
      state.inlineEdit.dirtyValues = dirtyValues.reduce((result, rowValues) => {
        const changes = getRowChangesFromCustomer(state, rowValues);
        delete changes[keyField];
        result[rowValues[keyField]] = changes;
        return result;
      }, {});
    }
    function normalizeEditable(column) {
      if (isEditableType(column.type)) {
        column.editable = normalizeBoolean(column.editable);
      } else {
        column.editable = false;
      }
    }
    function hasEditableColumn(columns) {
      return columns.some(column => column.editable);
    }
    function isInlineEditTriggered(state) {
      return Object.keys(state.inlineEdit.dirtyValues).length > 0;
    }
    function cancelInlineEdit(dt) {
      dt.state.inlineEdit.dirtyValues = {};
      setErrors(dt.state, {});
      updateRowsAndCellIndexes.call(dt);
    }
    function handleEditCell(event) {
      startPanelPositioning(this, event.target.parentElement);
      const inlineEdit = this.state.inlineEdit;

      if (inlineEdit.isPanelVisible) {
        // A special case when we are trying to open a edit but we have one open. (click on another edit while editing)
        // in this case we will need to process the values before re-open the edit panel with the new values or we may lose the edition.
        processInlineEditFinish(this, 'loosed-focus', inlineEdit.rowKeyValue, inlineEdit.colKeyValue);
      }

      const {
        rowKeyValue,
        colKeyValue
      } = event.detail;
      inlineEdit.isPanelVisible = true;
      inlineEdit.rowKeyValue = rowKeyValue;
      inlineEdit.colKeyValue = colKeyValue;
      inlineEdit.editedValue = getCellValue(this.state, rowKeyValue, colKeyValue);
      inlineEdit.massEditSelectedRows = getCurrentSelectionLength(this.state);
      inlineEdit.massEditEnabled = isSelectedRow(this.state, rowKeyValue) && inlineEdit.massEditSelectedRows > 1; // pass the column definition

      const colIndex = getStateColumnIndex(this.state, colKeyValue);
      inlineEdit.columnDef = getColumns(this.state)[colIndex];
      markSelectedCell(this.state, rowKeyValue, colKeyValue); // eslint-disable-next-line lwc/no-set-timeout

      setTimeout(() => {
        this.template.querySelector('lightning-primitive-datatable-iedit-panel').focus();
      }, 0);
    }
    function handleInlineEditFinish(event) {
      stopPanelPositioning(this);
      const {
        reason,
        rowKeyValue,
        colKeyValue
      } = event.detail;
      processInlineEditFinish(this, reason, rowKeyValue, colKeyValue);
    }
    function handleMassCheckboxChange(event) {
      const state = this.state;

      if (event.detail.checked) {
        markAllSelectedRowsAsSelectedCell(state);
      } else {
        markAllSelectedRowsAsDeselectedCell(this.state);
        markSelectedCell(state, state.inlineEdit.rowKeyValue, state.inlineEdit.colKeyValue);
      }
    } // hide panel on scroll

    const HIDE_PANEL_THRESHOLD = 5;
    function handleInlineEditPanelScroll(event) {
      const {
        isPanelVisible,
        rowKeyValue,
        colKeyValue
      } = this.state.inlineEdit;

      if (!isPanelVisible) {
        return;
      }

      let delta = 0;
      const container = lwc.unwrap(event).target;

      if (container.classList.contains('slds-scrollable_x')) {
        const scrollX = container.scrollLeft;

        if (this.privateLastScrollX == null) {
          this.privateLastScrollX = scrollX;
        } else {
          delta = Math.abs(this.privateLastScrollX - scrollX);
        }
      } else {
        const scrollY = container.scrollTop;

        if (this.privateLastScrollY == null) {
          this.privateLastScrollY = scrollY;
        } else {
          delta = Math.abs(this.privateLastScrollY - scrollY);
        }
      }

      if (delta > HIDE_PANEL_THRESHOLD) {
        this.privateLastScrollX = null;
        this.privateLastScrollY = null;
        stopPanelPositioning(this);
        processInlineEditFinish(this, 'loosed-focus', rowKeyValue, colKeyValue);
      } else {
        // we want to keep the panel attached to the cell before
        // reaching the threshold and hiding the panel
        repositionPanel(this);
      }
    }
    function getDirtyValue(state, rowKeyValue, colKeyValue) {
      const dirtyValues = state.inlineEdit.dirtyValues;

      if (dirtyValues.hasOwnProperty(rowKeyValue) && dirtyValues[rowKeyValue].hasOwnProperty(colKeyValue)) {
        return dirtyValues[rowKeyValue][colKeyValue];
      }

      return undefined;
    }
    /**
     * Will update the dirty values specified in rowColKeyValues
     *
     * @param {Object} state - state of the datatable
     * @param {Object} rowColKeyValues - An object in the form of { rowKeyValue: { colKeyValue1: value, ..., colKeyValueN: value } ... }
     */

    function updateDirtyValues(state, rowColKeyValues) {
      const dirtyValues = state.inlineEdit.dirtyValues;
      Object.keys(rowColKeyValues).forEach(rowKey => {
        if (!dirtyValues.hasOwnProperty(rowKey)) {
          dirtyValues[rowKey] = {};
        }

        Object.assign(dirtyValues[rowKey], rowColKeyValues[rowKey]);
      });
    }
    /**
     * Returns the current value of the cell, already takes into account the dirty value
     *
     * @param {Object} state - state of the datatable
     * @param {String} rowKeyValue - row key
     * @param {String} colKeyValue - column key
     *
     * @return {Object} the value for the current cell.
     */


    function getCellValue(state, rowKeyValue, colKeyValue) {
      const row = getRowByKey(state, rowKeyValue);
      const colIndex = getStateColumnIndex(state, colKeyValue);
      return row.cells[colIndex].value;
    }
    /**
     *
     * @param {Object} state - Datatable state
     * @param {Object} changes - The internal representation of changes in a row
     * @returns {Object} - the list of customer changes in a row
     */


    function getColumnsChangesForCustomer(state, changes) {
      return Object.keys(changes).reduce((result, colKey) => {
        const columns = getColumns(state);
        const columnIndex = getStateColumnIndex(state, colKey);
        result[columns[columnIndex].fieldName] = changes[colKey];
        return result;
      }, {});
    }

    function getRowChangesFromCustomer(state, changes) {
      return Object.keys(changes).reduce((result, fieldName) => {
        const columns = getColumns(state);
        const columnIndex = getColumnIndexByFieldName(state, fieldName);

        if (columnIndex >= 0) {
          const colKey = columns[columnIndex].colKeyValue;
          result[colKey] = changes[fieldName];
        }

        return result;
      }, {});
    }

    function getChangesForCustomer(state, changes) {
      const keyField = getKeyField(state);
      return Object.keys(changes).reduce((result, rowKey) => {
        const rowChanges = getColumnsChangesForCustomer(state, changes[rowKey]);

        if (Object.keys(rowChanges).length > 0) {
          rowChanges[keyField] = rowKey;
          result.push(rowChanges);
        }

        return result;
      }, []);
    }

    function dispatchCellChangeEvent(dtInstance, cellChange) {
      dtInstance.dispatchEvent(new CustomEvent('cellchange', {
        detail: {
          draftValues: getChangesForCustomer(dtInstance.state, cellChange)
        }
      }));
    }

    function closeInlineEdit(dt) {
      const inlineEditState = dt.state.inlineEdit;

      if (inlineEditState.isPanelVisible) {
        processInlineEditFinish(dt, 'loosed-focus', inlineEditState.rowKeyValue, inlineEditState.colKeyValue);
      }
    }

    function isValidCell(state, rowKeyValue, colKeyValue) {
      const row = getRowByKey(state, rowKeyValue);
      const colIndex = getStateColumnIndex(state, colKeyValue);
      return row && row.cells[colIndex];
    }
    /**
     * It will process when the datatable had finished an edition.
     *
     * @param {Object} dt - the datatable instance
     * @param {string} reason - the reason to finish the edition. valid reasons are: edit-canceled | loosed-focus | tab-pressed | submit-action
     * @param {string} rowKeyValue - the row key of the edited cell
     * @param {string} colKeyValue - the column key of the edited cell
     */


    function processInlineEditFinish(dt, reason, rowKeyValue, colKeyValue) {
      const state = dt.state;
      const inlineEditState = state.inlineEdit;
      const shouldSaveData = reason !== 'edit-canceled' && !(inlineEditState.massEditEnabled && reason === 'loosed-focus') && isValidCell(dt.state, rowKeyValue, colKeyValue);

      if (shouldSaveData) {
        const panel = dt.template.querySelector(PANEL_SEL);
        const editValue = panel.value;
        const isValidEditValue = panel.validity.valid;
        const updateAllSelectedRows = panel.isMassEditChecked;
        const currentValue = getCellValue(state, rowKeyValue, colKeyValue);

        if (isValidEditValue && (editValue !== currentValue || updateAllSelectedRows)) {
          const cellChange = {};
          cellChange[rowKeyValue] = {};
          cellChange[rowKeyValue][colKeyValue] = editValue;

          if (updateAllSelectedRows) {
            const selectedRowKeys = getSelectedRowsKeys(state);
            selectedRowKeys.forEach(rowKey => {
              cellChange[rowKey] = {};
              cellChange[rowKey][colKeyValue] = editValue;
            });
          }

          updateDirtyValues(state, cellChange);
          dispatchCellChangeEvent(dt, cellChange); // @todo: do we need to update all rows in the dt or just the one that was modified?

          updateRowsAndCellIndexes.call(dt);
        }
      }

      if (reason !== 'loosed-focus') {
        switch (reason) {
          case 'tab-pressed-next':
            {
              reactToTabRight(dt.template, state);
              break;
            }

          case 'tab-pressed-prev':
            {
              reactToTabLeft(dt.template, state);
              break;
            }

          default:
            {
              setFocusActiveCell(dt.template, state, 0);
            }
        }
      }

      markAllSelectedRowsAsDeselectedCell(state);
      markDeselectedCell(state, rowKeyValue, colKeyValue);
      inlineEditState.isPanelVisible = false;
    }

    function startPanelPositioning(dt, target) {
      requestAnimationFrame(() => {
        // we need to discard previous binding otherwise the panel
        // will retain previous alignment
        stopPanelPositioning(dt);
        dt.privatePositionRelationship = startPositioning(dt, {
          target,
          element: () => dt.template.querySelector(PANEL_SEL).getPositionedElement(),
          align: {
            horizontal: Direction.Left,
            vertical: Direction.Top
          },
          targetAlign: {
            horizontal: Direction.Left,
            vertical: Direction.Top
          },
          autoFlip: true
        });
      });
    }

    function stopPanelPositioning(dt) {
      if (dt.privatePositionRelationship) {
        stopPositioning(dt.privatePositionRelationship);
        dt.privatePositionRelationship = null;
      }
    } // reposition inline edit panel
    // this does not realign the element, so it doesn't fix alignment
    // when size of panel changes


    function repositionPanel(dt) {
      requestAnimationFrame(() => {
        if (dt.privatePositionRelationship) {
          dt.privatePositionRelationship.reposition();
        }
      });
    }

    function markAllSelectedRowsAsSelectedCell(state) {
      const {
        colKeyValue
      } = state.inlineEdit;
      const selectedRowKeys = getSelectedRowsKeys(state);
      selectedRowKeys.forEach(rowKeyValue => {
        markSelectedCell(state, rowKeyValue, colKeyValue);
      });
    }

    function markAllSelectedRowsAsDeselectedCell(state) {
      const {
        colKeyValue
      } = state.inlineEdit;
      const selectedRowKeys = getSelectedRowsKeys(state);
      selectedRowKeys.forEach(rowKeyValue => {
        markDeselectedCell(state, rowKeyValue, colKeyValue);
      });
    }

    var rowActionsDefaultAriaLabel = 'Actions';

    const i18n$B = {
      rowActionsDefaultAriaLabel
    };
    function getColumnsDefaultState() {
      return {
        columns: []
      };
    }
    function getColumns(state) {
      return state.columns;
    }
    function hasColumns(state) {
      return getColumns(state).length > 0;
    }
    const SELECTABLE_ROW_CHECKBOX = 'SELECTABLE_CHECKBOX';
    const SELECTABLE_COLUMN = {
      type: SELECTABLE_ROW_CHECKBOX,
      fixedWidth: 32,
      tabIndex: -1,
      internal: true
    };
    function normalizeColumns(state, columns, types) {
      if (columns.length !== 0) {
        let firstColumnForReaders = 0; // workaround https://git.soma.salesforce.com/raptor/raptor/issues/763

        const normalizedColumns = Object.assign([], columns);

        if (!state.hideCheckboxColumn) {
          firstColumnForReaders++;
          normalizedColumns.unshift(SELECTABLE_COLUMN);
        }

        if (hasRowNumberColumn(state) || hasEditableColumn(columns)) {
          firstColumnForReaders++;
          normalizedColumns.unshift(getRowNumberColumnDef());
        }

        state.columns = normalizedColumns.map((column, index) => {
          const normalizedColumn = Object.assign(getColumnDefaults(column), column);
          normalizedColumn.ariaLabel = normalizedColumn.label || normalizedColumn.ariaLabel || null;

          if (isCustomerColumn(normalizedColumn)) {
            normalizeColumnDataType(normalizedColumn, types);
            normalizeEditable(normalizedColumn);
            updateColumnSortingState(normalizedColumn, state);
          }

          if (isTreeType(normalizedColumn.type)) {
            normalizedColumn.typeAttributes = getNormalizedSubTypeAttribute(normalizedColumn.type, normalizedColumn.typeAttributes);
          }

          return Object.assign(normalizedColumn, {
            tabIndex: -1,
            colKeyValue: generateColKeyValue(normalizedColumn, index),
            isScopeCol: index === firstColumnForReaders
          });
        });
      } else {
        state.columns = [];
      }
    }

    function normalizeColumnDataType(column, types) {
      if (!types.isValidType(column.type)) {
        column.type = getRegularColumnDefaults().type;
      }
    }
    /**
     * Normalizes the subType and subTypeAttributes in the typeAttributes.
     * @param {String} type the type of this column
     * @param {Object} typeAttributes the type attributes of the column
     * @returns {Object} a new typeAttributes object with the sybtype and subTypeAttributes normalized.
     */


    function getNormalizedSubTypeAttribute(type, typeAttributes) {
      const typeAttributesOverrides = {};

      if (!isValidTypeForTree(typeAttributes.subType)) {
        typeAttributesOverrides.subType = getColumnDefaults({
          type
        }).subType;
      }

      if (!typeAttributes.subTypeAttributes) {
        typeAttributesOverrides.subTypeAttributes = {};
      }

      return Object.assign({}, typeAttributes, typeAttributesOverrides);
    }

    function getRegularColumnDefaults() {
      return {
        type: 'text',
        typeAttributes: {},
        cellAttributes: {}
      };
    }

    function getActionColumnDefaults() {
      return {
        fixedWidth: 50,
        resizable: false,
        ariaLabel: i18n$B.rowActionsDefaultAriaLabel
      };
    }

    function getTreeColumnDefaults() {
      return {
        type: 'tree',
        subType: 'text',
        typeAttributes: {},
        cellAttributes: {}
      };
    }

    function getColumnDefaults(column) {
      switch (column.type) {
        case 'action':
          return getActionColumnDefaults();

        case 'tree':
          return getTreeColumnDefaults();

        default:
          return getRegularColumnDefaults();
      }
    }

    function isCustomerColumn(column) {
      return column.internal !== true;
    }
    function getTypeAttributesValues(column) {
      if (isObjectLike(column.typeAttributes)) {
        return column.typeAttributes;
      }

      return {};
    }
    function getSubTypeAttributesValues(column) {
      if (isObjectLike(column.typeAttributes.subTypeAttributes)) {
        return column.typeAttributes.subTypeAttributes;
      }

      return {};
    }
    function getCellAttributesValues(column) {
      if (isObjectLike(column.cellAttributes)) {
        return column.cellAttributes;
      }

      return {};
    }
    /**
     * Return the index in dt.columns (user definition) related to colKeyValue.
     *      -1 if no column with that key exist or if its internal.
     * @param {Object} state The datatable state
     * @param {String} colKeyValue The generated key for the column
     * @return {Number} The index in dt.columns. -1 if not found or if its internal.
     */

    function getUserColumnIndex(state, colKeyValue) {
      const stateColumnIndex = getStateColumnIndex(state, colKeyValue);
      let internalColumns = 0;

      if (state.columns[stateColumnIndex].internal) {
        return -1;
      }

      for (let i = 0; i < stateColumnIndex; i++) {
        if (state.columns[i].internal) {
          internalColumns++;
        }
      }

      return stateColumnIndex - internalColumns;
    }
    /**
     * Return the index in state.columns (internal definition) related to colKeyValue.
     *
     * @param {Object} state The datatable state
     * @param {String} colKeyValue The generated key for the column
     * @return {number} The index in state.columns.
     */

    function getStateColumnIndex(state, colKeyValue) {
      return state.headerIndexes[colKeyValue];
    }
    /**
     *
     * @param {Object} state - The datatable state
     * @param {String} fieldName - the field name of the column
     * @returns {number} The index in state.columns, -1 if it does not exist
     */

    function getColumnIndexByFieldName(state, fieldName) {
      let i = 0;
      const columns = getColumns(state);
      const existFieldName = columns.some((column, index) => {
        i = index;
        return column.fieldName === fieldName;
      });
      return existFieldName ? i : -1;
    }

    /**
     * It return the default portion of state use it for the resizer
     * @returns {{resizer: {columnWidths: Array}}} - resizer default state
     */

    function getResizerDefaultState() {
      return {
        resizeColumnDisabled: false,
        resizeStep: 10,
        columnWidths: [],
        tableWidth: 0,
        minColumnWidth: 50,
        maxColumnWidth: 1000
      };
    } // *******************************
    // states Getters/Setters
    // *******************************

    /**
     * resizeColumnDisabled
     */

    function isResizeColumnDisabled(state) {
      return state.resizeColumnDisabled;
    }
    function setResizeColumnDisabled(state, value) {
      state.resizeColumnDisabled = normalizeBoolean(value);
    }
    /**
     * resizeStep
     */

    function setResizeStep(state, value) {
      state.resizeStep = normalizePositiveIntegerAttribute('resizeStep', value, getResizerDefaultState().resizeStep);
    }
    function getResizeStep(state) {
      return state.resizeStep;
    }
    /**
     * columnWidths
     */

    /**
     * It return true if there are widths store in the state
     * @param {object} state - table state
     * @returns {boolean} - true if there are widths store in the state
     */

    function hasDefinedColumnsWidths(state) {
      return state.columnWidths.length > 0;
    }
    /**
     * It return the columnsWidths saved in the state
     * @param {object} state - table state
     * @returns {Array|*} - list of column widths
     */

    function getColumnsWidths(state) {
      return state.columnWidths;
    }
    /**
     * It set columnWidths to empty array
     * @param {object} state - table state
     */

    function resetColumnWidths(state) {
      state.columnWidths = [];
    }
    /**
     * tableWidth
     */

    /**
     * Get the full width of table
     * @param {object} state - table state
     * @returns {number} - table's width
     */

    function getTableWidth(state) {
      return state.tableWidth;
    }

    function setTableWidth(state, tableWidth) {
      state.tableWidth = tableWidth;
    }
    /**
     * minColumnWidth
     */


    function setMinColumnWidth(state, value) {
      state.minColumnWidth = normalizePositiveIntegerAttribute('minColumnWidth', value, getResizerDefaultState().minColumnWidth);
      updateColumnWidthsMetadata(state);
    }
    function getMinColumnWidth(state) {
      return state.minColumnWidth;
    }
    /**
     * maxColumnWidth
     */

    function getMaxColumnWidth(state) {
      return state.maxColumnWidth;
    }
    function setMaxColumnWidth(state, value) {
      state.maxColumnWidth = normalizePositiveIntegerAttribute('maxColumnWidth', value, getResizerDefaultState().maxColumnWidth);
      updateColumnWidthsMetadata(state);
    } // *******************************
    // Logics
    // *******************************

    /**
     * Get the style to match the full width of table
     * @param {object} state - table state
     * @returns {string} - style string
     */

    function getTableWidthStyle(state) {
      return getWidthStyle(getTableWidth(state));
    }
    /**
     * - It adjust the columns in the DOM, based on the table width and width meta in column definitions
     * - It also update the table and scroller container with the expected width
     *
     * @param {node} root - table root element
     * @param {object} state - table state
     */

    const adjustColumnsSize = function (root, state) {
      const widthsMeta = getTotalWidthsMetadata(state);
      const expectedTableWidth = getExpectedTableWidth(state, root, widthsMeta);
      const expectedFlexibleColumnWidth = getFlexibleColumnWidth(widthsMeta, expectedTableWidth);
      let columnsWidthSum = 0;
      resetColumnWidths(state);
      getColumns(state).forEach((column, colIndex) => {
        const width = getColumnWidthFromDef(column) || expectedFlexibleColumnWidth;
        columnsWidthSum += width;
        updateColumnWidth(state, colIndex, width);
      });
      setTableWidth(state, Math.min(expectedTableWidth, columnsWidthSum));
    };
    /**
     * - It adjusts the columns widths from the state
     * - It is used when there are columnwidths in state but the table is hidden with offsetwidth 0
     * - In this case we reset the columns to the width in state
     *
     * @param {object} state - table state
     */

    const adjustColumnsSizeFromState = function (state) {
      const columnsWidths = getColumnsWidths(state);
      let columnsWidthSum = 0;
      getColumns(state).forEach((column, colIndex) => {
        const width = columnsWidths[colIndex];

        if (typeof columnsWidths[colIndex] !== 'undefined') {
          columnsWidthSum += width;
          column.columnWidth = columnsWidths[colIndex];
          column.style = getWidthStyle(columnsWidths[colIndex]);
        }
      });
      setTableWidth(state, columnsWidthSum);
    };

    function getColumnWidthFromDef(column) {
      let resizedWidth;

      if (column.isResized) {
        resizedWidth = column.columnWidth;
      }

      return column.fixedWidth || resizedWidth || column.initialWidth;
    }
    /**
     * It resize a column width
     * @param {object} state - table state
     * @param {number} colIndex - the index of the column based on state.columns
     * @param {number} width - the new width is gonna be applied
     */


    const resizeColumn = function (state, colIndex, width) {
      const column = getColumns(state)[colIndex];
      const columnsWidths = getColumnsWidths(state);
      const currentWidth = columnsWidths[colIndex];
      const {
        minWidth,
        maxWidth
      } = column;
      const newWidth = clamp(width, minWidth, maxWidth);

      if (currentWidth !== newWidth) {
        const newDelta = newWidth - currentWidth;
        setTableWidth(state, getTableWidth(state) + newDelta);
        updateColumnWidth(state, colIndex, newWidth);
        column.isResized = true;
      }
    };
    /**
     * It resize a column width
     * @param {object} state - table state
     * @param {number} colIndex - the index of the column based on state.columns
     * @param {number} widthDelta - the delta that creates the new width
     */

    const resizeColumnWithDelta = function (state, colIndex, widthDelta) {
      const currentWidth = getColumnsWidths(state)[colIndex];
      resizeColumn(state, colIndex, currentWidth + widthDelta);
    };

    function updateColumnWidth(state, colIndex, newWidth) {
      const columnsWidths = getColumnsWidths(state);
      columnsWidths[colIndex] = newWidth;
      const column = getColumns(state)[colIndex];
      column.columnWidth = newWidth;
      column.style = getWidthStyle(newWidth);
    }

    function getExpectedTableWidth(state, root, widthsMeta) {
      const availableWidth = getAvailableWidthFromDom(root);
      const minExpectedTableWidth = getMinExpectedTableWidth(widthsMeta);
      return hasNoFlexibleColumns(widthsMeta) ? minExpectedTableWidth : Math.max(minExpectedTableWidth, availableWidth);
    }
    /**
     * It return the current widths for customer columns
     * @param {object} state - table state
     * @returns {Array} - the widths collection, every element
     * belong to a column with the same index in column prop
     */


    function getCustomerColumnWidths(state) {
      const columns = getColumns(state);
      return columns.reduce((prev, column, index) => {
        if (isCustomerColumn(column)) {
          prev.push(state.columnWidths[index]);
        }

        return prev;
      }, []);
    }
    function updateColumnWidthsMetadata(state) {
      getColumns(state).forEach(col => {
        if (!col.internal) {
          col.minWidth = getMinColumnWidth(state);
          col.maxWidth = getMaxColumnWidth(state);
        }

        if (col.initialWidth) {
          col.initialWidth = clamp(col.initialWidth, col.minWidth, col.maxWidth);
        }
      });
    }
    /**
     * It returns if table is rendered and not hidden
     * @param {node} root - table root element
     * @returns {boolean} - true or false if dt is rendered and not hidden on the page
     */

    function isTableRenderedVisible(root) {
      const CONTAINER_SEL = '.slds-scrollable_y';
      const elem = root.querySelector(CONTAINER_SEL);
      return elem && !!(elem.offsetParent || elem.offsetHeight || elem.offsetWidth);
    }

    function getTotalWidthsMetadata(state) {
      const initial = {
        totalFixedWidth: 0,
        totalFixedColumns: 0,
        totalResizedWidth: 0,
        totalResizedColumns: 0,
        totalFlexibleColumns: 0,
        minColumnWidth: state.minColumnWidth,
        maxColumnWidth: state.maxColumnWidth
      };
      return getColumns(state).reduce((prev, col) => {
        if (col.fixedWidth) {
          prev.totalFixedWidth += col.fixedWidth;
          prev.totalFixedColumns += 1;
        } else if (col.isResized) {
          prev.totalResizedWidth += col.columnWidth;
          prev.totalResizedColumns += 1;
        } else if (col.initialWidth) {
          prev.totalResizedWidth += col.initialWidth;
          prev.totalResizedColumns += 1;
        } else {
          prev.totalFlexibleColumns += 1;
        }

        return prev;
      }, initial);
    }

    function getMinExpectedTableWidth(widthsMeta) {
      const {
        totalFixedWidth,
        totalResizedWidth,
        totalFlexibleColumns,
        minColumnWidth
      } = widthsMeta;
      const minTotalFlexibleWidth = totalFlexibleColumns * minColumnWidth;
      return minTotalFlexibleWidth + totalFixedWidth + totalResizedWidth;
    }

    function getFlexibleColumnWidth(widthsMeta, totalTableWidth) {
      const {
        totalFixedWidth,
        totalResizedWidth,
        totalFlexibleColumns,
        minColumnWidth,
        maxColumnWidth
      } = widthsMeta;
      const totalFlexibleWidth = totalTableWidth - totalFixedWidth - totalResizedWidth;
      const avgFlexibleColumnWidth = Math.floor(totalFlexibleWidth / totalFlexibleColumns);
      const allowedSpace = Math.max(avgFlexibleColumnWidth, minColumnWidth);
      return Math.min(maxColumnWidth, allowedSpace);
    }

    function hasNoFlexibleColumns(widthsMeta) {
      return widthsMeta.totalFlexibleColumns === 0;
    }
    /**
     * Get width of dom element.
     * @param  {node} element - target dom element
     * @returns {number} - integer width of element
     */


    function getDomWidth(element) {
      return element.offsetWidth;
    }

    const CONTAINER_SEL = '.slds-scrollable_x';

    function getAvailableWidthFromDom(root) {
      return getDomWidth(root.querySelector(CONTAINER_SEL));
    }

    function getWidthStyle(pixels) {
      return pixels > 0 ? `width:${pixels}px` : '';
    }

    var labelRowLevelErrorAssistiveText = '{0} has {1} errors';

    const CHAR_WIDTH = 10;
    const COLUMN_TYPE = 'rowNumber';
    const i18n$C = {
      rowLevelErrorAssistiveText: labelRowLevelErrorAssistiveText
    };
    function isRowNumberColumn(column) {
      return column.type === COLUMN_TYPE;
    }
    function getRowNumberColumnDef() {
      return {
        type: COLUMN_TYPE,
        sortable: false,
        initialWidth: 52,
        minWidth: 52,
        maxWidth: 1000,
        tabIndex: -1,
        internal: true,
        resizable: false
      };
    }
    function getRowNumberState() {
      return {
        showRowNumberColumn: false,
        rowNumberOffset: 0
      };
    }
    /**
     * showRowNumberColumn
     */

    function hasRowNumberColumn(state) {
      return state.showRowNumberColumn;
    }
    function setShowRowNumberColumn(state, value) {
      state.showRowNumberColumn = normalizeBoolean(value);
    }
    /**
     * rowNumberOffset
     */

    function getRowNumberOffset(state) {
      return state.rowNumberOffset;
    }
    function setRowNumberOffset(state, value) {
      state.rowNumberOffset = normalizePositiveIntegerAttribute('rowNumberOffset', value, getRowNumberState().rowNumberOffset);
    }
    /**
     * Functions to adjusting row number column width
     */

    function adjustRowNumberColumnWidth(root, state) {
      const colIndex = getRowNumberColumnIndex(state);

      if (colIndex > -1) {
        const rowNumberCol = getColumns(state)[colIndex];
        const newWidth = getAdjustedRowNumberColumnWidth(state);

        if (rowNumberCol.initialWidth !== newWidth) {
          rowNumberCol.initialWidth = Math.max(newWidth, rowNumberCol.minWidth);

          if (hasDefinedColumnsWidths(state)) {
            // when columns are resized with the resizer, a horizontal scroller appears.
            // adjusting the columns size, will respect widths already set and try to fit this column
            adjustColumnsSize(root, state);
          }
        }
      }
    }

    function getAdjustedRowNumberColumnWidth(state) {
      const numOfRows = state.rows.length;
      const offset = state.rowNumberOffset;
      const numberOfChars = String(numOfRows + offset).length;
      return CHAR_WIDTH * numberOfChars + 12
      /* padding */
      + 20
      /* primitive-tootlip */
      ;
    }

    function getRowNumberColumnIndex(state) {
      if (hasRowNumberColumn(state) && hasColumns(state)) {
        const columns = getColumns(state);

        for (let i = 0; i < columns.length; i++) {
          const column = columns[i];

          if (column.type === COLUMN_TYPE) {
            return i;
          }
        }
      }

      return -1;
    }

    function formatString(str, ...args) {
      if (str) {
        return str.replace(/{(\d+)}/g, (match, i) => {
          return typeof args[i] !== 'undefined' ? args[i] : match;
        });
      }

      return '';
    }

    function getRowNumberErrorColumnDef(rowErrors, rowTitle) {
      const {
        title,
        messages
      } = rowErrors;
      const alternativeText = formatString(i18n$C.rowLevelErrorAssistiveText, rowTitle || '', rowErrors.fieldNames ? rowErrors.fieldNames.length : '');
      return {
        type: COLUMN_TYPE,
        typeAttributes: {
          error: {
            title,
            messages,
            alternativeText
          }
        }
      };
    }

    const wrapableTypes = ['text', 'number', 'currency', 'percent', 'email', 'date', 'phone', 'url', 'location', 'tree'];
    const i18n$D = {
      clipText: labelClipText,
      wrapText: labelWrapText
    };

    function updateCellsWrapperText(state, colIndex, colKeyValue) {
      state.rows.forEach(row => {
        row.cells[colIndex].wrapText = state.wrapText[colKeyValue];
      });
    }

    function updateWrapTextState(state, colKeyValue) {
      const columns = getColumns(state);
      const colIndex = getStateColumnIndex(state, colKeyValue);
      const colData = columns[colIndex];
      colData.actions.internalActions.forEach(action => {
        if (action.name === 'wrap_text') {
          action.checked = state.wrapText[colKeyValue];
        }

        if (action.name === 'clip_text') {
          action.checked = !state.wrapText[colKeyValue];
        }
      });
      updateCellsWrapperText(state, colIndex, colKeyValue); // lets force a refresh on this column, because the wrapText checked value changed.

      colData.actions = Object.assign({}, colData.actions);
    }

    function getActions(state, columnDefinition) {
      const actions = [];

      if (!state.wrapText[columnDefinition.colKeyValue]) {
        // wraptext its off by default.
        state.wrapText[columnDefinition.colKeyValue] = false;
      }

      if (wrapableTypes.indexOf(columnDefinition.type) >= 0) {
        actions.push({
          label: `${i18n$D.wrapText}`,
          title: `${i18n$D.wrapText}`,
          checked: state.wrapText[columnDefinition.colKeyValue],
          name: 'wrap_text'
        });
        actions.push({
          label: `${i18n$D.clipText}`,
          title: `${i18n$D.clipText}`,
          checked: !state.wrapText[columnDefinition.colKeyValue],
          name: 'clip_text'
        });
      }

      return actions;
    }
    function handleTriggeredAction(state, action, colKeyValue) {
      if (action.name === 'wrap_text' || action.name === 'clip_text') {
        // If will change state
        if (state.wrapText[colKeyValue] !== (action.name === 'wrap_text')) {
          state.wrapText[colKeyValue] = action.name === 'wrap_text';
          updateWrapTextState(state, colKeyValue);
        }
      }
    }
    function getDefaultState() {
      return {
        wrapText: {}
      };
    }

    function getInternalActions(state, columnDefinition) {
      const internalActions = []; // just wrapper text for now.

      Array.prototype.push.apply(internalActions, getActions(state, columnDefinition));
      return internalActions;
    }

    function handleInternalTriggeredAction(dt, action, colKeyValue) {
      handleTriggeredAction(dt.state, action, colKeyValue);
    }

    function handleCustomerTriggeredAction(dt, action, colKeyValue) {
      const userColumnIndex = getUserColumnIndex(dt.state, colKeyValue);
      const customerColumnDefinition = dt.columns[userColumnIndex];
      dt.dispatchEvent(new CustomEvent('headeraction', {
        detail: {
          action: lwc.unwrap(action),
          columnDefinition: lwc.unwrap(customerColumnDefinition)
        }
      }));
    }

    function getMenuAlignment(columns, index) {
      const isLastColumn = index === columns.length - 1;
      return isLastColumn || columns[index + 1].type === 'action' ? 'right' : 'left';
    }
    /**
     * Overrides the actions with the internal ones, plus the customer ones.
     *
     * @param {Object} state The state of the datatable.
     */


    function updateHeaderActions(state) {
      const columns = getColumns(state);
      columns.forEach((column, idx) => {
        column.actions = {
          menuAlignment: getMenuAlignment(columns, idx),
          customerActions: Array.isArray(column.actions) ? column.actions : [],
          internalActions: getInternalActions(state, column)
        };
      });
    }
    function handleHeaderActionTriggered(event) {
      const {
        action,
        actionType,
        colKeyValue
      } = event.detail;
      event.stopPropagation();

      if (actionType === 'customer') {
        handleCustomerTriggeredAction(this, action, colKeyValue);
      } else {
        handleInternalTriggeredAction(this, action, colKeyValue);
      }
    }
    function getColumnActionsDefaultState() {
      return Object.assign({}, getDefaultState());
    }
    function handleHeaderActionMenuOpening(event) {
      event.stopPropagation();
      event.preventDefault();
      event.detail.saveContainerPosition(this.getViewableRect());
    }

    const SCROLLABLE_CONTAINER_SEL = '.slds-scrollable_y';
    const SCROLL_ALLOWANCE = 2;
    function getInfiniteLoadingDefaultState() {
      return {
        enableInfiniteLoading: false,
        loadMoreOffset: 20,
        isLoading: false
      };
    }
    function isLoading(state) {
      return state.isLoading;
    }
    function setLoading(state, value) {
      state.isLoading = normalizeBoolean(value);
    }
    function isInfiniteLoadingEnabled(state) {
      return state.enableInfiniteLoading;
    }
    function setInfiniteLoading(state, value) {
      state.enableInfiniteLoading = normalizeBoolean(value);
    }
    function getLoadMoreOffset(state) {
      return state.loadMoreOffset;
    }
    function setLoadMoreOffset(state, value) {
      if (!isPositiveInteger(value)) {
        // eslint-disable-next-line no-console
        console.warn(`The "loadMoreOffset" value passed into lightning:datatable
            is incorrect. "loadMoreOffset" value should be an integer >= 0.`);
      }

      state.loadMoreOffset = isPositiveInteger(value) ? parseInt(value, 10) : getInfiniteLoadingDefaultState().loadMoreOffset;
    }
    function handleLoadMoreCheck(event) {
      if (isLoading(this.state)) {
        return;
      }

      const contentContainer = lwc.unwrap(event).target.firstChild;

      if (!contentContainer) {
        return;
      }

      const offset = getOffsetFromTableEnd(contentContainer);
      const threshold = getLoadMoreOffset(this.state);

      if (offset < threshold) {
        this.dispatchEvent(new CustomEvent('loadmore'));
      }
    }

    function isScrollable(element) {
      // scrollHeight should be greater than clientHeight by some allowance
      return element && element.scrollHeight > element.clientHeight + SCROLL_ALLOWANCE;
    }

    function isScrollerVisible(elem) {
      return elem && !!(elem.offsetParent || elem.offsetHeight || elem.offsetWidth);
    }

    function hasData(root) {
      return root.querySelectorAll('tbody > tr').length > 0;
    }

    function handlePrefetch(root, state) {
      if (!isInfiniteLoadingEnabled(state) || isLoading(state) || !hasData(root)) {
        // dont prefetch if already loading or data is not set yet
        return;
      }

      const elem = root.querySelector(SCROLLABLE_CONTAINER_SEL);

      if (isScrollerVisible(elem) && !isScrollable(elem)) {
        this.dispatchEvent(new CustomEvent('loadmore'));
      }
    }

    function getOffsetFromTableEnd(el) {
      return el.scrollHeight - el.parentNode.scrollTop - el.parentNode.clientHeight;
    }

    function _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty$5(target, key, source[key]); }); } return target; }

    function _defineProperty$5(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

    const DEFAULTS = _objectSpread$5({}, getColumnsDefaultState(), getRowsDefaultState(), getSelectorDefaultState(), {
      headerIndexes: {}
    }, getKeyboardDefaultState(), {
      normalized: false
    }, getColumnActionsDefaultState(), getSortDefaultState(), getRowNumberState(), getResizerDefaultState(), getInfiniteLoadingDefaultState(), getInlineEditDefaultState(), getErrorsState(), {
      hideTableHeader: false
    });

    const getDefaultState$1 = function () {
      return JSON.parse(JSON.stringify(DEFAULTS));
    };
    /**
     * It generate headerIndexes based in the current metadata
     * headerIndexes represent the position of the header(column)
     * based on the unique colKeyValue
     * @param {object} columns - the current normalized column metadata
     * @returns {object} headerIndexes e.g. { 'name-text' 0, 'amount-number': 1 }
     */

    const generateHeaderIndexes = function (columns) {
      return columns.reduce((prev, col, index) => {
        prev[generateColKeyValue(col, index)] = index;
        return prev;
      }, {});
    };

    /**
     *
     * @param {CustomEvent} event - row action
     */

    function handleRowActionTriggered(event) {
      const {
        rowKeyValue,
        colKeyValue,
        action
      } = event.detail;
      const selectedRow = getUserRowByCellKeys(this.state, rowKeyValue, colKeyValue);
      event.stopPropagation();
      this.dispatchEvent(new CustomEvent('rowaction', {
        detail: {
          row: lwc.unwrap(selectedRow),
          action: lwc.unwrap(action)
        }
      }));
    }
    /**
     *
     * @param {CustomEvent} event - load dynamic actions
     */

    function handleLoadDynamicActions(event) {
      const {
        rowKeyValue,
        colKeyValue,
        actionsProviderFunction,
        doneCallback,
        saveContainerPosition
      } = event.detail;
      const selectedRow = getUserRowByCellKeys(this.state, rowKeyValue, colKeyValue);
      saveContainerPosition(this.getViewableRect());
      event.stopPropagation();
      actionsProviderFunction(lwc.unwrap(selectedRow), doneCallback);
    }
    /**
     *
     * @param {CustomEvent} event - fire `rowaction` on cell-button click
     */

    function handleCellButtonClick(event) {
      event.stopPropagation();
      const {
        rowKeyValue,
        colKeyValue
      } = event.detail;
      const row = getUserRowByCellKeys(this.state, rowKeyValue, colKeyValue);
      const userColumnIndex = getUserColumnIndex(this.state, colKeyValue);
      const userColumnDefinition = this._columns[userColumnIndex];
      this.dispatchEvent(new CustomEvent('rowaction', {
        detail: {
          row: lwc.unwrap(row),
          action: lwc.unwrap(userColumnDefinition.typeAttributes)
        }
      }));
    }

    /**
     * Based on Marc J. Schmidt library: https://github.com/marcj/css-element-queries/blob/master
     */
    class EventQueue {
      constructor() {
        this.q = [];
      }

      add(ev) {
        this.q.push(ev);
      }

      call(sizeInfo) {
        for (let i = 0, j = this.q.length; i < j; i++) {
          this.q[i].call(this, sizeInfo);
        }
      }

      remove(ev) {
        const newQueue = [];

        for (let i = 0, j = this.q.length; i < j; i++) {
          if (this.q[i] !== ev) {
            newQueue.push(this.q[i]);
          }
        }

        this.q = newQueue;
      }

      length() {
        return this.q.length;
      }

    }
    /**
     * Get element size
     * @param {HTMLElement} element - element to return the size.
     * @returns {Object} {width, height}
     */


    function getElementSize(element) {
      const rect = element.getBoundingClientRect();
      return {
        width: Math.round(rect.width),
        height: Math.round(rect.height)
      };
    }

    function createResizeSensor() {
      const resizeSensor = document.createElement('div');
      resizeSensor.dir = 'ltr';
      resizeSensor.className = 'resize-sensor';
      const style = 'position: absolute; left: -10px; top: -10px; right: 0; bottom: 0; overflow: hidden; z-index: -1; visibility: hidden;';
      const styleChild = 'position: absolute; left: 0; top: 0; transition: 0s;';
      resizeSensor.style.cssText = style; // eslint-disable-next-line lwc/no-inner-html

      resizeSensor.innerHTML = `<div class="resize-sensor-expand" style="${style}">` + `<div style="${styleChild}"></div>` + `</div>` + `<div class="resize-sensor-shrink" style="${style}">` + `<div style="${styleChild} width: 200%; height: 200%"></div>` + `</div>`;
      return resizeSensor;
    }
    /**
     *
     * @param {HTMLElement} element - element to listen resize.
     * @param {Function}    resizeListener - resize event listener.
     */


    function attachResizeEvent(element, resizeListener) {
      if (!element) {
        return;
      }

      if (element.resizedAttached) {
        element.resizedAttached.add(resizeListener);
        return;
      }

      element.resizedAttached = new EventQueue();
      element.resizedAttached.add(resizeListener);
      const resizeSensor = createResizeSensor();
      element.resizeSensor = resizeSensor;
      element.appendChild(resizeSensor);
      const position = (window.getComputedStyle(element) || element.style).getPropertyValue('position');

      if (position !== 'absolute' && position !== 'relative' && position !== 'fixed') {
        element.style.position = 'relative';
      }

      const expand = resizeSensor.childNodes[0];
      const expandChild = expand.childNodes[0];
      const shrink = resizeSensor.childNodes[1];
      let dirty, rafId;
      let size = getElementSize(element);
      let lastWidth = size.width;
      let lastHeight = size.height;
      let initialHiddenCheck = true,
          resetRafId;

      const resetExpandShrink = function () {
        expandChild.style.width = '100000px';
        expandChild.style.height = '100000px';
        expand.scrollLeft = 100000;
        expand.scrollTop = 100000;
        shrink.scrollLeft = 100000;
        shrink.scrollTop = 100000;
      };

      const reset = function () {
        // Check if element is hidden
        if (initialHiddenCheck) {
          if (!expand.scrollTop && !expand.scrollLeft) {
            // reset
            resetExpandShrink(); // Check in next frame

            if (!resetRafId) {
              resetRafId = requestAnimationFrame(() => {
                resetRafId = 0;
                reset();
              });
            }

            return;
          }

          initialHiddenCheck = false;
        }

        resetExpandShrink();
      };

      resizeSensor.resetSensor = reset;

      const onResized = function () {
        rafId = 0;

        if (!dirty) {
          return;
        }

        lastWidth = size.width;
        lastHeight = size.height;

        if (element.resizedAttached) {
          element.resizedAttached.call(size);
        }
      };

      const onScroll = function () {
        size = getElementSize(element);
        dirty = size.width !== lastWidth || size.height !== lastHeight;

        if (dirty && !rafId) {
          rafId = requestAnimationFrame(onResized);
        }

        reset();
      };

      const addEvent = function (el, name, cb) {
        el.addEventListener(name, cb);
      };

      addEvent(expand, 'scroll', onScroll);
      addEvent(shrink, 'scroll', onScroll); // Fix for custom Elements

      requestAnimationFrame(reset);
    }

    function detach(elem, ev) {
      if (!elem) {
        return;
      }

      if (elem.resizedAttached && typeof ev === 'function') {
        elem.resizedAttached.remove(ev);

        if (elem.resizedAttached.length()) {
          return;
        }
      }

      if (elem.resizeSensor) {
        if (elem.contains(elem.resizeSensor)) {
          elem.removeChild(elem.resizeSensor);
        }

        delete elem.resizeSensor;
        delete elem.resizedAttached;
      }
    }

    class ResizeSensor {
      constructor(element, resizeListener) {
        this.targetElement = element;
        this.resizeListener = resizeListener;
        attachResizeEvent(this.targetElement, this.resizeListener);
      }

      detach() {
        detach(this.targetElement, this.resizeListener);
      }

      reset() {
        this.targetElement.resizeSensor.resetSensor();
      }

    }

    const typesMap$1 = new WeakMap();

    class LightningDatatable extends lwc.LightningElement {
      constructor() {
        super();
        this.hasDetachedListeners = true;
        this._columns = [];
        this._hideCheckboxColumn = false;
        this._draftValues = [];
        this.customerSelectedRows = null;
        this.privateDatatableId = generateUniqueId('lgt-datatable');
        this.privateSuppressBottomBar = false;
        this.state = getDefaultState$1();

        if (!typesMap$1.has(this.constructor)) {
          const privateTypes = new DatatableTypes$1(this.constructor.customTypes);
          typesMap$1.set(this.constructor, privateTypes);
        }

        this.updateRowsAndCellIndexes = updateRowsAndCellIndexes.bind(this);
      }

      get privateTypes() {
        return typesMap$1.get(this.constructor);
      }

      set columns(value) {
        this._columns = Array.isArray(value) ? value : [];
        this.updateColumns(this._columns);
      }
      /**
       * Array of the columns object that's used to define the data types.
       * Required properties include 'label', 'fieldName', and 'type'. The default type is 'text'.
       * See the Documentation tab for more information.
       * @type {array}
       */


      get columns() {
        return this._columns;
      }

      set data(value) {
        setData(this.state, value);

        if (hasValidKeyField(this.state)) {
          this.updateRowsState();
        }

        if (this.customerSelectedRows) {
          this.setSelectedRows(this.customerSelectedRows);
        }
      }
      /**
       * The array of data to be displayed.
       * @type {array}
       */


      get data() {
        return getData(this.state);
      }

      set keyField(value) {
        setKeyField(this.state, value);
        setDirtyValues(this.state, this._draftValues);
        this.updateRowsState();
      }
      /**
       * Required for better performance.
       * Associates each row with a unique ID.
       * @type {string}
       * @required
       */


      get keyField() {
        return getKeyField(this.state);
      }

      set hideCheckboxColumn(value) {
        this._hideCheckboxColumn = value;
        this.state.hideCheckboxColumn = normalizeBoolean(value); // update the columns metadata again to update the status.

        this.updateColumns(this._columns);
      }
      /**
       * If present, the checkbox column for row selection is hidden.
       * @type {boolean}
       * @default false
       */


      get hideCheckboxColumn() {
        return this._hideCheckboxColumn;
      }

      set showRowNumberColumn(value) {
        setShowRowNumberColumn(this.state, value);
        this.updateColumns(this._columns);
      }
      /**
       * If present, the row numbers are shown in the first column.
       * @type {boolean}
       * @default false
       */


      get showRowNumberColumn() {
        return hasRowNumberColumn(this.state);
      }

      set rowNumberOffset(value) {
        const {
          state
        } = this;
        setRowNumberOffset(state, value);
        adjustRowNumberColumnWidth(this.template, state);
      }
      /**
       * Determines where to start counting the row number.
       * The default is 0.
       * @type {number}
       * @default 0
       */


      get rowNumberOffset() {
        return getRowNumberOffset(this.state);
      }

      set resizeColumnDisabled(value) {
        setResizeColumnDisabled(this.state, value);
      }
      /**
       * If present, column resizing is disabled.
       * @type {boolean}
       * @default false
       */


      get resizeColumnDisabled() {
        return isResizeColumnDisabled(this.state);
      }

      set minColumnWidth(value) {
        setMinColumnWidth(this.state, value);
      }
      /**
       * The minimum width for all columns.
       * The default is 50px.
       * @type {number}
       * @default 50px
       */


      get minColumnWidth() {
        return getMinColumnWidth(this.state);
      }

      set maxColumnWidth(value) {
        setMaxColumnWidth(this.state, value);
      }
      /**
       * The maximum width for all columns.
       * The default is 1000px.
       * @type {number}
       * @default 1000px
       */


      get maxColumnWidth() {
        return getMaxColumnWidth(this.state);
      }

      set resizeStep(value) {
        setResizeStep(this.state, value);
      }
      /**
       * The width to resize the column when a user presses left or right arrow.
       * The default is 10px.
       * @type {number}
       * @default 10px
       */


      get resizeStep() {
        return getResizeStep(this.state);
      }

      set sortedBy(value) {
        setSortedBy(this.state, value);
        updateSorting(this.state);
      }
      /**
       * The column fieldName that controls the sorting order.
       * Sort the data using the onsort event handler.
       * @type {string}
       */


      get sortedBy() {
        return getSortedBy(this.state);
      }

      set sortedDirection(value) {
        setSortedDirection(this.state, value);
        updateSorting(this.state);
      }
      /**
       * Specifies the sorting direction.
       * Sort the data using the onsort event handler.
       * Valid options include 'asc' and 'desc'.
       * @type {string}
       */


      get sortedDirection() {
        return getSortedDirection(this.state);
      }

      set defaultSortDirection(value) {
        setDefaultSortDirection(this.state, value);
        updateSorting(this.state);
      }
      /**
       * Specifies the default sorting direction on an unsorted column.
       * Valid options include 'asc' and 'desc'.
       * The default is 'asc' for sorting in ascending order.
       * @type {string}
       * @default asc
       */


      get defaultSortDirection() {
        return getDefaultSortDirection(this.state);
      }

      set enableInfiniteLoading(value) {
        setInfiniteLoading(this.state, value);
      }
      /**
       * If present, you can load a subset of data and then display more
       * when users scroll to the end of the table.
       * Use with the onloadmore event handler to retrieve more data.
       * @type {boolean}
       * @default false
       */


      get enableInfiniteLoading() {
        return isInfiniteLoadingEnabled(this.state);
      }

      set loadMoreOffset(value) {
        setLoadMoreOffset(this.state, value);
      }
      /**
       * Determines when to trigger infinite loading based on
       * how many pixels the table's scroll position is from the bottom of the table.
       * The default is 20.
       * @type {number}
       * @default 20
       */


      get loadMoreOffset() {
        return getLoadMoreOffset(this.state);
      }

      set isLoading(value) {
        setLoading(this.state, value);
      }
      /**
       * If present, a spinner is shown to indicate that more data is loading.
       * @type {boolean}
       * @default false
       */


      get isLoading() {
        return isLoading(this.state);
      }

      set maxRowSelection(value) {
        const previousSelectionLenght = getCurrentSelectionLength(this.state);
        setMaxRowSelection(this.state, value);

        if (previousSelectionLenght > 0) {
          this.fireSelectedRowsChange(this.getSelectedRows());
        }
      }
      /**
       * The maximum number of rows that can be selected.
       * Checkboxes are used for selection by default,
       * and radio buttons are used when maxRowSelection is 1.
       * @type {number}
       */


      get maxRowSelection() {
        return getMaxRowSelection(this.state);
      }

      set selectedRows(value) {
        this.customerSelectedRows = value;
        this.setSelectedRows(value);
      }
      /**
       * Enables programmatic row selection with a list of key-field values.
       * @type {list}
       */


      get selectedRows() {
        return getSelectedRowsKeys(this.state);
      }

      set errors(value) {
        setErrors(this.state, value);
        this.updateRowsState();
      }
      /**
       * Specifies an object containing information about cell level, row level, and table level errors.
       * When it's set, error messages are displayed on the table accordingly.
       * @type {object}
       */


      get errors() {
        return getErrors(this.state);
      }
      /**
       * The current values per row that are provided during inline edit.
       * @type {object}
       */


      get draftValues() {
        return getDirtyValues(this.state);
      }

      set draftValues(value) {
        this._draftValues = value;
        setDirtyValues(this.state, value);

        if (hasValidKeyField(this.state)) {
          this.updateRowsAndCellIndexes(this.state);
        }
      }
      /**
       * If present, the table header is hidden.
       * @type {boolean}
       * @default false
       */


      get hideTableHeader() {
        return this.state.hideTableHeader;
      }

      set hideTableHeader(value) {
        this.state.hideTableHeader = !!value;
      }

      get hasValidKeyField() {
        if (hasValidKeyField(this.state)) {
          return true;
        } // eslint-disable-next-line no-console


        console.error(`The "keyField" is a required attribute of lightning:datatable.`);
        return false;
      }

      get showSelectAllCheckbox() {
        return !getHideSelectAllCheckbox(this.state);
      }
      /**
       * If present, the footer that displays the Save and Cancel buttons is hidden during inline editing.
       * @type {boolean}
       * @default false
       */


      get suppressBottomBar() {
        return this.privateSuppressBottomBar;
      }

      set suppressBottomBar(value) {
        this.privateSuppressBottomBar = !!value;
      }

      connectedCallback() {
        const {
          handleResizeColumn,
          handleUpdateColumnSort,
          handleCellFocusByClick,
          handleFalseCellBlur
        } = this;
        this.template.addEventListener('selectallrows', handleSelectAllRows.bind(this));
        this.template.addEventListener('deselectallrows', handleDeselectAllRows.bind(this));
        this.template.addEventListener('selectrow', handleSelectRow.bind(this));
        this.template.addEventListener('deselectrow', handleDeselectRow.bind(this));
        this.addEventListener('rowselection', handleRowSelectionChange.bind(this));
        this.template.addEventListener('resizecol', handleResizeColumn.bind(this));
        this.template.addEventListener('privateupdatecolsort', handleUpdateColumnSort.bind(this));
        this.template.addEventListener('privatecellkeydown', handleCellKeydown.bind(this));
        this.template.addEventListener('privatecellfocusedbyclick', handleCellFocusByClick.bind(this));
        this.template.addEventListener('privatecellfalseblurred', handleFalseCellBlur.bind(this)); // row-level-actions

        this.template.addEventListener('privatecellactiontriggered', handleRowActionTriggered.bind(this));
        this.template.addEventListener('privatecellactionmenuopening', handleLoadDynamicActions.bind(this));
        this.template.addEventListener('privatecellbuttonclicked', handleCellButtonClick.bind(this)); // header-actions

        this.template.addEventListener('privatecellheaderactionmenuopening', handleHeaderActionMenuOpening.bind(this));
        this.template.addEventListener('privatecellheaderactiontriggered', handleHeaderActionTriggered.bind(this)); // inline-edit

        this.template.addEventListener('privateeditcell', handleEditCell.bind(this));
      }

      render() {
        return _tmpl$1b;
      }

      handleTrRowKeyDown(event) {
        // we probably should not be doing this unless we actually are interested in it
        if (this.state.keyboardMode === 'NAVIGATION' && this.state.rowMode === true) {
          event.stopPropagation();
          const tr = event.currentTarget;
          const rowKeyValue = tr.getAttribute('data-row-key-value');
          const keyCode = event.keyCode;
          const rowHasChildren = !!tr.getAttribute('aria-expanded');
          const rowExpanded = tr.getAttribute('aria-expanded') === 'true';
          const rowLevel = tr.getAttribute('aria-level');
          const evt = {
            target: tr,
            detail: {
              rowKeyValue,
              keyCode,
              rowHasChildren,
              rowExpanded,
              rowLevel,
              keyEvent: event
            }
          };
          reactToKeyboardOnRow(this, this.state, evt);
        }
      }

      disconnectedCallback() {
        // raptor does the removeEventListeners, so no need to detach them.
        this.hasDetachedListeners = true;
        const resizeTarget = lwc.unwrap(this.template.querySelector('.dt-width-observer'));
        this.privateWidthObserver.detach(resizeTarget);
      }

      renderedCallback() {
        if (this.hasDetachedListeners) {
          this.attachListeners();
        }

        const {
          state
        } = this;

        if (hasColumns(state) && !hasDefinedColumnsWidths(state)) {
          adjustColumnsSize(this.template, state);
          this.fireOnResize();
        }

        handlePrefetch.call(this, this.template, state); // customerSelectedRows is only valid till render, after it, the one used should be the one from the state.

        this.customerSelectedRows = null; // set the previous focused cell to null after render is done

        resetCellToFocusFromPrev(state);
      }

      setSelectedRows(value) {
        setSelectedRowsKeys(this.state, value);
        handleRowSelectionChange.call(this);
      }

      updateRowsState() {
        const {
          state
        } = this; // calculate cell to focus next before indexes are updated

        setCellToFocusFromPrev(state);
        this.updateRowsAndCellIndexes(state);
        adjustRowNumberColumnWidth(this.template, state); // update celltofocus next to null if the row still exists after indexes calculation

        updateCellToFocusFromPrev(state);
        syncSelectedRowsKeys(state, this.getSelectedRows()).ifChanged(selectedRows => this.fireSelectedRowsChange(selectedRows));
        syncActiveCell(state);

        if (state.keyboardMode === 'NAVIGATION') {
          updateTabIndexActiveCell(state);
          updateTabIndexActiveRow(state);
        } // if there is previously focused cell which was deleted set focus from celltofocus next


        if (state.cellToFocusNext) {
          setFocusActiveCell(this.template, this.state);
        }
      }

      updateColumns(columns) {
        const {
          state
        } = this;
        const hadTreeDataTypePreviously = hasTreeDataType(state); // calculate cell to focus next before indexes are updated

        setCellToFocusFromPrev(state);
        normalizeColumns(state, columns, this.privateTypes);
        setDirtyValues(state, this._draftValues);
        updateRowNavigationMode(hadTreeDataTypePreviously, state);
        state.headerIndexes = generateHeaderIndexes(getColumns(state));
        updateHeaderActions(state);
        this.updateRowsAndCellIndexes(state);
        updateSelectionState(state);
        adjustRowNumberColumnWidth(this.template, state);
        updateColumnWidthsMetadata(state); // set the celltofocus next to null if the column still exists after indexes calculation

        updateCellToFocusFromPrev(state);

        if (getColumns(state).length !== getColumnsWidths(state).length) {
          resetColumnWidths(state);

          if (getData(state).length > 0) {
            // when there are column changes, update the active cell
            syncActiveCell(state);
          }
        } else if (hasDefinedColumnsWidths(state)) {
          // try to adjust column size if previous size in the state and table is visible (not hidden)
          if (isTableRenderedVisible(this.template)) {
            adjustColumnsSize(this.template, state);
          } else {
            adjustColumnsSizeFromState(state);
          }
        }

        if (state.keyboardMode === 'NAVIGATION') {
          updateTabIndexActiveCell(state);
          updateTabIndexActiveRow(state);
        } // if there is previously focused cell which was deleted set focus from celltofocus next


        if (state.cellToFocusNext) {
          setFocusActiveCell(this.template, this.state);
        }
      }

      get computedTableHeaderClass() {
        if (this.state.hideTableHeader) {
          return 'slds-assistive-text';
        }

        return undefined;
      }

      get computedScrollerStyle() {
        return getTableWidthStyle(this.state);
      }

      get computedTableClass() {
        return classSet('slds-table slds-table_header-fixed slds-table_bordered slds-table_edit').add({
          'slds-table_resizable-cols': this.hasResizebleColumns
        }).add({
          'slds-tree slds-table_tree': hasTreeDataType(this.state)
        }).toString();
      }

      get computedTableRole() {
        return hasTreeDataType(this.state) ? 'treegrid' : 'grid';
      }

      get computedTableStyle() {
        return ['table-layout:fixed', getTableWidthStyle(this.state)].join(';');
      }

      get computedTbodyStyle() {
        if (hasRowNumberColumn(this.state) && getRowNumberOffset(this.state) >= 0) {
          return 'counter-reset: row-number ' + getRowNumberOffset(this.state);
        }

        return '';
      }

      get hasSelectableRows() {
        return !this.state.hideCheckboxColumn;
      }

      get hasResizebleColumns() {
        return !isResizeColumnDisabled(this.state);
      }

      get numberOfColumns() {
        return getColumns(this.state).length;
      }

      get showLoadingIndicator() {
        return isLoading(this.state);
      }

      get scrollerXStyles() {
        const styles = {
          height: '100%'
        };

        if (this.showStatusBar) {
          styles['padding-bottom'] = '3rem';
        }

        return Object.entries(styles).map(([key, value]) => key + ':' + value).join(';');
      }

      get showStatusBar() {
        return isInlineEditTriggered(this.state) && !this.suppressBottomBar;
      }

      get tableError() {
        return getTableError(this.state);
      }

      handleUpdateColumnSort(event) {
        event.stopPropagation();
        const {
          fieldName,
          sortDirection
        } = event.detail;
        this.fireSortedColumnChange(fieldName, sortDirection);
      }

      handleHorizontalScroll(event) {
        handleInlineEditPanelScroll.call(this, event);
      }

      handleVerticalScroll(event) {
        if (this.enableInfiniteLoading) {
          handleLoadMoreCheck.call(this, event);
        }

        handleInlineEditPanelScroll.call(this, event);
      }

      fireSelectedRowsChange(selectedRows) {
        const event = new CustomEvent('rowselection', {
          detail: {
            selectedRows
          }
        });
        this.dispatchEvent(event);
      }

      fireSortedColumnChange(fieldName, sortDirection) {
        const event = new CustomEvent('sort', {
          detail: {
            fieldName,
            sortDirection
          }
        });
        this.dispatchEvent(event);
      }

      fireOnResize() {
        const event = new CustomEvent('resize', {
          detail: {
            columnWidths: getCustomerColumnWidths(this.state)
          }
        });
        this.dispatchEvent(event);
      }

      handleResizeColumn(event) {
        event.stopPropagation();
        const {
          colIndex,
          widthDelta
        } = event.detail;

        if (widthDelta !== 0) {
          resizeColumnWithDelta(this.state, colIndex, widthDelta);
          this.fireOnResize();
        }
      }

      get tableTabIndex() {
        return this.state.focusIsInside ? '-1' : '0';
      }

      handleTableFocus() {
        // dont modify the state if we can't focus on elements within the table
        if (!this.state.activeCell) {
          return;
        }

        this.state.tabindex = false; // Safari don't like tabindex=-1

        if (this.state.rowMode) {
          setFocusActiveRow(this.template, this.state);
        } else {
          setFocusActiveCell(this.template, this.state, NAVIGATION_DIR.USE_CURRENT);
        }
      }

      handleCellFocusByClick(event) {
        event.stopPropagation();
        const {
          rowKeyValue,
          colKeyValue
        } = event.detail;
        const {
          state
        } = this;

        if (!isActiveCell(state, rowKeyValue, colKeyValue)) {
          if (state.rowMode && state.activeCell) {
            unsetRowNavigationMode(state);
            const {
              rowIndex
            } = getIndexesActiveCell(state);
            updateTabIndexRow(state, rowIndex, -1);
          }

          this.setActiveCell(rowKeyValue, colKeyValue);
        }

        if (!datatableHasFocus(state)) {
          setCellClickedForFocus(state);
        }
      }

      handleCellClick(event) {
        // handles the case when clicking on the margin/pading of the td/th
        const targetTagName = event.target.tagName.toLowerCase();

        if (targetTagName === 'td' || targetTagName === 'th') {
          // get the row/col key value from the primitive cell.
          const {
            rowKeyValue,
            colKeyValue
          } = event.target.querySelector(':first-child');
          const {
            state
          } = this;

          if (state.rowMode || !isActiveCell(state, rowKeyValue, colKeyValue)) {
            if (state.rowMode && state.activeCell) {
              unsetRowNavigationMode(state);
              const {
                rowIndex
              } = getIndexesActiveCell(state);
              updateTabIndexRow(state, rowIndex, -1);
            }

            this.setActiveCell(rowKeyValue, colKeyValue);
          }

          if (!datatableHasFocus(state)) {
            setCellClickedForFocus(state);
          }
        }
      }

      setActiveCell(rowKeyValue, colKeyValue) {
        const {
          template,
          state
        } = this;
        const {
          rowIndex,
          colIndex
        } = getIndexesByKeys(state, rowKeyValue, colKeyValue);
        setBlurActiveCell(template, state);
        updateActiveCell(state, rowKeyValue, colKeyValue);
        addFocusStylesToActiveCell(template, state);
        updateTabIndex(state, rowIndex, colIndex, 0);
      }

      handleFalseCellBlur(event) {
        event.stopPropagation();
        const {
          template,
          state
        } = this;
        const {
          rowKeyValue,
          colKeyValue
        } = event.detail;

        if (!isActiveCell(state, rowKeyValue, colKeyValue)) {
          this.setActiveCell(rowKeyValue, colKeyValue);
        }

        setFocusActiveCell(template, state);
      }
      /**
       * Returns data in each selected row.
       * @returns {array} An array of data in each selected row.
       */


      getSelectedRows() {
        const data = lwc.unwrap(getData(this.state));
        return this.state.rows.reduce((prev, row, index) => {
          if (row.isSelected) {
            prev.push(data[index]);
          }

          return prev;
        }, []);
      }

      attachListeners() {
        const resizeTarget = lwc.unwrap(this.template.querySelector('.dt-width-observer'));
        this.privateWidthObserver = new ResizeSensor(resizeTarget, debounce(() => {
          // since this event handler is debounced, it might be the case that at the time the handler is called,
          // the element is disconnected (this.hasDetachedListeners)
          if (!this.hasDetachedListeners) {
            adjustColumnsSize(this.template, this.state);
          }
        }, 200));
        this.hasDetachedListeners = false;
      }

      handleTableFocusIn(event) {
        handleDatatableFocusIn.call(this, event);
      }

      handleTableFocusOut(event) {
        handleDatatableLosedFocus.call(this, event);
      }
      /**
       * @return {Object} containing the visible dimensions of the table { left, right, top, bottom, }
       */


      getViewableRect() {
        const scrollerX = this.template.querySelector('.slds-scrollable_x').getBoundingClientRect();
        const scrollerY = this.template.querySelector('.slds-scrollable_y').getBoundingClientRect();
        return {
          left: scrollerX.left,
          right: scrollerX.right,
          top: scrollerY.top,
          bottom: scrollerY.bottom
        };
      }

      handleInlineEditFinish(event) {
        handleInlineEditFinish.call(this, event);
      }

      handleMassCheckboxChange(event) {
        handleMassCheckboxChange.call(this, event);
      }

      handleInlineEditSave(event) {
        event.stopPropagation();
        event.preventDefault();
        closeInlineEdit(this);
        const draftValues = this.draftValues;
        this.dispatchEvent(new CustomEvent('save', {
          detail: {
            draftValues
          }
        }));
      }

      handleInlineEditCancel(event) {
        event.stopPropagation();
        event.preventDefault();
        closeInlineEdit(this);
        const customerEvent = new CustomEvent('cancel', {
          cancelable: true
        });
        this.dispatchEvent(customerEvent);

        if (!customerEvent.defaultPrevented) {
          cancelInlineEdit(this);
        }
      }

      handleTableKeydown(event) {
        handleKeyDown.call(this, event);
      }

    }

    lwc.registerDecorators(LightningDatatable, {
      publicProps: {
        columns: {
          config: 3
        },
        data: {
          config: 3
        },
        keyField: {
          config: 3
        },
        hideCheckboxColumn: {
          config: 3
        },
        showRowNumberColumn: {
          config: 3
        },
        rowNumberOffset: {
          config: 3
        },
        resizeColumnDisabled: {
          config: 3
        },
        minColumnWidth: {
          config: 3
        },
        maxColumnWidth: {
          config: 3
        },
        resizeStep: {
          config: 3
        },
        sortedBy: {
          config: 3
        },
        sortedDirection: {
          config: 3
        },
        defaultSortDirection: {
          config: 3
        },
        enableInfiniteLoading: {
          config: 3
        },
        loadMoreOffset: {
          config: 3
        },
        isLoading: {
          config: 3
        },
        maxRowSelection: {
          config: 3
        },
        selectedRows: {
          config: 3
        },
        errors: {
          config: 3
        },
        draftValues: {
          config: 3
        },
        hideTableHeader: {
          config: 3
        },
        suppressBottomBar: {
          config: 3
        }
      },
      publicMethods: ["getSelectedRows"],
      track: {
        privateSuppressBottomBar: 1,
        state: 1
      }
    });

    var _lightningDatatable = lwc.registerComponent(LightningDatatable, {
      tmpl: _tmpl$1b
    });

    function tmpl$1L($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element,
        h: api_element
      } = $api;
      const {
        _m0,
        _m1,
        _m2,
        _m3,
        _m4
      } = $ctx;
      return [api_custom_element("lightning-card", _lightningCard, {
        props: {
          "title": "Edit/Delete Client Objectives - V1.0.2",
          "iconName": "custom:custom63"
        },
        key: 2
      }, [$cmp.areDetailsVisible ? api_custom_element("lightning-record-form", _lightningRecordForm, {
        props: {
          "recordId": $cmp.COrecordId,
          "objectApiName": $cmp.COobjectApiName,
          "columns": "2",
          "mode": "edit",
          "layoutType": "Compact"
        },
        key: 4,
        on: {
          "success": _m0 || ($ctx._m0 = api_bind($cmp.handleSuccess)),
          "cancel": _m1 || ($ctx._m1 = api_bind($cmp.handleCancel))
        }
      }, []) : null, api_element("input", {
        attrs: {
          "size": "30",
          "type": "search",
          "placeholder": "Search Name, Program or SD..."
        },
        key: 5,
        on: {
          "input": _m2 || ($ctx._m2 = api_bind($cmp.handleSearchKeyInput))
        }
      }, []), api_custom_element("lightning-button", _lightningButton, {
        classMap: {
          "slds-m-left_x-small": true
        },
        props: {
          "label": "Refresh",
          "title": "Refresh"
        },
        key: 6,
        on: {
          "click": _m3 || ($ctx._m3 = api_bind($cmp.handleClick))
        }
      }, []), api_custom_element("lightning-datatable", _lightningDatatable, {
        props: {
          "hideCheckboxColumn": true,
          "keyField": "Id",
          "data": $cmp.clientobjectives,
          "columns": $cmp.columns
        },
        key: 7,
        on: {
          "rowaction": _m4 || ($ctx._m4 = api_bind($cmp.handleRowAction))
        }
      }, [])])];
    }

    var _tmpl$1c = lwc.registerTemplate(tmpl$1L);
    tmpl$1L.stylesheets = [];
    tmpl$1L.stylesheetTokens = {
      hostAttribute: "lwc-lwcrelatedclientobjectives_lwcrelatedclientobjectives-host",
      shadowAttribute: "lwc-lwcrelatedclientobjectives_lwcrelatedclientobjectives"
    };

    const apexInvoker = lds.getApexInvoker("", "MBSessionObjectives", "getClientObjectives", false);
    wireService.register(apexInvoker, lds.generateGetApexWireAdapter("", "MBSessionObjectives", "getClientObjectives", false));

    /**
     * A basic pub-sub mechanism for sibling component communication
     *
     * TODO - adopt standard flexipage sibling communication mechanism when it's available.
     */
    const events = {};
    /**
     * Registers a callback for an event
     * @param {string} eventName - Name of the event to listen for.
     * @param {function} callback - Function to invoke when said event is fired.
     * @param {object} thisArg - The value to be passed as the this parameter to the callback function is bound.
     */


    const registerListener = (eventName, callback, thisArg) => {
      // Checking that the listener has a pageRef property. We rely on that property for filtering purpose in fireEvent()
      if (!thisArg.pageRef) {
        throw new Error('pubsub listeners need a "@wire(CurrentPageReference) pageRef" property');
      }

      if (!events[eventName]) {
        events[eventName] = [];
      }

      const duplicate = events[eventName].find(listener => {
        return listener.callback === callback && listener.thisArg === thisArg;
      });

      if (!duplicate) {
        events[eventName].push({
          callback,
          thisArg
        });
      }
    };
    /**
     * Unregisters all event listeners bound to an object.
     * @param {object} thisArg - All the callbacks bound to this object will be removed.
     */


    const unregisterAllListeners = thisArg => {
      Object.keys(events).forEach(eventName => {
        events[eventName] = events[eventName].filter(listener => listener.thisArg !== thisArg);
      });
    };

    const DEFAULT_TOAST_MODE = 'dismissible';
    const DEFAULT_VARIANT$2 = 'info';
    const DEFAULT_DURATION = 3000;
    const WARN_MESSAGES = {
      IGNORING_MESSAGE_DATA: 'Ignoring messageData attribute in toast definition, messageData should be an array of action links.',
      MISSING_TITLE_AND_MESSAGE: "Toast definition is invalid. Missing both attributes 'title' and 'message'. At east one of them should be present",
      TOAST_DEFINITION_SHOULD_BE_OBJECT: "The toast definition should be an object, for example: { title: 'Title text', message: 'Message text' }"
    };

    function setPropertyIfTruthyValue(obj, prop, propValue) {
      if (propValue) {
        obj[prop] = propValue;
      }
    }

    function getStringProp(obj, prop) {
      let value = obj[prop] ? obj[prop] : undefined;

      if (value && !(typeof value === 'string')) {
        console.warn(`Attribute '${prop}' should have a string value.`); // eslint-disable-line no-console

        value = undefined;
      }

      return value;
    }

    function getMessageData(definition) {
      const msgData = definition.messageData;
      const msgDataIsArray = Array.isArray(msgData);

      if (msgData && !msgDataIsArray) {
        console.warn(WARN_MESSAGES.IGNORING_MESSAGE_DATA); // eslint-disable-line no-console
      }

      return msgData && msgDataIsArray ? msgData : undefined;
    }

    function getValidToastDefinition(toastDefinition) {
      const toastDefinitionIsObject = toastDefinition !== null && typeof toastDefinition === 'object' && !Array.isArray(toastDefinition);

      if (!toastDefinitionIsObject) {
        console.warn(WARN_MESSAGES.TOAST_DEFINITION_SHOULD_BE_OBJECT); // eslint-disable-line no-console

        return null;
      }

      const title = getStringProp(toastDefinition, 'title');
      const message = getStringProp(toastDefinition, 'message');

      if (!title && !message) {
        console.warn(WARN_MESSAGES.MISSING_TITLE_AND_MESSAGE); // eslint-disable-line no-console

        return null;
      }

      return toastDefinition;
    }

    function getNormalizedToastDefinition(validDefinition) {
      const normalizedToastDefinition = {};
      const title = getStringProp(validDefinition, 'title');
      const message = getStringProp(validDefinition, 'message');
      const messageData = getMessageData(validDefinition);
      normalizedToastDefinition.type = normalizeString(validDefinition.variant, {
        fallbackValue: DEFAULT_VARIANT$2,
        validValues: ['info', 'success', 'warning', 'error']
      });
      normalizedToastDefinition.mode = normalizeString(validDefinition.mode, {
        fallbackValue: DEFAULT_TOAST_MODE,
        validValues: ['dismissible', 'pester', 'sticky']
      });
      normalizedToastDefinition.duration = DEFAULT_DURATION;
      setPropertyIfTruthyValue(normalizedToastDefinition, 'title', title);
      setPropertyIfTruthyValue(normalizedToastDefinition, 'message', message);
      setPropertyIfTruthyValue(normalizedToastDefinition, 'messageData', messageData);
      return normalizedToastDefinition;
    }

    function getToastEventArgument(normalizedToastDefinition) {
      const eventArguments = {
        mode: normalizedToastDefinition.mode,
        duration: normalizedToastDefinition.duration,
        type: normalizedToastDefinition.type
      };

      if (normalizedToastDefinition.title && normalizedToastDefinition.message) {
        eventArguments.title = normalizedToastDefinition.title;
      }

      eventArguments.message = normalizedToastDefinition.message ? normalizedToastDefinition.message : normalizedToastDefinition.title;

      if (normalizedToastDefinition.messageData) {
        eventArguments.messageTemplate = eventArguments.message;
        eventArguments.messageTemplateData = normalizedToastDefinition.messageData;
      }

      return eventArguments;
    }

    function showToast(toastDefinition, eventDispatcher) {
      const validToastDefinition = getValidToastDefinition(toastDefinition);
      const shouldShowToast = validToastDefinition !== null;

      if (validToastDefinition !== null) {
        const normalizedToast = getNormalizedToastDefinition(validToastDefinition);
        eventDispatcher(getToastEventArgument(normalizedToast));
      }

      return shouldShowToast;
    }

    function tmpl$1M($api, $cmp, $slotset, $ctx) {
      const {
        b: api_bind,
        c: api_custom_element
      } = $api;
      const {
        _m0
      } = $ctx;
      return [api_custom_element("lightning-button", _lightningButton, {
        props: {
          "label": $cmp.buttonText
        },
        key: 2,
        on: {
          "click": _m0 || ($ctx._m0 = api_bind($cmp.handleButtonClick))
        }
      }, [])];
    }

    var _tmpl$1d = lwc.registerTemplate(tmpl$1M);
    tmpl$1M.stylesheets = [];
    tmpl$1M.stylesheetTokens = {
      hostAttribute: "lightning-noticeFooter_noticeFooter-host",
      shadowAttribute: "lightning-noticeFooter_noticeFooter"
    };

    var labelOkButton = 'OK';

    const i18n$E = {
      okButton: labelOkButton
    };

    class NoticeFooter extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.handleClickCallback = void 0;
      }

      get buttonText() {
        return `${i18n$E.okButton}`;
      }

      handleButtonClick() {
        if (typeof this.handleClickCallback === 'function') {
          this.handleClickCallback.call();
        }
      }

    }

    lwc.registerDecorators(NoticeFooter, {
      publicProps: {
        handleClickCallback: {
          config: 0
        }
      }
    });

    lwc.registerComponent(NoticeFooter, {
      tmpl: _tmpl$1d
    });

    function tmpl$1N($api, $cmp, $slotset, $ctx) {
      const {
        d: api_dynamic,
        h: api_element,
        c: api_custom_element
      } = $api;
      return [$cmp.messageTitle ? api_element("p", {
        key: 2
      }, [api_element("strong", {
        key: 3
      }, [api_dynamic($cmp.messageTitle)])]) : null, api_element("p", {
        key: 4
      }, [api_custom_element("lightning-formatted-text", _lightningFormattedText, {
        props: {
          "value": $cmp.messageBody,
          "linkify": "true"
        },
        key: 5
      }, [])])];
    }

    var _tmpl$1e = lwc.registerTemplate(tmpl$1N);
    tmpl$1N.stylesheets = [];
    tmpl$1N.stylesheetTokens = {
      hostAttribute: "lightning-noticeContent_noticeContent-host",
      shadowAttribute: "lightning-noticeContent_noticeContent"
    };

    class NoticeContent extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.messageTitle = void 0;
        this.messageBody = void 0;
      }

    }

    lwc.registerDecorators(NoticeContent, {
      publicProps: {
        messageTitle: {
          config: 0
        },
        messageBody: {
          config: 0
        }
      }
    });

    lwc.registerComponent(NoticeContent, {
      tmpl: _tmpl$1e
    });

    const ShowToastEventName = 'lightning__showtoast';
    class ShowToastEvent extends CustomEvent {
      constructor(toast) {
        super(ShowToastEventName, {
          composed: true,
          cancelable: true,
          bubbles: true
        });
        showToast(toast, forceShowToastAttributes => {
          Object.defineProperties(this, {
            toastAttributes: {
              value: forceShowToastAttributes,
              writable: false
            }
          });
        });
      }

    }

    const actions = [{
      label: 'Edit details',
      name: 'edit_details'
    }, {
      label: 'Delete',
      name: 'delete'
    }];
    const columns = [{
      label: 'Program',
      fieldName: 'Program_Name__c',
      type: 'text'
    }, {
      label: 'SD',
      fieldName: 'SD_Name__c',
      type: 'text'
    }, {
      label: 'Objective',
      fieldName: 'Objective_Name__c',
      type: 'text'
    }, {
      label: 'Status',
      fieldName: 'Status__c',
      type: 'text'
    }, {
      type: 'action',
      typeAttributes: {
        rowActions: actions
      }
    }];

    class lwcrelatedclientobjectives extends lwc.LightningElement {
      constructor(...args) {
        super(...args);
        this.searchKey = '';
        this.recordId = '0012v00002fY86nAAC';
        this.COrecordId = '';
        this.COobjectApiName = 'Client_Objective__c';
        this.columns = columns;
        this.clientobjectives = void 0;
        this.allObjectives = {};
        this.pageRef = void 0;
        this.draftValues = [];
        this.areDetailsVisible = false;
      }

      //@wire(getClientObjectives, { searchKey: '$recordId' }) clientobjectives;
      connectedCallback() {
        console.log('subscribing to pub sub inputChangeEvent');
        registerListener('inputChangeEvent', this.handleChange, this);
        console.log('starting, getting client objectives, recordId = ' + this.recordId);
        this.refresh();
      }

      handleRowAction(event) {
        const actionName = event.detail.action.name;
        const row = event.detail.row;
        console.log(JSON.stringify(row));

        switch (actionName) {
          case 'delete':
            console.log('DELETING');
            lds.deleteRecord(row.Id).then(() => {
              this.dispatchEvent(new ShowToastEvent({
                title: 'Success',
                message: 'Cient Objective deleted',
                variant: 'success'
              }));
              this.refresh();
            }).catch(error => {
              this.dispatchEvent(new ShowToastEvent({
                title: 'Error deleting record',
                message: 'Error',
                variant: 'error'
              }));
            });
            break;

          case 'edit_details':
            this.COrecordId = row.Id;
            console.log('EDIT DETAILS');
            console.log(this.COrecordId);
            this.areDetailsVisible = true;
            break;

          default:
        }
      }

      handleSuccess(event) {
        const evt = new ShowToastEvent({
          title: "Success",
          message: "Client objective updated",
          variant: "success"
        });
        this.dispatchEvent(evt);
        this.areDetailsVisible = false;
        this.refresh();
      }

      refresh() {
        console.log('in refactored this.refresh()');
        console.log('starting, getting client objectives, recordId = ' + this.recordId);
        apexInvoker({
          searchKey: this.recordId
        }).then(result => {
          console.log('RETURNED');
          this.clientobjectives = result;
          this.allObjectives = result;
          console.log(JSON.stringify(this.clientobjectives));
        }).catch(error => {
          this.error = error;
          console.log('ERROR' + JSON.stringify(error));
        });
      }

      handleCancel(event) {
        console.log('Cancelling');
        this.areDetailsVisible = false;
      }

      handleSave(event) {
        console.log(JSON.stringify(event.detail.draftValues));
        const recordInputs = event.detail.draftValues.slice().map(draft => {
          const fields = Object.assign({}, draft);
          return {
            fields
          };
        });
        const promises = recordInputs.map(recordInput => lds.updateRecord(recordInput));
        Promise.all(promises).then(contacts => {
          this.dispatchEvent(new ShowToastEvent({
            title: 'Success',
            message: 'Client objectives updated',
            variant: 'success'
          })); // Clear all draft values

          this.draftValues = []; // Display fresh data in the datatable

          console.log('REFRESH is turned ON');
          this.refresh();
        }).catch(error => {// Handle error
        });
      }

      handleClick(event) {
        //this.clientobjectives={};
        this.refresh();
      }

      disconnectedCallback() {
        // unsubscribe from inputChangeEvent event
        unregisterAllListeners(this);
      }

      handleChange(inpVal) {
        console.log('received pub sub input event');
        apexInvoker({
          searchKey: this.recordId
        }).then(result => {
          console.log('RETURNED in handle change()');
          this.clientobjectives = result;
          this.allObjectives = result;
          console.log(JSON.stringify(this.clientobjectives));
        }).catch(error => {
          this.error = error;
          console.log('ERROR' + JSON.stringify(error));
        });
      }

      handleSearchKeyInput(event) {
        const searchKey = event.target.value.toLowerCase();
        console.log('SEARCHKEY=' + searchKey + '. this.allObjectives= ' + JSON.stringify(this.allObjectives));
        this.clientobjectives = this.allObjectives.filter(so => so.Name.toLowerCase().includes(searchKey) || so.SD_Name__c.toLowerCase().includes(searchKey) || so.Program_Name__c.toLowerCase().includes(searchKey) || so.Objective_Name__c.toLowerCase().includes(searchKey));
        console.log('this.clientobjectives=' + JSON.stringify(this.clientobjectives));
      }

    }

    lwc.registerDecorators(lwcrelatedclientobjectives, {
      publicProps: {
        recordId: {
          config: 0
        }
      },
      wire: {
        pageRef: {
          adapter: navigation.CurrentPageReference
        }
      },
      track: {
        searchKey: 1,
        COrecordId: 1,
        COobjectApiName: 1,
        columns: 1,
        clientobjectives: 1,
        draftValues: 1,
        areDetailsVisible: 1
      }
    });

    var lwcrelatedclientobjectives$1 = lwc.registerComponent(lwcrelatedclientobjectives, {
      tmpl: _tmpl$1c
    });

    return lwcrelatedclientobjectives$1;

});
